From 47b8af9c77a46cd6e5c53af9f20d93383ff88f72 Mon Sep 17 00:00:00 2001
From: Arik Nemtsov <arik@wizery.com>
Date: Sun, 3 Jun 2012 23:32:32 +0300
Subject: [PORT FROM MAIN] TI R5.00.21 intergration.

BZ: 49009

Integration of TI R5.SP1 Driver.

Change-Id: Ibf4fe124458ef4b8f74139e80737c447459eb248
Orig-Change-Id: I6b98c79cb7caf1cfb7a07de9c4a5d09bd94c9472
Signed-off-by: Jean Trivelly <jean.trivelly@intel.com>
Reviewed-on: http://android.intel.com:8080/62707
Reviewed-by: Regairaz, Julie <julie.regairaz@intel.com>
Reviewed-by: De Cesco, Jonathan <jonathan.de.cesco@intel.com>
Tested-by: Champciaux, Nicolas <nicolas.champciaux@intel.com>
Reviewed-by: buildbot <buildbot@intel.com>
Tested-by: buildbot <buildbot@intel.com>
Reviewed-on: http://android.intel.com:8080/77980
Reviewed-by: Li, XiaojingX <xiaojingx.li@intel.com>
Tested-by: Li, XiaojingX <xiaojingx.li@intel.com>
---
 wl12xx-compat/drivers/net/wireless/wl12xx/boot.c   |  340 ++++++++++----
 wl12xx-compat/drivers/net/wireless/wl12xx/boot.h   |    2 +
 wl12xx-compat/drivers/net/wireless/wl12xx/cmd.c    |   99 +++--
 wl12xx-compat/drivers/net/wireless/wl12xx/cmd.h    |    8 +-
 wl12xx-compat/drivers/net/wireless/wl12xx/conf.h   |   10 +
 .../drivers/net/wireless/wl12xx/debugfs.c          |   47 ++
 wl12xx-compat/drivers/net/wireless/wl12xx/event.c  |   21 +-
 wl12xx-compat/drivers/net/wireless/wl12xx/event.h  |    2 +-
 wl12xx-compat/drivers/net/wireless/wl12xx/init.c   |   15 +-
 wl12xx-compat/drivers/net/wireless/wl12xx/io.c     |   91 +++-
 wl12xx-compat/drivers/net/wireless/wl12xx/io.h     |  101 +++--
 wl12xx-compat/drivers/net/wireless/wl12xx/main.c   |  486 ++++++++++++++++----
 wl12xx-compat/drivers/net/wireless/wl12xx/ps.c     |   18 +-
 wl12xx-compat/drivers/net/wireless/wl12xx/rx.c     |   38 ++-
 wl12xx-compat/drivers/net/wireless/wl12xx/rx.h     |    4 +-
 wl12xx-compat/drivers/net/wireless/wl12xx/scan.c   |   16 +-
 wl12xx-compat/drivers/net/wireless/wl12xx/sdio.c   |   50 ++-
 wl12xx-compat/drivers/net/wireless/wl12xx/spi.c    |   14 +-
 wl12xx-compat/drivers/net/wireless/wl12xx/tx.c     |   90 +++-
 wl12xx-compat/drivers/net/wireless/wl12xx/tx.h     |    5 +-
 wl12xx-compat/drivers/net/wireless/wl12xx/wl12xx.h |   17 +-
 wl12xx-compat/include/linux/nl80211.h              |   26 +
 wl12xx-compat/include/net/cfg80211.h               |    2 +
 wl12xx-compat/net/mac80211/mlme.c                  |    3 -
 wl12xx-compat/net/mac80211/pm.c                    |    9 +
 wl12xx-compat/net/mac80211/sta_info.c              |    4 +-
 wl12xx-compat/net/mac80211/work.c                  |    3 +-
 wl12xx-compat/net/wireless/nl80211.c               |   12 +-
 28 files changed, 1176 insertions(+), 357 deletions(-)

diff --git a/wl12xx-compat/drivers/net/wireless/wl12xx/boot.c b/wl12xx-compat/drivers/net/wireless/wl12xx/boot.c
index a947793..c872542 100644
--- a/wl12xx-compat/drivers/net/wireless/wl12xx/boot.c
+++ b/wl12xx-compat/drivers/net/wireless/wl12xx/boot.c
@@ -33,16 +33,22 @@
 #include "event.h"
 #include "rx.h"
 
-static void wl1271_boot_set_ecpu_ctrl(struct wl1271 *wl, u32 flag)
+static int wl1271_boot_set_ecpu_ctrl(struct wl1271 *wl, u32 flag)
 {
 	u32 cpu_ctrl;
+	int ret;
 
 	/* 10.5.0 run the firmware (I) */
-	cpu_ctrl = wl1271_read32(wl, ACX_REG_ECPU_CONTROL);
+	ret = wl1271_read32(wl, ACX_REG_ECPU_CONTROL, &cpu_ctrl);
+	if (ret < 0)
+		goto out;
 
 	/* 10.5.1 run the firmware (II) */
 	cpu_ctrl |= flag;
-	wl1271_write32(wl, ACX_REG_ECPU_CONTROL, cpu_ctrl);
+	ret = wl1271_write32(wl, ACX_REG_ECPU_CONTROL, cpu_ctrl);
+
+out:
+	return ret;
 }
 
 static unsigned int wl12xx_get_fw_ver_quirks(struct wl1271 *wl)
@@ -81,12 +87,15 @@ static void wl1271_parse_fw_ver(struct wl1271 *wl)
 	wl->quirks |= wl12xx_get_fw_ver_quirks(wl);
 }
 
-static void wl1271_boot_fw_version(struct wl1271 *wl)
+static int wl1271_boot_fw_version(struct wl1271 *wl)
 {
 	struct wl1271_static_data static_data;
+	int ret;
 
-	wl1271_read(wl, wl->cmd_box_addr, &static_data, sizeof(static_data),
-		    false);
+	ret = wl1271_read(wl, wl->cmd_box_addr, &static_data,
+			  sizeof(static_data), false);
+	if (ret < 0)
+		return ret;
 
 	strncpy(wl->chip.fw_ver_str, static_data.fw_version,
 		sizeof(wl->chip.fw_ver_str));
@@ -95,6 +104,8 @@ static void wl1271_boot_fw_version(struct wl1271 *wl)
 	wl->chip.fw_ver_str[sizeof(wl->chip.fw_ver_str) - 1] = '\0';
 
 	wl1271_parse_fw_ver(wl);
+
+	return 0;
 }
 
 static int wl1271_boot_upload_firmware_chunk(struct wl1271 *wl, void *buf,
@@ -103,6 +114,7 @@ static int wl1271_boot_upload_firmware_chunk(struct wl1271 *wl, void *buf,
 	struct wl1271_partition_set partition;
 	int addr, chunk_num, partition_limit;
 	u8 *p, *chunk;
+	int ret;
 
 	/* whal_FwCtrl_LoadFwImageSm() */
 
@@ -124,7 +136,9 @@ static int wl1271_boot_upload_firmware_chunk(struct wl1271 *wl, void *buf,
 
 	memcpy(&partition, &wl12xx_part_table[PART_DOWN], sizeof(partition));
 	partition.mem.start = dest;
-	wl1271_set_partition(wl, &partition);
+	ret = wl1271_set_partition(wl, &partition);
+	if (ret < 0)
+		goto out;
 
 	/* 10.1 set partition limit and chunk num */
 	chunk_num = 0;
@@ -138,7 +152,9 @@ static int wl1271_boot_upload_firmware_chunk(struct wl1271 *wl, void *buf,
 			partition_limit = chunk_num * CHUNK_SIZE +
 				wl12xx_part_table[PART_DOWN].mem.size;
 			partition.mem.start = addr;
-			wl1271_set_partition(wl, &partition);
+			ret = wl1271_set_partition(wl, &partition);
+			if (ret < 0)
+				goto out;
 		}
 
 		/* 10.3 upload the chunk */
@@ -147,7 +163,9 @@ static int wl1271_boot_upload_firmware_chunk(struct wl1271 *wl, void *buf,
 		memcpy(chunk, p, CHUNK_SIZE);
 		wl1271_debug(DEBUG_BOOT, "uploading fw chunk 0x%p to 0x%x",
 			     p, addr);
-		wl1271_write(wl, addr, chunk, CHUNK_SIZE, false);
+		ret = wl1271_write(wl, addr, chunk, CHUNK_SIZE, false);
+		if (ret < 0)
+			goto out;
 
 		chunk_num++;
 	}
@@ -158,10 +176,11 @@ static int wl1271_boot_upload_firmware_chunk(struct wl1271 *wl, void *buf,
 	memcpy(chunk, p, fw_data_len % CHUNK_SIZE);
 	wl1271_debug(DEBUG_BOOT, "uploading fw last chunk (%zd B) 0x%p to 0x%x",
 		     fw_data_len % CHUNK_SIZE, p, addr);
-	wl1271_write(wl, addr, chunk, fw_data_len % CHUNK_SIZE, false);
+	ret = wl1271_write(wl, addr, chunk, fw_data_len % CHUNK_SIZE, false);
 
+out:
 	kfree(chunk);
-	return 0;
+	return ret;
 }
 
 static int wl1271_boot_upload_firmware(struct wl1271 *wl)
@@ -203,6 +222,7 @@ static int wl1271_boot_upload_nvs(struct wl1271 *wl)
 	int i;
 	u32 dest_addr, val;
 	u8 *nvs_ptr, *nvs_aligned;
+	int ret;
 
 	if (wl->nvs == NULL)
 		return -ENODEV;
@@ -298,7 +318,9 @@ static int wl1271_boot_upload_nvs(struct wl1271 *wl)
 			wl1271_debug(DEBUG_BOOT,
 				     "nvs burst write 0x%x: 0x%x",
 				     dest_addr, val);
-			wl1271_write32(wl, dest_addr, val);
+			ret = wl1271_write32(wl, dest_addr, val);
+			if (ret < 0)
+				return ret;
 
 			nvs_ptr += 4;
 			dest_addr += 4;
@@ -324,7 +346,9 @@ static int wl1271_boot_upload_nvs(struct wl1271 *wl)
 	nvs_len -= nvs_ptr - (u8 *)wl->nvs;
 
 	/* Now we must set the partition correctly */
-	wl1271_set_partition(wl, &wl12xx_part_table[PART_WORK]);
+	ret = wl1271_set_partition(wl, &wl12xx_part_table[PART_WORK]);
+	if (ret < 0)
+		return ret;
 
 	/* Copy the NVS tables to a new block to ensure alignment */
 	nvs_aligned = kmemdup(nvs_ptr, nvs_len, GFP_KERNEL);
@@ -332,7 +356,9 @@ static int wl1271_boot_upload_nvs(struct wl1271 *wl)
 		return -ENOMEM;
 
 	/* And finally we upload the NVS tables */
-	wl1271_write(wl, CMD_MBOX_ADDRESS, nvs_aligned, nvs_len, false);
+	ret = wl1271_write(wl, CMD_MBOX_ADDRESS, nvs_aligned, nvs_len, false);
+	if (ret < 0)
+		return ret;
 
 	kfree(nvs_aligned);
 	return 0;
@@ -342,26 +368,41 @@ out_badnvs:
 	return -EILSEQ;
 }
 
-static void wl1271_boot_enable_interrupts(struct wl1271 *wl)
+static int wl1271_boot_enable_interrupts(struct wl1271 *wl)
 {
+	int ret;
+
 	wl1271_enable_interrupts(wl);
-	wl1271_write32(wl, ACX_REG_INTERRUPT_MASK,
-		       WL1271_ACX_INTR_ALL & ~(WL1271_INTR_MASK));
-	wl1271_write32(wl, HI_CFG, HI_CFG_DEF_VAL);
+	ret = wl1271_write32(wl, ACX_REG_INTERRUPT_MASK,
+			     WL1271_ACX_INTR_ALL & ~(WL1271_INTR_MASK));
+	if (ret < 0)
+		goto out;
+
+	ret = wl1271_write32(wl, HI_CFG, HI_CFG_DEF_VAL);
+
+out:
+	return ret;
 }
 
 static int wl1271_boot_soft_reset(struct wl1271 *wl)
 {
 	unsigned long timeout;
 	u32 boot_data;
+	int ret;
 
 	/* perform soft reset */
-	wl1271_write32(wl, ACX_REG_SLV_SOFT_RESET, ACX_SLV_SOFT_RESET_BIT);
+	ret = wl1271_write32(wl, ACX_REG_SLV_SOFT_RESET,
+			     ACX_SLV_SOFT_RESET_BIT);
+	if (ret < 0)
+		goto out;
 
 	/* SOFT_RESET is self clearing */
 	timeout = jiffies + usecs_to_jiffies(SOFT_RESET_MAX_TIME);
 	while (1) {
-		boot_data = wl1271_read32(wl, ACX_REG_SLV_SOFT_RESET);
+		ret = wl1271_read32(wl, ACX_REG_SLV_SOFT_RESET, &boot_data);
+		if (ret < 0)
+			goto out;
+
 		wl1271_debug(DEBUG_BOOT, "soft reset bootdata 0x%x", boot_data);
 		if ((boot_data & ACX_SLV_SOFT_RESET_BIT) == 0)
 			break;
@@ -370,19 +411,23 @@ static int wl1271_boot_soft_reset(struct wl1271 *wl)
 			/* 1.2 check pWhalBus->uSelfClearTime if the
 			 * timeout was reached */
 			wl1271_error("soft reset timeout");
-			return -1;
+			ret = -ETIMEDOUT;
+			goto out;
 		}
 
 		udelay(SOFT_RESET_STALL_TIME);
 	}
 
 	/* disable Rx/Tx */
-	wl1271_write32(wl, ENABLE, 0x0);
+	ret = wl1271_write32(wl, ENABLE, 0x0);
+	if (ret < 0)
+		goto out;
 
 	/* disable auto calibration on start*/
-	wl1271_write32(wl, SPARE_A2, 0xffff);
+	ret = wl1271_write32(wl, SPARE_A2, 0xffff);
 
-	return 0;
+out:
+	return ret;
 }
 
 static int wl1271_boot_run_firmware(struct wl1271 *wl)
@@ -390,32 +435,42 @@ static int wl1271_boot_run_firmware(struct wl1271 *wl)
 	int loop, ret;
 	u32 chip_id, intr;
 
-	wl1271_boot_set_ecpu_ctrl(wl, ECPU_CONTROL_HALT);
+	ret = wl1271_boot_set_ecpu_ctrl(wl, ECPU_CONTROL_HALT);
+	if (ret < 0)
+		goto out;
 
-	chip_id = wl1271_read32(wl, CHIP_ID_B);
+	ret = wl1271_read32(wl, CHIP_ID_B, &chip_id);
+	if (ret < 0)
+		goto out;
 
 	wl1271_debug(DEBUG_BOOT, "chip id after firmware boot: 0x%x", chip_id);
 
 	if (chip_id != wl->chip.id) {
 		wl1271_error("chip id doesn't match after firmware boot");
-		return -EIO;
+		ret = -EIO;
+		goto out;
 	}
 
 	/* wait for init to complete */
 	loop = 0;
 	while (loop++ < INIT_LOOP) {
 		udelay(INIT_LOOP_DELAY);
-		intr = wl1271_read32(wl, ACX_REG_INTERRUPT_NO_CLEAR);
+		ret = wl1271_read32(wl, ACX_REG_INTERRUPT_NO_CLEAR, &intr);
+		if (ret < 0)
+			goto out;
 
 		if (intr == 0xffffffff) {
 			wl1271_error("error reading hardware complete "
 				     "init indication");
-			return -EIO;
+			ret = -EIO;
+			goto out;
 		}
 		/* check that ACX_INTR_INIT_COMPLETE is enabled */
 		else if (intr & WL1271_ACX_INTR_INIT_COMPLETE) {
-			wl1271_write32(wl, ACX_REG_INTERRUPT_ACK,
-				       WL1271_ACX_INTR_INIT_COMPLETE);
+			ret = wl1271_write32(wl, ACX_REG_INTERRUPT_ACK,
+					     WL1271_ACX_INTR_INIT_COMPLETE);
+			if (ret < 0)
+				goto out;
 			break;
 		}
 	}
@@ -423,22 +478,31 @@ static int wl1271_boot_run_firmware(struct wl1271 *wl)
 	if (loop > INIT_LOOP) {
 		wl1271_error("timeout waiting for the hardware to "
 			     "complete initialization");
-		return -EIO;
+		ret = -EIO;
+		goto out;
 	}
 
 	/* get hardware config command mail box */
-	wl->cmd_box_addr = wl1271_read32(wl, REG_COMMAND_MAILBOX_PTR);
+	ret = wl1271_read32(wl, REG_COMMAND_MAILBOX_PTR, &wl->cmd_box_addr);
+	if (ret < 0)
+		goto out;
 
 	/* get hardware config event mail box */
-	wl->event_box_addr = wl1271_read32(wl, REG_EVENT_MAILBOX_PTR);
+	ret = wl1271_read32(wl, REG_EVENT_MAILBOX_PTR, &wl->event_box_addr);
+	if (ret < 0)
+		goto out;
 
 	/* set the working partition to its "running" mode offset */
-	wl1271_set_partition(wl, &wl12xx_part_table[PART_WORK]);
+	ret = wl1271_set_partition(wl, &wl12xx_part_table[PART_WORK]);
+	if (ret < 0)
+		goto out;
 
 	wl1271_debug(DEBUG_MAILBOX, "cmd_box_addr 0x%x event_box_addr 0x%x",
 		     wl->cmd_box_addr, wl->event_box_addr);
 
-	wl1271_boot_fw_version(wl);
+	ret = wl1271_boot_fw_version(wl);
+	if (ret < 0)
+		goto out;
 
 	/*
 	 * in case of full asynchronous mode the firmware event must be
@@ -465,42 +529,54 @@ static int wl1271_boot_run_firmware(struct wl1271 *wl)
 	ret = wl1271_event_unmask(wl);
 	if (ret < 0) {
 		wl1271_error("EVENT mask setting failed");
-		return ret;
+		goto out;
 	}
 
-	wl1271_event_mbox_config(wl);
+	ret = wl1271_event_mbox_config(wl);
 
 	/* firmware startup completed */
-	return 0;
+out:
+	return ret;
 }
 
 static int wl1271_boot_write_irq_polarity(struct wl1271 *wl)
 {
-	u32 polarity;
+	u16 polarity;
+	int ret;
 
-	polarity = wl1271_top_reg_read(wl, OCP_REG_POLARITY);
+	ret = wl1271_top_reg_read(wl, OCP_REG_POLARITY, &polarity);
+	if (ret < 0)
+		return ret;
 
 	/* We use HIGH polarity, so unset the LOW bit */
 	polarity &= ~POLARITY_LOW;
-	wl1271_top_reg_write(wl, OCP_REG_POLARITY, polarity);
+	ret = wl1271_top_reg_write(wl, OCP_REG_POLARITY, polarity);
 
-	return 0;
+	return ret;
 }
 
 static int wl128x_switch_tcxo_to_fref(struct wl1271 *wl)
 {
 	u16 spare_reg;
+	int ret;
 
 	/* Mask bits [2] & [8:4] in the sys_clk_cfg register */
-	spare_reg = wl1271_top_reg_read(wl, WL_SPARE_REG);
+	ret = wl1271_top_reg_read(wl, WL_SPARE_REG, &spare_reg);
+	if (ret < 0)
+		return ret;
+
 	if (spare_reg == 0xFFFF)
 		return -EFAULT;
 	spare_reg |= (BIT(3) | BIT(5) | BIT(6));
-	wl1271_top_reg_write(wl, WL_SPARE_REG, spare_reg);
+	ret = wl1271_top_reg_write(wl, WL_SPARE_REG, spare_reg);
+	if (ret < 0)
+		return ret;
 
 	/* Enable FREF_CLK_REQ & mux MCS and coex PLLs to FREF */
-	wl1271_top_reg_write(wl, SYS_CLK_CFG_REG,
-			     WL_CLK_REQ_TYPE_PG2 | MCS_PLL_CLK_SEL_FREF);
+	ret = wl1271_top_reg_write(wl, SYS_CLK_CFG_REG,
+				   WL_CLK_REQ_TYPE_PG2 | MCS_PLL_CLK_SEL_FREF);
+	if (ret < 0)
+		return ret;
 
 	/* Delay execution for 15msec, to let the HW settle */
 	mdelay(15);
@@ -511,8 +587,12 @@ static int wl128x_switch_tcxo_to_fref(struct wl1271 *wl)
 static bool wl128x_is_tcxo_valid(struct wl1271 *wl)
 {
 	u16 tcxo_detection;
+	int ret;
+
+	ret = wl1271_top_reg_read(wl, TCXO_CLK_DETECT_REG, &tcxo_detection);
+	if (ret < 0)
+		return false;
 
-	tcxo_detection = wl1271_top_reg_read(wl, TCXO_CLK_DETECT_REG);
 	if (tcxo_detection & TCXO_DET_FAILED)
 		return false;
 
@@ -522,8 +602,12 @@ static bool wl128x_is_tcxo_valid(struct wl1271 *wl)
 static bool wl128x_is_fref_valid(struct wl1271 *wl)
 {
 	u16 fref_detection;
+	int ret;
+
+	ret = wl1271_top_reg_read(wl, FREF_CLK_DETECT_REG, &fref_detection);
+	if (ret < 0)
+		return false;
 
-	fref_detection = wl1271_top_reg_read(wl, FREF_CLK_DETECT_REG);
 	if (fref_detection & FREF_CLK_DETECT_FAIL)
 		return false;
 
@@ -532,11 +616,21 @@ static bool wl128x_is_fref_valid(struct wl1271 *wl)
 
 static int wl128x_manually_configure_mcs_pll(struct wl1271 *wl)
 {
-	wl1271_top_reg_write(wl, MCS_PLL_M_REG, MCS_PLL_M_REG_VAL);
-	wl1271_top_reg_write(wl, MCS_PLL_N_REG, MCS_PLL_N_REG_VAL);
-	wl1271_top_reg_write(wl, MCS_PLL_CONFIG_REG, MCS_PLL_CONFIG_REG_VAL);
+	int ret;
 
-	return 0;
+	ret = wl1271_top_reg_write(wl, MCS_PLL_M_REG, MCS_PLL_M_REG_VAL);
+	if (ret < 0)
+		goto out;
+
+	ret = wl1271_top_reg_write(wl, MCS_PLL_N_REG, MCS_PLL_N_REG_VAL);
+	if (ret < 0)
+		goto out;
+
+	ret = wl1271_top_reg_write(wl, MCS_PLL_CONFIG_REG,
+				   MCS_PLL_CONFIG_REG_VAL);
+
+out:
+	return ret;
 }
 
 static int wl128x_configure_mcs_pll(struct wl1271 *wl, int clk)
@@ -544,13 +638,20 @@ static int wl128x_configure_mcs_pll(struct wl1271 *wl, int clk)
 	u16 spare_reg;
 	u16 pll_config;
 	u8 input_freq;
+	int ret;
 
 	/* Mask bits [3:1] in the sys_clk_cfg register */
-	spare_reg = wl1271_top_reg_read(wl, WL_SPARE_REG);
+	ret = wl1271_top_reg_read(wl, WL_SPARE_REG, &spare_reg);
+	if (ret < 0)
+		return ret;
+
 	if (spare_reg == 0xFFFF)
 		return -EFAULT;
 	spare_reg |= BIT(2);
-	wl1271_top_reg_write(wl, WL_SPARE_REG, spare_reg);
+
+	ret = wl1271_top_reg_write(wl, WL_SPARE_REG, spare_reg);
+	if (ret < 0)
+		return ret;
 
 	/* Handle special cases of the TCXO clock */
 	if (wl->tcxo_clock == WL12XX_TCXOCLOCK_16_8 ||
@@ -560,14 +661,18 @@ static int wl128x_configure_mcs_pll(struct wl1271 *wl, int clk)
 	/* Set the input frequency according to the selected clock source */
 	input_freq = (clk & 1) + 1;
 
-	pll_config = wl1271_top_reg_read(wl, MCS_PLL_CONFIG_REG);
+	ret = wl1271_top_reg_read(wl, MCS_PLL_CONFIG_REG, &pll_config);
+	if (ret < 0)
+		return ret;
+
 	if (pll_config == 0xFFFF)
 		return -EFAULT;
 	pll_config |= (input_freq << MCS_SEL_IN_FREQ_SHIFT);
 	pll_config |= MCS_PLL_ENABLE_HP;
-	wl1271_top_reg_write(wl, MCS_PLL_CONFIG_REG, pll_config);
 
-	return 0;
+	ret = wl1271_top_reg_write(wl, MCS_PLL_CONFIG_REG, pll_config);
+
+	return ret;
 }
 
 /*
@@ -577,9 +682,10 @@ static int wl128x_configure_mcs_pll(struct wl1271 *wl, int clk)
  * In cases where TCXO is 32.736MHz or 16.368MHz, the FREF will be used
  * as the WLAN/BT main clock.
  */
-static int wl128x_boot_clk(struct wl1271 *wl, int *selected_clock)
+int wl128x_boot_clk(struct wl1271 *wl, int *selected_clock)
 {
 	u16 sys_clk_cfg;
+	int ret;
 
 	/* For XTAL-only modes, FREF will be used after switching from TCXO */
 	if (wl->ref_clock == WL12XX_REFCLOCK_26_XTAL ||
@@ -590,7 +696,10 @@ static int wl128x_boot_clk(struct wl1271 *wl, int *selected_clock)
 	}
 
 	/* Query the HW, to determine which clock source we should use */
-	sys_clk_cfg = wl1271_top_reg_read(wl, SYS_CLK_CFG_REG);
+	ret = wl1271_top_reg_read(wl, SYS_CLK_CFG_REG, &sys_clk_cfg);
+	if (ret < 0)
+		return ret;
+
 	if (sys_clk_cfg == 0xFFFF)
 		return -EINVAL;
 	if (sys_clk_cfg & PRCM_CM_EN_MUX_WLAN_FREF)
@@ -620,10 +729,11 @@ config_mcs_pll:
 	return wl128x_configure_mcs_pll(wl, *selected_clock);
 }
 
-static int wl127x_boot_clk(struct wl1271 *wl)
+int wl127x_boot_clk(struct wl1271 *wl)
 {
 	u32 pause;
 	u32 clk;
+	int ret;
 
 	if (WL127X_PG_GET_MAJOR(wl->hw_pg_ver) < 3)
 		wl->quirks |= WL12XX_QUIRK_END_OF_TRANSACTION;
@@ -643,34 +753,54 @@ static int wl127x_boot_clk(struct wl1271 *wl)
 	if (wl->ref_clock != CONF_REF_CLK_19_2_E) {
 		u16 val;
 		/* Set clock type (open drain) */
-		val = wl1271_top_reg_read(wl, OCP_REG_CLK_TYPE);
+		ret = wl1271_top_reg_read(wl, OCP_REG_CLK_TYPE, &val);
+		if (ret < 0)
+			return ret;
+
 		val &= FREF_CLK_TYPE_BITS;
-		wl1271_top_reg_write(wl, OCP_REG_CLK_TYPE, val);
+		ret = wl1271_top_reg_write(wl, OCP_REG_CLK_TYPE, val);
+		if (ret < 0)
+			return ret;
 
 		/* Set clock pull mode (no pull) */
-		val = wl1271_top_reg_read(wl, OCP_REG_CLK_PULL);
+		ret = wl1271_top_reg_read(wl, OCP_REG_CLK_PULL, &val);
+		if (ret < 0)
+			return ret;
+
 		val |= NO_PULL;
-		wl1271_top_reg_write(wl, OCP_REG_CLK_PULL, val);
+		ret = wl1271_top_reg_write(wl, OCP_REG_CLK_PULL, val);
+		if (ret < 0)
+			return ret;
 	} else {
 		u16 val;
 		/* Set clock polarity */
-		val = wl1271_top_reg_read(wl, OCP_REG_CLK_POLARITY);
+		ret = wl1271_top_reg_read(wl, OCP_REG_CLK_POLARITY, &val);
+		if (ret < 0)
+			return ret;
+
 		val &= FREF_CLK_POLARITY_BITS;
 		val |= CLK_REQ_OUTN_SEL;
-		wl1271_top_reg_write(wl, OCP_REG_CLK_POLARITY, val);
+		ret = wl1271_top_reg_write(wl, OCP_REG_CLK_POLARITY, val);
+		if (ret < 0)
+			return ret;
 	}
 
-	wl1271_write32(wl, PLL_PARAMETERS, clk);
+	ret = wl1271_write32(wl, PLL_PARAMETERS, clk);
+	if (ret < 0)
+		goto out;
 
-	pause = wl1271_read32(wl, PLL_PARAMETERS);
+	ret = wl1271_read32(wl, PLL_PARAMETERS, &pause);
+	if (ret < 0)
+		goto out;
 
 	wl1271_debug(DEBUG_BOOT, "pause1 0x%x", pause);
 
 	pause &= ~(WU_COUNTER_PAUSE_VAL);
 	pause |= WU_COUNTER_PAUSE_VAL;
-	wl1271_write32(wl, WU_COUNTER_PAUSE, pause);
+	ret = wl1271_write32(wl, WU_COUNTER_PAUSE, pause);
 
-	return 0;
+out:
+	return ret;
 }
 
 /* uploads NVS and firmware */
@@ -680,28 +810,22 @@ int wl1271_load_firmware(struct wl1271 *wl)
 	u32 tmp, clk;
 	int selected_clock = -1;
 
-	if (wl->chip.id == CHIP_ID_1283_PG20) {
-		ret = wl128x_boot_clk(wl, &selected_clock);
-		if (ret < 0)
-			goto out;
-	} else {
-		ret = wl127x_boot_clk(wl);
-		if (ret < 0)
-			goto out;
-	}
-
-	/* Continue the ELP wake up sequence */
-	wl1271_write32(wl, WELP_ARM_COMMAND, WELP_ARM_COMMAND_VAL);
-	udelay(500);
+	ret = wl12xx_init_pll_clock(wl, &selected_clock);
+	if (ret < 0)
+		goto out;
 
-	wl1271_set_partition(wl, &wl12xx_part_table[PART_DRPW]);
+	ret = wl1271_set_partition(wl, &wl12xx_part_table[PART_DRPW]);
+	if (ret < 0)
+		goto out;
 
 	/* Read-modify-write DRPW_SCRATCH_START register (see next state)
 	   to be used by DRPw FW. The RTRIM value will be added by the FW
 	   before taking DRPw out of reset */
 
 	wl1271_debug(DEBUG_BOOT, "DRPW_SCRATCH_START %08x", DRPW_SCRATCH_START);
-	clk = wl1271_read32(wl, DRPW_SCRATCH_START);
+	ret = wl1271_read32(wl, DRPW_SCRATCH_START, &clk);
+	if (ret < 0)
+		goto out;
 
 	wl1271_debug(DEBUG_BOOT, "clk2 0x%x", clk);
 
@@ -711,12 +835,18 @@ int wl1271_load_firmware(struct wl1271 *wl)
 		clk |= (wl->ref_clock << 1) << 4;
 	}
 
-	wl1271_write32(wl, DRPW_SCRATCH_START, clk);
+	ret = wl1271_write32(wl, DRPW_SCRATCH_START, clk);
+	if (ret < 0)
+		goto out;
 
-	wl1271_set_partition(wl, &wl12xx_part_table[PART_WORK]);
+	ret = wl1271_set_partition(wl, &wl12xx_part_table[PART_WORK]);
+	if (ret < 0)
+		goto out;
 
 	/* Disable interrupts */
-	wl1271_write32(wl, ACX_REG_INTERRUPT_MASK, WL1271_ACX_INTR_ALL);
+	ret = wl1271_write32(wl, ACX_REG_INTERRUPT_MASK, WL1271_ACX_INTR_ALL);
+	if (ret < 0)
+		goto out;
 
 	ret = wl1271_boot_soft_reset(wl);
 	if (ret < 0)
@@ -731,20 +861,30 @@ int wl1271_load_firmware(struct wl1271 *wl)
 	 * ACX_EEPROMLESS_IND_REG */
 	wl1271_debug(DEBUG_BOOT, "ACX_EEPROMLESS_IND_REG");
 
-	wl1271_write32(wl, ACX_EEPROMLESS_IND_REG, ACX_EEPROMLESS_IND_REG);
+	ret = wl1271_write32(wl, ACX_EEPROMLESS_IND_REG,
+			     ACX_EEPROMLESS_IND_REG);
+	if (ret < 0)
+		goto out;
 
-	tmp = wl1271_read32(wl, CHIP_ID_B);
+	ret = wl1271_read32(wl, CHIP_ID_B, &tmp);
+	if (ret < 0)
+		goto out;
 
 	wl1271_debug(DEBUG_BOOT, "chip id 0x%x", tmp);
 
 	/* 6. read the EEPROM parameters */
-	tmp = wl1271_read32(wl, SCR_PAD2);
+	ret = wl1271_read32(wl, SCR_PAD2, &tmp);
+	if (ret < 0)
+		goto out;
 
 	/* WL1271: The reference driver skips steps 7 to 10 (jumps directly
 	 * to upload_fw) */
 
-	if (wl->chip.id == CHIP_ID_1283_PG20)
-		wl1271_top_reg_write(wl, SDIO_IO_DS, wl->conf.hci_io_ds);
+	if (wl->chip.id == CHIP_ID_1283_PG20) {
+		ret = wl1271_top_reg_write(wl, SDIO_IO_DS, wl->conf.hci_io_ds);
+		if (ret < 0)
+			goto out;
+	}
 
 	ret = wl1271_boot_upload_firmware(wl);
 	if (ret < 0)
@@ -776,13 +916,17 @@ int wl1271_boot(struct wl1271 *wl)
 	if (ret < 0)
 		goto out;
 
-	wl1271_write32(wl, ACX_REG_INTERRUPT_MASK,
-		       WL1271_ACX_ALL_EVENTS_VECTOR);
+	ret = wl1271_write32(wl, ACX_REG_INTERRUPT_MASK,
+			     WL1271_ACX_ALL_EVENTS_VECTOR);
+	if (ret < 0)
+		goto out;
 
 	/* Enable firmware interrupts now */
-	wl1271_boot_enable_interrupts(wl);
+	ret = wl1271_boot_enable_interrupts(wl);
+	if (ret < 0)
+		goto out;
 
-	wl1271_event_mbox_config(wl);
+	ret = wl1271_event_mbox_config(wl);
 
 out:
 	return ret;
diff --git a/wl12xx-compat/drivers/net/wireless/wl12xx/boot.h b/wl12xx-compat/drivers/net/wireless/wl12xx/boot.h
index c3adc09..29e5259 100644
--- a/wl12xx-compat/drivers/net/wireless/wl12xx/boot.h
+++ b/wl12xx-compat/drivers/net/wireless/wl12xx/boot.h
@@ -28,6 +28,8 @@
 
 int wl1271_boot(struct wl1271 *wl);
 int wl1271_load_firmware(struct wl1271 *wl);
+int wl128x_boot_clk(struct wl1271 *wl, int *selected_clock);
+int wl127x_boot_clk(struct wl1271 *wl);
 
 #define WL1271_NO_SUBBANDS 8
 #define WL1271_NO_POWER_LEVELS 4
diff --git a/wl12xx-compat/drivers/net/wireless/wl12xx/cmd.c b/wl12xx-compat/drivers/net/wireless/wl12xx/cmd.c
index 4afe44f..9515853 100644
--- a/wl12xx-compat/drivers/net/wireless/wl12xx/cmd.c
+++ b/wl12xx-compat/drivers/net/wireless/wl12xx/cmd.c
@@ -65,13 +65,20 @@ int wl1271_cmd_send(struct wl1271 *wl, u16 id, void *buf, size_t len,
 	WARN_ON(len % 4 != 0);
 	WARN_ON(test_bit(WL1271_FLAG_IN_ELP, &wl->flags));
 
-	wl1271_write(wl, wl->cmd_box_addr, buf, len, false);
+	ret = wl1271_write(wl, wl->cmd_box_addr, buf, len, false);
+	if (ret < 0)
+		goto fail;
 
-	wl1271_write32(wl, ACX_REG_INTERRUPT_TRIG, INTR_TRIG_CMD);
+	ret = wl1271_write32(wl, ACX_REG_INTERRUPT_TRIG, INTR_TRIG_CMD);
+	if (ret < 0)
+		goto fail;
 
 	timeout = jiffies + msecs_to_jiffies(WL1271_COMMAND_TIMEOUT);
 
-	intr = wl1271_read32(wl, ACX_REG_INTERRUPT_NO_CLEAR);
+	ret = wl1271_read32(wl, ACX_REG_INTERRUPT_NO_CLEAR, &intr);
+	if (ret < 0)
+		goto fail;
+
 	while (!(intr & WL1271_ACX_INTR_CMD_COMPLETE)) {
 		if (time_after(jiffies, timeout)) {
 			wl1271_error("command complete timeout");
@@ -85,13 +92,17 @@ int wl1271_cmd_send(struct wl1271 *wl, u16 id, void *buf, size_t len,
 		else
 			msleep(1);
 
-		intr = wl1271_read32(wl, ACX_REG_INTERRUPT_NO_CLEAR);
+		ret = wl1271_read32(wl, ACX_REG_INTERRUPT_NO_CLEAR, &intr);
+		if (ret < 0)
+			goto fail;
 	}
 
 	/* read back the status code of the command */
 	if (res_len == 0)
 		res_len = sizeof(struct wl1271_cmd_header);
-	wl1271_read(wl, wl->cmd_box_addr, cmd, res_len, false);
+	ret = wl1271_read(wl, wl->cmd_box_addr, cmd, res_len, false);
+	if (ret < 0)
+		goto fail;
 
 	status = le16_to_cpu(cmd->status);
 	if (status != CMD_STATUS_SUCCESS) {
@@ -100,12 +111,11 @@ int wl1271_cmd_send(struct wl1271 *wl, u16 id, void *buf, size_t len,
 		goto fail;
 	}
 
-	wl1271_write32(wl, ACX_REG_INTERRUPT_ACK,
-		       WL1271_ACX_INTR_CMD_COMPLETE);
-	return 0;
+	ret = wl1271_write32(wl, ACX_REG_INTERRUPT_ACK,
+			     WL1271_ACX_INTR_CMD_COMPLETE);
+	return ret;
 
 fail:
-	WARN_ON(1);
 	wl12xx_queue_recovery_work(wl);
 	return ret;
 }
@@ -340,28 +350,40 @@ int wl1271_cmd_ext_radio_parms(struct wl1271 *wl)
  * Poll the mailbox event field until any of the bits in the mask is set or a
  * timeout occurs (WL1271_EVENT_TIMEOUT in msecs)
  */
-static int wl1271_cmd_wait_for_event_or_timeout(struct wl1271 *wl, u32 mask)
+static int wl1271_cmd_wait_for_event_or_timeout(struct wl1271 *wl, u32 mask,
+						bool *timeout)
 {
 	u32 events_vector, event;
-	unsigned long timeout;
+	unsigned long timeout_time;
+	int ret;
 
-	timeout = jiffies + msecs_to_jiffies(WL1271_EVENT_TIMEOUT);
+	*timeout = false;
+
+	timeout_time = jiffies + msecs_to_jiffies(WL1271_EVENT_TIMEOUT);
 
 	do {
-		if (time_after(jiffies, timeout)) {
+		if (time_after(jiffies, timeout_time)) {
 			wl1271_debug(DEBUG_CMD, "timeout waiting for event %d",
 				     (int)mask);
-			return -ETIMEDOUT;
+			*timeout = true;
+			return 0;
 		}
 
 		msleep(1);
 
 		/* read from both event fields */
-		wl1271_read(wl, wl->mbox_ptr[0], &events_vector,
-			    sizeof(events_vector), false);
+		ret = wl1271_read(wl, wl->mbox_ptr[0], &events_vector,
+				  sizeof(events_vector), false);
+		if (ret < 0)
+			return ret;
+
 		event = events_vector & mask;
-		wl1271_read(wl, wl->mbox_ptr[1], &events_vector,
-			    sizeof(events_vector), false);
+
+		ret = wl1271_read(wl, wl->mbox_ptr[1], &events_vector,
+				  sizeof(events_vector), false);
+		if (ret < 0)
+			return ret;
+
 		event |= events_vector & mask;
 	} while (!event);
 
@@ -371,9 +393,10 @@ static int wl1271_cmd_wait_for_event_or_timeout(struct wl1271 *wl, u32 mask)
 static int wl1271_cmd_wait_for_event(struct wl1271 *wl, u32 mask)
 {
 	int ret;
+	bool timeout = false;
 
-	ret = wl1271_cmd_wait_for_event_or_timeout(wl, mask);
-	if (ret != 0) {
+	ret = wl1271_cmd_wait_for_event_or_timeout(wl, mask, &timeout);
+	if (ret != 0 || timeout) {
 		wl12xx_queue_recovery_work(wl);
 		return ret;
 	}
@@ -1179,12 +1202,14 @@ out:
 int wl12xx_cmd_build_probe_req(struct wl1271 *wl, struct wl12xx_vif *wlvif,
 			       u8 role_id, u8 band,
 			       const u8 *ssid, size_t ssid_len,
-			       const u8 *ie, size_t ie_len)
+			       const u8 *ie, size_t ie_len, bool sched_scan)
 {
 	struct ieee80211_vif *vif = wl12xx_wlvif_to_vif(wlvif);
 	struct sk_buff *skb;
 	int ret;
 	u32 rate;
+	u16 template_id_2_4 = CMD_TEMPL_CFG_PROBE_REQ_2_4;
+	u16 template_id_5 = CMD_TEMPL_CFG_PROBE_REQ_5;
 
 	skb = ieee80211_probereq_get(wl->hw, vif, ssid, ssid_len,
 				     ie, ie_len);
@@ -1195,14 +1220,19 @@ int wl12xx_cmd_build_probe_req(struct wl1271 *wl, struct wl12xx_vif *wlvif,
 
 	wl1271_dump(DEBUG_SCAN, "PROBE REQ: ", skb->data, skb->len);
 
+	if (!sched_scan) {
+		template_id_2_4 = CMD_TEMPL_APP_PROBE_REQ_2_4;
+		template_id_5 = CMD_TEMPL_APP_PROBE_REQ_5;
+	}
+
 	rate = wl1271_tx_min_rate_get(wl, wlvif->bitrate_masks[band]);
 	if (band == IEEE80211_BAND_2GHZ)
 		ret = wl1271_cmd_template_set(wl, role_id,
-					      CMD_TEMPL_CFG_PROBE_REQ_2_4,
+					      template_id_2_4,
 					      skb->data, skb->len, 0, rate);
 	else
 		ret = wl1271_cmd_template_set(wl, role_id,
-					      CMD_TEMPL_CFG_PROBE_REQ_5,
+					      template_id_5,
 					      skb->data, skb->len, 0, rate);
 
 out:
@@ -1606,6 +1636,7 @@ int wl12xx_cmd_remove_peer(struct wl1271 *wl, u8 hlid)
 {
 	struct wl12xx_cmd_remove_peer *cmd;
 	int ret;
+	bool timeout = false;
 
 	wl1271_debug(DEBUG_CMD, "cmd remove peer %d", (int)hlid);
 
@@ -1626,12 +1657,16 @@ int wl12xx_cmd_remove_peer(struct wl1271 *wl, u8 hlid)
 		goto out_free;
 	}
 
+	ret = wl1271_cmd_wait_for_event_or_timeout(wl,
+					   PEER_REMOVE_COMPLETE_EVENT_ID,
+					   &timeout);
 	/*
 	 * We are ok with a timeout here. The event is sometimes not sent
-	 * due to a firmware bug.
+	 * due to a firmware bug. In case of another error (like SDIO timeout)
+	 * queue a recovery.
 	 */
-	wl1271_cmd_wait_for_event_or_timeout(wl,
-					     PEER_REMOVE_COMPLETE_EVENT_ID);
+	if (ret)
+		wl12xx_queue_recovery_work(wl);
 
 out_free:
 	kfree(cmd);
@@ -1839,6 +1874,14 @@ int wl12xx_croc(struct wl1271 *wl, u8 role_id)
 		goto out;
 
 	__clear_bit(role_id, wl->roc_map);
+
+	/*
+	 * Rearm the tx watchdog when removing the last ROC. This prevents
+	 * recoveries due to just finished ROCs - when Tx hasn't yet had
+	 * a chance to get out.
+	 */
+	if (find_first_bit(wl->roc_map, WL12XX_MAX_ROLES) >= WL12XX_MAX_ROLES)
+		wl12xx_rearm_tx_watchdog_locked(wl);
 out:
 	return ret;
 }
@@ -1940,7 +1983,9 @@ int wl12xx_stop_dev(struct wl1271 *wl, struct wl12xx_vif *wlvif)
 		return -EINVAL;
 
 	/* flush all pending packets */
-	wl1271_tx_work_locked(wl);
+	ret = wl1271_tx_work_locked(wl);
+	if (ret < 0)
+		goto out;
 
 	if (test_bit(wlvif->dev_role_id, wl->roc_map)) {
 		ret = wl12xx_croc(wl, wlvif->dev_role_id);
diff --git a/wl12xx-compat/drivers/net/wireless/wl12xx/cmd.h b/wl12xx-compat/drivers/net/wireless/wl12xx/cmd.h
index fe3ffeb..3a67fe6 100644
--- a/wl12xx-compat/drivers/net/wireless/wl12xx/cmd.h
+++ b/wl12xx-compat/drivers/net/wireless/wl12xx/cmd.h
@@ -63,7 +63,7 @@ int wl1271_cmd_build_ps_poll(struct wl1271 *wl, struct wl12xx_vif *wlvif,
 int wl12xx_cmd_build_probe_req(struct wl1271 *wl, struct wl12xx_vif *wlvif,
 			       u8 role_id, u8 band,
 			       const u8 *ssid, size_t ssid_len,
-			       const u8 *ie, size_t ie_len);
+			       const u8 *ie, size_t ie_len, bool sched_scan);
 struct sk_buff *wl1271_cmd_build_ap_probe_req(struct wl1271 *wl,
 					      struct wl12xx_vif *wlvif,
 					      struct sk_buff *skb);
@@ -177,8 +177,8 @@ enum cmd_templ {
 	CMD_TEMPL_PS_POLL,
 	CMD_TEMPL_KLV,
 	CMD_TEMPL_DISCONNECT,
-	CMD_TEMPL_PROBE_REQ_2_4, /* for firmware internal use only */
-	CMD_TEMPL_PROBE_REQ_5,   /* for firmware internal use only */
+	CMD_TEMPL_APP_PROBE_REQ_2_4,
+	CMD_TEMPL_APP_PROBE_REQ_5,
 	CMD_TEMPL_BAR,           /* for firmware internal use only */
 	CMD_TEMPL_CTS,           /*
 				  * For CTS-to-self (FastCTS) mechanism
@@ -197,7 +197,7 @@ enum cmd_templ {
 #define WL1271_COMMAND_TIMEOUT     2000
 #define WL1271_CMD_TEMPL_DFLT_SIZE 252
 #define WL1271_CMD_TEMPL_MAX_SIZE  512
-#define WL1271_EVENT_TIMEOUT       1000
+#define WL1271_EVENT_TIMEOUT       1500
 
 struct wl1271_cmd_header {
 	__le16 id;
diff --git a/wl12xx-compat/drivers/net/wireless/wl12xx/conf.h b/wl12xx-compat/drivers/net/wireless/wl12xx/conf.h
index 7ca6c6c..cb03274 100644
--- a/wl12xx-compat/drivers/net/wireless/wl12xx/conf.h
+++ b/wl12xx-compat/drivers/net/wireless/wl12xx/conf.h
@@ -690,6 +690,9 @@ struct conf_tx_settings {
 	 */
 	u8 tmpl_short_retry_limit;
 	u8 tmpl_long_retry_limit;
+
+	/* Time in ms for Tx watchdog timer to expire */
+	u32 tx_watchdog_timeout;
 };
 
 enum {
@@ -979,6 +982,13 @@ struct conf_conn_settings {
 	 * Range: u16
 	 */
 	u8 max_listen_interval;
+
+	/*
+	 * Specifies the timeout in which the host will allow the chip to go
+	 * into ELP. Mainly needed for TX traffic to prevent the host from
+	 * interrogating the FW status for each packets.
+	 */
+	u16 elp_timeout;
 };
 
 enum {
diff --git a/wl12xx-compat/drivers/net/wireless/wl12xx/debugfs.c b/wl12xx-compat/drivers/net/wireless/wl12xx/debugfs.c
index acee35f..59cc5d9 100644
--- a/wl12xx-compat/drivers/net/wireless/wl12xx/debugfs.c
+++ b/wl12xx-compat/drivers/net/wireless/wl12xx/debugfs.c
@@ -487,6 +487,52 @@ static const struct file_operations split_scan_timeout_ops = {
 	.llseek = default_llseek,
 };
 
+
+static ssize_t elp_timeout_read(struct file *file, char __user *user_buf,
+			  size_t count, loff_t *ppos)
+{
+	struct wl1271 *wl = file->private_data;
+
+	return wl1271_format_buffer(user_buf, count,
+				    ppos, "%d\n",
+				    wl->conf.conn.elp_timeout);
+}
+
+static ssize_t elp_timeout_write(struct file *file,
+				    const char __user *user_buf,
+				    size_t count, loff_t *ppos)
+{
+	struct wl1271 *wl = file->private_data;
+	unsigned long value;
+	int ret;
+
+	ret = kstrtoul_from_user(user_buf, count, 10, &value);
+	if (ret < 0) {
+		wl1271_warning("illegal value in dynamic_ps");
+		return -EINVAL;
+	}
+
+	if (value < 1 || value > 65535) {
+		wl1271_warning("dyanmic_ps_timeout is not in valid range");
+		return -ERANGE;
+	}
+
+	mutex_lock(&wl->mutex);
+
+	wl->conf.conn.elp_timeout = value;
+
+	mutex_unlock(&wl->mutex);
+	return count;
+}
+
+static const struct file_operations elp_timeout_ops = {
+	.read = elp_timeout_read,
+	.write = elp_timeout_write,
+	.open = wl1271_open_file_generic,
+	.llseek = default_llseek,
+};
+
+
 static ssize_t driver_state_read(struct file *file, char __user *user_buf,
 				 size_t count, loff_t *ppos)
 {
@@ -1132,6 +1178,7 @@ static int wl1271_debugfs_add_files(struct wl1271 *wl,
 	DEBUGFS_ADD(dynamic_ps_timeout, rootdir);
 	DEBUGFS_ADD(forced_ps, rootdir);
 	DEBUGFS_ADD(split_scan_timeout, rootdir);
+	DEBUGFS_ADD(elp_timeout, rootdir);
 
 	streaming = debugfs_create_dir("rx_streaming", rootdir);
 	if (!streaming || IS_ERR(streaming))
diff --git a/wl12xx-compat/drivers/net/wireless/wl12xx/event.c b/wl12xx-compat/drivers/net/wireless/wl12xx/event.c
index a080781..9e1003b 100644
--- a/wl12xx-compat/drivers/net/wireless/wl12xx/event.c
+++ b/wl12xx-compat/drivers/net/wireless/wl12xx/event.c
@@ -306,13 +306,20 @@ int wl1271_event_unmask(struct wl1271 *wl)
 	return 0;
 }
 
-void wl1271_event_mbox_config(struct wl1271 *wl)
+int wl1271_event_mbox_config(struct wl1271 *wl)
 {
-	wl->mbox_ptr[0] = wl1271_read32(wl, REG_EVENT_MAILBOX_PTR);
+	int ret;
+
+	ret = wl1271_read32(wl, REG_EVENT_MAILBOX_PTR, &wl->mbox_ptr[0]);
+	if (ret < 0)
+		return ret;
+
 	wl->mbox_ptr[1] = wl->mbox_ptr[0] + sizeof(struct event_mailbox);
 
 	wl1271_debug(DEBUG_EVENT, "MBOX ptrs: 0x%x 0x%x",
 		     wl->mbox_ptr[0], wl->mbox_ptr[1]);
+
+	return 0;
 }
 
 int wl1271_event_handle(struct wl1271 *wl, u8 mbox_num)
@@ -326,8 +333,10 @@ int wl1271_event_handle(struct wl1271 *wl, u8 mbox_num)
 		return -EINVAL;
 
 	/* first we read the mbox descriptor */
-	wl1271_read(wl, wl->mbox_ptr[mbox_num], &mbox,
-		    sizeof(struct event_mailbox), false);
+	ret = wl1271_read(wl, wl->mbox_ptr[mbox_num], &mbox,
+			  sizeof(struct event_mailbox), false);
+	if (ret < 0)
+		return ret;
 
 	/* process the descriptor */
 	ret = wl1271_event_process(wl, &mbox);
@@ -335,7 +344,7 @@ int wl1271_event_handle(struct wl1271 *wl, u8 mbox_num)
 		return ret;
 
 	/* then we let the firmware know it can go on...*/
-	wl1271_write32(wl, ACX_REG_INTERRUPT_TRIG, INTR_TRIG_EVENT_ACK);
+	ret = wl1271_write32(wl, ACX_REG_INTERRUPT_TRIG, INTR_TRIG_EVENT_ACK);
 
-	return 0;
+	return ret;
 }
diff --git a/wl12xx-compat/drivers/net/wireless/wl12xx/event.h b/wl12xx-compat/drivers/net/wireless/wl12xx/event.h
index 057d193..803e8a4 100644
--- a/wl12xx-compat/drivers/net/wireless/wl12xx/event.h
+++ b/wl12xx-compat/drivers/net/wireless/wl12xx/event.h
@@ -133,7 +133,7 @@ struct event_mailbox {
 } __packed;
 
 int wl1271_event_unmask(struct wl1271 *wl);
-void wl1271_event_mbox_config(struct wl1271 *wl);
+int wl1271_event_mbox_config(struct wl1271 *wl);
 int wl1271_event_handle(struct wl1271 *wl, u8 mbox);
 
 #endif
diff --git a/wl12xx-compat/drivers/net/wireless/wl12xx/init.c b/wl12xx-compat/drivers/net/wireless/wl12xx/init.c
index 88a4679..88d4282 100644
--- a/wl12xx-compat/drivers/net/wireless/wl12xx/init.c
+++ b/wl12xx-compat/drivers/net/wireless/wl12xx/init.c
@@ -55,6 +55,20 @@ int wl1271_init_templates_config(struct wl1271 *wl)
 		return ret;
 
 	ret = wl1271_cmd_template_set(wl, WL12XX_INVALID_ROLE_ID,
+			CMD_TEMPL_APP_PROBE_REQ_2_4, NULL,
+			WL1271_CMD_TEMPL_MAX_SIZE,
+			0, WL1271_RATE_AUTOMATIC);
+	if (ret < 0)
+		return ret;
+
+	ret = wl1271_cmd_template_set(wl, WL12XX_INVALID_ROLE_ID,
+			CMD_TEMPL_APP_PROBE_REQ_5, NULL,
+			WL1271_CMD_TEMPL_MAX_SIZE,
+			0, WL1271_RATE_AUTOMATIC);
+	if (ret < 0)
+		return ret;
+
+	ret = wl1271_cmd_template_set(wl, WL12XX_INVALID_ROLE_ID,
 				      CMD_TEMPL_NULL_DATA, NULL,
 				      sizeof(struct wl12xx_null_data_template),
 				      0, WL1271_RATE_AUTOMATIC);
@@ -573,7 +587,6 @@ int wl1271_init_vif_specific(struct wl1271 *wl, struct ieee80211_vif *vif)
 
 	/*
 	 * consider all existing roles before configuring psm.
-	 * TODO: reconfigure on interface removal.
 	 */
 	if (!wl->ap_count) {
 		if (is_ap) {
diff --git a/wl12xx-compat/drivers/net/wireless/wl12xx/io.c b/wl12xx-compat/drivers/net/wireless/wl12xx/io.c
index c574a3b..573c9a2 100644
--- a/wl12xx-compat/drivers/net/wireless/wl12xx/io.c
+++ b/wl12xx-compat/drivers/net/wireless/wl12xx/io.c
@@ -119,11 +119,21 @@ void wl1271_disable_interrupts(struct wl1271 *wl)
 	disable_irq(wl->irq);
 }
 
+void wlcore_disable_interrupts_nosync(struct wl1271 *wl)
+{
+	disable_irq_nosync(wl->irq);
+}
+
 void wl1271_enable_interrupts(struct wl1271 *wl)
 {
 	enable_irq(wl->irq);
 }
 
+void wlcore_synchronize_interrupts(struct wl1271 *wl)
+{
+	synchronize_irq(wl->irq);
+}
+
 /* Set the SPI partitions to access the chip addresses
  *
  * To simplify driver code, a fixed (virtual) memory map is defined for
@@ -161,6 +171,8 @@ void wl1271_enable_interrupts(struct wl1271 *wl)
 int wl1271_set_partition(struct wl1271 *wl,
 			 struct wl1271_partition_set *p)
 {
+	int ret;
+
 	/* copy partition info */
 	memcpy(&wl->part, p, sizeof(*p));
 
@@ -174,15 +186,33 @@ int wl1271_set_partition(struct wl1271 *wl,
 		     p->mem3.start, p->mem3.size);
 
 	/* write partition info to the chipset */
-	wl1271_raw_write32(wl, HW_PART0_START_ADDR, p->mem.start);
-	wl1271_raw_write32(wl, HW_PART0_SIZE_ADDR, p->mem.size);
-	wl1271_raw_write32(wl, HW_PART1_START_ADDR, p->reg.start);
-	wl1271_raw_write32(wl, HW_PART1_SIZE_ADDR, p->reg.size);
-	wl1271_raw_write32(wl, HW_PART2_START_ADDR, p->mem2.start);
-	wl1271_raw_write32(wl, HW_PART2_SIZE_ADDR, p->mem2.size);
-	wl1271_raw_write32(wl, HW_PART3_START_ADDR, p->mem3.start);
+	ret = wl1271_raw_write32(wl, HW_PART0_START_ADDR, p->mem.start);
+	if (ret < 0)
+		return ret;
 
-	return 0;
+	ret = wl1271_raw_write32(wl, HW_PART0_SIZE_ADDR, p->mem.size);
+	if (ret < 0)
+		return ret;
+
+	ret = wl1271_raw_write32(wl, HW_PART1_START_ADDR, p->reg.start);
+	if (ret < 0)
+		return ret;
+
+	ret = wl1271_raw_write32(wl, HW_PART1_SIZE_ADDR, p->reg.size);
+	if (ret < 0)
+		return ret;
+
+	ret = wl1271_raw_write32(wl, HW_PART2_START_ADDR, p->mem2.start);
+	if (ret < 0)
+		return ret;
+
+	ret = wl1271_raw_write32(wl, HW_PART2_SIZE_ADDR, p->mem2.size);
+	if (ret < 0)
+		return ret;
+
+	ret = wl1271_raw_write32(wl, HW_PART3_START_ADDR, p->mem3.start);
+
+	return ret;
 }
 EXPORT_SYMBOL_GPL(wl1271_set_partition);
 
@@ -198,47 +228,66 @@ void wl1271_io_init(struct wl1271 *wl)
 		wl->if_ops->init(wl->dev);
 }
 
-void wl1271_top_reg_write(struct wl1271 *wl, int addr, u16 val)
+int __must_check wl1271_top_reg_write(struct wl1271 *wl, int addr, u16 val)
 {
+	int ret;
+
 	/* write address >> 1 + 0x30000 to OCP_POR_CTR */
 	addr = (addr >> 1) + 0x30000;
-	wl1271_write32(wl, OCP_POR_CTR, addr);
+	ret = wl1271_write32(wl, OCP_POR_CTR, addr);
+	if (ret < 0)
+		goto out;
 
 	/* write value to OCP_POR_WDATA */
-	wl1271_write32(wl, OCP_DATA_WRITE, val);
+	ret = wl1271_write32(wl, OCP_DATA_WRITE, val);
+	if (ret < 0)
+		goto out;
 
 	/* write 1 to OCP_CMD */
-	wl1271_write32(wl, OCP_CMD, OCP_CMD_WRITE);
+	ret = wl1271_write32(wl, OCP_CMD, OCP_CMD_WRITE);
+
+out:
+	return ret;
 }
 
-u16 wl1271_top_reg_read(struct wl1271 *wl, int addr)
+int __must_check wl1271_top_reg_read(struct wl1271 *wl, int addr, u16 *out)
 {
 	u32 val;
 	int timeout = OCP_CMD_LOOP;
+	int ret;
 
 	/* write address >> 1 + 0x30000 to OCP_POR_CTR */
 	addr = (addr >> 1) + 0x30000;
-	wl1271_write32(wl, OCP_POR_CTR, addr);
+	ret = wl1271_write32(wl, OCP_POR_CTR, addr);
+	if (ret < 0)
+		return ret;
 
 	/* write 2 to OCP_CMD */
-	wl1271_write32(wl, OCP_CMD, OCP_CMD_READ);
+	ret = wl1271_write32(wl, OCP_CMD, OCP_CMD_READ);
+	if (ret < 0)
+		return ret;
 
 	/* poll for data ready */
 	do {
-		val = wl1271_read32(wl, OCP_DATA_READ);
+		ret = wl1271_read32(wl, OCP_DATA_READ, &val);
+		if (ret < 0)
+			return ret;
 	} while (!(val & OCP_READY_MASK) && --timeout);
 
 	if (!timeout) {
 		wl1271_warning("Top register access timed out.");
-		return 0xffff;
+		return -ETIMEDOUT;
 	}
 
 	/* check data status and return if OK */
-	if ((val & OCP_STATUS_MASK) == OCP_STATUS_OK)
-		return val & 0xffff;
-	else {
+	if ((val & OCP_STATUS_MASK) != OCP_STATUS_OK) {
 		wl1271_warning("Top register access returned error.");
-		return 0xffff;
+		return -EIO;
 	}
+
+	if (out)
+		*out = val & 0xffff;
+
+	return 0;
 }
 
diff --git a/wl12xx-compat/drivers/net/wireless/wl12xx/io.h b/wl12xx-compat/drivers/net/wireless/wl12xx/io.h
index 4fb3dab..38c2023 100644
--- a/wl12xx-compat/drivers/net/wireless/wl12xx/io.h
+++ b/wl12xx-compat/drivers/net/wireless/wl12xx/io.h
@@ -48,37 +48,69 @@ extern struct wl1271_partition_set wl12xx_part_table[PART_TABLE_LEN];
 struct wl1271;
 
 void wl1271_disable_interrupts(struct wl1271 *wl);
+void wlcore_disable_interrupts_nosync(struct wl1271 *wl);
 void wl1271_enable_interrupts(struct wl1271 *wl);
+void wlcore_synchronize_interrupts(struct wl1271 *wl);
 
 void wl1271_io_reset(struct wl1271 *wl);
 void wl1271_io_init(struct wl1271 *wl);
 
 /* Raw target IO, address is not translated */
-static inline void wl1271_raw_write(struct wl1271 *wl, int addr, void *buf,
-				    size_t len, bool fixed)
+static inline int __must_check wl1271_raw_write(struct wl1271 *wl, int addr,
+						void *buf, size_t len, bool
+						fixed)
 {
-	wl->if_ops->write(wl->dev, addr, buf, len, fixed);
+	int ret;
+
+	if (test_bit(WL1271_FLAG_IO_FAILED, &wl->flags))
+		return -EIO;
+
+	ret = wl->if_ops->write(wl->dev, addr, buf, len, fixed);
+	if (ret && wl->state != WL1271_STATE_OFF)
+		set_bit(WL1271_FLAG_IO_FAILED, &wl->flags);
+
+	return ret;
 }
 
-static inline void wl1271_raw_read(struct wl1271 *wl, int addr, void *buf,
-				   size_t len, bool fixed)
+static inline int __must_check wl1271_raw_read(struct wl1271 *wl, int addr,
+					       void *buf, size_t len, bool
+					       fixed)
 {
-	wl->if_ops->read(wl->dev, addr, buf, len, fixed);
+	int ret;
+
+	if (test_bit(WL1271_FLAG_IO_FAILED, &wl->flags))
+		return -EIO;
+
+	ret = wl->if_ops->read(wl->dev, addr, buf, len, fixed);
+	if (ret && wl->state != WL1271_STATE_OFF)
+		set_bit(WL1271_FLAG_IO_FAILED, &wl->flags);
+
+	return ret;
 }
 
-static inline u32 wl1271_raw_read32(struct wl1271 *wl, int addr)
+static inline int __must_check wl1271_raw_read32(struct wl1271 *wl, int addr,
+						 u32 *val)
 {
-	wl1271_raw_read(wl, addr, &wl->buffer_32,
-			    sizeof(wl->buffer_32), false);
+	int ret;
+
+	ret = wl1271_raw_read(wl, addr, &wl->buffer_32, sizeof(wl->buffer_32),
+			      false);
+	if (ret < 0)
+		goto out;
+
+	if (val)
+		*val = le32_to_cpu(wl->buffer_32);
 
-	return le32_to_cpu(wl->buffer_32);
+out:
+	return ret;
 }
 
-static inline void wl1271_raw_write32(struct wl1271 *wl, int addr, u32 val)
+static inline int __must_check wl1271_raw_write32(struct wl1271 *wl, int addr,
+						  u32 val)
 {
 	wl->buffer_32 = cpu_to_le32(val);
-	wl1271_raw_write(wl, addr, &wl->buffer_32,
-			     sizeof(wl->buffer_32), false);
+	return wl1271_raw_write(wl, addr, &wl->buffer_32,
+				sizeof(wl->buffer_32), false);
 }
 
 /* Translated target IO */
@@ -105,28 +137,29 @@ static inline int wl1271_translate_addr(struct wl1271 *wl, int addr)
 		return addr - wl->part.mem.start;
 }
 
-static inline void wl1271_read(struct wl1271 *wl, int addr, void *buf,
-			       size_t len, bool fixed)
+static inline int __must_check wl1271_read(struct wl1271 *wl, int addr,
+					   void *buf, size_t len, bool fixed)
 {
 	int physical;
 
 	physical = wl1271_translate_addr(wl, addr);
 
-	wl1271_raw_read(wl, physical, buf, len, fixed);
+	return wl1271_raw_read(wl, physical, buf, len, fixed);
 }
 
-static inline void wl1271_write(struct wl1271 *wl, int addr, void *buf,
-				size_t len, bool fixed)
+static inline int __must_check wl1271_write(struct wl1271 *wl, int addr,
+					    void *buf, size_t len, bool fixed)
 {
 	int physical;
 
 	physical = wl1271_translate_addr(wl, addr);
 
-	wl1271_raw_write(wl, physical, buf, len, fixed);
+	return wl1271_raw_write(wl, physical, buf, len, fixed);
 }
 
-static inline void wl1271_read_hwaddr(struct wl1271 *wl, int hwaddr,
-				      void *buf, size_t len, bool fixed)
+static inline int __must_check wl1271_read_hwaddr(struct wl1271 *wl,
+						  int hwaddr, void *buf,
+						  size_t len, bool fixed)
 {
 	int physical;
 	int addr;
@@ -136,23 +169,31 @@ static inline void wl1271_read_hwaddr(struct wl1271 *wl, int hwaddr,
 
 	physical = wl1271_translate_addr(wl, addr);
 
-	wl1271_raw_read(wl, physical, buf, len, fixed);
+	return wl1271_raw_read(wl, physical, buf, len, fixed);
 }
 
-static inline u32 wl1271_read32(struct wl1271 *wl, int addr)
+static inline int __must_check wl1271_read32(struct wl1271 *wl, int addr,
+					     u32 *val)
 {
-	return wl1271_raw_read32(wl, wl1271_translate_addr(wl, addr));
+	return wl1271_raw_read32(wl, wl1271_translate_addr(wl, addr), val);
 }
 
-static inline void wl1271_write32(struct wl1271 *wl, int addr, u32 val)
+static inline int __must_check wl1271_write32(struct wl1271 *wl, int addr,
+					      u32 val)
 {
-	wl1271_raw_write32(wl, wl1271_translate_addr(wl, addr), val);
+	return wl1271_raw_write32(wl, wl1271_translate_addr(wl, addr), val);
 }
 
 static inline void wl1271_power_off(struct wl1271 *wl)
 {
-	wl->if_ops->power(wl->dev, false);
-	clear_bit(WL1271_FLAG_GPIO_POWER, &wl->flags);
+	int ret;
+
+	if (!test_bit(WL1271_FLAG_GPIO_POWER, &wl->flags))
+		return;
+
+	ret = wl->if_ops->power(wl->dev, false);
+	if (!ret)
+		clear_bit(WL1271_FLAG_GPIO_POWER, &wl->flags);
 }
 
 static inline int wl1271_power_on(struct wl1271 *wl)
@@ -166,8 +207,8 @@ static inline int wl1271_power_on(struct wl1271 *wl)
 
 
 /* Top Register IO */
-void wl1271_top_reg_write(struct wl1271 *wl, int addr, u16 val);
-u16 wl1271_top_reg_read(struct wl1271 *wl, int addr);
+int __must_check wl1271_top_reg_write(struct wl1271 *wl, int addr, u16 val);
+int __must_check wl1271_top_reg_read(struct wl1271 *wl, int addr, u16 *out);
 
 int wl1271_set_partition(struct wl1271 *wl,
 			 struct wl1271_partition_set *p);
diff --git a/wl12xx-compat/drivers/net/wireless/wl12xx/main.c b/wl12xx-compat/drivers/net/wireless/wl12xx/main.c
index 74abd93..a968998 100644
--- a/wl12xx-compat/drivers/net/wireless/wl12xx/main.c
+++ b/wl12xx-compat/drivers/net/wireless/wl12xx/main.c
@@ -217,6 +217,7 @@ static struct conf_drv_settings default_conf = {
 		.basic_rate_5                = CONF_HW_BIT_RATE_6MBPS,
 		.tmpl_short_retry_limit      = 10,
 		.tmpl_long_retry_limit       = 10,
+		.tx_watchdog_timeout         = 5000,
 	},
 	.conn = {
 		.wake_up_event               = CONF_WAKE_UP_EVENT_DTIM,
@@ -257,6 +258,7 @@ static struct conf_drv_settings default_conf = {
 		.forced_ps                   = false,
 		.keep_alive_interval         = 10000,
 		.max_listen_interval         = 20,
+		.elp_timeout                 = 200,
 	},
 	.itrim = {
 		.enable = false,
@@ -407,7 +409,7 @@ static int wl1271_register_hw(struct wl1271 *wl);
 static void __wl1271_op_remove_interface(struct wl1271 *wl,
 					 struct ieee80211_vif *vif,
 					 bool reset_tx_queues);
-static void wl1271_op_stop(struct ieee80211_hw *hw);
+static void wl1271_op_stop_locked(struct wl1271 *wl);
 static void wl1271_free_ap_keys(struct wl1271 *wl, struct wl12xx_vif *wlvif);
 
 static DEFINE_MUTEX(wl_list_mutex);
@@ -643,6 +645,80 @@ static void wl1271_rx_streaming_timer(unsigned long data)
 	ieee80211_queue_work(wl->hw, &wlvif->rx_streaming_disable_work);
 }
 
+/* wl->mutex must be taken */
+void wl12xx_rearm_tx_watchdog_locked(struct wl1271 *wl)
+{
+	/* if the watchdog is not armed, don't do anything */
+	if (wl->tx_allocated_blocks == 0)
+		return;
+
+	cancel_delayed_work(&wl->tx_watchdog_work);
+	ieee80211_queue_delayed_work(wl->hw, &wl->tx_watchdog_work,
+		msecs_to_jiffies(wl->conf.tx.tx_watchdog_timeout));
+}
+
+static void wl12xx_tx_watchdog_work(struct work_struct *work)
+{
+	struct delayed_work *dwork;
+	struct wl1271 *wl;
+
+	dwork = container_of(work, struct delayed_work, work);
+	wl = container_of(dwork, struct wl1271, tx_watchdog_work);
+
+	mutex_lock(&wl->mutex);
+
+	if (unlikely(wl->state == WL1271_STATE_OFF))
+		goto out;
+
+	/* Tx went out in the meantime - everything is ok */
+	if (unlikely(wl->tx_allocated_blocks == 0))
+		goto out;
+
+	/*
+	 * if a ROC is in progress, we might not have any Tx for a long
+	 * time (e.g. pending Tx on the non-ROC channels)
+	 */
+	if (find_first_bit(wl->roc_map, WL12XX_MAX_ROLES) < WL12XX_MAX_ROLES) {
+		wl1271_debug(DEBUG_TX, "No Tx (in FW) for %d ms due to ROC",
+			     wl->conf.tx.tx_watchdog_timeout);
+		wl12xx_rearm_tx_watchdog_locked(wl);
+		goto out;
+	}
+
+	/*
+	 * if a scan is in progress, we might not have any Tx for a long
+	 * time
+	 */
+	if (wl->scan.state != WL1271_SCAN_STATE_IDLE) {
+		wl1271_debug(DEBUG_TX, "No Tx (in FW) for %d ms due to scan",
+			     wl->conf.tx.tx_watchdog_timeout);
+		wl12xx_rearm_tx_watchdog_locked(wl);
+		goto out;
+	}
+
+	/*
+	* AP might cache a frame for a long time for a sleeping station,
+	* so rearm the timer if there's an AP interface with stations. If
+	* Tx is genuinely stuck we will most hopefully discover it when all
+	* stations are removed due to inactivity.
+	*/
+	if (wl->active_sta_count) {
+		wl1271_debug(DEBUG_TX, "No Tx (in FW) for %d ms. AP has "
+			     " %d stations",
+			      wl->conf.tx.tx_watchdog_timeout,
+			      wl->active_sta_count);
+		wl12xx_rearm_tx_watchdog_locked(wl);
+		goto out;
+	}
+
+	wl1271_error("Tx stuck (in FW) for %d ms. Starting recovery",
+		     wl->conf.tx.tx_watchdog_timeout);
+	wl12xx_queue_recovery_work(wl);
+
+out:
+	mutex_unlock(&wl->mutex);
+}
+
 static void wl1271_conf_init(struct wl1271 *wl)
 {
 
@@ -837,16 +913,20 @@ static void wl12xx_irq_update_links_status(struct wl1271 *wl,
 	}
 }
 
-static void wl12xx_fw_status(struct wl1271 *wl,
-			     struct wl12xx_fw_status *status)
+static int wl12xx_fw_status(struct wl1271 *wl,
+			    struct wl12xx_fw_status *status)
 {
 	struct wl12xx_vif *wlvif;
 	struct timespec ts;
 	u32 old_tx_blk_count = wl->tx_blocks_available;
 	int avail, freed_blocks;
 	int i;
+	int ret;
 
-	wl1271_raw_read(wl, FW_STATUS_ADDR, status, sizeof(*status), false);
+	ret = wl1271_raw_read(wl, FW_STATUS_ADDR, status, sizeof(*status),
+			      false);
+	if (ret < 0)
+		return ret;
 
 	wl1271_debug(DEBUG_IRQ, "intr: 0x%x (fw_rx_counter = %d, "
 		     "drv_rx_counter = %d, tx_results_counter = %d)",
@@ -877,6 +957,18 @@ static void wl12xx_fw_status(struct wl1271 *wl,
 
 	wl->tx_allocated_blocks -= freed_blocks;
 
+	/*
+	 * If the FW freed some blocks:
+	 * If we still have allocated blocks - re-arm the timer, Tx is
+	 * not stuck. Otherwise, cancel the timer (no Tx currently).
+	 */
+	if (freed_blocks) {
+		if (wl->tx_allocated_blocks)
+			wl12xx_rearm_tx_watchdog_locked(wl);
+		else
+			cancel_delayed_work(&wl->tx_watchdog_work);
+	}
+
 	avail = le32_to_cpu(status->tx_total) - wl->tx_allocated_blocks;
 
 	/*
@@ -903,6 +995,8 @@ static void wl12xx_fw_status(struct wl1271 *wl,
 	getnstimeofday(&ts);
 	wl->time_offset = (timespec_to_ns(&ts) >> 10) -
 		(s64)le32_to_cpu(status->fw_localtime);
+
+	return 0;
 }
 
 static void wl1271_flush_deferred_work(struct wl1271 *wl)
@@ -930,20 +1024,15 @@ static void wl1271_netstack_work(struct work_struct *work)
 
 #define WL1271_IRQ_MAX_LOOPS 256
 
-static irqreturn_t wl1271_irq(int irq, void *cookie)
+static int wl12xx_irq_locked(struct wl1271 *wl)
 {
-	int ret;
+	int ret = 0;
 	u32 intr;
 	int loopcount = WL1271_IRQ_MAX_LOOPS;
-	struct wl1271 *wl = (struct wl1271 *)cookie;
 	bool done = false;
 	unsigned int defer_count;
 	unsigned long flags;
 
-	/* TX might be handled here, avoid redundant work */
-	set_bit(WL1271_FLAG_TX_PENDING, &wl->flags);
-	cancel_work_sync(&wl->tx_work);
-
 	/*
 	 * In case edge triggered interrupt must be used, we cannot iterate
 	 * more than once without introducing race conditions with the hardirq.
@@ -951,8 +1040,6 @@ static irqreturn_t wl1271_irq(int irq, void *cookie)
 	if (wl->platform_quirks & WL12XX_PLATFORM_QUIRK_EDGE_IRQ)
 		loopcount = 1;
 
-	mutex_lock(&wl->mutex);
-
 	wl1271_debug(DEBUG_IRQ, "IRQ work");
 
 	if (unlikely(wl->state == WL1271_STATE_OFF))
@@ -971,7 +1058,10 @@ static irqreturn_t wl1271_irq(int irq, void *cookie)
 		clear_bit(WL1271_FLAG_IRQ_RUNNING, &wl->flags);
 		smp_mb__after_clear_bit();
 
-		wl12xx_fw_status(wl, wl->fw_status);
+		ret = wl12xx_fw_status(wl, wl->fw_status);
+		if (ret < 0)
+			goto out;
+
 		intr = le32_to_cpu(wl->fw_status->intr);
 		intr &= WL1271_INTR_MASK;
 		if (!intr) {
@@ -983,16 +1073,18 @@ static irqreturn_t wl1271_irq(int irq, void *cookie)
 			wl1271_error("watchdog interrupt received! "
 				     "starting recovery.");
 			wl->watchdog_recovery = true;
-			wl12xx_queue_recovery_work(wl);
 
 			/* restarting the chip. ignore any other interrupt. */
+			ret = -EIO;
 			goto out;
 		}
 
 		if (likely(intr & WL1271_ACX_INTR_DATA)) {
 			wl1271_debug(DEBUG_IRQ, "WL1271_ACX_INTR_DATA");
 
-			wl12xx_rx(wl, wl->fw_status);
+			ret = wl12xx_rx(wl, wl->fw_status);
+			if (ret < 0)
+				goto out;
 
 			/* Check if any tx blocks were freed */
 			spin_lock_irqsave(&wl->wl_lock, flags);
@@ -1003,15 +1095,20 @@ static irqreturn_t wl1271_irq(int irq, void *cookie)
 				 * In order to avoid starvation of the TX path,
 				 * call the work function directly.
 				 */
-				wl1271_tx_work_locked(wl);
+				ret = wl1271_tx_work_locked(wl);
+				if (ret < 0)
+					goto out;
 			} else {
 				spin_unlock_irqrestore(&wl->wl_lock, flags);
 			}
 
 			/* check for tx results */
 			if (wl->fw_status->tx_results_counter !=
-			    (wl->tx_results_count & 0xff))
-				wl1271_tx_complete(wl);
+			    (wl->tx_results_count & 0xff)) {
+				ret = wl1271_tx_complete(wl);
+				if (ret < 0)
+					goto out;
+			}
 
 			/* Make sure the deferred queues don't get too long */
 			defer_count = skb_queue_len(&wl->deferred_tx_queue) +
@@ -1022,12 +1119,16 @@ static irqreturn_t wl1271_irq(int irq, void *cookie)
 
 		if (intr & WL1271_ACX_INTR_EVENT_A) {
 			wl1271_debug(DEBUG_IRQ, "WL1271_ACX_INTR_EVENT_A");
-			wl1271_event_handle(wl, 0);
+			ret = wl1271_event_handle(wl, 0);
+			if (ret < 0)
+				goto out;
 		}
 
 		if (intr & WL1271_ACX_INTR_EVENT_B) {
 			wl1271_debug(DEBUG_IRQ, "WL1271_ACX_INTR_EVENT_B");
-			wl1271_event_handle(wl, 1);
+			ret = wl1271_event_handle(wl, 1);
+			if (ret < 0)
+				goto out;
 		}
 
 		if (intr & WL1271_ACX_INTR_INIT_COMPLETE)
@@ -1041,6 +1142,25 @@ static irqreturn_t wl1271_irq(int irq, void *cookie)
 	wl1271_ps_elp_sleep(wl);
 
 out:
+	return ret;
+}
+
+static irqreturn_t wl12xx_irq(int irq, void *cookie)
+{
+	int ret;
+	unsigned long flags;
+	struct wl1271 *wl = cookie;
+
+	/* TX might be handled here, avoid redundant work */
+	set_bit(WL1271_FLAG_TX_PENDING, &wl->flags);
+	cancel_work_sync(&wl->tx_work);
+
+	mutex_lock(&wl->mutex);
+
+	ret = wl12xx_irq_locked(wl);
+	if (ret)
+		wl12xx_queue_recovery_work(wl);
+
 	spin_lock_irqsave(&wl->wl_lock, flags);
 	/* In case TX was not handled here, queue TX work */
 	clear_bit(WL1271_FLAG_TX_PENDING, &wl->flags);
@@ -1197,9 +1317,16 @@ static int wl1271_fetch_nvs_nowait(struct wl1271 *wl)
 
 void wl12xx_queue_recovery_work(struct wl1271 *wl)
 {
-	if (!test_bit(WL1271_FLAG_RECOVERY_IN_PROGRESS, &wl->flags)) {
+	WARN_ON(!test_bit(WL1271_FLAG_INTENDED_FW_RECOVERY, &wl->flags));
+
+	/* Avoid a recursive recovery */
+	if (!test_and_set_bit(WL1271_FLAG_RECOVERY_IN_PROGRESS, &wl->flags)) {
+		wlcore_disable_interrupts_nosync(wl);
+#ifdef CONFIG_HAS_WAKELOCK
+		/* give us a grace period for recovery */
+		wake_lock_timeout(&wl->recovery_wake, 5 * HZ);
+#endif
 		ieee80211_queue_work(wl->hw, &wl->recovery_work);
-		set_bit(WL1271_FLAG_RECOVERY_WORK_PENDING, &wl->flags);
 	}
 }
 
@@ -1231,6 +1358,7 @@ static void wl12xx_read_fwlog_panic(struct wl1271 *wl)
 	u32 addr;
 	u32 first_addr;
 	u8 *block;
+	int ret;
 
 	if ((wl->quirks & WL12XX_QUIRK_FWLOG_NOT_IMPLEMENTED) ||
 	    (wl->conf.fwlog.mode != WL12XX_FWLOG_ON_DEMAND) ||
@@ -1254,7 +1382,10 @@ static void wl12xx_read_fwlog_panic(struct wl1271 *wl)
 		goto out;
 
 	/* Read the first memory block address */
-	wl12xx_fw_status(wl, wl->fw_status);
+	ret = wl12xx_fw_status(wl, wl->fw_status);
+	if (ret < 0)
+		goto out;
+
 	first_addr = le32_to_cpu(wl->fw_status->log_start_addr);
 	if (!first_addr)
 		goto out;
@@ -1263,8 +1394,10 @@ static void wl12xx_read_fwlog_panic(struct wl1271 *wl)
 	addr = first_addr;
 	do {
 		memset(block, 0, WL12XX_HW_BLOCK_SIZE);
-		wl1271_read_hwaddr(wl, addr, block, WL12XX_HW_BLOCK_SIZE,
-				   false);
+		ret = wl1271_read_hwaddr(wl, addr, block, WL12XX_HW_BLOCK_SIZE,
+					 false);
+		if (ret < 0)
+			goto out;
 
 		/*
 		 * Memory blocks are linked to one another. The first 4 bytes
@@ -1283,6 +1416,21 @@ out:
 	kfree(block);
 }
 
+static void wl12xx_print_recovery(struct wl1271 *wl)
+{
+	u32 pc = 0;
+	int ret;
+
+	wl1271_info("Hardware recovery in progress. FW ver: %s",
+		    wl->chip.fw_ver_str);
+
+	ret = wl1271_read32(wl, SCR_PAD4, &pc);
+	if (ret < 0)
+		return;
+
+	wl1271_info("pc: 0x%x", pc);
+}
+
 static void wl1271_recovery_work(struct work_struct *work)
 {
 	struct wl1271 *wl =
@@ -1295,13 +1443,10 @@ static void wl1271_recovery_work(struct work_struct *work)
 	if (wl->state != WL1271_STATE_ON)
 		goto out_unlock;
 
-	/* Avoid a recursive recovery */
-	set_bit(WL1271_FLAG_RECOVERY_IN_PROGRESS, &wl->flags);
-
-	wl->watchdog_recovery = false;
-
-	wl1271_info("Hardware recovery in progress. FW ver: %s",
-		    wl->chip.fw_ver_str);
+	if (!test_bit(WL1271_FLAG_INTENDED_FW_RECOVERY, &wl->flags)) {
+		wl12xx_read_fwlog_panic(wl);
+		wl12xx_print_recovery(wl);
+	}
 
 	BUG_ON(bug_on_recovery &&
 	       !test_bit(WL1271_FLAG_INTENDED_FW_RECOVERY, &wl->flags));
@@ -1333,10 +1478,7 @@ static void wl1271_recovery_work(struct work_struct *work)
 		vif = wl12xx_wlvif_to_vif(wlvif);
 		__wl1271_op_remove_interface(wl, vif, false);
 	}
-	mutex_unlock(&wl->mutex);
-	wl1271_op_stop(wl->hw);
-
-	clear_bit(WL1271_FLAG_RECOVERY_IN_PROGRESS, &wl->flags);
+	wl1271_op_stop_locked(wl);
 
 	ieee80211_restart_hw(wl->hw);
 
@@ -1346,18 +1488,21 @@ static void wl1271_recovery_work(struct work_struct *work)
 	 */
 	ieee80211_wake_queues(wl->hw);
 	clear_bit(WL1271_FLAG_RECOVERY_WORK_PENDING, &wl->flags);
-	return;
 out_unlock:
+	wl->watchdog_recovery = false;
+	if (test_and_clear_bit(WL1271_FLAG_RECOVERY_IN_PROGRESS,
+			       &wl->flags))
+		wl1271_enable_interrupts(wl);
 	mutex_unlock(&wl->mutex);
 	clear_bit(WL1271_FLAG_RECOVERY_WORK_PENDING, &wl->flags);
 }
 
-static void wl1271_fw_wakeup(struct wl1271 *wl)
+static int wl1271_fw_wakeup(struct wl1271 *wl)
 {
 	u32 elp_reg;
 
 	elp_reg = ELPCTRL_WAKE_UP;
-	wl1271_raw_write32(wl, HW_ACCESS_ELP_CTRL_REG_ADDR, elp_reg);
+	return wl1271_raw_write32(wl, HW_ACCESS_ELP_CTRL_REG_ADDR, elp_reg);
 }
 
 static int wl1271_setup(struct wl1271 *wl)
@@ -1387,13 +1532,21 @@ static int wl12xx_set_power_on(struct wl1271 *wl)
 	wl1271_io_reset(wl);
 	wl1271_io_init(wl);
 
-	wl1271_set_partition(wl, &wl12xx_part_table[PART_DOWN]);
+	ret = wl1271_set_partition(wl, &wl12xx_part_table[PART_DOWN]);
+	if (ret < 0)
+		goto fail;
 
 	/* ELP module wake up */
-	wl1271_fw_wakeup(wl);
+	ret = wl1271_fw_wakeup(wl);
+	if (ret < 0)
+		goto fail;
 
 out:
 	return ret;
+
+fail:
+	wl1271_power_off(wl);
+	return ret;
 }
 
 static int wl12xx_chip_wakeup(struct wl1271 *wl, bool plt)
@@ -1568,6 +1721,7 @@ int wl1271_plt_stop(struct wl1271 *wl)
 	cancel_work_sync(&wl->netstack_work);
 	cancel_work_sync(&wl->recovery_work);
 	cancel_delayed_work_sync(&wl->elp_work);
+	cancel_delayed_work_sync(&wl->tx_watchdog_work);
 
 	mutex_lock(&wl->mutex);
 	wl1271_power_off(wl);
@@ -1640,6 +1794,7 @@ int wl1271_tx_dummy_packet(struct wl1271 *wl)
 {
 	unsigned long flags;
 	int q;
+	int ret = 0;
 
 	/* no need to queue a new dummy packet if one is already pending */
 	if (test_bit(WL1271_FLAG_DUMMY_PACKET_PENDING, &wl->flags))
@@ -1654,13 +1809,13 @@ int wl1271_tx_dummy_packet(struct wl1271 *wl)
 
 	/* The FW is low on RX memory blocks, so send the dummy packet asap */
 	if (!test_bit(WL1271_FLAG_FW_TX_BUSY, &wl->flags))
-		wl1271_tx_work_locked(wl);
+		ret = wl1271_tx_work_locked(wl);
 
 	/*
 	 * If the FW TX is busy, TX work will be scheduled by the threaded
 	 * interrupt handler function
 	 */
-	return 0;
+	return ret;
 }
 
 /*
@@ -1904,7 +2059,18 @@ int wl1271_convert_wowlan_pattern_to_rx_filter(
 		i = j;
 	}
 
-	filter->action = FILTER_SIGNAL;
+	switch (p->action) {
+	case NL80211_WOWLAN_ACTION_ALLOW:
+		filter->action = FILTER_SIGNAL;
+		break;
+	case NL80211_WOWLAN_ACTION_DROP:
+		filter->action = FILTER_DROP;
+		break;
+	default:
+		wl1271_warning("Bad wowlan action: %d", p->action);
+		ret = -EINVAL;
+		goto err;
+	}
 
 	*f = filter;
 	return 0;
@@ -1922,8 +2088,13 @@ static int wl1271_configure_wowlan(struct wl1271 *wl,
 	int i, ret;
 
 	if (!wow || wow->any || !wow->n_patterns) {
-		wl1271_rx_data_filtering_enable(wl, 0, FILTER_SIGNAL);
-		wl1271_rx_data_filters_clear_all(wl);
+		ret = wl1271_rx_data_filtering_enable(wl, 0, FILTER_SIGNAL);
+		if (ret < 0)
+			goto out;
+
+		ret = wl1271_rx_data_filters_clear_all(wl);
+		if (ret < 0)
+			goto out;
 		return 0;
 	}
 
@@ -1939,8 +2110,13 @@ static int wl1271_configure_wowlan(struct wl1271 *wl,
 		}
 	}
 
-	wl1271_rx_data_filtering_enable(wl, 0, FILTER_SIGNAL);
-	wl1271_rx_data_filters_clear_all(wl);
+	ret = wl1271_rx_data_filtering_enable(wl, 0, FILTER_SIGNAL);
+	if (ret < 0)
+		goto out;
+
+	ret = wl1271_rx_data_filters_clear_all(wl);
+	if (ret < 0)
+		goto out;
 
 	/* Translate WoWLAN patterns into filters */
 	for (i = 0; i < wow->n_patterns; i++) {
@@ -2080,6 +2256,16 @@ static int wl1271_op_suspend(struct ieee80211_hw *hw,
 		return -EBUSY;
 	}
 
+	/* we want to perform the recovery before suspending */
+	if (test_bit(WL1271_FLAG_RECOVERY_IN_PROGRESS, &wl->flags)) {
+		wl1271_warning("postponing suspend to perform recovery");
+#ifdef CONFIG_HAS_WAKELOCK
+		/* give us a grace period for recovery */
+		wake_lock_timeout(&wl->recovery_wake, 5 * HZ);
+#endif
+		return -EBUSY;
+	}
+
 	wl1271_tx_flush(wl);
 	wl->wow_enabled = true;
 
@@ -2089,6 +2275,7 @@ static int wl1271_op_suspend(struct ieee80211_hw *hw,
 		ret = wl1271_configure_suspend(wl, wlvif, wow);
 		if (ret < 0) {
 			wl->wow_enabled = false;
+			mutex_unlock(&wl->mutex);
 			wl1271_warning("couldn't prepare device to suspend");
 			return ret;
 		}
@@ -2123,7 +2310,7 @@ static int wl1271_op_resume(struct ieee80211_hw *hw)
 	struct wl1271 *wl = hw->priv;
 	struct wl12xx_vif *wlvif;
 	unsigned long flags;
-	bool run_irq_work = false;
+	bool run_irq_work = false, pending_recovery;
 	int ret = 0;
 
 	wl1271_debug(DEBUG_MAC80211, "mac80211 resume wow=%d",
@@ -2143,22 +2330,39 @@ static int wl1271_op_resume(struct ieee80211_hw *hw)
 		run_irq_work = true;
 	spin_unlock_irqrestore(&wl->wl_lock, flags);
 
+	mutex_lock(&wl->mutex);
+
+	/* test the recovery flag before calling any SDIO functions */
+	pending_recovery = test_bit(WL1271_FLAG_RECOVERY_IN_PROGRESS,
+				    &wl->flags);
+
 	if (run_irq_work) {
 		wl1271_debug(DEBUG_MAC80211,
 			     "run postponed irq_work directly");
-		wl1271_irq(0, wl);
+
+		/* don't talk to the HW if recovery is pending */
+		if (!pending_recovery) {
+			ret = wl12xx_irq_locked(wl);
+			if (ret)
+				wl12xx_queue_recovery_work(wl);
+		}
+
 		wl1271_enable_interrupts(wl);
 	}
 
+	if (pending_recovery) {
+		wl1271_warning("queuing forgotten recovery on resume");
+		ieee80211_queue_work(wl->hw, &wl->recovery_work);
+		goto out;
+	}
 #ifndef CONFIG_HAS_EARLYSUSPEND
-	mutex_lock(&wl->mutex);
 	wl12xx_for_each_wlvif(wl, wlvif) {
 		wl1271_configure_resume(wl, wlvif);
 	}
-	mutex_unlock(&wl->mutex);
 #endif
-
+out:
 	wl->wow_enabled = false;
+	mutex_unlock(&wl->mutex);
 	return ret;
 }
 #endif /* CONFIG_PM */
@@ -2228,29 +2432,15 @@ static int wl1271_op_start(struct ieee80211_hw *hw)
 	return 0;
 }
 
-static void wl1271_op_stop(struct ieee80211_hw *hw)
+static void wl1271_op_stop_locked(struct wl1271 *wl)
 {
-	struct wl1271 *wl = hw->priv;
 	int i;
 
-	wl1271_debug(DEBUG_MAC80211, "mac80211 stop");
-
-	/*
-	 * Interrupts must be disabled before setting the state to OFF.
-	 * Otherwise, the interrupt handler might be called and exit without
-	 * reading the interrupt status.
-	 */
-	wl1271_disable_interrupts(wl);
-	mutex_lock(&wl->mutex);
 	if (wl->state == WL1271_STATE_OFF) {
-		mutex_unlock(&wl->mutex);
+		if (test_and_clear_bit(WL1271_FLAG_RECOVERY_IN_PROGRESS,
+				       &wl->flags))
+			wl1271_enable_interrupts(wl);
 
-		/*
-		 * This will not necessarily enable interrupts as interrupts
-		 * may have been disabled when op_stop was called. It will,
-		 * however, balance the above call to disable_interrupts().
-		 */
-		wl1271_enable_interrupts(wl);
 		return;
 	}
 
@@ -2259,23 +2449,39 @@ static void wl1271_op_stop(struct ieee80211_hw *hw)
 	 * functions don't perform further work.
 	 */
 	wl->state = WL1271_STATE_OFF;
+
+	/*
+	 * Use the nosync variant to disable interrupts, so the mutex could be
+	 * held while doing so without deadlocking.
+	 */
+	wlcore_disable_interrupts_nosync(wl);
 	mutex_unlock(&wl->mutex);
 
 	mutex_lock(&wl_list_mutex);
 	list_del(&wl->list);
 	mutex_unlock(&wl_list_mutex);
 
+	wlcore_synchronize_interrupts(wl);
 	wl1271_flush_deferred_work(wl);
 	cancel_delayed_work_sync(&wl->scan_complete_work);
 	cancel_work_sync(&wl->netstack_work);
 	cancel_work_sync(&wl->tx_work);
 	cancel_delayed_work_sync(&wl->elp_work);
+	cancel_delayed_work_sync(&wl->tx_watchdog_work);
 
 	/* let's notify MAC80211 about the remaining pending TX frames */
 	wl12xx_tx_reset(wl, true);
 	mutex_lock(&wl->mutex);
 
 	wl1271_power_off(wl);
+	/*
+	 * In case a recovery was scheduled, interrupts were disabled to avoid
+	 * an interrupt storm. Now that the power is down, it is safe to
+	 * re-enable interrupts to balance the disable depth
+	 */
+	if (test_and_clear_bit(WL1271_FLAG_RECOVERY_IN_PROGRESS, &wl->flags))
+		wl1271_enable_interrupts(wl);
+
 	wl->fw_type = WL12XX_FW_TYPE_NONE;
 
 	wl->band = IEEE80211_BAND_2GHZ;
@@ -2320,6 +2526,17 @@ static void wl1271_op_stop(struct ieee80211_hw *hw)
 	wl->tx_res_if = NULL;
 	kfree(wl->target_mem_map);
 	wl->target_mem_map = NULL;
+}
+
+static void wl1271_op_stop(struct ieee80211_hw *hw)
+{
+	struct wl1271 *wl = hw->priv;
+
+	wl1271_debug(DEBUG_MAC80211, "mac80211 stop");
+
+	mutex_lock(&wl->mutex);
+
+	wl1271_op_stop_locked(wl);
 
 	mutex_unlock(&wl->mutex);
 }
@@ -2696,6 +2913,12 @@ static void __wl1271_op_remove_interface(struct wl1271 *wl,
 
 	if (wl->scan.state != WL1271_SCAN_STATE_IDLE &&
 	    wl->scan_vif == vif) {
+		/*
+		 * Rearm the tx watchdog just before idling scan. This
+		 * prevents just-finished scans from triggering the watchdog
+		 */
+		wl12xx_rearm_tx_watchdog_locked(wl);
+
 		wl->scan.state = WL1271_SCAN_STATE_IDLE;
 		memset(wl->scan.scanned_ch, 0, sizeof(wl->scan.scanned_ch));
 		wl->scan_vif = NULL;
@@ -2711,7 +2934,9 @@ static void __wl1271_op_remove_interface(struct wl1271 *wl,
 
 		if (wlvif->bss_type == BSS_TYPE_STA_BSS ||
 		    wlvif->bss_type == BSS_TYPE_IBSS) {
-			wl1271_configure_wowlan(wl, NULL);
+			ret = wl1271_configure_wowlan(wl, NULL);
+			if (ret < 0)
+				goto deinit;
 
 			if (wl12xx_dev_role_started(wlvif))
 				wl12xx_stop_dev(wl, wlvif);
@@ -2765,6 +2990,21 @@ deinit:
 	else
 		wl->sta_count--;
 
+	/*
+	 * Last AP, have more stations. Configure sleep auth according to STA.
+	 * Don't do this on unintended recovery.
+	 */
+	if (test_bit(WL1271_FLAG_RECOVERY_IN_PROGRESS, &wl->flags) &&
+	    !test_bit(WL1271_FLAG_INTENDED_FW_RECOVERY, &wl->flags))
+		goto unlock;
+
+	if (wl->ap_count == 0 && wlvif->bss_type == BSS_TYPE_AP_BSS
+	    && wl->sta_count) {
+		/* Configure for ELP power saving */
+		wl1271_acx_sleep_auth(wl, WL1271_PSM_ELP);
+	}
+
+unlock:
 	mutex_unlock(&wl->mutex);
 
 	del_timer_sync(&wlvif->rx_streaming_timer);
@@ -2988,7 +3228,10 @@ static int wl12xx_config_vif(struct wl1271 *wl, struct wl12xx_vif *wlvif,
 	    ((wlvif->band != conf->channel->band) ||
 	     (wlvif->channel != channel))) {
 		/* send all pending packets */
-		wl1271_tx_work_locked(wl);
+		ret = wl1271_tx_work_locked(wl);
+		if (ret < 0)
+			return ret;
+
 		wlvif->band = conf->channel->band;
 		wlvif->channel = channel;
 
@@ -3584,10 +3827,11 @@ static int wl1271_op_set_default_key_idx(struct ieee80211_hw *hw,
 	struct wl1271 *wl = hw->priv;
 	struct wl12xx_vif *wlvif = wl12xx_vif_to_data(vif);
 	int ret = 0;
-	mutex_lock(&wl->mutex);
 
-	if (wlvif->default_key == key_idx)
-		goto out_unlock;
+	wl1271_debug(DEBUG_MAC80211, "mac80211 set default key idx %d",
+		     key_idx);
+
+	mutex_lock(&wl->mutex);
 
 	ret = wl1271_ps_elp_wakeup(wl);
 	if (ret < 0)
@@ -3705,6 +3949,13 @@ static void wl1271_op_cancel_hw_scan(struct ieee80211_hw *hw,
 		if (ret < 0)
 			goto out_sleep;
 	}
+
+	/*
+	 * Rearm the tx watchdog just before idling scan. This
+	 * prevents just-finished scans from triggering the watchdog
+	 */
+	wl12xx_rearm_tx_watchdog_locked(wl);
+
 	wl->scan.state = WL1271_SCAN_STATE_IDLE;
 	memset(wl->scan.scanned_ch, 0, sizeof(wl->scan.scanned_ch));
 	wl->scan_vif = NULL;
@@ -4811,6 +5062,13 @@ void wl1271_free_sta(struct wl1271 *wl, struct wl12xx_vif *wlvif, u8 hlid)
 	__clear_bit(hlid, (unsigned long *)&wl->ap_fw_ps_map);
 	wl12xx_free_link(wl, wlvif, &hlid);
 	wl->active_sta_count--;
+
+	/*
+	 * rearm the tx watchdog when the last STA is freed - give the FW a
+	 * chance to return STA-buffered packets before complaining.
+	 */
+	if (wl->active_sta_count == 0)
+		wl12xx_rearm_tx_watchdog_locked(wl);
 }
 
 void wl12xx_update_sta_state(struct wl1271 *wl,
@@ -5703,38 +5961,83 @@ static void wl12xx_derive_mac_addresses(struct wl1271 *wl,
 	wl->hw->wiphy->addresses = wl->addresses;
 }
 
-static void wl12xx_get_fuse_mac(struct wl1271 *wl)
+int wl12xx_init_pll_clock(struct wl1271 *wl, int *selected_clock)
+{
+	int ret;
+
+	if (wl->chip.id == CHIP_ID_1283_PG20) {
+		ret = wl128x_boot_clk(wl, selected_clock);
+		if (ret < 0)
+			return ret;
+	} else {
+		ret = wl127x_boot_clk(wl);
+		if (ret < 0)
+			return ret;
+	}
+
+	/* Continue the ELP wake up sequence */
+	ret = wl1271_write32(wl, WELP_ARM_COMMAND, WELP_ARM_COMMAND_VAL);
+	if (ret < 0)
+		return ret;
+
+	udelay(500);
+	return ret;
+}
+
+static int wl12xx_get_fuse_mac(struct wl1271 *wl)
 {
 	u32 mac1, mac2;
+	int ret;
+	int selected_clock = -1;
+
+	ret = wl12xx_init_pll_clock(wl, &selected_clock);
+	if (ret < 0)
+		goto out;
+
+	ret = wl1271_set_partition(wl, &wl12xx_part_table[PART_DRPW]);
+	if (ret < 0)
+		goto out;
 
-	wl1271_set_partition(wl, &wl12xx_part_table[PART_DRPW]);
+	ret = wl1271_read32(wl, WL12XX_REG_FUSE_BD_ADDR_1, &mac1);
+	if (ret < 0)
+		goto out;
 
-	mac1 = wl1271_read32(wl, WL12XX_REG_FUSE_BD_ADDR_1);
-	mac2 = wl1271_read32(wl, WL12XX_REG_FUSE_BD_ADDR_2);
+	ret = wl1271_read32(wl, WL12XX_REG_FUSE_BD_ADDR_2, &mac2);
+	if (ret < 0)
+		goto out;
 
 	/* these are the two parts of the BD_ADDR */
 	wl->fuse_oui_addr = ((mac2 & 0xffff) << 8) +
 		((mac1 & 0xff000000) >> 24);
 	wl->fuse_nic_addr = mac1 & 0xffffff;
 
-	wl1271_set_partition(wl, &wl12xx_part_table[PART_DOWN]);
+	ret = wl1271_set_partition(wl, &wl12xx_part_table[PART_DOWN]);
+
+out:
+	return ret;
 }
 
 static int wl12xx_get_hw_info(struct wl1271 *wl)
 {
 	int ret;
-	u32 die_info;
+	u16 die_info;
 
 	ret = wl12xx_set_power_on(wl);
 	if (ret < 0)
 		goto out;
 
-	wl->chip.id = wl1271_read32(wl, CHIP_ID_B);
+	ret = wl1271_read32(wl, CHIP_ID_B, &wl->chip.id);
+	if (ret < 0)
+		goto out;
 
 	if (wl->chip.id == CHIP_ID_1283_PG20)
-		die_info = wl1271_top_reg_read(wl, WL128X_REG_FUSE_DATA_2_1);
+		ret = wl1271_top_reg_read(wl, WL128X_REG_FUSE_DATA_2_1,
+					  &die_info);
 	else
-		die_info = wl1271_top_reg_read(wl, WL127X_REG_FUSE_DATA_2_1);
+		ret = wl1271_top_reg_read(wl, WL127X_REG_FUSE_DATA_2_1,
+					  &die_info);
+	if (ret < 0)
+		goto out;
 
 	wl->hw_pg_ver = (s8) (die_info & PG_VER_MASK) >> PG_VER_OFFSET;
 
@@ -5742,11 +6045,13 @@ static int wl12xx_get_hw_info(struct wl1271 *wl)
 		wl->fuse_oui_addr = 0;
 		wl->fuse_nic_addr = 0;
 	} else {
-		wl12xx_get_fuse_mac(wl);
+		ret = wl12xx_get_fuse_mac(wl);
+		if (ret < 0)
+			goto out;
 	}
 
-	wl1271_power_off(wl);
 out:
+	wl1271_power_off(wl);
 	return ret;
 }
 
@@ -5961,6 +6266,7 @@ static struct ieee80211_hw *wl1271_alloc_hw(void)
 	INIT_WORK(&wl->tx_work, wl1271_tx_work);
 	INIT_WORK(&wl->recovery_work, wl1271_recovery_work);
 	INIT_DELAYED_WORK(&wl->scan_complete_work, wl1271_scan_complete_work);
+	INIT_DELAYED_WORK(&wl->tx_watchdog_work, wl12xx_tx_watchdog_work);
 
 	wl->freezable_wq = create_freezable_workqueue("wl12xx_wq");
 	if (!wl->freezable_wq) {
@@ -5996,6 +6302,7 @@ static struct ieee80211_hw *wl1271_alloc_hw(void)
 #ifdef CONFIG_HAS_WAKELOCK
 	wake_lock_init(&wl->wake_lock, WAKE_LOCK_SUSPEND, "wl1271_wake");
 	wake_lock_init(&wl->rx_wake, WAKE_LOCK_SUSPEND, "rx_wake");
+	wake_lock_init(&wl->recovery_wake, WAKE_LOCK_SUSPEND, "recovery_wake");
 #endif
 
 	wl->state = WL1271_STATE_OFF;
@@ -6051,6 +6358,7 @@ static int wl1271_free_hw(struct wl1271 *wl)
 #ifdef CONFIG_HAS_WAKELOCK
 	wake_lock_destroy(&wl->wake_lock);
 	wake_lock_destroy(&wl->rx_wake);
+	wake_lock_destroy(&wl->recovery_wake);
 #endif
 	/* Unblock any fwlog readers */
 	mutex_lock(&wl->mutex);
@@ -6158,7 +6466,7 @@ static int __devinit wl12xx_probe(struct platform_device *pdev)
 	/* The driver handles the interrupt during suspend */
 	irqflags |= IRQF_NO_SUSPEND;
 
-	ret = request_threaded_irq(wl->irq, wl12xx_hardirq, wl1271_irq,
+	ret = request_threaded_irq(wl->irq, wl12xx_hardirq, wl12xx_irq,
 				   irqflags,
 				   pdev->name, wl);
 	if (ret < 0) {
diff --git a/wl12xx-compat/drivers/net/wireless/wl12xx/ps.c b/wl12xx-compat/drivers/net/wireless/wl12xx/ps.c
index 4ca5a41..9d971eb 100644
--- a/wl12xx-compat/drivers/net/wireless/wl12xx/ps.c
+++ b/wl12xx-compat/drivers/net/wireless/wl12xx/ps.c
@@ -34,6 +34,7 @@ void wl1271_elp_work(struct work_struct *work)
 	struct delayed_work *dwork;
 	struct wl1271 *wl;
 	struct wl12xx_vif *wlvif;
+	int ret;
 
 	dwork = container_of(work, struct delayed_work, work);
 	wl = container_of(dwork, struct wl1271, elp_work);
@@ -62,7 +63,13 @@ void wl1271_elp_work(struct work_struct *work)
 	}
 
 	wl1271_debug(DEBUG_PSM, "chip to elp");
-	wl1271_raw_write32(wl, HW_ACCESS_ELP_CTRL_REG_ADDR, ELPCTRL_SLEEP);
+	ret = wl1271_raw_write32(wl, HW_ACCESS_ELP_CTRL_REG_ADDR,
+				 ELPCTRL_SLEEP);
+	if (ret < 0) {
+		wl12xx_queue_recovery_work(wl);
+		goto out;
+	}
+
 	set_bit(WL1271_FLAG_IN_ELP, &wl->flags);
 
 out:
@@ -93,7 +100,7 @@ void wl1271_ps_elp_sleep(struct wl1271 *wl)
 	if (wl->conf.conn.forced_ps)
 		timeout = ELP_ENTRY_DELAY;
 	else
-		timeout = wl->conf.conn.dynamic_ps_timeout;
+		timeout = wl->conf.conn.elp_timeout;
 
 	ieee80211_queue_delayed_work(wl->hw, &wl->elp_work,
 				     msecs_to_jiffies(timeout));
@@ -133,7 +140,12 @@ int wl1271_ps_elp_wakeup(struct wl1271 *wl)
 		wl->elp_compl = &compl;
 	spin_unlock_irqrestore(&wl->wl_lock, flags);
 
-	wl1271_raw_write32(wl, HW_ACCESS_ELP_CTRL_REG_ADDR, ELPCTRL_WAKE_UP);
+	ret = wl1271_raw_write32(wl, HW_ACCESS_ELP_CTRL_REG_ADDR,
+				 ELPCTRL_WAKE_UP);
+	if (ret < 0) {
+		wl12xx_queue_recovery_work(wl);
+		goto err;
+	}
 
 	if (!pending) {
 		ret = wait_for_completion_timeout(
diff --git a/wl12xx-compat/drivers/net/wireless/wl12xx/rx.c b/wl12xx-compat/drivers/net/wireless/wl12xx/rx.c
index dff5dbd..3dd569c 100644
--- a/wl12xx-compat/drivers/net/wireless/wl12xx/rx.c
+++ b/wl12xx-compat/drivers/net/wireless/wl12xx/rx.c
@@ -190,7 +190,7 @@ static int wl1271_rx_handle_data(struct wl1271 *wl, u8 *data, u32 length,
 	return is_data;
 }
 
-void wl12xx_rx(struct wl1271 *wl, struct wl12xx_fw_status *status)
+int wl12xx_rx(struct wl1271 *wl, struct wl12xx_fw_status *status)
 {
 	struct wl1271_acx_mem_map *wl_mem_map = wl->target_mem_map;
 	unsigned long active_hlids[BITS_TO_LONGS(WL12XX_MAX_LINKS)] = {0};
@@ -203,6 +203,7 @@ void wl12xx_rx(struct wl1271 *wl, struct wl12xx_fw_status *status)
 	u32 pkt_offset;
 	u8 hlid;
 	bool unaligned = false;
+	int ret = 0;
 
 	while (drv_rx_counter != fw_rx_counter) {
 		buf_size = 0;
@@ -236,14 +237,18 @@ void wl12xx_rx(struct wl1271 *wl, struct wl12xx_fw_status *status)
 			wl->rx_mem_pool_addr.addr_extra =
 				wl->rx_mem_pool_addr.addr + 4;
 
-			wl1271_write(wl, WL1271_SLV_REG_DATA,
-				     &wl->rx_mem_pool_addr,
-				     sizeof(wl->rx_mem_pool_addr), false);
+			ret = wl1271_write(wl, WL1271_SLV_REG_DATA,
+					   &wl->rx_mem_pool_addr,
+					   sizeof(wl->rx_mem_pool_addr), false);
+			if (ret < 0)
+				goto out;
 		}
 
 		/* Read all available packets at once */
-		wl1271_read(wl, WL1271_SLV_MEM_DATA, wl->aggr_buf,
-				buf_size, true);
+		ret = wl1271_read(wl, WL1271_SLV_MEM_DATA, wl->aggr_buf,
+				  buf_size, true);
+		if (ret < 0)
+			goto out;
 
 		/* Split data into separate packets */
 		pkt_offset = 0;
@@ -282,10 +287,17 @@ void wl12xx_rx(struct wl1271 *wl, struct wl12xx_fw_status *status)
 	 * Write the driver's packet counter to the FW. This is only required
 	 * for older hardware revisions
 	 */
-	if (wl->quirks & WL12XX_QUIRK_END_OF_TRANSACTION)
-		wl1271_write32(wl, RX_DRIVER_COUNTER_ADDRESS, wl->rx_counter);
+	if (wl->quirks & WL12XX_QUIRK_END_OF_TRANSACTION) {
+		ret = wl1271_write32(wl, RX_DRIVER_COUNTER_ADDRESS,
+				     wl->rx_counter);
+		if (ret < 0)
+			goto out;
+	}
 
 	wl12xx_rearm_rx_streaming(wl, active_hlids);
+
+out:
+	return ret;
 }
 
 /*
@@ -338,13 +350,19 @@ int wl1271_rx_data_filter_enable(struct wl1271 *wl,
 }
 
 /* Unset any active filters */
-void wl1271_rx_data_filters_clear_all(struct wl1271 *wl)
+int wl1271_rx_data_filters_clear_all(struct wl1271 *wl)
 {
 	int i;
+	int ret = 0;
 
 	for (i = 0; i < WL1271_MAX_RX_FILTERS; i++) {
 		if (!wl->rx_data_filters_status[i])
 			continue;
-		wl1271_rx_data_filter_enable(wl, i, 0, NULL);
+		ret = wl1271_rx_data_filter_enable(wl, i, 0, NULL);
+		if (ret < 0)
+			goto out;
 	}
+
+out:
+	return ret;
 }
diff --git a/wl12xx-compat/drivers/net/wireless/wl12xx/rx.h b/wl12xx-compat/drivers/net/wireless/wl12xx/rx.h
index 6ef5889..3e1b3b6 100644
--- a/wl12xx-compat/drivers/net/wireless/wl12xx/rx.h
+++ b/wl12xx-compat/drivers/net/wireless/wl12xx/rx.h
@@ -126,7 +126,7 @@ struct wl1271_rx_descriptor {
 	u8  reserved;
 } __packed;
 
-void wl12xx_rx(struct wl1271 *wl, struct wl12xx_fw_status *status);
+int wl12xx_rx(struct wl1271 *wl, struct wl12xx_fw_status *status);
 u8 wl1271_rate_to_idx(int rate, enum ieee80211_band band);
 void wl1271_set_default_filters(struct wl1271 *wl);
 int wl1271_rx_data_filtering_enable(struct wl1271 *wl, bool enable,
@@ -135,5 +135,5 @@ int wl1271_rx_data_filter_enable(struct wl1271 *wl,
 				 int index,
 				 bool enable,
 				 struct wl12xx_rx_data_filter *filter);
-void wl1271_rx_data_filters_clear_all(struct wl1271 *wl);
+int wl1271_rx_data_filters_clear_all(struct wl1271 *wl);
 #endif
diff --git a/wl12xx-compat/drivers/net/wireless/wl12xx/scan.c b/wl12xx-compat/drivers/net/wireless/wl12xx/scan.c
index 416f3d9..75b624b 100644
--- a/wl12xx-compat/drivers/net/wireless/wl12xx/scan.c
+++ b/wl12xx-compat/drivers/net/wireless/wl12xx/scan.c
@@ -57,6 +57,12 @@ void wl1271_scan_complete_work(struct work_struct *work)
 	vif = wl->scan_vif;
 	wlvif = wl12xx_vif_to_data(vif);
 
+	/*
+	 * Rearm the tx watchdog just before idling scan. This
+	 * prevents just-finished scans from triggering the watchdog
+	 */
+	wl12xx_rearm_tx_watchdog_locked(wl);
+
 	wl->scan.state = WL1271_SCAN_STATE_IDLE;
 	memset(wl->scan.scanned_ch, 0, sizeof(wl->scan.scanned_ch));
 	wl->scan.req = NULL;
@@ -252,7 +258,7 @@ static int wl1271_scan_send(struct wl1271 *wl, struct ieee80211_vif *vif,
 					 cmd->params.role_id, band,
 					 wl->scan.ssid, wl->scan.ssid_len,
 					 wl->scan.req->ie,
-					 wl->scan.req->ie_len);
+					 wl->scan.req->ie_len, false);
 	if (ret < 0) {
 		wl1271_error("PROBE request template failed");
 		goto out;
@@ -659,7 +665,9 @@ wl12xx_scan_sched_scan_ssid_list(struct wl1271 *wl,
 					continue;
 
 				for (j = 0; j < cmd->n_ssids; j++)
-					if (!memcmp(req->ssids[i].ssid,
+					if ((req->ssids[i].ssid_len ==
+					     cmd->ssids[j].len) &&
+					    !memcmp(req->ssids[i].ssid,
 						   cmd->ssids[j].ssid,
 						   req->ssids[i].ssid_len)) {
 						cmd->ssids[j].type =
@@ -758,7 +766,7 @@ int wl1271_scan_sched_scan_config(struct wl1271 *wl,
 						 req->ssids[0].ssid,
 						 req->ssids[0].ssid_len,
 						 ies->ie[band],
-						 ies->len[band]);
+						 ies->len[band], true);
 		if (ret < 0) {
 			wl1271_error("2.4GHz PROBE request template failed");
 			goto out;
@@ -772,7 +780,7 @@ int wl1271_scan_sched_scan_config(struct wl1271 *wl,
 						 req->ssids[0].ssid,
 						 req->ssids[0].ssid_len,
 						 ies->ie[band],
-						 ies->len[band]);
+						 ies->len[band], true);
 		if (ret < 0) {
 			wl1271_error("5GHz PROBE request template failed");
 			goto out;
diff --git a/wl12xx-compat/drivers/net/wireless/wl12xx/sdio.c b/wl12xx-compat/drivers/net/wireless/wl12xx/sdio.c
index 0be27e6..dd5c1e1 100644
--- a/wl12xx-compat/drivers/net/wireless/wl12xx/sdio.c
+++ b/wl12xx-compat/drivers/net/wireless/wl12xx/sdio.c
@@ -67,8 +67,8 @@ static void wl1271_sdio_set_block_size(struct device *child,
 	sdio_release_host(func);
 }
 
-static void wl12xx_sdio_raw_read(struct device *child, int addr, void *buf,
-				 size_t len, bool fixed)
+static int __must_check wl12xx_sdio_raw_read(struct device *child, int addr,
+					     void *buf, size_t len, bool fixed)
 {
 	int ret;
 	struct wl12xx_sdio_glue *glue = dev_get_drvdata(child->parent);
@@ -92,12 +92,14 @@ static void wl12xx_sdio_raw_read(struct device *child, int addr, void *buf,
 
 	sdio_release_host(func);
 
-	if (ret)
+	if (WARN_ON(ret))
 		dev_err(child->parent, "sdio read failed (%d)\n", ret);
+
+	return ret;
 }
 
-static void wl12xx_sdio_raw_write(struct device *child, int addr, void *buf,
-				  size_t len, bool fixed)
+static int __must_check wl12xx_sdio_raw_write(struct device *child, int addr,
+					      void *buf, size_t len, bool fixed)
 {
 	int ret;
 	struct wl12xx_sdio_glue *glue = dev_get_drvdata(child->parent);
@@ -121,30 +123,35 @@ static void wl12xx_sdio_raw_write(struct device *child, int addr, void *buf,
 
 	sdio_release_host(func);
 
-	if (ret)
+	if (WARN_ON(ret))
 		dev_err(child->parent, "sdio write failed (%d)\n", ret);
+
+	return ret;
 }
 
 static int wl12xx_sdio_power_on(struct wl12xx_sdio_glue *glue)
 {
 	int ret;
 	struct sdio_func *func = dev_to_sdio_func(glue->dev);
+	struct mmc_card *card = func->card;
 
 	/* Avoid manual resume */
 	func->card->host->bus_resume_flags = 0;
 
-	/* If enabled, tell runtime PM not to power off the card */
-	if (pm_runtime_enabled(&func->dev)) {
-		ret = pm_runtime_get_sync(&func->dev);
-		if (ret < 0)
+	ret = pm_runtime_get_sync(&card->dev);
+	if (ret) {
+		/*
+		 * Runtime PM might be temporarily disabled, or the device
+		 * might have a positive reference counter. Make sure it is
+		 * really powered on.
+		 */
+		ret = mmc_power_restore_host(card->host);
+		if (ret < 0) {
+			pm_runtime_put_sync(&card->dev);
 			goto out;
+		}
 	}
 
-	/* Runtime PM is disabled: power up the card manually */
-	ret = mmc_power_restore_host(func->card->host);
-	if (ret < 0)
-		goto out;
-
 	sdio_claim_host(func);
 	sdio_enable_func(func);
 	sdio_release_host(func);
@@ -157,23 +164,24 @@ static int wl12xx_sdio_power_off(struct wl12xx_sdio_glue *glue)
 {
 	int ret;
 	struct sdio_func *func = dev_to_sdio_func(glue->dev);
+	struct mmc_card *card = func->card;
 
 	sdio_claim_host(func);
 	sdio_disable_func(func);
 	sdio_release_host(func);
 
-	/* Power off the card manually, even if runtime PM is enabled. */
-	ret = mmc_power_save_host(func->card->host);
+	/* Power off the card manually in case it wasn't powered off above */
+	ret = mmc_power_save_host(card->host);
 	if (ret < 0)
-		return ret;
+		goto out;
 
-	/* If enabled, let runtime PM know the card is powered off */
-	if (pm_runtime_enabled(&func->dev))
-		ret = pm_runtime_put_sync(&func->dev);
+	/* Let runtime PM know the card is powered off */
+	pm_runtime_put_sync(&card->dev);
 
 	/* Enable manual resume */
 	func->card->host->bus_resume_flags |= MMC_BUSRESUME_MANUAL_RESUME;
 
+out:
 	return ret;
 }
 
diff --git a/wl12xx-compat/drivers/net/wireless/wl12xx/spi.c b/wl12xx-compat/drivers/net/wireless/wl12xx/spi.c
index e006820..a6aa532 100644
--- a/wl12xx-compat/drivers/net/wireless/wl12xx/spi.c
+++ b/wl12xx-compat/drivers/net/wireless/wl12xx/spi.c
@@ -195,8 +195,8 @@ static int wl12xx_spi_read_busy(struct device *child)
 	return -ETIMEDOUT;
 }
 
-static void wl12xx_spi_raw_read(struct device *child, int addr, void *buf,
-				size_t len, bool fixed)
+static int __must_check wl12xx_spi_raw_read(struct device *child, int addr,
+					    void *buf, size_t len, bool fixed)
 {
 	struct wl12xx_spi_glue *glue = dev_get_drvdata(child->parent);
 	struct wl1271 *wl = dev_get_drvdata(child);
@@ -240,7 +240,7 @@ static void wl12xx_spi_raw_read(struct device *child, int addr, void *buf,
 		if (!(busy_buf[WL1271_BUSY_WORD_CNT - 1] & 0x1) &&
 		    wl12xx_spi_read_busy(child)) {
 			memset(buf, 0, chunk_len);
-			return;
+			return 0;
 		}
 
 		spi_message_init(&m);
@@ -258,10 +258,12 @@ static void wl12xx_spi_raw_read(struct device *child, int addr, void *buf,
 		buf += chunk_len;
 		len -= chunk_len;
 	}
+
+	return 0;
 }
 
-static void wl12xx_spi_raw_write(struct device *child, int addr, void *buf,
-				 size_t len, bool fixed)
+static int __must_check wl12xx_spi_raw_write(struct device *child, int addr,
+					     void *buf, size_t len, bool fixed)
 {
 	struct wl12xx_spi_glue *glue = dev_get_drvdata(child->parent);
 	struct spi_transfer t[2 * WSPI_MAX_NUM_OF_CHUNKS];
@@ -306,6 +308,8 @@ static void wl12xx_spi_raw_write(struct device *child, int addr, void *buf,
 	}
 
 	spi_sync(to_spi_device(glue->dev), &m);
+
+	return 0;
 }
 
 static struct wl1271_if_operations spi_ops = {
diff --git a/wl12xx-compat/drivers/net/wireless/wl12xx/tx.c b/wl12xx-compat/drivers/net/wireless/wl12xx/tx.c
index 63821f0..ff74ad1 100644
--- a/wl12xx-compat/drivers/net/wireless/wl12xx/tx.c
+++ b/wl12xx-compat/drivers/net/wireless/wl12xx/tx.c
@@ -220,6 +220,10 @@ static int wl1271_tx_allocate(struct wl1271 *wl, struct wl12xx_vif *wlvif,
 		wl->tx_blocks_available -= total_blocks;
 		wl->tx_allocated_blocks += total_blocks;
 
+		/* If the FW was empty before, arm the Tx watchdog */
+		if (wl->tx_allocated_blocks == total_blocks)
+			wl12xx_rearm_tx_watchdog_locked(wl);
+
 		ac = wl1271_tx_get_queue(skb_get_queue_mapping(skb));
 		wl->tx_allocated_pkts[ac]++;
 
@@ -300,11 +304,15 @@ static void wl1271_tx_fill_hdr(struct wl1271 *wl, struct wl12xx_vif *wlvif,
 	if (is_dummy || !wlvif)
 		rate_idx = 0;
 	else if (wlvif->bss_type != BSS_TYPE_AP_BSS) {
-		/* if the packets are destined for AP (have a STA entry)
-		   send them with AP rate policies, otherwise use default
-		   basic rates */
+		/*
+		 * if the packets are destined for AP (have a STA entry)
+		 * send them with AP rate policies (EAPOLs are an exception),
+		 * otherwise use default basic rates
+		 */
 		if (control->flags & IEEE80211_TX_CTL_NO_CCK_RATE)
 			rate_idx = wlvif->sta.p2p_rate_idx;
+		else if (skb->protocol == cpu_to_be16(ETH_P_PAE))
+			rate_idx = wlvif->sta.basic_rate_idx;
 		else if (control->control.sta)
 			rate_idx = wlvif->sta.ap_rate_idx;
 		else
@@ -371,8 +379,10 @@ static int wl1271_prepare_tx_frame(struct wl1271 *wl, struct wl12xx_vif *wlvif,
 	bool is_dummy;
 	bool is_gem = false;
 
-	if (!skb)
+	if (!skb) {
+		wl1271_error("discarding null skb");
 		return -EINVAL;
+	}
 
 	info = IEEE80211_SKB_CB(skb);
 
@@ -401,6 +411,8 @@ static int wl1271_prepare_tx_frame(struct wl1271 *wl, struct wl12xx_vif *wlvif,
 
 		is_gem = (cipher == WL1271_CIPHER_SUITE_GEM);
 	}
+
+	is_gem |= (skb->protocol == cpu_to_be16(WL1271_ETH_P_WAI));
 	hlid = wl12xx_tx_get_hlid(wl, wlvif, skb);
 	if (hlid == WL12XX_INVALID_LINK_ID) {
 		wl1271_error("invalid hlid. dropping skb 0x%p", skb);
@@ -684,7 +696,17 @@ void wl12xx_rearm_rx_streaming(struct wl1271 *wl, unsigned long *active_hlids)
 	}
 }
 
-void wl1271_tx_work_locked(struct wl1271 *wl)
+/*
+ * Returns failure values only in case of failed bus ops within this function.
+ * wl1271_prepare_tx_frame retvals won't be returned in order to avoid
+ * triggering recovery by higher layers when not necessary.
+ * In case a FW command fails within wl1271_prepare_tx_frame fails a recovery
+ * will be queued in wl1271_cmd_send. -EAGAIN/-EBUSY from prepare_tx_frame
+ * can occur and are legitimate so don't propagate. -EINVAL will emit a WARNING
+ * within prepare_tx_frame code but there's nothing we should do about those
+ * as well.
+ */
+int wl1271_tx_work_locked(struct wl1271 *wl)
 {
 	struct wl12xx_vif *wlvif;
 	struct sk_buff *skb;
@@ -692,10 +714,11 @@ void wl1271_tx_work_locked(struct wl1271 *wl)
 	u32 buf_offset = 0;
 	bool sent_packets = false;
 	unsigned long active_hlids[BITS_TO_LONGS(WL12XX_MAX_LINKS)] = {0};
-	int ret;
+	int ret = 0;
+	int bus_ret = 0;
 
 	if (unlikely(wl->state == WL1271_STATE_OFF))
-		return;
+		return 0;
 
 	while ((skb = wl1271_skb_dequeue(wl))) {
 		struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
@@ -713,8 +736,11 @@ void wl1271_tx_work_locked(struct wl1271 *wl)
 			 * Flush buffer and try again.
 			 */
 			wl1271_skb_queue_head(wl, wlvif, skb);
-			wl1271_write(wl, WL1271_SLV_MEM_DATA, wl->aggr_buf,
-				     buf_offset, true);
+			bus_ret = wl1271_write(wl, WL1271_SLV_MEM_DATA,
+					       wl->aggr_buf, buf_offset, true);
+			if (bus_ret < 0)
+				goto out;
+
 			sent_packets = true;
 			buf_offset = 0;
 			continue;
@@ -748,8 +774,11 @@ void wl1271_tx_work_locked(struct wl1271 *wl)
 
 out_ack:
 	if (buf_offset) {
-		wl1271_write(wl, WL1271_SLV_MEM_DATA, wl->aggr_buf,
-				buf_offset, true);
+		bus_ret = wl1271_write(wl, WL1271_SLV_MEM_DATA, wl->aggr_buf,
+				       buf_offset, true);
+		if (bus_ret < 0)
+			goto out;
+
 		sent_packets = true;
 	}
 	if (sent_packets) {
@@ -757,13 +786,19 @@ out_ack:
 		 * Interrupt the firmware with the new packets. This is only
 		 * required for older hardware revisions
 		 */
-		if (wl->quirks & WL12XX_QUIRK_END_OF_TRANSACTION)
-			wl1271_write32(wl, WL1271_HOST_WR_ACCESS,
-				       wl->tx_packets_count);
+		if (wl->quirks & WL12XX_QUIRK_END_OF_TRANSACTION) {
+			bus_ret = wl1271_write32(wl, WL1271_HOST_WR_ACCESS,
+						 wl->tx_packets_count);
+			if (bus_ret < 0)
+				goto out;
+		}
 
 		wl1271_handle_tx_low_watermark(wl);
 	}
 	wl12xx_rearm_rx_streaming(wl, active_hlids);
+
+out:
+	return bus_ret;
 }
 
 void wl1271_tx_work(struct work_struct *work)
@@ -776,7 +811,11 @@ void wl1271_tx_work(struct work_struct *work)
 	if (ret < 0)
 		goto out;
 
-	wl1271_tx_work_locked(wl);
+	ret = wl1271_tx_work_locked(wl);
+	if (ret < 0) {
+		wl12xx_queue_recovery_work(wl);
+		goto out;
+	}
 
 	wl1271_ps_elp_sleep(wl);
 out:
@@ -888,22 +927,28 @@ static void wl1271_tx_complete_packet(struct wl1271 *wl,
 }
 
 /* Called upon reception of a TX complete interrupt */
-void wl1271_tx_complete(struct wl1271 *wl)
+int wl1271_tx_complete(struct wl1271 *wl)
 {
 	struct wl1271_acx_mem_map *memmap =
 		(struct wl1271_acx_mem_map *)wl->target_mem_map;
 	u32 count, fw_counter;
 	u32 i;
+	int ret;
 
 	/* read the tx results from the chipset */
-	wl1271_read(wl, le32_to_cpu(memmap->tx_result),
-		    wl->tx_res_if, sizeof(*wl->tx_res_if), false);
+	ret = wl1271_read(wl, le32_to_cpu(memmap->tx_result),
+			  wl->tx_res_if, sizeof(*wl->tx_res_if), false);
+	if (ret < 0)
+		goto out;
+
 	fw_counter = le32_to_cpu(wl->tx_res_if->tx_result_fw_counter);
 
 	/* write host counter to chipset (to ack) */
-	wl1271_write32(wl, le32_to_cpu(memmap->tx_result) +
-		       offsetof(struct wl1271_tx_hw_res_if,
-				tx_result_host_counter), fw_counter);
+	ret = wl1271_write32(wl, le32_to_cpu(memmap->tx_result) +
+			     offsetof(struct wl1271_tx_hw_res_if,
+				      tx_result_host_counter), fw_counter);
+	if (ret < 0)
+		goto out;
 
 	count = fw_counter - wl->tx_results_count;
 	wl1271_debug(DEBUG_TX, "tx_complete received, packets: %d", count);
@@ -923,6 +968,9 @@ void wl1271_tx_complete(struct wl1271 *wl)
 
 		wl->tx_results_count++;
 	}
+
+out:
+	return ret;
 }
 
 void wl1271_tx_reset_link_queues(struct wl1271 *wl, u8 hlid)
diff --git a/wl12xx-compat/drivers/net/wireless/wl12xx/tx.h b/wl12xx-compat/drivers/net/wireless/wl12xx/tx.h
index 3be8e56..a0c56fa 100644
--- a/wl12xx-compat/drivers/net/wireless/wl12xx/tx.h
+++ b/wl12xx-compat/drivers/net/wireless/wl12xx/tx.h
@@ -208,8 +208,8 @@ static inline int wl1271_tx_total_queue_count(struct wl1271 *wl)
 }
 
 void wl1271_tx_work(struct work_struct *work);
-void wl1271_tx_work_locked(struct wl1271 *wl);
-void wl1271_tx_complete(struct wl1271 *wl);
+int wl1271_tx_work_locked(struct wl1271 *wl);
+int wl1271_tx_complete(struct wl1271 *wl);
 void wl12xx_tx_reset_wlvif(struct wl1271 *wl, struct wl12xx_vif *wlvif);
 void wl12xx_tx_reset(struct wl1271 *wl, bool reset_tx_queues);
 void wl1271_tx_flush(struct wl1271 *wl);
@@ -228,5 +228,6 @@ void wl12xx_rearm_rx_streaming(struct wl1271 *wl, unsigned long *active_hlids);
 
 /* from main.c */
 void wl1271_free_sta(struct wl1271 *wl, struct wl12xx_vif *wlvif, u8 hlid);
+void wl12xx_rearm_tx_watchdog_locked(struct wl1271 *wl);
 
 #endif
diff --git a/wl12xx-compat/drivers/net/wireless/wl12xx/wl12xx.h b/wl12xx-compat/drivers/net/wireless/wl12xx/wl12xx.h
index 65961d8..c42562a 100644
--- a/wl12xx-compat/drivers/net/wireless/wl12xx/wl12xx.h
+++ b/wl12xx-compat/drivers/net/wireless/wl12xx/wl12xx.h
@@ -58,6 +58,7 @@
 #define WL1271_TX_SQN_POST_RECOVERY_PADDING 0xff
 
 #define WL1271_CIPHER_SUITE_GEM 0x00147201
+#define WL1271_ETH_P_WAI 0x88B4
 
 #define WL1271_BUSY_WORD_CNT 1
 #define WL1271_BUSY_WORD_LEN (WL1271_BUSY_WORD_CNT * sizeof(u32))
@@ -226,10 +227,10 @@ struct wl1271_scan {
 };
 
 struct wl1271_if_operations {
-	void (*read)(struct device *child, int addr, void *buf, size_t len,
-		     bool fixed);
-	void (*write)(struct device *child, int addr, void *buf, size_t len,
-		     bool fixed);
+	int __must_check (*read)(struct device *child, int addr, void *buf,
+				 size_t len, bool fixed);
+	int __must_check (*write)(struct device *child, int addr, void *buf,
+				  size_t len, bool fixed);
 	void (*reset)(struct device *child);
 	void (*init)(struct device *child);
 	int (*power)(struct device *child, bool enable);
@@ -266,6 +267,7 @@ enum wl12xx_flags {
 	WL1271_FLAG_VIF_CHANGE_IN_PROGRESS,
 	WL1271_FLAG_INTENDED_FW_RECOVERY,
 	WL1271_FLAG_RECOVERY_WORK_PENDING,
+	WL1271_FLAG_IO_FAILED,
 };
 
 enum wl12xx_vif_flags {
@@ -303,7 +305,7 @@ struct ap_peers {
 	struct ieee80211_hw *hw;
 };
 
-#define WL1271_MAX_RX_FILTERS 5
+#define WL1271_MAX_RX_FILTERS 7
 #define WL1271_RX_FILTER_MAX_FIELDS 8
 
 #define WL1271_RX_FILTER_ETH_HEADER_SIZE 14
@@ -481,6 +483,7 @@ struct wl1271 {
 #ifdef CONFIG_HAS_WAKELOCK
 	struct wake_lock wake_lock;
 	struct wake_lock rx_wake;
+	struct wake_lock recovery_wake;
 #endif
 
 	struct wl1271_stats stats;
@@ -553,6 +556,9 @@ struct wl1271 {
 	struct list_head peers_list;
 
 	bool watchdog_recovery;
+
+	/* work to fire when Tx is stuck */
+	struct delayed_work tx_watchdog_work;
 };
 
 struct wl1271_station {
@@ -730,6 +736,7 @@ int wl1271_op_sta_add_locked(struct ieee80211_hw *hw,
 void wl12xx_update_sta_state(struct wl1271 *wl,
 			     struct ieee80211_sta *sta,
 			     enum ieee80211_sta_state state);
+int wl12xx_init_pll_clock(struct wl1271 *wl, int *selected_clock);
 
 #define JOIN_TIMEOUT 5000 /* 5000 milliseconds to join */
 
diff --git a/wl12xx-compat/include/linux/nl80211.h b/wl12xx-compat/include/linux/nl80211.h
index 51f3e74..b06670e 100644
--- a/wl12xx-compat/include/linux/nl80211.h
+++ b/wl12xx-compat/include/linux/nl80211.h
@@ -2574,6 +2574,13 @@ enum nl80211_tx_power_setting {
  *	Note that the pattern matching is done as though frames were not
  *	802.11 frames but 802.3 frames, i.e. the frame is fully unpacked
  *	first (including SNAP header unpacking) and then matched.
+ * @NL80211_WOWLAN_ACTION: pattern action which can be either to wake up
+ *      on this pattern or drop it and avoid wake up. This can be used to
+ *      specify an excpetion/blacklist pattern that shouldn't cause wakeup
+ *      despite the packet matching another wowlan pattern. For example:
+ *      configure all IPv4 multicast to wake up except certain type of packets
+ *      This can be either NL80211_WOWLAN_ACTION_ALLOW or DROP.
+ *      If this attribute is missing the default would be ALLOW.
  * @NUM_NL80211_WOWLAN_PKTPAT: number of attributes
  * @MAX_NL80211_WOWLAN_PKTPAT: max attribute number
  */
@@ -2581,11 +2588,30 @@ enum nl80211_wowlan_packet_pattern_attr {
 	__NL80211_WOWLAN_PKTPAT_INVALID,
 	NL80211_WOWLAN_PKTPAT_MASK,
 	NL80211_WOWLAN_PKTPAT_PATTERN,
+	NL80211_WOWLAN_PKTPAT_ACTION,
 
 	NUM_NL80211_WOWLAN_PKTPAT,
 	MAX_NL80211_WOWLAN_PKTPAT = NUM_NL80211_WOWLAN_PKTPAT - 1,
 };
 
+
+/**
+ * enum nl80211_wowlan_action - WoWLAN packet pattern action
+ * @NL80211_WOWLAN_ACTION_ALLOW: this pattern should wake up the host
+ * and the packet should be forwarded to the host unless this packet
+ * matches a DROP rule.
+ * @NL80211_WOWLAN_ACTION_DROP: a packet containing this pattern shouldn't
+ * wake up the host.
+ */
+enum nl80211_wowlan_action {
+	NL80211_WOWLAN_ACTION_ALLOW,
+	NL80211_WOWLAN_ACTION_DROP,
+
+	/* keep last */
+	NUM_NL80211_WOWLAN_ACTION,
+	MAX_NL80211_WOWLAN_ACTION = NUM_NL80211_WOWLAN_ACTION - 1,
+};
+
 /**
  * struct nl80211_wowlan_pattern_support - pattern support information
  * @max_patterns: maximum number of patterns supported
diff --git a/wl12xx-compat/include/net/cfg80211.h b/wl12xx-compat/include/net/cfg80211.h
index 3090129..21e2100 100644
--- a/wl12xx-compat/include/net/cfg80211.h
+++ b/wl12xx-compat/include/net/cfg80211.h
@@ -1264,6 +1264,7 @@ struct cfg80211_pmksa {
  *	one bit per byte, in same format as nl80211
  * @pattern: bytes to match where bitmask is 1
  * @pattern_len: length of pattern (in bytes)
+ * @action: whether to drop or allow this pattern
  *
  * Internal note: @mask and @pattern are allocated in one chunk of
  * memory, free @mask only!
@@ -1271,6 +1272,7 @@ struct cfg80211_pmksa {
 struct cfg80211_wowlan_trig_pkt_pattern {
 	u8 *mask, *pattern;
 	int pattern_len;
+	u8 action;
 };
 
 /**
diff --git a/wl12xx-compat/net/mac80211/mlme.c b/wl12xx-compat/net/mac80211/mlme.c
index 962f072..8a5d2a2 100644
--- a/wl12xx-compat/net/mac80211/mlme.c
+++ b/wl12xx-compat/net/mac80211/mlme.c
@@ -653,9 +653,6 @@ static bool ieee80211_powersave_allowed(struct ieee80211_sub_if_data *sdata)
 	if (!mgd->associated)
 		return false;
 
-	if (!mgd->associated->beacon_ies)
-		return false;
-
 	if (mgd->flags & (IEEE80211_STA_BEACON_POLL |
 			  IEEE80211_STA_CONNECTION_POLL))
 		return false;
diff --git a/wl12xx-compat/net/mac80211/pm.c b/wl12xx-compat/net/mac80211/pm.c
index e6ee9ae..8160b97 100644
--- a/wl12xx-compat/net/mac80211/pm.c
+++ b/wl12xx-compat/net/mac80211/pm.c
@@ -77,6 +77,15 @@ int __ieee80211_suspend(struct ieee80211_hw *hw, struct cfg80211_wowlan *wowlan)
 		int err = drv_suspend(local, wowlan);
 		if (err < 0) {
 			local->quiescing = false;
+			local->wowlan = false;
+			if (hw->flags & IEEE80211_HW_AMPDU_AGGREGATION) {
+				mutex_lock(&local->sta_mtx);
+				list_for_each_entry(sta,
+						    &local->sta_list, list) {
+					clear_sta_flag(sta, WLAN_STA_BLOCK_BA);
+				}
+				mutex_unlock(&local->sta_mtx);
+			}
 			ieee80211_wake_queues_by_reason(hw,
 					IEEE80211_QUEUE_STOP_REASON_SUSPEND);
 			return err;
diff --git a/wl12xx-compat/net/mac80211/sta_info.c b/wl12xx-compat/net/mac80211/sta_info.c
index 672a170..e71fd62 100644
--- a/wl12xx-compat/net/mac80211/sta_info.c
+++ b/wl12xx-compat/net/mac80211/sta_info.c
@@ -409,7 +409,7 @@ static int sta_info_insert_finish(struct sta_info *sta) __acquires(RCU)
 		/* make the station visible */
 		sta_info_hash_add(local, sta);
 
-		list_add(&sta->list, &local->sta_list);
+		list_add_rcu(&sta->list, &local->sta_list);
 	} else {
 		sta->dummy = false;
 	}
@@ -742,7 +742,7 @@ static int __must_check __sta_info_destroy(struct sta_info *sta)
 	if (ret)
 		return ret;
 
-	list_del(&sta->list);
+	list_del_rcu(&sta->list);
 
 	mutex_lock(&local->key_mtx);
 	for (i = 0; i < NUM_DEFAULT_KEYS; i++)
diff --git a/wl12xx-compat/net/mac80211/work.c b/wl12xx-compat/net/mac80211/work.c
index 6486d42..8eedf5d 100644
--- a/wl12xx-compat/net/mac80211/work.c
+++ b/wl12xx-compat/net/mac80211/work.c
@@ -619,7 +619,8 @@ ieee80211_rx_mgmt_auth(struct ieee80211_work *wk,
 	auth_transaction = le16_to_cpu(mgmt->u.auth.auth_transaction);
 	status_code = le16_to_cpu(mgmt->u.auth.status_code);
 
-	if (auth_alg != wk->probe_auth.algorithm ||
+	if ((auth_alg != wk->probe_auth.algorithm &&
+	     status_code != WLAN_STATUS_NOT_SUPPORTED_AUTH_ALG) ||
 	    auth_transaction != wk->probe_auth.transaction)
 		return WORK_ACT_NONE;
 
diff --git a/wl12xx-compat/net/wireless/nl80211.c b/wl12xx-compat/net/wireless/nl80211.c
index 655be00..e3a3172 100644
--- a/wl12xx-compat/net/wireless/nl80211.c
+++ b/wl12xx-compat/net/wireless/nl80211.c
@@ -5910,6 +5910,8 @@ static int nl80211_get_wowlan(struct sk_buff *skb, struct genl_info *info)
 				NLA_PUT(msg, NL80211_WOWLAN_PKTPAT_PATTERN,
 					pat_len,
 					rdev->wowlan->patterns[i].pattern);
+				NLA_PUT_U8(msg, NL80211_WOWLAN_PKTPAT_ACTION,
+					   rdev->wowlan->patterns[i].action);
 				nla_nest_end(msg, nl_pat);
 			}
 			nla_nest_end(msg, nl_pats);
@@ -6017,6 +6019,8 @@ static int nl80211_set_wowlan(struct sk_buff *skb, struct genl_info *info)
 
 		nla_for_each_nested(pat, tb[NL80211_WOWLAN_TRIG_PKT_PATTERN],
 				    rem) {
+			u8 action = NL80211_WOWLAN_ACTION_ALLOW;
+
 			nla_parse(pat_tb, MAX_NL80211_WOWLAN_PKTPAT,
 				  nla_data(pat), nla_len(pat), NULL);
 			err = -EINVAL;
@@ -6031,7 +6035,13 @@ static int nl80211_set_wowlan(struct sk_buff *skb, struct genl_info *info)
 			if (pat_len > wowlan->pattern_max_len ||
 			    pat_len < wowlan->pattern_min_len)
 				goto error;
-
+			if (pat_tb[NL80211_WOWLAN_PKTPAT_ACTION]) {
+				action = nla_get_u8(
+					pat_tb[NL80211_WOWLAN_PKTPAT_ACTION]);
+				if (action > MAX_NL80211_WOWLAN_ACTION)
+					goto error;
+			}
+			new_triggers.patterns[i].action = action;
 			new_triggers.patterns[i].mask =
 				kmalloc(mask_len + pat_len, GFP_KERNEL);
 			if (!new_triggers.patterns[i].mask) {
-- 
1.7.4.1

