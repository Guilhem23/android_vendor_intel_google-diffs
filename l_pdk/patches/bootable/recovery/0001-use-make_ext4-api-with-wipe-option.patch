From d68e3fad1d6ffac04d418bf507a1946db95a7f7c Mon Sep 17 00:00:00 2001
From: Marie-Cecile Afantenos <marie.cecile.afantenos@intel.com>
Date: Tue, 6 Aug 2013 18:59:47 +0200
Subject: use make_ext4 api with wipe option

BZ: 82879

Category: aosp improvement
Domain: PUPDR-Recovery
Origin: internal
Upstream-Candidate: no, need rework

Change-Id: I5d68df05dee78aa421e7669abb4784886e5670ed
Signed-off-by: Marie-Cecile Afantenos <marie.cecile.afantenos@intel.com>
Reviewed-on: http://android.intel.com:8080/123955
Reviewed-by: Auger, Florent <florent.auger@intel.com>
Reviewed-by: Dong, Chuanxiao <chuanxiao.dong@intel.com>
Reviewed-by: Tinelli, Vincent <vincent.tinelli@intel.com>
Tested-by: Lumbierres, PhilippeX <philippex.lumbierres@intel.com>
Reviewed-by: cactus <cactus@intel.com>
Tested-by: cactus <cactus@intel.com>
---
 roots.cpp         |   20 +++++++++++++++++++-
 updater/install.c |   13 +++++++++++--
 2 files changed, 30 insertions(+), 3 deletions(-)

diff --git a/roots.cpp b/roots.cpp
index 66481a3..805c4f6 100644
--- a/roots.cpp
+++ b/roots.cpp
@@ -29,6 +29,7 @@
 #include "roots.h"
 #include "common.h"
 #include "make_ext4fs.h"
+#include "cutils/properties.h"
 extern "C" {
 #include "wipe.h"
 #include "cryptfs.h"
@@ -38,6 +39,14 @@ static struct fstab *fstab = NULL;
 
 extern struct selabel_handle *sehandle;
 
+/* Flag to set which wipe feature will be use while erasing
+ * To be used carefully especially for production & care
+ * Should only be used during power-on or engineering
+ * Has to be used on mechanical hard-drives until we query disk's capabilities
+ * */
+int g_wipe_flag = WIPE_FALLBACK;
+
+
 void load_volume_table()
 {
     int i;
@@ -153,6 +162,8 @@ int ensure_path_unmounted(const char* path) {
 
 int format_volume(const char* volume) {
     Volume* v = volume_for_path(volume);
+    char value[PROPERTY_VALUE_MAX+1];
+
     if (v == NULL) {
         LOGE("unknown volume \"%s\"\n", volume);
         return -1;
@@ -202,7 +213,14 @@ int format_volume(const char* volume) {
         } else if (v->key_loc != NULL && strcmp(v->key_loc, "footer") == 0) {
             length = -CRYPT_FOOTER_OFFSET;
         }
-        int result = make_ext4fs(v->blk_device, length, volume, sehandle);
+
+        int len = property_get("ro.g_wipe_flag", value, NULL);
+        if (len == 1) {
+            g_wipe_flag = atoi(value);
+        }
+
+        /* get the wipe flag for unsecure, secure, or no wipe */
+        int result = make_ext4fs(v->blk_device, length, volume, sehandle, g_wipe_flag);
         if (result != 0) {
             LOGE("format_volume: make_extf4fs failed on %s\n", v->blk_device);
             return -1;
diff --git a/updater/install.c b/updater/install.c
index e1071c9..f8de6f3 100644
--- a/updater/install.c
+++ b/updater/install.c
@@ -51,6 +51,7 @@
 #ifdef USE_EXT4
 #include "make_ext4fs.h"
 #include "wipe.h"
+int g_wipe_flag = WIPE_FALLBACK;
 #endif
 
 // Take a sha-1 digest and return it as a newly-allocated hex string.
@@ -229,7 +230,9 @@ Value* FormatFn(const char* name, State* state, int argc, Expr* argv[]) {
     char* location;
     char* fs_size;
     char* mount_point;
-
+#ifdef USE_EXT4
+    char value[PROPERTY_VALUE_MAX];
+#endif
     if (ReadArgs(state, argv, 5, &fs_type, &partition_type, &location, &fs_size, &mount_point) < 0) {
         return NULL;
     }
@@ -282,7 +285,13 @@ Value* FormatFn(const char* name, State* state, int argc, Expr* argv[]) {
         result = location;
 #ifdef USE_EXT4
     } else if (strcmp(fs_type, "ext4") == 0) {
-        int status = make_ext4fs(location, atoll(fs_size), mount_point, sehandle);
+        /* get the wipe flag for unsecure, secure, or no wipe */
+        int len = property_get("ro.g_wipe_flag", value, NULL);
+        if (len == 1) {
+            g_wipe_flag = atoi(value);
+        }
+
+        int status = make_ext4fs(location, atoll(fs_size), mount_point, sehandle, g_wipe_flag);
         if (status != 0) {
             printf("%s: make_ext4fs failed (%d) on %s",
                     name, status, location);
-- 
1.7.4.1

