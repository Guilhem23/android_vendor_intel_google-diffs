From 9f2c7d66ae146c7e638bb40cf049eba69f2e0cb4 Mon Sep 17 00:00:00 2001
From: Yong Yao <yong.yao@intel.com>
Date: Tue, 24 Jun 2014 22:09:28 +0800
Subject: pass build for L PDK

Change-Id: I146fe4d47ac7c6521f2d02eb98089150690d3207
Signed-off-by: Yong Yao <yong.yao@intel.com>
---
 BoardConfig.mk                  |   26 +--
 MmgrClients.mk                  |    6 +-
 bluetooth/AndroidBtCommon.mk    |    8 +-
 common.mk                       |    2 +-
 external/generic_rules.mk       |    7 -
 fg_config/fg_conf_helper.c      |  158 +++++++-------
 gps/Android.mk                  |   24 --
 kernel-headers/asm/elf.h        |   50 -----
 kernel-headers/asm/page_types.h |   63 ++++++
 kernel-headers/linux/elf.h      |  394 ----------------------------------
 kernel-headers/linux/ext3_fs.h  |  448 +++++++++++++++++++++++++++++++++++++++
 test_suites.mk                  |   73 -------
 wifi/WifiBoardConfig.mk         |   26 ---
 13 files changed, 601 insertions(+), 684 deletions(-)
 delete mode 100644 kernel-headers/asm/elf.h
 create mode 100644 kernel-headers/asm/page_types.h
 delete mode 100644 kernel-headers/linux/elf.h
 create mode 100644 kernel-headers/linux/ext3_fs.h

diff --git a/BoardConfig.mk b/BoardConfig.mk
index 3dcaf49..1948806 100755
--- a/BoardConfig.mk
+++ b/BoardConfig.mk
@@ -8,7 +8,7 @@ TARGET_CPU_ABI := x86
 TARGET_CPU_SMP := true
 TARGET_NO_BOOTLOADER := true
 TARGET_NO_RADIOIMAGE := true
-TARGET_NO_RECOVERY := false
+TARGET_NO_RECOVERY := true
 TARGET_PRELINK_MODULE := false
 TARGET_PROVIDES_INIT_RC := true
 TARGET_USERIMAGES_USE_EXT4 := true
@@ -17,24 +17,9 @@ TARGET_BOARD_KERNEL_HEADERS := $(COMMON_PATH)/kernel-headers
 KERNEL_SRC_DIR ?= linux/kernel
 
 BOARD_SYSTEMIMAGE_PARTITION_SIZE := 2147483648
+PRODUCT_OUT ?= out/target/product/mofd_v1
 
 # Customization of BOOTCLASSPATH and init.environ.rc
-PRODUCT_BOOT_JARS := $(PRODUCT_BOOT_JARS):com.intel.multidisplay:com.intel.config:com.intel.cam.api
-ifeq ($(strip $(INTEL_FEATURE_AWARESERVICE)),true)
-PRODUCT_BOOT_JARS := $(PRODUCT_BOOT_JARS):com.intel.aware.awareservice
-endif
-ifeq ($(strip $(INTEL_FEATURE_LPAL)),true)
-PRODUCT_BOOT_JARS := $(PRODUCT_BOOT_JARS):com.intel.vtsv.service
-endif
-ifeq ($(strip $(INTEL_FEATURE_ASF)),true)
-PRODUCT_BOOT_JARS := $(PRODUCT_BOOT_JARS):com.intel.asf
-endif
-ifeq ($(strip $(INTEL_FEATURE_ARKHAM)),true)
-PRODUCT_BOOT_JARS := $(PRODUCT_BOOT_JARS):com.intel.arkham.services
-endif
-ifeq ($(strip $(DOLBY_DAP)),true)
-PRODUCT_BOOT_JARS := $(PRODUCT_BOOT_JARS):dolby_ds
-endif
 
 # Appends path to ARM libs for Houdini
 PRODUCT_LIBRARY_PATH := $(PRODUCT_LIBRARY_PATH):/system/lib/arm
@@ -121,12 +106,6 @@ $(call add-path-map, stlport:external/stlport/stlport \
 ifneq (user,$(findstring $(TARGET_BUILD_VARIANT),user))
 export DISPLAY_DRIVER_DEBUG_INTERFACE=true
 endif
-#Enable ODEX for userdebug and user builds
-ifneq (,$(findstring $(TARGET_BUILD_VARIANT),userdebug user))
-WITH_DEXPREOPT := true
-# enable dex-preopt on prebuilt apks
-WITH_DEXPREOPT_PREBUILT := true
-endif
 
 # Enabling logs into file system for eng and user debug builds
 ifeq ($(PRODUCT_MANUFACTURER),intel)
@@ -334,6 +313,7 @@ endif
 # stitch kernel. We overide the default script to
 # adapt to out own IAFW format.
 ifeq ($(TARGET_PARTITIONING_SCHEME),"osip-gpt")
+BOARD_CUSTOM_MKBOOTIMG := $(SUPPORT_PATH)/mkbootimg
 MKBOOTIMG := $(SUPPORT_PATH)/mkbootimg
 endif
 
diff --git a/MmgrClients.mk b/MmgrClients.mk
index 5600bf6..e33b09e 100644
--- a/MmgrClients.mk
+++ b/MmgrClients.mk
@@ -6,7 +6,7 @@
 # NVM Server
 # Modem Image Updater
 # Modem files
-PRODUCT_PACKAGES += \
+#PRODUCT_PACKAGES += \
     librapid-ril-core \
     librapid-ril-util \
     libmamgr-xmm \
@@ -19,14 +19,14 @@ PRODUCT_PACKAGES += \
     modem
 
 #OemTelephony for OEM HOOK API
-PRODUCT_PACKAGES += \
+#PRODUCT_PACKAGES += \
     com.intel.internal.telephony.OemTelephony \
     com.intel.internal.telephony.OemTelephony.xml
 
 # AMTL : Android Modem Traces and Logs
 # TelephonyEventsNotifier
 ifneq (, $(findstring "$(TARGET_BUILD_VARIANT)", "eng" "userdebug"))
-PRODUCT_PACKAGES += \
+#PRODUCT_PACKAGES += \
     Amtl \
     libamtl_jni \
     TelephonyEventsNotifier
diff --git a/bluetooth/AndroidBtCommon.mk b/bluetooth/AndroidBtCommon.mk
index 07d792c..75b1da4 100644
--- a/bluetooth/AndroidBtCommon.mk
+++ b/bluetooth/AndroidBtCommon.mk
@@ -47,8 +47,8 @@ include $(BUILD_PREBUILT)
 
 ##################################################
 
-ifeq ($(COMBO_CHIP_VENDOR),bcm)
-LIBBT_CONF_PATH := hardware/broadcom/libbt/conf/intel
-include $(LIBBT_CONF_PATH)/Android.mk
-endif
+#ifeq ($(COMBO_CHIP_VENDOR),bcm)
+#LIBBT_CONF_PATH := hardware/broadcom/libbt/conf/intel
+#include $(LIBBT_CONF_PATH)/Android.mk
+#endif
 
diff --git a/common.mk b/common.mk
index cf27265..b2824ed 100644
--- a/common.mk
+++ b/common.mk
@@ -88,7 +88,7 @@ PRODUCT_PACKAGES += libhoudini \
 endif
 
 #GMS package
--include vendor/google/PRIVATE/gms/products/gms.mk
+#-include vendor/google/PRIVATE/gms/products/gms.mk
 
 ifneq ($(strip $(TARGET_BUILD_VARIANT)),user)
 PRODUCT_COPY_FILES += \
diff --git a/external/generic_rules.mk b/external/generic_rules.mk
index 2f4da57..b061b6c 100644
--- a/external/generic_rules.mk
+++ b/external/generic_rules.mk
@@ -113,13 +113,6 @@ $(LOCAL_MODULE_PREBUILT_MAKEFILE): $(ACP) $(EXTERNAL_BUILD_SYSTEM)/generic_rules
 	@echo 'endif' >> $@
 endif
 
-# with odex, non optimized libraries are saved with a .dex suffix
-ifdef LOCAL_DEX_PREOPT
-EXT_JAVALIB_SUFFIX := .dex
-else
-EXT_JAVALIB_SUFFIX :=
-endif
-
 # this implement mapping between metatarget names, and what prebuilt is waiting for
 $(call external-gather-files,executable,EXECUTABLES)
 $(call external-gather-files,shared_library,LIBS)
diff --git a/fg_config/fg_conf_helper.c b/fg_config/fg_conf_helper.c
index 1600f50..320cd42 100644
--- a/fg_config/fg_conf_helper.c
+++ b/fg_config/fg_conf_helper.c
@@ -54,7 +54,7 @@ struct __attribute__((__packed__)) sec_file_body {
 	MAX_FG_TABLES * sizeof(struct table_body))
 
 
-#define LOG_TAG "EM FG User Space:"
+#define ALOG_TAG "EM FG User Space:"
 
 int read_primary_header(struct primary_header *pheader)
 {
@@ -85,7 +85,7 @@ int read_primary_file(unsigned char *buf, int size)
 
 	ret = read(fd, buf, size);
 	if (ret != size) {
-		LOGI("requested bytes:%d read bytes:%d\n", size, ret);
+		ALOGI("requested bytes:%d read bytes:%d\n", size, ret);
 		close(fd);
 		return ENODATA;
 	}
@@ -154,7 +154,7 @@ int get_battery_ps_name(char *ps_battery_path)
 				return 0;
 				}
 
-			LOGI("Power Supply type=%.8s name=%s\n", buf, ps_name);
+			ALOGI("Power Supply type=%.8s name=%s\n", buf, ps_name);
 		}
 	}
 	closedir(dir);
@@ -169,13 +169,13 @@ int get_battid(char *battid)
 	char battid_path[PATH_MAX];
 	ret =  get_battery_ps_name(ps_batt_name);
 	if (ret) {
-		LOGE("Error(%d) in get_battery_ps_name:%s\n", ret, strerror(ret));
+		ALOGE("Error(%d) in get_battery_ps_name:%s\n", ret, strerror(ret));
 		return ret;
 	}
 
 	snprintf(battid_path, sizeof(battid_path), "%s/%s/model_name", POWER_SUPPLY_PATH, ps_batt_name);
 
-	LOGI("Reading battid from %s\n", battid_path);
+	ALOGI("Reading battid from %s\n", battid_path);
 
 	fd = open(battid_path, O_RDONLY);
 
@@ -199,13 +199,13 @@ int get_serial_num(char *serial_num)
 	char serial_num_path[PATH_MAX];
 	ret =  get_battery_ps_name(ps_batt_name);
 	if (ret) {
-		LOGE("Error(%d) in get_battery_ps_name:%s\n", ret, strerror(ret));
+		ALOGE("Error(%d) in get_battery_ps_name:%s\n", ret, strerror(ret));
 		return ret;
 	}
 
 	snprintf(serial_num_path, sizeof(serial_num_path), "%s/%s/serial_number", POWER_SUPPLY_PATH, ps_batt_name);
 
-	LOGI("Reading serial number from %s\n", serial_num_path);
+	ALOGI("Reading serial number from %s\n", serial_num_path);
 
 	fd = open(serial_num_path, O_RDONLY);
 
@@ -231,7 +231,7 @@ bool is_prim_cksum_ok(unsigned char *buf, int size)
 	pheader->cksum = 0x00;
 
 	if (checksum(buf, size) != pcksum) {
-		LOGE("Primary checksum failed:%x:%x\n",
+		ALOGE("Primary checksum failed:%x:%x\n",
 				checksum(buf, size), pcksum);
 		pheader->cksum = pcksum;
 		return FALSE;
@@ -244,7 +244,7 @@ bool is_prim_cksum_ok(unsigned char *buf, int size)
 bool is_sec_cksum_ok(struct sec_file_body *sbuf, int len)
 {
 	if (checksum(sbuf, len - 2) != sbuf->tbl.cksum) {
-		LOGE("Secondary checksum failed:%x:%x\n", checksum(sbuf, len - 2), sbuf->tbl.cksum);
+		ALOGE("Secondary checksum failed:%x:%x\n", checksum(sbuf, len - 2), sbuf->tbl.cksum);
 		return FALSE;
 	} else
 		return TRUE;
@@ -285,7 +285,7 @@ int get_primary_fg_config(unsigned char *pbuf,
 
 	ret = get_battery_ps_name(ps_batt_name);
 	if (ret) {
-		LOGE("Error(%d) in get_battery_ps_name:%s\n", ret, strerror(ret));
+		ALOGE("Error(%d) in get_battery_ps_name:%s\n", ret, strerror(ret));
 		return ret;
 	}
 
@@ -294,20 +294,20 @@ int get_primary_fg_config(unsigned char *pbuf,
 	ptr  = (unsigned char *)pbuf;
 	ptr += size;
 
-	LOGI("pheader->file_size =%d\n", pheader->file_size);
+	ALOGI("pheader->file_size =%d\n", pheader->file_size);
 
 	while (size < pheader->file_size) {
 
 		temp_tbl = (struct table_body *)ptr;
-		LOGI("Table[%d].name:%.8s FG.name=%s\n", i, temp_tbl->table_name, ps_batt_name);
-		LOGI("Table[%d].Battid:%.8s FG.Battid:%.8s\n",
+		ALOGI("Table[%d].name:%.8s FG.name=%s\n", i, temp_tbl->table_name, ps_batt_name);
+		ALOGI("Table[%d].Battid:%.8s FG.Battid:%.8s\n",
 				i, temp_tbl->battid, battid);
 		/* FIXME: Read Table name from power_supply sysfs */
 		if (!strncmp(temp_tbl->table_name, ps_batt_name,
 					MAX_TABLE_NAME_SIZE)) {
 			if (!strncmp(temp_tbl->battid, battid,
 						MODEL_NAME_SIZE)) {
-				LOGI("Matching table_name and battid:%.8s:%.8s\n", temp_tbl->table_name, temp_tbl->battid);
+				ALOGI("Matching table_name and battid:%.8s:%.8s\n", temp_tbl->table_name, temp_tbl->battid);
 				memcpy(tbl, temp_tbl, sizeof(*tbl));
 				return 0;
 			}
@@ -330,12 +330,12 @@ static int isCOS()
 
 	fd = open("/proc/cmdline", O_RDONLY);
 	if (fd < 0) {
-		LOGI("%s:Unable to read commandline\n", __func__);
+		ALOGI("%s:Unable to read commandline\n", __func__);
 	} else {
 		size = read(fd, cmdline_buf, MAX_COMMAND_LINE_BUF);
 		cmdline_buf[MAX_COMMAND_LINE_BUF - 1] = '\0';
 		if ( size <= 0) {
-			LOGI("%s:error to read commandline\n", __func__);
+			ALOGI("%s:error to read commandline\n", __func__);
 		} else {
 			ptr = strstr(cmdline_buf, "androidboot.mode=");
 			if (ptr != NULL) {
@@ -366,54 +366,54 @@ int get_fg_config_table(struct table_body *sec_tbl)
 	/* get battid */
 	ret = get_battid(battid);
 	if (ret) {
-		LOGE("Error(%d) in get_battid:%s\n", ret, strerror(ret));
+		ALOGE("Error(%d) in get_battid:%s\n", ret, strerror(ret));
 		return ret;
 	}
 
 	/* get serial number */
 	ret = get_serial_num(serial_num);
 	if (ret) {
-		LOGE("Error(%d) in get_serial_num:%s\n", ret, strerror(ret));
+		ALOGE("Error(%d) in get_serial_num:%s\n", ret, strerror(ret));
 		return ret;
 	}
 
 	/* read primary header */
 	ret = read_primary_header(&pheader);
 	if (ret) {
-		LOGE("Error(%d) in read_primary_header:%s\n", ret, strerror(ret));
+		ALOGE("Error(%d) in read_primary_header:%s\n", ret, strerror(ret));
 		return ret;
 	}
 
 	pbuf = malloc(pheader.file_size);
 
 	if (pbuf == NULL) {
-		LOGE("%s:%d:insufficient memory\n", __func__, __LINE__);
+		ALOGE("%s:%d:insufficient memory\n", __func__, __LINE__);
 		return ENOMEM;
 	}
 
 	/*read primary file including header */
 	ret = read_primary_file(pbuf, pheader.file_size);
 	if (ret) {
-		LOGE("Error(%d) in read_primary:%s\n", ret, strerror(ret));
+		ALOGE("Error(%d) in read_primary:%s\n", ret, strerror(ret));
 		free(pbuf);
 		return ret;
 	}
 
-	LOGI("pheader.size=%d\n", pheader.file_size);
+	ALOGI("pheader.size=%d\n", pheader.file_size);
 
 	is_pcksum_ok = is_prim_cksum_ok(pbuf, pheader.file_size);
 
 	/* read secondary */
 	ret = read_secondary_file(&sbuf);
 	if (ret) {
-		LOGE("Error(%d) in read_secondary_file:%s\n", ret, strerror(ret));
+		ALOGE("Error(%d) in read_secondary_file:%s\n", ret, strerror(ret));
 		goto read_pri_config;
 	} else
 		is_scksum_ok = is_sec_cksum_ok(&sbuf, sizeof(sbuf.tbl));
 
 	/* If primary checksum mismatch return error */
 	if (!(is_pcksum_ok) && !(is_scksum_ok)) {
-		LOGE("primary and secondary checksum failed.\n");
+		ALOGE("primary and secondary checksum failed.\n");
 		free(pbuf);
 		return EINVAL;
 	}
@@ -421,18 +421,18 @@ int get_fg_config_table(struct table_body *sec_tbl)
 	/* Read primary config if secondary battid doesn't match or
 	secondary checksum is not ok or primary file has a new config */
 	if (!is_scksum_ok)
-		LOGE("Secondary checksum failed\n");
+		ALOGE("Secondary checksum failed\n");
 	else if (strncmp(sbuf.tbl.battid, battid, MODEL_NAME_SIZE))
-		LOGE("Secondary Battid doesn't match %s:%s\n", sbuf.tbl.battid, battid);
+		ALOGE("Secondary Battid doesn't match %s:%s\n", sbuf.tbl.battid, battid);
 	else if ((strlen(sbuf.serial_num) !=
 		strnlen(serial_num, MAX_SERIAL_NUM_SIZE+1))
 		|| (strncmp(sbuf.serial_num, serial_num,
 		strnlen(serial_num, MAX_SERIAL_NUM_SIZE+1))))
-		LOGE("Secondary serial number doesn't match %s:%s\n", sbuf.serial_num, serial_num);
+		ALOGE("Secondary serial number doesn't match %s:%s\n", sbuf.serial_num, serial_num);
 	else if (pheader.cksum != sbuf.pcksum)
-		LOGE("Secondary.primary_checksum mismatch. New primary file detected\n");
+		ALOGE("Secondary.primary_checksum mismatch. New primary file detected\n");
 	else {
-		LOGI("Using FG data from %s\n", SECONDARY_FILE);
+		ALOGI("Using FG data from %s\n", SECONDARY_FILE);
 		memcpy(sec_tbl, &sbuf.tbl, sizeof(*sec_tbl));
 		free(pbuf);
 		return 0;
@@ -444,16 +444,16 @@ read_pri_config:
 		return -EINVAL;
 	}
 
-	LOGI("Using FG data from %s\n", PRIMARY_FILE);
+	ALOGI("Using FG data from %s\n", PRIMARY_FILE);
 	ret = get_primary_fg_config(pbuf, &sbuf.tbl, battid);
 	if (ret) {
-		LOGE("Error(%d) in get_primary_fg_config:%s\n", ret, strerror(ret));
+		ALOGE("Error(%d) in get_primary_fg_config:%s\n", ret, strerror(ret));
 		free(pbuf);
 		return ret;
 	}
 	/* WA to  set fg_config.config_init = 1 in COS */
 	inCOS = isCOS();
-	LOGI("inCOS=%d\n", inCOS);
+	ALOGI("inCOS=%d\n", inCOS);
 	if(inCOS)
 		sbuf.tbl.config_init = 1;
 	/* copy the secondary table */
@@ -470,7 +470,7 @@ int write_sec_config(struct sec_file_body *sbuf)
 	/* open secondary file in write mode */
 	fds = open(SECONDARY_FILE, O_WRONLY|O_CREAT, S_IRWXU|S_IRWXG|S_IRWXO);
 	if (fds < 0) {
-		LOGE("Error(%d) in opening %s:%s\n", errno, SECONDARY_FILE, strerror(errno));
+		ALOGE("Error(%d) in opening %s:%s\n", errno, SECONDARY_FILE, strerror(errno));
 		return errno;
 	}
 
@@ -479,7 +479,7 @@ int write_sec_config(struct sec_file_body *sbuf)
 	can be read from primary, instead of reading from secondary.*/
 	ret = read_primary_header(&pheader);
 	if (ret) {
-		LOGE("Error(%d) in read_primary_header:%s\n", ret, strerror(ret));
+		ALOGE("Error(%d) in read_primary_header:%s\n", ret, strerror(ret));
 		close(fds);
 		return ENODATA;
 	}
@@ -497,7 +497,7 @@ int write_sec_config(struct sec_file_body *sbuf)
 	 */
 	 ret = get_serial_num(serial_num);
 	 if (ret) {
-		LOGE("Error(%d) in get_serial_num%s\n", ret, strerror(ret));
+		ALOGE("Error(%d) in get_serial_num%s\n", ret, strerror(ret));
 		close(fds);
 		return ENODATA;
 	}
@@ -508,12 +508,12 @@ int write_sec_config(struct sec_file_body *sbuf)
 	/* write secondary file */
 	ret = write(fds, sbuf, sizeof(*sbuf));
 	if (ret != sizeof(*sbuf)) {
-		LOGE("Error in writing secondary file\n");
+		ALOGE("Error in writing secondary file\n");
 		close(fds);
 		return ENODATA;
 	}
 	close(fds);
-	LOGI("Wrote %d bytes to %s Size of table=%d\n", ret, SECONDARY_FILE, sizeof(sbuf->tbl));
+	ALOGI("Wrote %d bytes to %s Size of table=%d\n", ret, SECONDARY_FILE, sizeof(sbuf->tbl));
 	return 0;
 }
 
@@ -540,7 +540,7 @@ int  read_fg_write_sec()
 	/*open device file */
 	fdd = open(DEV_FILE, O_RDONLY);
 	if (fdd < 0) {
-		LOGE("Error(%d) in opening %s:%s\n", errno, DEV_FILE, strerror(errno));
+		ALOGE("Error(%d) in opening %s:%s\n", errno, DEV_FILE, strerror(errno));
 		return errno;
 	}
 
@@ -549,7 +549,7 @@ int  read_fg_write_sec()
 	if (ret != (sizeof(sbuf.tbl) - sizeof(sbuf.tbl.cksum))) {
 		close(fdd);
 
-		LOGE("Error(%d) in reading %s:%s requested=%d read=%d\n", errno, DEV_FILE, strerror(errno),
+		ALOGE("Error(%d) in reading %s:%s requested=%d read=%d\n", errno, DEV_FILE, strerror(errno),
 				(int)(sizeof(sbuf.tbl) - sizeof(sbuf.tbl.cksum)), ret);
 		if (ret < 0)
 			return errno;
@@ -559,7 +559,7 @@ int  read_fg_write_sec()
 
 	ret = write_sec_config(&sbuf);
 	if (ret) {
-		LOGE("Error(%d) in saving secondary:%s\n", ret, strerror(ret));
+		ALOGE("Error(%d) in saving secondary:%s\n", ret, strerror(ret));
 	}
 
 	close(fdd);
@@ -599,33 +599,33 @@ int dump_config(struct table_body *config)
 	int char_table_size;
 
 
-	LOGI("table_type:0x%x\n", (unsigned int)config->table_type);
-	LOGI("size:0x%x\n", config->size);
-	LOGI("revision:0x%x\n", (int)config->rev);
-	LOGI("table_name:%.8s\n", config->table_name);
-	LOGI("battid:%.8s\n", config->battid);
-	LOGI("reserved:0x%x\n", (unsigned int)config->config_init);
+	ALOGI("table_type:0x%x\n", (unsigned int)config->table_type);
+	ALOGI("size:0x%x\n", config->size);
+	ALOGI("revision:0x%x\n", (int)config->rev);
+	ALOGI("table_name:%.8s\n", config->table_name);
+	ALOGI("battid:%.8s\n", config->battid);
+	ALOGI("reserved:0x%x\n", (unsigned int)config->config_init);
 
 	while (cfg_name[i] != NULL)
-		LOGI("%s:0x%x\n", cfg_name[i++], *data_ptr++);
+		ALOGI("%s:0x%x\n", cfg_name[i++], *data_ptr++);
 
 	data_ptr--;
 
 	char_table_size = MAX_FG_CONFIG_SIZE / sizeof(unsigned short);
 
 	for (i = (i - 1); i < char_table_size; ++i)
-		LOGI("cell_char_tbl[%d]:0x%x\n", i, *data_ptr++);
+		ALOGI("cell_char_tbl[%d]:0x%x\n", i, *data_ptr++);
 
-	LOGI("checksum:0x%x\n", config->cksum);
+	ALOGI("checksum:0x%x\n", config->cksum);
 	return 0;
 }
 void dump_primary_header(struct primary_header pheader)
 {
-	LOGI("Primary Header\n===================\n");
-	LOGI("revision=0x%x\n", (unsigned short) pheader.rev);
-	LOGI("file_size=0x%x\n", (unsigned short) pheader.file_size);
-	LOGI("checksum=0x%x\n", (unsigned short) pheader.cksum);
-	LOGI("reserved=0x%x\n", (unsigned short) pheader.res);
+	ALOGI("Primary Header\n===================\n");
+	ALOGI("revision=0x%x\n", (unsigned short) pheader.rev);
+	ALOGI("file_size=0x%x\n", (unsigned short) pheader.file_size);
+	ALOGI("checksum=0x%x\n", (unsigned short) pheader.cksum);
+	ALOGI("reserved=0x%x\n", (unsigned short) pheader.res);
 
 }
 
@@ -644,7 +644,7 @@ int dump_fg_config(char sel)
 		/* read primary header */
 		ret = read_primary_header(&pheader);
 		if (ret) {
-			LOGE("Error(%d) in read_primary_header:%s\n", ret, strerror(ret));
+			ALOGE("Error(%d) in read_primary_header:%s\n", ret, strerror(ret));
 			return ret;
 		}
 
@@ -653,7 +653,7 @@ int dump_fg_config(char sel)
 		pbuf = malloc(pheader.file_size);
 
 		if (pbuf == NULL) {
-			LOGE("%s:%d:Error: Insufficient memory\n",
+			ALOGE("%s:%d:Error: Insufficient memory\n",
 					__func__, __LINE__);
 			return ENOMEM;
 		}
@@ -661,17 +661,17 @@ int dump_fg_config(char sel)
 		/*read primary file including header */
 		ret = read_primary_file(pbuf, pheader.file_size);
 		if (ret) {
-			LOGE("Error(%d) in read_primary:%s\n", ret, strerror(ret));
+			ALOGE("Error(%d) in read_primary:%s\n", ret, strerror(ret));
 			free(pbuf);
 			return ret;
 		}
 
 		offset += sizeof(pheader);
 		while (offset < pheader.file_size) {
-			LOGI("Table:%d\n=========================\n", i++);
+			ALOGI("Table:%d\n=========================\n", i++);
 			ret = dump_config((struct table_body *)(pbuf + offset));
 			if (ret) {
-				LOGE("Error(%d) in dump_config:%s\n", ret, strerror(ret));
+				ALOGE("Error(%d) in dump_config:%s\n", ret, strerror(ret));
 				free(pbuf);
 				return ret;
 			}
@@ -686,12 +686,12 @@ int dump_fg_config(char sel)
 	else if (sel == '\0')
 		ret = get_fg_config_table(&sbuf.tbl);
 	else {
-		LOGE("Invalid argument with -d\n");
+		ALOGE("Invalid argument with -d\n");
 		return EINVAL;
 	}
 
 	if (ret) {
-		LOGE("Error(%d) in reading config:%s\n", ret, strerror(ret));
+		ALOGE("Error(%d) in reading config:%s\n", ret, strerror(ret));
 		return ret;
 	}
 	return dump_config(&sbuf.tbl);
@@ -699,12 +699,12 @@ int dump_fg_config(char sel)
 
 void print_help(void)
 {
-	LOGI("\nfg_conf [-w/-r/-d/-ds/-dp]\n");
-	LOGI("-w - Read config and write to fg interface\n");
-	LOGI("-r - Read config from fg and save in secondary\n");
-	LOGI("-d - Dump the matching table from secondary/primary\n");
-	LOGI("-ds - Dump secondaty file\n");
-	LOGI("-dp -  Dump primary file\n");
+	ALOGI("\nfg_conf [-w/-r/-d/-ds/-dp]\n");
+	ALOGI("-w - Read config and write to fg interface\n");
+	ALOGI("-r - Read config from fg and save in secondary\n");
+	ALOGI("-d - Dump the matching table from secondary/primary\n");
+	ALOGI("-ds - Dump secondaty file\n");
+	ALOGI("-dp -  Dump primary file\n");
 
 }
 
@@ -712,7 +712,7 @@ int main(int argc, char *argv[])
 {
 	int ret = 0;
 	if (argc != 2) {
-		LOGE("Invalid argument list\n");
+		ALOGE("Invalid argument list\n");
 		return -EINVAL;
 	}
 
@@ -720,42 +720,42 @@ int main(int argc, char *argv[])
 		switch (argv[1][1]) {
 
 		case 'w':
-			LOGI("Invoked with -w\n");
+			ALOGI("Invoked with -w\n");
 			ret = write_fgdev_config();
 			if (ret) {
-				LOGE("Error(%d) in write_fgdev_config\n", ret);
+				ALOGE("Error(%d) in write_fgdev_config\n", ret);
 				return ret;
 			}
-			LOGI("Restored FG data successfully\n");
+			ALOGI("Restored FG data successfully\n");
 
 			break;
 		case 'r':
-			LOGI("Invoked with -r\n");
+			ALOGI("Invoked with -r\n");
 			ret = read_fg_write_sec();
 			if (ret) {
-				LOGE("Error(%d) in read_fg_write_sec\n", ret);
+				ALOGE("Error(%d) in read_fg_write_sec\n", ret);
 				return ret;
 			}
-			LOGI("Saved FG data successfully in %s\n", SECONDARY_FILE);
+			ALOGI("Saved FG data successfully in %s\n", SECONDARY_FILE);
 			break;
 		case 'd':
-			LOGI("Invoked with -d\n");
+			ALOGI("Invoked with -d\n");
 			ret =  dump_fg_config(argv[1][2]);
 			if (ret) {
-				LOGE("Error(%d) in dumping FG Config:%s\n", ret, strerror(ret));
+				ALOGE("Error(%d) in dumping FG Config:%s\n", ret, strerror(ret));
 				return ret;
 			}
 			break;
 		case 'h':
-			LOGI("Invoked with -h\n");
+			ALOGI("Invoked with -h\n");
 			print_help();
 			break;
 		default:
-			LOGE("Invoked with invalid argument\n");
+			ALOGE("Invoked with invalid argument\n");
 			return EINVAL;
 		}
 	} else  {
-		LOGE("Invoked with invalid argument\n");
+		ALOGE("Invoked with invalid argument\n");
 		return EINVAL;
 
 	}
diff --git a/gps/Android.mk b/gps/Android.mk
index a526066..e69de29 100644
--- a/gps/Android.mk
+++ b/gps/Android.mk
@@ -1,24 +0,0 @@
-LOCAL_PATH := $(call my-dir)
-PLATFORM_PATH := ../../$(TARGET_BOARD_PLATFORM)
-
-include $(LOCAL_PATH)/ChipVendor.mk
-
-ifeq (,$(filter none,$(GPS_CHIP_VENDOR) $(GPS_CHIP)))
-
-##################################################
-
-include $(LOCAL_PATH)/$(GPS_CHIP_VENDOR)/Android.mk
-
-##################################################
-
-include $(CLEAR_VARS)
-LOCAL_MODULE := gps_common
-LOCAL_MODULE_TAGS := optional
-LOCAL_REQUIRED_MODULES :=  \
-    gps.$(TARGET_DEVICE) \
-    init.gps.rc
-include $(BUILD_PHONY_PACKAGE)
-
-##################################################
-
-endif
diff --git a/kernel-headers/asm/elf.h b/kernel-headers/asm/elf.h
deleted file mode 100644
index 2d1edfd..0000000
--- a/kernel-headers/asm/elf.h
+++ /dev/null
@@ -1,50 +0,0 @@
-/****************************************************************************
- ****************************************************************************
- ***
- ***   This header was automatically generated from a Linux kernel header
- ***   of the same name, to make information necessary for userspace to
- ***   call into the kernel available to libc.  It contains only constants,
- ***   structures, and macros generated from the original header, and thus,
- ***   contains no copyrightable information.
- ***
- ***   To edit the content of this header, modify the corresponding
- ***   source file (e.g. under external/kernel-headers/original/) then
- ***   run bionic/libc/kernel/tools/update_all.py
- ***
- ***   Any manual change here will be lost the next time this script will
- ***   be run. You've been warned!
- ***
- ****************************************************************************
- ****************************************************************************/
-#ifndef _ASM_X86_ELF_H
-#define _ASM_X86_ELF_H
-#include <asm/ptrace.h>
-#include <asm/user.h>
-/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
-#include <asm/auxvec.h>
-typedef unsigned long elf_greg_t;
-#define ELF_NGREG (sizeof (struct user_regs_struct) / sizeof(elf_greg_t))
-typedef elf_greg_t elf_gregset_t[ELF_NGREG];
-/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
-typedef struct user_i387_struct elf_fpregset_t;
-typedef struct user_fxsr_struct elf_fpxregset_t;
-#define R_386_NONE 0
-#define R_386_32 1
-/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
-#define R_386_PC32 2
-#define R_386_GOT32 3
-#define R_386_PLT32 4
-#define R_386_COPY 5
-/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
-#define R_386_GLOB_DAT 6
-#define R_386_JMP_SLOT 7
-#define R_386_RELATIVE 8
-#define R_386_GOTOFF 9
-/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
-#define R_386_GOTPC 10
-#define R_386_NUM 11
-#define ELF_CLASS ELFCLASS32
-#define ELF_DATA ELFDATA2LSB
-/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
-#define ELF_ARCH EM_386
-#endif
diff --git a/kernel-headers/asm/page_types.h b/kernel-headers/asm/page_types.h
new file mode 100644
index 0000000..54c9787
--- /dev/null
+++ b/kernel-headers/asm/page_types.h
@@ -0,0 +1,63 @@
+#ifndef _ASM_X86_PAGE_DEFS_H
+#define _ASM_X86_PAGE_DEFS_H
+
+#include <linux/const.h>
+#include <linux/types.h>
+
+/* PAGE_SHIFT determines the page size */
+#define PAGE_SHIFT	12
+#define PAGE_SIZE	(_AC(1,UL) << PAGE_SHIFT)
+#define PAGE_MASK	(~(PAGE_SIZE-1))
+
+#define __PHYSICAL_MASK		((phys_addr_t)((1ULL << __PHYSICAL_MASK_SHIFT) - 1))
+#define __VIRTUAL_MASK		((1UL << __VIRTUAL_MASK_SHIFT) - 1)
+
+/* Cast PAGE_MASK to a signed type so that it is sign-extended if
+   virtual addresses are 32-bits but physical addresses are larger
+   (ie, 32-bit PAE). */
+#define PHYSICAL_PAGE_MASK	(((signed long)PAGE_MASK) & __PHYSICAL_MASK)
+
+#define PMD_PAGE_SIZE		(_AC(1, UL) << PMD_SHIFT)
+#define PMD_PAGE_MASK		(~(PMD_PAGE_SIZE-1))
+
+#define HPAGE_SHIFT		PMD_SHIFT
+#define HPAGE_SIZE		(_AC(1,UL) << HPAGE_SHIFT)
+#define HPAGE_MASK		(~(HPAGE_SIZE - 1))
+#define HUGETLB_PAGE_ORDER	(HPAGE_SHIFT - PAGE_SHIFT)
+
+#define HUGE_MAX_HSTATE 2
+
+#define PAGE_OFFSET		((unsigned long)__PAGE_OFFSET)
+
+#define VM_DATA_DEFAULT_FLAGS \
+	(((current->personality & READ_IMPLIES_EXEC) ? VM_EXEC : 0 ) | \
+	 VM_READ | VM_WRITE | VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC)
+
+#ifdef CONFIG_X86_64
+#include <asm/page_64_types.h>
+#else
+#include <asm/page_32_types.h>
+#endif	/* CONFIG_X86_64 */
+
+#ifndef __ASSEMBLY__
+
+extern int devmem_is_allowed(unsigned long pagenr);
+
+extern unsigned long max_low_pfn_mapped;
+extern unsigned long max_pfn_mapped;
+
+static inline phys_addr_t get_max_mapped(void)
+{
+	return (phys_addr_t)max_pfn_mapped << PAGE_SHIFT;
+}
+
+bool pfn_range_is_mapped(unsigned long start_pfn, unsigned long end_pfn);
+
+extern unsigned long init_memory_mapping(unsigned long start,
+					 unsigned long end);
+
+extern void initmem_init(void);
+
+#endif	/* !__ASSEMBLY__ */
+
+#endif	/* _ASM_X86_PAGE_DEFS_H */
diff --git a/kernel-headers/linux/elf.h b/kernel-headers/linux/elf.h
deleted file mode 100644
index 86dbfbd..0000000
--- a/kernel-headers/linux/elf.h
+++ /dev/null
@@ -1,394 +0,0 @@
-/****************************************************************************
- ****************************************************************************
- ***
- ***   This header was automatically generated from a Linux kernel header
- ***   of the same name, to make information necessary for userspace to
- ***   call into the kernel available to libc.  It contains only constants,
- ***   structures, and macros generated from the original header, and thus,
- ***   contains no copyrightable information.
- ***
- ***   To edit the content of this header, modify the corresponding
- ***   source file (e.g. under external/kernel-headers/original/) then
- ***   run bionic/libc/kernel/tools/update_all.py
- ***
- ***   Any manual change here will be lost the next time this script will
- ***   be run. You've been warned!
- ***
- ****************************************************************************
- ****************************************************************************/
-#ifndef _LINUX_ELF_H
-#define _LINUX_ELF_H
-#include <linux/types.h>
-#include <linux/auxvec.h>
-/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
-#include <linux/elf-em.h>
-#include <asm/elf.h>
-#ifndef elf_read_implies_exec
-#define elf_read_implies_exec(ex, have_pt_gnu_stack) 0
-/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
-#endif
-typedef __u32 Elf32_Addr;
-typedef __u16 Elf32_Half;
-typedef __u32 Elf32_Off;
-/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
-typedef __s32 Elf32_Sword;
-typedef __u32 Elf32_Word;
-typedef __u64 Elf64_Addr;
-typedef __u16 Elf64_Half;
-/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
-typedef __s16 Elf64_SHalf;
-typedef __u64 Elf64_Off;
-typedef __s32 Elf64_Sword;
-typedef __u32 Elf64_Word;
-/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
-typedef __u64 Elf64_Xword;
-typedef __s64 Elf64_Sxword;
-#define PT_NULL 0
-#define PT_LOAD 1
-/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
-#define PT_DYNAMIC 2
-#define PT_INTERP 3
-#define PT_NOTE 4
-#define PT_SHLIB 5
-/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
-#define PT_PHDR 6
-#define PT_TLS 7
-#define PT_LOOS 0x60000000
-#define PT_HIOS 0x6fffffff
-/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
-#define PT_LOPROC 0x70000000
-#define PT_HIPROC 0x7fffffff
-#define PT_GNU_EH_FRAME 0x6474e550
-#define PT_GNU_STACK (PT_LOOS + 0x474e551)
-/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
-#define ET_NONE 0
-#define ET_REL 1
-#define ET_EXEC 2
-#define ET_DYN 3
-/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
-#define ET_CORE 4
-#define ET_LOPROC 0xff00
-#define ET_HIPROC 0xffff
-#define DT_NULL 0
-/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
-#define DT_NEEDED 1
-#define DT_PLTRELSZ 2
-#define DT_PLTGOT 3
-#define DT_HASH 4
-/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
-#define DT_STRTAB 5
-#define DT_SYMTAB 6
-#define DT_RELA 7
-#define DT_RELASZ 8
-/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
-#define DT_RELAENT 9
-#define DT_STRSZ 10
-#define DT_SYMENT 11
-#define DT_INIT 12
-/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
-#define DT_FINI 13
-#define DT_SONAME 14
-#define DT_RPATH 15
-#define DT_SYMBOLIC 16
-/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
-#define DT_REL 17
-#define DT_RELSZ 18
-#define DT_RELENT 19
-#define DT_PLTREL 20
-/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
-#define DT_DEBUG 21
-#define DT_TEXTREL 22
-#define DT_JMPREL 23
-#define DT_LOPROC 0x70000000
-/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
-#define DT_HIPROC 0x7fffffff
-#define STB_LOCAL 0
-#define STB_GLOBAL 1
-#define STB_WEAK 2
-/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
-#define STT_NOTYPE 0
-#define STT_OBJECT 1
-#define STT_FUNC 2
-#define STT_SECTION 3
-/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
-#define STT_FILE 4
-#define STT_COMMON 5
-#define STT_TLS 6
-#define ELF_ST_BIND(x) ((x) >> 4)
-/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
-#define ELF_ST_TYPE(x) (((unsigned int) x) & 0xf)
-#define ELF32_ST_BIND(x) ELF_ST_BIND(x)
-#define ELF32_ST_TYPE(x) ELF_ST_TYPE(x)
-#define ELF64_ST_BIND(x) ELF_ST_BIND(x)
-/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
-#define ELF64_ST_TYPE(x) ELF_ST_TYPE(x)
-typedef struct dynamic{
- Elf32_Sword d_tag;
- union{
-/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
- Elf32_Sword d_val;
- Elf32_Addr d_ptr;
- } d_un;
-} Elf32_Dyn;
-/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
-typedef struct {
- Elf64_Sxword d_tag;
- union {
- Elf64_Xword d_val;
-/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
- Elf64_Addr d_ptr;
- } d_un;
-} Elf64_Dyn;
-#define ELF32_R_SYM(x) ((x) >> 8)
-/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
-#define ELF32_R_TYPE(x) ((x) & 0xff)
-#define ELF64_R_SYM(i) ((i) >> 32)
-#define ELF64_R_TYPE(i) ((i) & 0xffffffff)
-typedef struct elf32_rel {
-/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
- Elf32_Addr r_offset;
- Elf32_Word r_info;
-} Elf32_Rel;
-typedef struct elf64_rel {
-/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
- Elf64_Addr r_offset;
- Elf64_Xword r_info;
-} Elf64_Rel;
-typedef struct elf32_rela{
-/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
- Elf32_Addr r_offset;
- Elf32_Word r_info;
- Elf32_Sword r_addend;
-} Elf32_Rela;
-/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
-typedef struct elf64_rela {
- Elf64_Addr r_offset;
- Elf64_Xword r_info;
- Elf64_Sxword r_addend;
-/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
-} Elf64_Rela;
-typedef struct elf32_sym{
- Elf32_Word st_name;
- Elf32_Addr st_value;
-/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
- Elf32_Word st_size;
- unsigned char st_info;
- unsigned char st_other;
- Elf32_Half st_shndx;
-/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
-} Elf32_Sym;
-typedef struct elf64_sym {
- Elf64_Word st_name;
- unsigned char st_info;
-/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
- unsigned char st_other;
- Elf64_Half st_shndx;
- Elf64_Addr st_value;
- Elf64_Xword st_size;
-/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
-} Elf64_Sym;
-#define EI_NIDENT 16
-typedef struct elf32_hdr{
- unsigned char e_ident[EI_NIDENT];
-/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
- Elf32_Half e_type;
- Elf32_Half e_machine;
- Elf32_Word e_version;
- Elf32_Addr e_entry;
-/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
- Elf32_Off e_phoff;
- Elf32_Off e_shoff;
- Elf32_Word e_flags;
- Elf32_Half e_ehsize;
-/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
- Elf32_Half e_phentsize;
- Elf32_Half e_phnum;
- Elf32_Half e_shentsize;
- Elf32_Half e_shnum;
-/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
- Elf32_Half e_shstrndx;
-} Elf32_Ehdr;
-typedef struct elf64_hdr {
- unsigned char e_ident[16];
-/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
- Elf64_Half e_type;
- Elf64_Half e_machine;
- Elf64_Word e_version;
- Elf64_Addr e_entry;
-/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
- Elf64_Off e_phoff;
- Elf64_Off e_shoff;
- Elf64_Word e_flags;
- Elf64_Half e_ehsize;
-/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
- Elf64_Half e_phentsize;
- Elf64_Half e_phnum;
- Elf64_Half e_shentsize;
- Elf64_Half e_shnum;
-/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
- Elf64_Half e_shstrndx;
-} Elf64_Ehdr;
-#define PF_R 0x4
-#define PF_W 0x2
-/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
-#define PF_X 0x1
-typedef struct elf32_phdr{
- Elf32_Word p_type;
- Elf32_Off p_offset;
-/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
- Elf32_Addr p_vaddr;
- Elf32_Addr p_paddr;
- Elf32_Word p_filesz;
- Elf32_Word p_memsz;
-/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
- Elf32_Word p_flags;
- Elf32_Word p_align;
-} Elf32_Phdr;
-typedef struct elf64_phdr {
-/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
- Elf64_Word p_type;
- Elf64_Word p_flags;
- Elf64_Off p_offset;
- Elf64_Addr p_vaddr;
-/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
- Elf64_Addr p_paddr;
- Elf64_Xword p_filesz;
- Elf64_Xword p_memsz;
- Elf64_Xword p_align;
-/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
-} Elf64_Phdr;
-#define SHT_NULL 0
-#define SHT_PROGBITS 1
-#define SHT_SYMTAB 2
-/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
-#define SHT_STRTAB 3
-#define SHT_RELA 4
-#define SHT_HASH 5
-#define SHT_DYNAMIC 6
-/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
-#define SHT_NOTE 7
-#define SHT_NOBITS 8
-#define SHT_REL 9
-#define SHT_SHLIB 10
-/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
-#define SHT_DYNSYM 11
-#define SHT_NUM 12
-#define SHT_LOPROC 0x70000000
-#define SHT_HIPROC 0x7fffffff
-/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
-#define SHT_LOUSER 0x80000000
-#define SHT_HIUSER 0xffffffff
-#define SHF_WRITE 0x1
-#define SHF_ALLOC 0x2
-/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
-#define SHF_EXECINSTR 0x4
-#define SHF_MASKPROC 0xf0000000
-#define SHN_UNDEF 0
-#define SHN_LORESERVE 0xff00
-/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
-#define SHN_LOPROC 0xff00
-#define SHN_HIPROC 0xff1f
-#define SHN_ABS 0xfff1
-#define SHN_COMMON 0xfff2
-/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
-#define SHN_HIRESERVE 0xffff
-typedef struct {
- Elf32_Word sh_name;
- Elf32_Word sh_type;
-/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
- Elf32_Word sh_flags;
- Elf32_Addr sh_addr;
- Elf32_Off sh_offset;
- Elf32_Word sh_size;
-/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
- Elf32_Word sh_link;
- Elf32_Word sh_info;
- Elf32_Word sh_addralign;
- Elf32_Word sh_entsize;
-/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
-} Elf32_Shdr;
-typedef struct elf64_shdr {
- Elf64_Word sh_name;
- Elf64_Word sh_type;
-/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
- Elf64_Xword sh_flags;
- Elf64_Addr sh_addr;
- Elf64_Off sh_offset;
- Elf64_Xword sh_size;
-/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
- Elf64_Word sh_link;
- Elf64_Word sh_info;
- Elf64_Xword sh_addralign;
- Elf64_Xword sh_entsize;
-/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
-} Elf64_Shdr;
-#define EI_MAG0 0
-#define EI_MAG1 1
-#define EI_MAG2 2
-/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
-#define EI_MAG3 3
-#define EI_CLASS 4
-#define EI_DATA 5
-#define EI_VERSION 6
-/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
-#define EI_OSABI 7
-#define EI_PAD 8
-#define ELFMAG0 0x7f
-#define ELFMAG1 'E'
-/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
-#define ELFMAG2 'L'
-#define ELFMAG3 'F'
-#define ELFMAG "\177ELF"
-#define SELFMAG 4
-/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
-#define ELFCLASSNONE 0
-#define ELFCLASS32 1
-#define ELFCLASS64 2
-#define ELFCLASSNUM 3
-/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
-#define ELFDATANONE 0
-#define ELFDATA2LSB 1
-#define ELFDATA2MSB 2
-#define EV_NONE 0
-/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
-#define EV_CURRENT 1
-#define EV_NUM 2
-#define ELFOSABI_NONE 0
-#define ELFOSABI_LINUX 3
-/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
-#ifndef ELF_OSABI
-#define ELF_OSABI ELFOSABI_NONE
-#endif
-#define NT_PRSTATUS 1
-/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
-#define NT_PRFPREG 2
-#define NT_PRPSINFO 3
-#define NT_TASKSTRUCT 4
-#define NT_AUXV 6
-/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
-#define NT_PRXFPREG 0x46e62b7f
-typedef struct elf32_note {
- Elf32_Word n_namesz;
- Elf32_Word n_descsz;
-/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
- Elf32_Word n_type;
-} Elf32_Nhdr;
-typedef struct elf64_note {
- Elf64_Word n_namesz;
-/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
- Elf64_Word n_descsz;
- Elf64_Word n_type;
-} Elf64_Nhdr;
-#if ELF_CLASS == ELFCLASS32
-/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
-#define elfhdr elf32_hdr
-#define elf_phdr elf32_phdr
-#define elf_note elf32_note
-#else
-/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
-#define elfhdr elf64_hdr
-#define elf_phdr elf64_phdr
-#define elf_note elf64_note
-#endif
-/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
-#endif
diff --git a/kernel-headers/linux/ext3_fs.h b/kernel-headers/linux/ext3_fs.h
new file mode 100644
index 0000000..8016fd1
--- /dev/null
+++ b/kernel-headers/linux/ext3_fs.h
@@ -0,0 +1,448 @@
+/****************************************************************************
+ ****************************************************************************
+ ***
+ ***   This header was automatically generated from a Linux kernel header
+ ***   of the same name, to make information necessary for userspace to
+ ***   call into the kernel available to libc.  It contains only constants,
+ ***   structures, and macros generated from the original header, and thus,
+ ***   contains no copyrightable information.
+ ***
+ ****************************************************************************
+ ****************************************************************************/
+#ifndef _LINUX_EXT3_FS_H
+#define _LINUX_EXT3_FS_H
+
+#include <linux/types.h>
+
+#undef EXT3FS_DEBUG
+
+#define EXT3_DEFAULT_RESERVE_BLOCKS 8
+
+#define EXT3_MAX_RESERVE_BLOCKS 1027
+#define EXT3_RESERVE_WINDOW_NOT_ALLOCATED 0
+
+#define CONFIG_EXT3_INDEX
+
+#ifdef EXT3FS_DEBUG
+#define ext3_debug(f, a...)   do {   printk (KERN_DEBUG "EXT3-fs DEBUG (%s, %d): %s:",   __FILE__, __LINE__, __FUNCTION__);   printk (KERN_DEBUG f, ## a);   } while (0)
+#else
+#define ext3_debug(f, a...) do {} while (0)
+#endif
+
+#define EXT3_BAD_INO 1  
+#define EXT3_ROOT_INO 2  
+#define EXT3_BOOT_LOADER_INO 5  
+#define EXT3_UNDEL_DIR_INO 6  
+#define EXT3_RESIZE_INO 7  
+#define EXT3_JOURNAL_INO 8  
+
+#define EXT3_GOOD_OLD_FIRST_INO 11
+
+#define EXT3_SUPER_MAGIC 0xEF53
+
+#define EXT3_LINK_MAX 32000
+
+#define EXT3_MIN_BLOCK_SIZE 1024
+#define EXT3_MAX_BLOCK_SIZE 4096
+#define EXT3_MIN_BLOCK_LOG_SIZE 10
+#define EXT3_BLOCK_SIZE(s) (EXT3_MIN_BLOCK_SIZE << (s)->s_log_block_size)
+#define EXT3_ADDR_PER_BLOCK(s) (EXT3_BLOCK_SIZE(s) / sizeof (__u32))
+#define EXT3_BLOCK_SIZE_BITS(s) ((s)->s_log_block_size + 10)
+#define EXT3_INODE_SIZE(s) (((s)->s_rev_level == EXT3_GOOD_OLD_REV) ?   EXT3_GOOD_OLD_INODE_SIZE :   (s)->s_inode_size)
+#define EXT3_FIRST_INO(s) (((s)->s_rev_level == EXT3_GOOD_OLD_REV) ?   EXT3_GOOD_OLD_FIRST_INO :   (s)->s_first_ino)
+
+#define EXT3_MIN_FRAG_SIZE 1024
+#define EXT3_MAX_FRAG_SIZE 4096
+#define EXT3_MIN_FRAG_LOG_SIZE 10
+#define EXT3_FRAG_SIZE(s) (EXT3_MIN_FRAG_SIZE << (s)->s_log_frag_size)
+#define EXT3_FRAGS_PER_BLOCK(s) (EXT3_BLOCK_SIZE(s) / EXT3_FRAG_SIZE(s))
+
+struct ext3_group_desc
+{
+ __le32 bg_block_bitmap;
+ __le32 bg_inode_bitmap;
+ __le32 bg_inode_table;
+ __le16 bg_free_blocks_count;
+ __le16 bg_free_inodes_count;
+ __le16 bg_used_dirs_count;
+ __u16 bg_pad;
+ __le32 bg_reserved[3];
+};
+
+#define EXT3_BLOCKS_PER_GROUP(s) ((s)->s_blocks_per_group)
+#define EXT3_DESC_PER_BLOCK(s) (EXT3_BLOCK_SIZE(s) / sizeof (struct ext3_group_desc))
+#define EXT3_INODES_PER_GROUP(s) ((s)->s_inodes_per_group)
+
+#define EXT3_NDIR_BLOCKS 12
+#define EXT3_IND_BLOCK EXT3_NDIR_BLOCKS
+#define EXT3_DIND_BLOCK (EXT3_IND_BLOCK + 1)
+#define EXT3_TIND_BLOCK (EXT3_DIND_BLOCK + 1)
+#define EXT3_N_BLOCKS (EXT3_TIND_BLOCK + 1)
+
+#define EXT3_SECRM_FL 0x00000001  
+#define EXT3_UNRM_FL 0x00000002  
+#define EXT3_COMPR_FL 0x00000004  
+#define EXT3_SYNC_FL 0x00000008  
+#define EXT3_IMMUTABLE_FL 0x00000010  
+#define EXT3_APPEND_FL 0x00000020  
+#define EXT3_NODUMP_FL 0x00000040  
+#define EXT3_NOATIME_FL 0x00000080  
+
+#define EXT3_DIRTY_FL 0x00000100
+#define EXT3_COMPRBLK_FL 0x00000200  
+#define EXT3_NOCOMPR_FL 0x00000400  
+#define EXT3_ECOMPR_FL 0x00000800  
+
+#define EXT3_INDEX_FL 0x00001000  
+#define EXT3_IMAGIC_FL 0x00002000  
+#define EXT3_JOURNAL_DATA_FL 0x00004000  
+#define EXT3_NOTAIL_FL 0x00008000  
+#define EXT3_DIRSYNC_FL 0x00010000  
+#define EXT3_TOPDIR_FL 0x00020000  
+#define EXT3_RESERVED_FL 0x80000000  
+
+#define EXT3_FL_USER_VISIBLE 0x0003DFFF  
+#define EXT3_FL_USER_MODIFIABLE 0x000380FF  
+
+#define EXT3_STATE_JDATA 0x00000001  
+#define EXT3_STATE_NEW 0x00000002  
+#define EXT3_STATE_XATTR 0x00000004  
+
+struct ext3_new_group_input {
+ __u32 group;
+ __u32 block_bitmap;
+ __u32 inode_bitmap;
+ __u32 inode_table;
+ __u32 blocks_count;
+ __u16 reserved_blocks;
+ __u16 unused;
+};
+
+struct ext3_new_group_data {
+ __u32 group;
+ __u32 block_bitmap;
+ __u32 inode_bitmap;
+ __u32 inode_table;
+ __u32 blocks_count;
+ __u16 reserved_blocks;
+ __u16 unused;
+ __u32 free_blocks_count;
+};
+
+#define EXT3_IOC_GETFLAGS _IOR('f', 1, long)
+#define EXT3_IOC_SETFLAGS _IOW('f', 2, long)
+#define EXT3_IOC_GETVERSION _IOR('f', 3, long)
+#define EXT3_IOC_SETVERSION _IOW('f', 4, long)
+#define EXT3_IOC_GROUP_EXTEND _IOW('f', 7, unsigned long)
+#define EXT3_IOC_GROUP_ADD _IOW('f', 8,struct ext3_new_group_input)
+#define EXT3_IOC_GETVERSION_OLD _IOR('v', 1, long)
+#define EXT3_IOC_SETVERSION_OLD _IOW('v', 2, long)
+#define EXT3_IOC_GETRSVSZ _IOR('f', 5, long)
+#define EXT3_IOC_SETRSVSZ _IOW('f', 6, long)
+
+struct ext3_mount_options {
+ unsigned long s_mount_opt;
+ uid_t s_resuid;
+ gid_t s_resgid;
+ unsigned long s_commit_interval;
+};
+
+struct ext3_inode {
+ __le16 i_mode;
+ __le16 i_uid;
+ __le32 i_size;
+ __le32 i_atime;
+ __le32 i_ctime;
+ __le32 i_mtime;
+ __le32 i_dtime;
+ __le16 i_gid;
+ __le16 i_links_count;
+ __le32 i_blocks;
+ __le32 i_flags;
+ union {
+ struct {
+ __u32 l_i_reserved1;
+ } linux1;
+ struct {
+ __u32 h_i_translator;
+ } hurd1;
+ struct {
+ __u32 m_i_reserved1;
+ } masix1;
+ } osd1;
+ __le32 i_block[EXT3_N_BLOCKS];
+ __le32 i_generation;
+ __le32 i_file_acl;
+ __le32 i_dir_acl;
+ __le32 i_faddr;
+ union {
+ struct {
+ __u8 l_i_frag;
+ __u8 l_i_fsize;
+ __u16 i_pad1;
+ __le16 l_i_uid_high;
+ __le16 l_i_gid_high;
+ __u32 l_i_reserved2;
+ } linux2;
+ struct {
+ __u8 h_i_frag;
+ __u8 h_i_fsize;
+ __u16 h_i_mode_high;
+ __u16 h_i_uid_high;
+ __u16 h_i_gid_high;
+ __u32 h_i_author;
+ } hurd2;
+ struct {
+ __u8 m_i_frag;
+ __u8 m_i_fsize;
+ __u16 m_pad1;
+ __u32 m_i_reserved2[2];
+ } masix2;
+ } osd2;
+ __le16 i_extra_isize;
+ __le16 i_pad1;
+};
+
+#define i_size_high i_dir_acl
+
+#ifdef __linux__
+#define i_reserved1 osd1.linux1.l_i_reserved1
+#define i_frag osd2.linux2.l_i_frag
+#define i_fsize osd2.linux2.l_i_fsize
+#define i_uid_low i_uid
+#define i_gid_low i_gid
+#define i_uid_high osd2.linux2.l_i_uid_high
+#define i_gid_high osd2.linux2.l_i_gid_high
+#define i_reserved2 osd2.linux2.l_i_reserved2
+
+#elif defined(__GNU__)
+
+#define i_translator osd1.hurd1.h_i_translator
+#define i_frag osd2.hurd2.h_i_frag;
+#define i_fsize osd2.hurd2.h_i_fsize;
+#define i_uid_high osd2.hurd2.h_i_uid_high
+#define i_gid_high osd2.hurd2.h_i_gid_high
+#define i_author osd2.hurd2.h_i_author
+
+#elif defined(__masix__)
+
+#define i_reserved1 osd1.masix1.m_i_reserved1
+#define i_frag osd2.masix2.m_i_frag
+#define i_fsize osd2.masix2.m_i_fsize
+#define i_reserved2 osd2.masix2.m_i_reserved2
+
+#endif
+
+#define EXT3_VALID_FS 0x0001  
+#define EXT3_ERROR_FS 0x0002  
+#define EXT3_ORPHAN_FS 0x0004  
+
+#define EXT3_MOUNT_CHECK 0x00001  
+#define EXT3_MOUNT_OLDALLOC 0x00002  
+#define EXT3_MOUNT_GRPID 0x00004  
+#define EXT3_MOUNT_DEBUG 0x00008  
+#define EXT3_MOUNT_ERRORS_CONT 0x00010  
+#define EXT3_MOUNT_ERRORS_RO 0x00020  
+#define EXT3_MOUNT_ERRORS_PANIC 0x00040  
+#define EXT3_MOUNT_MINIX_DF 0x00080  
+#define EXT3_MOUNT_NOLOAD 0x00100  
+#define EXT3_MOUNT_ABORT 0x00200  
+#define EXT3_MOUNT_DATA_FLAGS 0x00C00  
+#define EXT3_MOUNT_JOURNAL_DATA 0x00400  
+#define EXT3_MOUNT_ORDERED_DATA 0x00800  
+#define EXT3_MOUNT_WRITEBACK_DATA 0x00C00  
+#define EXT3_MOUNT_UPDATE_JOURNAL 0x01000  
+#define EXT3_MOUNT_NO_UID32 0x02000  
+#define EXT3_MOUNT_XATTR_USER 0x04000  
+#define EXT3_MOUNT_POSIX_ACL 0x08000  
+#define EXT3_MOUNT_RESERVATION 0x10000  
+#define EXT3_MOUNT_BARRIER 0x20000  
+#define EXT3_MOUNT_NOBH 0x40000  
+#define EXT3_MOUNT_QUOTA 0x80000  
+#define EXT3_MOUNT_USRQUOTA 0x100000  
+#define EXT3_MOUNT_GRPQUOTA 0x200000  
+
+#ifndef _LINUX_EXT2_FS_H
+#define clear_opt(o, opt) o &= ~EXT3_MOUNT_##opt
+#define set_opt(o, opt) o |= EXT3_MOUNT_##opt
+#define test_opt(sb, opt) (EXT3_SB(sb)->s_mount_opt &   EXT3_MOUNT_##opt)
+#else
+#define EXT2_MOUNT_NOLOAD EXT3_MOUNT_NOLOAD
+#define EXT2_MOUNT_ABORT EXT3_MOUNT_ABORT
+#define EXT2_MOUNT_DATA_FLAGS EXT3_MOUNT_DATA_FLAGS
+#endif
+
+#define ext3_set_bit ext2_set_bit
+#define ext3_set_bit_atomic ext2_set_bit_atomic
+#define ext3_clear_bit ext2_clear_bit
+#define ext3_clear_bit_atomic ext2_clear_bit_atomic
+#define ext3_test_bit ext2_test_bit
+#define ext3_find_first_zero_bit ext2_find_first_zero_bit
+#define ext3_find_next_zero_bit ext2_find_next_zero_bit
+
+#define EXT3_DFL_MAX_MNT_COUNT 20  
+#define EXT3_DFL_CHECKINTERVAL 0  
+
+#define EXT3_ERRORS_CONTINUE 1  
+#define EXT3_ERRORS_RO 2  
+#define EXT3_ERRORS_PANIC 3  
+#define EXT3_ERRORS_DEFAULT EXT3_ERRORS_CONTINUE
+
+struct ext3_super_block {
+  __le32 s_inodes_count;
+ __le32 s_blocks_count;
+ __le32 s_r_blocks_count;
+ __le32 s_free_blocks_count;
+  __le32 s_free_inodes_count;
+ __le32 s_first_data_block;
+ __le32 s_log_block_size;
+ __le32 s_log_frag_size;
+  __le32 s_blocks_per_group;
+ __le32 s_frags_per_group;
+ __le32 s_inodes_per_group;
+ __le32 s_mtime;
+  __le32 s_wtime;
+ __le16 s_mnt_count;
+ __le16 s_max_mnt_count;
+ __le16 s_magic;
+ __le16 s_state;
+ __le16 s_errors;
+ __le16 s_minor_rev_level;
+  __le32 s_lastcheck;
+ __le32 s_checkinterval;
+ __le32 s_creator_os;
+ __le32 s_rev_level;
+  __le16 s_def_resuid;
+ __le16 s_def_resgid;
+
+ __le32 s_first_ino;
+ __le16 s_inode_size;
+ __le16 s_block_group_nr;
+ __le32 s_feature_compat;
+  __le32 s_feature_incompat;
+ __le32 s_feature_ro_compat;
+  __u8 s_uuid[16];
+  char s_volume_name[16];
+  char s_last_mounted[64];
+  __le32 s_algorithm_usage_bitmap;
+
+ __u8 s_prealloc_blocks;
+ __u8 s_prealloc_dir_blocks;
+ __u16 s_reserved_gdt_blocks;
+
+  __u8 s_journal_uuid[16];
+  __le32 s_journal_inum;
+ __le32 s_journal_dev;
+ __le32 s_last_orphan;
+ __le32 s_hash_seed[4];
+ __u8 s_def_hash_version;
+ __u8 s_reserved_char_pad;
+ __u16 s_reserved_word_pad;
+ __le32 s_default_mount_opts;
+ __le32 s_first_meta_bg;
+ __u32 s_reserved[190];
+};
+
+#define EXT3_SB(sb) (sb)
+
+#define NEXT_ORPHAN(inode) EXT3_I(inode)->i_dtime
+
+#define EXT3_OS_LINUX 0
+#define EXT3_OS_HURD 1
+#define EXT3_OS_MASIX 2
+#define EXT3_OS_FREEBSD 3
+#define EXT3_OS_LITES 4
+
+#define EXT3_GOOD_OLD_REV 0  
+#define EXT3_DYNAMIC_REV 1  
+
+#define EXT3_CURRENT_REV EXT3_GOOD_OLD_REV
+#define EXT3_MAX_SUPP_REV EXT3_DYNAMIC_REV
+
+#define EXT3_GOOD_OLD_INODE_SIZE 128
+
+#define EXT3_HAS_COMPAT_FEATURE(sb,mask)   ( EXT3_SB(sb)->s_es->s_feature_compat & cpu_to_le32(mask) )
+#define EXT3_HAS_RO_COMPAT_FEATURE(sb,mask)   ( EXT3_SB(sb)->s_es->s_feature_ro_compat & cpu_to_le32(mask) )
+#define EXT3_HAS_INCOMPAT_FEATURE(sb,mask)   ( EXT3_SB(sb)->s_es->s_feature_incompat & cpu_to_le32(mask) )
+#define EXT3_SET_COMPAT_FEATURE(sb,mask)   EXT3_SB(sb)->s_es->s_feature_compat |= cpu_to_le32(mask)
+#define EXT3_SET_RO_COMPAT_FEATURE(sb,mask)   EXT3_SB(sb)->s_es->s_feature_ro_compat |= cpu_to_le32(mask)
+#define EXT3_SET_INCOMPAT_FEATURE(sb,mask)   EXT3_SB(sb)->s_es->s_feature_incompat |= cpu_to_le32(mask)
+#define EXT3_CLEAR_COMPAT_FEATURE(sb,mask)   EXT3_SB(sb)->s_es->s_feature_compat &= ~cpu_to_le32(mask)
+#define EXT3_CLEAR_RO_COMPAT_FEATURE(sb,mask)   EXT3_SB(sb)->s_es->s_feature_ro_compat &= ~cpu_to_le32(mask)
+#define EXT3_CLEAR_INCOMPAT_FEATURE(sb,mask)   EXT3_SB(sb)->s_es->s_feature_incompat &= ~cpu_to_le32(mask)
+
+#define EXT3_FEATURE_COMPAT_DIR_PREALLOC 0x0001
+#define EXT3_FEATURE_COMPAT_IMAGIC_INODES 0x0002
+#define EXT3_FEATURE_COMPAT_HAS_JOURNAL 0x0004
+#define EXT3_FEATURE_COMPAT_EXT_ATTR 0x0008
+#define EXT3_FEATURE_COMPAT_RESIZE_INODE 0x0010
+#define EXT3_FEATURE_COMPAT_DIR_INDEX 0x0020
+
+#define EXT3_FEATURE_RO_COMPAT_SPARSE_SUPER 0x0001
+#define EXT3_FEATURE_RO_COMPAT_LARGE_FILE 0x0002
+#define EXT3_FEATURE_RO_COMPAT_BTREE_DIR 0x0004
+
+#define EXT3_FEATURE_INCOMPAT_COMPRESSION 0x0001
+#define EXT3_FEATURE_INCOMPAT_FILETYPE 0x0002
+#define EXT3_FEATURE_INCOMPAT_RECOVER 0x0004  
+#define EXT3_FEATURE_INCOMPAT_JOURNAL_DEV 0x0008  
+#define EXT3_FEATURE_INCOMPAT_META_BG 0x0010
+
+#define EXT3_FEATURE_COMPAT_SUPP EXT2_FEATURE_COMPAT_EXT_ATTR
+#define EXT3_FEATURE_INCOMPAT_SUPP (EXT3_FEATURE_INCOMPAT_FILETYPE|   EXT3_FEATURE_INCOMPAT_RECOVER|   EXT3_FEATURE_INCOMPAT_META_BG)
+#define EXT3_FEATURE_RO_COMPAT_SUPP (EXT3_FEATURE_RO_COMPAT_SPARSE_SUPER|   EXT3_FEATURE_RO_COMPAT_LARGE_FILE|   EXT3_FEATURE_RO_COMPAT_BTREE_DIR)
+
+#define EXT3_DEF_RESUID 0
+#define EXT3_DEF_RESGID 0
+
+#define EXT3_DEFM_DEBUG 0x0001
+#define EXT3_DEFM_BSDGROUPS 0x0002
+#define EXT3_DEFM_XATTR_USER 0x0004
+#define EXT3_DEFM_ACL 0x0008
+#define EXT3_DEFM_UID16 0x0010
+#define EXT3_DEFM_JMODE 0x0060
+#define EXT3_DEFM_JMODE_DATA 0x0020
+#define EXT3_DEFM_JMODE_ORDERED 0x0040
+#define EXT3_DEFM_JMODE_WBACK 0x0060
+
+#define EXT3_NAME_LEN 255
+
+struct ext3_dir_entry {
+ __le32 inode;
+ __le16 rec_len;
+ __le16 name_len;
+ char name[EXT3_NAME_LEN];
+};
+
+struct ext3_dir_entry_2 {
+ __le32 inode;
+ __le16 rec_len;
+ __u8 name_len;
+ __u8 file_type;
+ char name[EXT3_NAME_LEN];
+};
+
+#define EXT3_FT_UNKNOWN 0
+#define EXT3_FT_REG_FILE 1
+#define EXT3_FT_DIR 2
+#define EXT3_FT_CHRDEV 3
+#define EXT3_FT_BLKDEV 4
+#define EXT3_FT_FIFO 5
+#define EXT3_FT_SOCK 6
+#define EXT3_FT_SYMLINK 7
+
+#define EXT3_FT_MAX 8
+
+#define EXT3_DIR_PAD 4
+#define EXT3_DIR_ROUND (EXT3_DIR_PAD - 1)
+#define EXT3_DIR_REC_LEN(name_len) (((name_len) + 8 + EXT3_DIR_ROUND) &   ~EXT3_DIR_ROUND)
+
+#define is_dx(dir) 0
+#define EXT3_DIR_LINK_MAX(dir) ((dir)->i_nlink >= EXT3_LINK_MAX)
+#define EXT3_DIR_LINK_EMPTY(dir) ((dir)->i_nlink == 2)
+
+#define DX_HASH_LEGACY 0
+#define DX_HASH_HALF_MD4 1
+#define DX_HASH_TEA 2
+
+#endif
diff --git a/test_suites.mk b/test_suites.mk
index 98875bb..deebfd5 100644
--- a/test_suites.mk
+++ b/test_suites.mk
@@ -1,74 +1 @@
 #Test and eng packages
-PRODUCT_PACKAGES_ENG += \
-    AsfCtc \
-    ASF_CTC \
-    DeviceHookTest \
-    Inotify_test \
-    libsv_test \
-    IntelFMStackTestApp \
-    DownloadTool \
-    FlsTool \
-    CC6_UMIP_ACCESS_APP \
-    CC6_SIGNED_IMAGE_VERIFY \
-    LIBSECURITY_API_STUB_SHARED \
-    LIBSECURITY_API_STUB_STATIC \
-    SEC_TOOLS \
-    hwc-overlay \
-    InfiniteThreadApp \
-    LinkedListService \
-    RecursiveFunctionApp \
-    mutex_stress \
-    RebootCounter \
-    AlarmApplication \
-    VideoApplication \
-    blit_test \
-    pvr_test \
-    Timer \
-    test_widi_audiocapturesrc \
-    test_extmode_security \
-    test_widi_fwupgrade_cli \
-    test_widi_fwupgrade \
-    test_auto_connect \
-    test_widi_p2p_cli \
-    test_widi_p2p \
-    test_widi_p2p_cc \
-    test_libwidip2p_cli \
-    test_widi_rtsp_cli \
-    test_widi_rtspsrc \
-    widirtspsink \
-    test_widi_streaming \
-    test_widi_ub_mode \
-    test_widi_videocapturesrc \
-    test_wifi_latency \
-    flashtool \
-    test_alek \
-    bist_test \
-    calibration \
-    imginfo \
-    TXEI_TEST \
-    TXEI_SEC_TOOLS \
-    iperf
-
-ifeq ($(BOARD_HAVE_MODEM), true)
-PRODUCT_PACKAGES_ENG += \
-    mts-test \
-    modem_test
-endif
-
-PRODUCT_PACKAGES_DEBUG += \
-    ssploop \
-    sspconf \
-    audience_write \
-    ct_monitor \
-    testsigmartspcmds \
-    camtest_Features \
-    kcmdline \
-    peeknpoke \
-    purgatory-i386 \
-    kexec-i386 \
-    phonemonitor \
-    crashlogd \
-    libdebug_anr \
-    parse_stack \
-    ad_drv_test \
-    gtester
diff --git a/wifi/WifiBoardConfig.mk b/wifi/WifiBoardConfig.mk
index 2840d8b..69839d3 100644
--- a/wifi/WifiBoardConfig.mk
+++ b/wifi/WifiBoardConfig.mk
@@ -9,32 +9,6 @@ BOARD_WLAN_DEVICE := wl12xx-compat
 endif
 
 ifeq (bcm,$(findstring bcm,$(COMBO_CHIP_VENDOR)))
-BOARD_WLAN_DEVICE := bcmdhd
-WPA_SUPPLICANT_VERSION := VER_0_8_X
-BOARD_WPA_SUPPLICANT_PRIVATE_LIB := lib_driver_cmd_bcmdhd
-BOARD_HOSTAPD_DRIVER        := NL80211
-BOARD_HOSTAPD_PRIVATE_LIB   += lib_driver_cmd_bcmdhd
-WIFI_DRIVER_FW_PATH_PARAM   := "/sys/module/bcmdhd/parameters/firmware_path"
-
-# These hardcoded path are also defined in
-# device/intel/common/wifi/bcm_specific/load_bcmdriver so make sure to change
-# at both places with one patch (libhardware_legacy makes use of these
-# defines).
-WIFI_DRIVER_43241_FW_PATH_STA     := "/system/etc/firmware/fw_bcmdhd_43241.bin"
-WIFI_DRIVER_43241_FW_PATH_P2P     := "/system/etc/firmware/fw_bcmdhd_43241.bin"
-WIFI_DRIVER_43241_FW_PATH_AP      := "/system/etc/firmware/fw_bcmdhd_43241_apsta.bin"
-
-WIFI_DRIVER_4334_FW_PATH_STA     := "/system/etc/firmware/fw_bcmdhd_4334.bin"
-WIFI_DRIVER_4334_FW_PATH_P2P     := "/system/etc/firmware/fw_bcmdhd_4334.bin"
-WIFI_DRIVER_4334_FW_PATH_AP      := "/system/etc/firmware/fw_bcmdhd_4334_apsta.bin"
-
-WIFI_DRIVER_4335_FW_PATH_STA     := "/system/etc/firmware/fw_bcmdhd_4335.bin"
-WIFI_DRIVER_4335_FW_PATH_P2P     := "/system/etc/firmware/fw_bcmdhd_4335.bin"
-WIFI_DRIVER_4335_FW_PATH_AP      := "/system/etc/firmware/fw_bcmdhd_4335_apsta.bin"
-
-# Enable workarounds to make JB MR2 compatible with Kernel 3.10.
-K310_MR2_COMPATIBILITY := true
-
 endif
 
 ifneq (,$(filter wifi_rtl%,$(PRODUCTS.$(INTERNAL_PRODUCT).PRODUCT_PACKAGES)))
-- 
1.7.4.1

