From 7cfee96fb4b31435c51051d8520c043cfb8a933b Mon Sep 17 00:00:00 2001
From: Mathieu Soulard <mathieu.soulard@intel.com>
Date: Fri, 22 Feb 2013 17:40:10 +0100
Subject: [PATCH 8/9] [REVERT ME][Audio] Introduces custom properties in policy

BZ: 217971

Orig-Bug: 76237

This patches is introduced to solve the music volume tuning issue
while in call (CSV or VOIP).

The solution implies to introduce a new tuning way using the file
audio_policy.conf which is updated to handle custom properties.

Change-Id: I9409105dce18f5f5eef55c1b9d5ba6c671d008b5
Signed-off-by: Mathieu Soulard <mathieu.soulard@intel.com>
---
 audio/AudioPolicyManagerBase.cpp                 | 143 ++++++++++++++++++++---
 include/hardware_legacy/AudioPolicyManagerBase.h |  27 +++--
 include/hardware_legacy/audio_policy_conf.h      |   1 +
 3 files changed, 145 insertions(+), 26 deletions(-)

diff --git a/audio/AudioPolicyManagerBase.cpp b/audio/AudioPolicyManagerBase.cpp
index da373b0..ac8f262 100644
--- a/audio/AudioPolicyManagerBase.cpp
+++ b/audio/AudioPolicyManagerBase.cpp
@@ -2417,7 +2417,7 @@ void AudioPolicyManagerBase::checkOutputForAllStrategies()
     checkOutputForStrategy(STRATEGY_DTMF);
 }
 
-audio_io_handle_t AudioPolicyManagerBase::getA2dpOutput()
+audio_io_handle_t AudioPolicyManagerBase::getA2dpOutput() const
 {
     if (!mHasA2dp) {
         return 0;
@@ -3257,16 +3257,12 @@ void AudioPolicyManagerBase::initializeVolumeCurves()
 
 float AudioPolicyManagerBase::computeVolume(int stream,
                                             int index,
-                                            audio_io_handle_t output,
                                             audio_devices_t device)
 {
-    float volume = 1.0;
-    AudioOutputDescriptor *outputDesc = mOutputs.valueFor(output);
-    StreamDescriptor &streamDesc = mStreams[stream];
+    LOG_ALWAYS_FATAL_IF(device == AUDIO_DEVICE_NONE);
 
-    if (device == AUDIO_DEVICE_NONE) {
-        device = outputDesc->device();
-    }
+    float volume = 1.0;
+    const StreamDescriptor &streamDesc = mStreams[stream];
 
     // if volume is not 0 (not muted), force media volume to max on digital output
     if (stream == AudioSystem::MUSIC &&
@@ -3303,10 +3299,7 @@ float AudioPolicyManagerBase::computeVolume(int stream,
         if (isStreamActive(AudioSystem::MUSIC, SONIFICATION_HEADSET_MUSIC_DELAY) ||
                 mLimitRingtoneVolume) {
             audio_devices_t musicDevice = getDeviceForStrategy(STRATEGY_MEDIA, true /*fromCache*/);
-            float musicVol = computeVolume(AudioSystem::MUSIC,
-                               mStreams[AudioSystem::MUSIC].getVolumeIndex(musicDevice),
-                               output,
-                               musicDevice);
+            float musicVol = getVolume(AudioSystem::MUSIC, musicDevice);
             float minVol = (musicVol > SONIFICATION_HEADSET_VOLUME_MIN) ?
                                 musicVol : SONIFICATION_HEADSET_VOLUME_MIN;
             if (volume > minVol) {
@@ -3319,6 +3312,12 @@ float AudioPolicyManagerBase::computeVolume(int stream,
     return volume;
 }
 
+// Returns the stream volume
+float AudioPolicyManagerBase::getVolume(int stream, audio_devices_t device)
+{
+    return computeVolume(stream, mStreams[stream].getVolumeIndex(device), device);
+}
+
 status_t AudioPolicyManagerBase::checkAndSetVolume(int stream,
                                                    int index,
                                                    audio_io_handle_t output,
@@ -3342,7 +3341,8 @@ status_t AudioPolicyManagerBase::checkAndSetVolume(int stream,
         return INVALID_OPERATION;
     }
 
-    float volume = computeVolume(stream, index, output, device);
+    audio_devices_t checkedDevice = (device == AUDIO_DEVICE_NONE) ? mOutputs.valueFor(output)->device() : device;
+    float volume = computeVolume(stream, index, checkedDevice);
     // We actually change the volume if:
     // - the float value returned by computeVolume() changed
     // - the force flag is set
@@ -3491,7 +3491,7 @@ void AudioPolicyManagerBase::handleIncallSonification(int stream, bool starting,
     }
 }
 
-bool AudioPolicyManagerBase::isInCall()
+bool AudioPolicyManagerBase::isInCall() const
 {
     return isStateInCall(mPhoneState);
 }
@@ -3707,7 +3707,7 @@ AudioPolicyManagerBase::StreamDescriptor::StreamDescriptor()
     mIndexCur.add(AUDIO_DEVICE_OUT_DEFAULT, 0);
 }
 
-int AudioPolicyManagerBase::StreamDescriptor::getVolumeIndex(audio_devices_t device)
+int AudioPolicyManagerBase::StreamDescriptor::getVolumeIndex(audio_devices_t device) const
 {
     device = AudioPolicyManagerBase::getDeviceForVolume(device);
     // there is always a valid entry for AUDIO_DEVICE_OUT_DEFAULT
@@ -4162,9 +4162,9 @@ void AudioPolicyManagerBase::loadOutChannels(char *name, IOProfile *profile)
     return;
 }
 
-status_t AudioPolicyManagerBase::loadInput(cnode *root, HwModule *module)
+status_t AudioPolicyManagerBase::loadInput(const cnode *root, HwModule *module)
 {
-    cnode *node = root->first_child;
+    const cnode *node = root->first_child;
 
     IOProfile *profile = new IOProfile(module);
 
@@ -4203,9 +4203,9 @@ status_t AudioPolicyManagerBase::loadInput(cnode *root, HwModule *module)
     }
 }
 
-status_t AudioPolicyManagerBase::loadOutput(cnode *root, HwModule *module)
+status_t AudioPolicyManagerBase::loadOutput(const cnode *root, HwModule *module)
 {
-    cnode *node = root->first_child;
+    const cnode *node = root->first_child;
 
     IOProfile *profile = new IOProfile(module);
 
@@ -4307,12 +4307,27 @@ void AudioPolicyManagerBase::loadHwModules(cnode *root)
     }
 }
 
+void AudioPolicyManagerBase::loadCustomProperties(const cnode *root)
+{
+    const cnode *node = root->first_child;
+
+    while (node) {
+        String8 aKey(node->name);
+        String8 aValue(node->value);
+        // Add the property in the custom properties map
+        mCustomPropertiesMap.add(aKey, aValue);
+
+        node = node->next;
+    }
+}
+
 void AudioPolicyManagerBase::loadGlobalConfig(cnode *root)
 {
     cnode *node = config_find(root, GLOBAL_CONFIG_TAG);
     if (node == NULL) {
         return;
     }
+
     node = node->first_child;
     while (node) {
         if (strcmp(ATTACHED_OUTPUT_DEVICES_TAG, node->name) == 0) {
@@ -4333,6 +4348,9 @@ void AudioPolicyManagerBase::loadGlobalConfig(cnode *root)
         } else if (strcmp(SPEAKER_DRC_ENABLED_TAG, node->name) == 0) {
             mSpeakerDrcEnabled = stringToBool((char *)node->value);
             ALOGV("loadGlobalConfig() mSpeakerDrcEnabled = %d", mSpeakerDrcEnabled);
+        } else if (strcmp(GLOBAL_CUSTOM_PROPERTIES, node->name) == 0) {
+            // Load custom properties section
+            loadCustomProperties(node);
         }
         node = node->next;
     }
@@ -4391,4 +4409,91 @@ void AudioPolicyManagerBase::defaultAudioPolicyConfig(void)
     mHwModules.add(module);
 }
 
+bool AudioPolicyManagerBase::getCustomPropertyAsString(const String8 &name, String8 &value) const
+{
+    if (mCustomPropertiesMap.indexOfKey(name) == NAME_NOT_FOUND) {
+        return false;
+    }
+    // Retrieve the value associated to the key
+    value = mCustomPropertiesMap.valueFor(name);
+    return true;
+}
+
+bool AudioPolicyManagerBase::getCustomPropertyAsLong(const String8 &name, long &value) const
+{
+    String8 strValue;
+
+    if (!getCustomPropertyAsString(name, strValue)) {
+        return false;
+    }
+
+    const char *valueAsChars = strValue.string();
+    char *endp;
+    long tmpValue = strtol(valueAsChars, &endp, 10);
+    if (*endp != '\0') {
+        ALOGW("Bad long value for custom property '%s': %s",name.string(),valueAsChars);
+        return false;
+    }
+
+    value = tmpValue;
+    return true;
+}
+
+bool AudioPolicyManagerBase::getCustomPropertyAsULong(const String8 &name, unsigned long &value) const
+{
+    String8 strValue;
+
+    if (!getCustomPropertyAsString(name, strValue)) {
+        return false;
+    }
+
+    const char *valueAsChars = strValue.string();
+    char *endp;
+    unsigned long tmpValue = strtoul(valueAsChars, &endp, 10);
+    if (*endp != '\0') {
+        ALOGW("Bad unsigned long value for custom property '%s': %s",name.string(),valueAsChars);
+        return false;
+    }
+
+    value = tmpValue;
+    return true;
+}
+
+bool AudioPolicyManagerBase::getCustomPropertyAsFloat(const String8 &name, float &value) const
+{
+    String8 strValue;
+
+    if (!getCustomPropertyAsString(name, strValue)) {
+        return false;
+    }
+
+    const char *valueAsChars = strValue.string();
+    char *endp;
+    float tmpValue = strtof(valueAsChars, &endp);
+    if (*endp != '\0') {
+        ALOGW("Bad float value for custom property '%s': %s",name.string(),valueAsChars);
+        return false;
+    }
+
+    value = tmpValue;
+    return true;
+}
+
+bool AudioPolicyManagerBase::getCustomPropertyAsBool(const String8 &name, bool &value) const
+{
+    String8 strValue;
+
+    if (!getCustomPropertyAsString(name, strValue)) {
+        return false;
+    }
+
+    if ((strValue != "true") && (strValue != "false")) {
+        ALOGW("Bad boolean value for custom property '%s': %s",name.string(),strValue.string());
+        return false;
+    }
+
+    value = (strValue == "true");
+    return true;
+}
+
 }; // namespace android
diff --git a/include/hardware_legacy/AudioPolicyManagerBase.h b/include/hardware_legacy/AudioPolicyManagerBase.h
index 5437335..9dab5bf 100644
--- a/include/hardware_legacy/AudioPolicyManagerBase.h
+++ b/include/hardware_legacy/AudioPolicyManagerBase.h
@@ -317,7 +317,7 @@ protected:
         public:
             StreamDescriptor();
 
-            int getVolumeIndex(audio_devices_t device);
+            int getVolumeIndex(audio_devices_t device) const;
             void dump(int fd);
 
             int mIndexMin;      // min volume index
@@ -382,7 +382,10 @@ protected:
 
         // compute the actual volume for a given stream according to the requested index and a particular
         // device
-        virtual float computeVolume(int stream, int index, audio_io_handle_t output, audio_devices_t device);
+        virtual float computeVolume(int stream, int index, audio_devices_t device);
+
+        // Returns the stream volume
+        float getVolume(int stream, audio_devices_t device);
 
         // check that volume change is permitted, compute and send new volume to audio hardware
         status_t checkAndSetVolume(int stream, int index, audio_io_handle_t output, audio_devices_t device, int delayMs = 0, bool force = false);
@@ -409,10 +412,10 @@ protected:
         void handleIncallSonification(int stream, bool starting, bool stateChange);
 
         // true if device is in a telephony or VoIP call
-        virtual bool isInCall();
+        virtual bool isInCall() const;
 
         // true if given state represents a device in a telephony or VoIP call
-        virtual bool isStateInCall(int state);
+        static bool isStateInCall(int state);
 
         // when a device is connected, checks if an open output can be routed
         // to this device. If none is open, tries to open one of the available outputs.
@@ -446,7 +449,7 @@ protected:
         void checkA2dpSuspend();
 
         // returns the A2DP output handle if it is open or 0 otherwise
-        audio_io_handle_t getA2dpOutput();
+        audio_io_handle_t getA2dpOutput() const;
 
         // selects the most appropriate device on output for current state
         // must be called every time a condition that affects the device choice for a given output is
@@ -520,13 +523,21 @@ protected:
         void loadFormats(char *name, IOProfile *profile);
         void loadOutChannels(char *name, IOProfile *profile);
         void loadInChannels(char *name, IOProfile *profile);
-        status_t loadOutput(cnode *root,  HwModule *module);
-        status_t loadInput(cnode *root,  HwModule *module);
+        status_t loadOutput(const cnode *root,  HwModule *module);
+        status_t loadInput(const cnode *root,  HwModule *module);
         void loadHwModule(cnode *root);
         void loadHwModules(cnode *root);
+        void loadCustomProperties(const cnode *root);
         void loadGlobalConfig(cnode *root);
         status_t loadAudioPolicyConfig(const char *path);
         void defaultAudioPolicyConfig(void);
+        // Custom properties accessors
+        // if the accessor fails, the value parameter is unchanged
+        bool getCustomPropertyAsString(const String8 &name, String8 &value) const;
+        bool getCustomPropertyAsLong(const String8 &name, long &value) const;
+        bool getCustomPropertyAsULong(const String8 &name, unsigned long &value) const;
+        bool getCustomPropertyAsFloat(const String8 &name, float &value) const;
+        bool getCustomPropertyAsBool(const String8 &name, bool &value) const;
 
         virtual status_t doParseParameters(AudioParameter &param);
 
@@ -602,6 +613,8 @@ private:
         // updates device caching and output for streams that can influence the
         //    routing of notifications
         void handleNotificationRoutingForStream(AudioSystem::stream_type stream);
+	// Custom properties map
+	DefaultKeyedVector<String8, String8> mCustomPropertiesMap;
 };
 
 };
diff --git a/include/hardware_legacy/audio_policy_conf.h b/include/hardware_legacy/audio_policy_conf.h
index 3ec2c94..409c4b6 100644
--- a/include/hardware_legacy/audio_policy_conf.h
+++ b/include/hardware_legacy/audio_policy_conf.h
@@ -30,6 +30,7 @@
 
 // global configuration
 #define GLOBAL_CONFIG_TAG "global_configuration"
+#define GLOBAL_CUSTOM_PROPERTIES "custom_properties"
 
 #define ATTACHED_OUTPUT_DEVICES_TAG "attached_output_devices"
 #define DEFAULT_OUTPUT_DEVICE_TAG "default_output_device"
-- 
1.9.2

