From 5f3e31d0d96ec2ed2e4db0eff218512ceb7f3aff Mon Sep 17 00:00:00 2001
From: Matt Gumbel <matthew.k.gumbel@intel.com>
Date: Fri, 11 Jan 2013 14:01:27 -0800
Subject: Added gnu-efi prebuilts

This was built from external/gnu-efi commit 7ee908b by running
external/gnu-efi/build-for-android-ia.sh and copying the results to
this directory.

Change-Id: I28ad432ad1727af7333df9003ea3f3580bb46806
Signed-off-by: Matt Gumbel <matthew.k.gumbel@intel.com>
---
 linux-x86/gnu-efi/include/efi/efi.h                |   50 +
 linux-x86/gnu-efi/include/efi/efi_nii.h            |   74 +
 linux-x86/gnu-efi/include/efi/efi_pxe.h            | 1743 ++++++++++++++++++++
 linux-x86/gnu-efi/include/efi/efiapi.h             |  890 ++++++++++
 linux-x86/gnu-efi/include/efi/eficon.h             |  302 ++++
 linux-x86/gnu-efi/include/efi/efidebug.h           |  110 ++
 linux-x86/gnu-efi/include/efi/efidef.h             |  196 +++
 linux-x86/gnu-efi/include/efi/efidevp.h            |  402 +++++
 linux-x86/gnu-efi/include/efi/efierr.h             |   60 +
 linux-x86/gnu-efi/include/efi/efifs.h              |  116 ++
 linux-x86/gnu-efi/include/efi/efigpt.h             |   68 +
 linux-x86/gnu-efi/include/efi/efilib.h             |  880 ++++++++++
 linux-x86/gnu-efi/include/efi/efilink.h            |  177 ++
 linux-x86/gnu-efi/include/efi/efinet.h             |  340 ++++
 linux-x86/gnu-efi/include/efi/efipart.h            |   61 +
 linux-x86/gnu-efi/include/efi/efipciio.h           |  219 +++
 linux-x86/gnu-efi/include/efi/efiprot.h            |  736 +++++++++
 linux-x86/gnu-efi/include/efi/efipxebc.h           |  463 ++++++
 linux-x86/gnu-efi/include/efi/efirtlib.h           |  141 ++
 linux-x86/gnu-efi/include/efi/efiser.h             |  132 ++
 linux-x86/gnu-efi/include/efi/efistdarg.h          |   33 +
 linux-x86/gnu-efi/include/efi/efiui.h              |   54 +
 linux-x86/gnu-efi/include/efi/ia32/efibind.h       |  282 ++++
 linux-x86/gnu-efi/include/efi/ia32/efilibplat.h    |   26 +
 linux-x86/gnu-efi/include/efi/ia32/pe.h            |  591 +++++++
 linux-x86/gnu-efi/include/efi/libsmbios.h          |  132 ++
 linux-x86/gnu-efi/include/efi/pci22.h              |  193 +++
 .../gnu-efi/include/efi/protocol/adapterdebug.h    |   32 +
 .../gnu-efi/include/efi/protocol/eficonsplit.h     |   32 +
 linux-x86/gnu-efi/include/efi/protocol/efidbg.h    |  210 +++
 linux-x86/gnu-efi/include/efi/protocol/efivar.h    |  133 ++
 linux-x86/gnu-efi/include/efi/protocol/intload.h   |   27 +
 .../gnu-efi/include/efi/protocol/legacyboot.h      |  119 ++
 linux-x86/gnu-efi/include/efi/protocol/piflash64.h |  121 ++
 linux-x86/gnu-efi/include/efi/protocol/vgaclass.h  |   95 ++
 linux-x86/gnu-efi/include/efi/romload.h            |   41 +
 linux-x86/gnu-efi/lib/crt0-efi-ia32.o              |  Bin 0 -> 868 bytes
 linux-x86/gnu-efi/lib/elf_ia32_efi.lds             |   75 +
 linux-x86/gnu-efi/lib/libefi.a                     |  Bin 0 -> 89186 bytes
 linux-x86/gnu-efi/lib/libgnuefi.a                  |  Bin 0 -> 1880 bytes
 linux-x86_64/gnu-efi/include/efi/efi.h             |   50 +
 linux-x86_64/gnu-efi/include/efi/efi_nii.h         |   74 +
 linux-x86_64/gnu-efi/include/efi/efi_pxe.h         | 1743 ++++++++++++++++++++
 linux-x86_64/gnu-efi/include/efi/efiapi.h          |  890 ++++++++++
 linux-x86_64/gnu-efi/include/efi/eficon.h          |  302 ++++
 linux-x86_64/gnu-efi/include/efi/efidebug.h        |  110 ++
 linux-x86_64/gnu-efi/include/efi/efidef.h          |  196 +++
 linux-x86_64/gnu-efi/include/efi/efidevp.h         |  402 +++++
 linux-x86_64/gnu-efi/include/efi/efierr.h          |   60 +
 linux-x86_64/gnu-efi/include/efi/efifs.h           |  116 ++
 linux-x86_64/gnu-efi/include/efi/efigpt.h          |   68 +
 linux-x86_64/gnu-efi/include/efi/efilib.h          |  880 ++++++++++
 linux-x86_64/gnu-efi/include/efi/efilink.h         |  177 ++
 linux-x86_64/gnu-efi/include/efi/efinet.h          |  340 ++++
 linux-x86_64/gnu-efi/include/efi/efipart.h         |   61 +
 linux-x86_64/gnu-efi/include/efi/efipciio.h        |  219 +++
 linux-x86_64/gnu-efi/include/efi/efiprot.h         |  736 +++++++++
 linux-x86_64/gnu-efi/include/efi/efipxebc.h        |  463 ++++++
 linux-x86_64/gnu-efi/include/efi/efirtlib.h        |  141 ++
 linux-x86_64/gnu-efi/include/efi/efiser.h          |  132 ++
 linux-x86_64/gnu-efi/include/efi/efistdarg.h       |   33 +
 linux-x86_64/gnu-efi/include/efi/efiui.h           |   54 +
 linux-x86_64/gnu-efi/include/efi/libsmbios.h       |  132 ++
 linux-x86_64/gnu-efi/include/efi/pci22.h           |  193 +++
 .../gnu-efi/include/efi/protocol/adapterdebug.h    |   32 +
 .../gnu-efi/include/efi/protocol/eficonsplit.h     |   32 +
 linux-x86_64/gnu-efi/include/efi/protocol/efidbg.h |  210 +++
 linux-x86_64/gnu-efi/include/efi/protocol/efivar.h |  133 ++
 .../gnu-efi/include/efi/protocol/intload.h         |   27 +
 .../gnu-efi/include/efi/protocol/legacyboot.h      |  119 ++
 .../gnu-efi/include/efi/protocol/piflash64.h       |  121 ++
 .../gnu-efi/include/efi/protocol/vgaclass.h        |   95 ++
 linux-x86_64/gnu-efi/include/efi/romload.h         |   41 +
 linux-x86_64/gnu-efi/include/efi/x86_64/efibind.h  |  285 ++++
 .../gnu-efi/include/efi/x86_64/efilibplat.h        |   26 +
 linux-x86_64/gnu-efi/include/efi/x86_64/pe.h       |  591 +++++++
 linux-x86_64/gnu-efi/lib/crt0-efi-x86_64.o         |  Bin 0 -> 1328 bytes
 linux-x86_64/gnu-efi/lib/elf_x86_64_efi.lds        |   63 +
 linux-x86_64/gnu-efi/lib/libefi.a                  |  Bin 0 -> 115022 bytes
 linux-x86_64/gnu-efi/lib/libgnuefi.a               |  Bin 0 -> 2472 bytes
 80 files changed, 18703 insertions(+), 0 deletions(-)
 create mode 100644 linux-x86/gnu-efi/include/efi/efi.h
 create mode 100644 linux-x86/gnu-efi/include/efi/efi_nii.h
 create mode 100644 linux-x86/gnu-efi/include/efi/efi_pxe.h
 create mode 100644 linux-x86/gnu-efi/include/efi/efiapi.h
 create mode 100644 linux-x86/gnu-efi/include/efi/eficon.h
 create mode 100644 linux-x86/gnu-efi/include/efi/efidebug.h
 create mode 100644 linux-x86/gnu-efi/include/efi/efidef.h
 create mode 100644 linux-x86/gnu-efi/include/efi/efidevp.h
 create mode 100644 linux-x86/gnu-efi/include/efi/efierr.h
 create mode 100644 linux-x86/gnu-efi/include/efi/efifs.h
 create mode 100644 linux-x86/gnu-efi/include/efi/efigpt.h
 create mode 100644 linux-x86/gnu-efi/include/efi/efilib.h
 create mode 100644 linux-x86/gnu-efi/include/efi/efilink.h
 create mode 100644 linux-x86/gnu-efi/include/efi/efinet.h
 create mode 100644 linux-x86/gnu-efi/include/efi/efipart.h
 create mode 100644 linux-x86/gnu-efi/include/efi/efipciio.h
 create mode 100644 linux-x86/gnu-efi/include/efi/efiprot.h
 create mode 100644 linux-x86/gnu-efi/include/efi/efipxebc.h
 create mode 100644 linux-x86/gnu-efi/include/efi/efirtlib.h
 create mode 100644 linux-x86/gnu-efi/include/efi/efiser.h
 create mode 100644 linux-x86/gnu-efi/include/efi/efistdarg.h
 create mode 100644 linux-x86/gnu-efi/include/efi/efiui.h
 create mode 100644 linux-x86/gnu-efi/include/efi/ia32/efibind.h
 create mode 100644 linux-x86/gnu-efi/include/efi/ia32/efilibplat.h
 create mode 100644 linux-x86/gnu-efi/include/efi/ia32/pe.h
 create mode 100644 linux-x86/gnu-efi/include/efi/libsmbios.h
 create mode 100644 linux-x86/gnu-efi/include/efi/pci22.h
 create mode 100644 linux-x86/gnu-efi/include/efi/protocol/adapterdebug.h
 create mode 100644 linux-x86/gnu-efi/include/efi/protocol/eficonsplit.h
 create mode 100644 linux-x86/gnu-efi/include/efi/protocol/efidbg.h
 create mode 100644 linux-x86/gnu-efi/include/efi/protocol/efivar.h
 create mode 100644 linux-x86/gnu-efi/include/efi/protocol/intload.h
 create mode 100644 linux-x86/gnu-efi/include/efi/protocol/legacyboot.h
 create mode 100644 linux-x86/gnu-efi/include/efi/protocol/piflash64.h
 create mode 100644 linux-x86/gnu-efi/include/efi/protocol/vgaclass.h
 create mode 100644 linux-x86/gnu-efi/include/efi/romload.h
 create mode 100644 linux-x86/gnu-efi/lib/crt0-efi-ia32.o
 create mode 100644 linux-x86/gnu-efi/lib/elf_ia32_efi.lds
 create mode 100644 linux-x86/gnu-efi/lib/libefi.a
 create mode 100644 linux-x86/gnu-efi/lib/libgnuefi.a
 create mode 100644 linux-x86_64/gnu-efi/include/efi/efi.h
 create mode 100644 linux-x86_64/gnu-efi/include/efi/efi_nii.h
 create mode 100644 linux-x86_64/gnu-efi/include/efi/efi_pxe.h
 create mode 100644 linux-x86_64/gnu-efi/include/efi/efiapi.h
 create mode 100644 linux-x86_64/gnu-efi/include/efi/eficon.h
 create mode 100644 linux-x86_64/gnu-efi/include/efi/efidebug.h
 create mode 100644 linux-x86_64/gnu-efi/include/efi/efidef.h
 create mode 100644 linux-x86_64/gnu-efi/include/efi/efidevp.h
 create mode 100644 linux-x86_64/gnu-efi/include/efi/efierr.h
 create mode 100644 linux-x86_64/gnu-efi/include/efi/efifs.h
 create mode 100644 linux-x86_64/gnu-efi/include/efi/efigpt.h
 create mode 100644 linux-x86_64/gnu-efi/include/efi/efilib.h
 create mode 100644 linux-x86_64/gnu-efi/include/efi/efilink.h
 create mode 100644 linux-x86_64/gnu-efi/include/efi/efinet.h
 create mode 100644 linux-x86_64/gnu-efi/include/efi/efipart.h
 create mode 100644 linux-x86_64/gnu-efi/include/efi/efipciio.h
 create mode 100644 linux-x86_64/gnu-efi/include/efi/efiprot.h
 create mode 100644 linux-x86_64/gnu-efi/include/efi/efipxebc.h
 create mode 100644 linux-x86_64/gnu-efi/include/efi/efirtlib.h
 create mode 100644 linux-x86_64/gnu-efi/include/efi/efiser.h
 create mode 100644 linux-x86_64/gnu-efi/include/efi/efistdarg.h
 create mode 100644 linux-x86_64/gnu-efi/include/efi/efiui.h
 create mode 100644 linux-x86_64/gnu-efi/include/efi/libsmbios.h
 create mode 100644 linux-x86_64/gnu-efi/include/efi/pci22.h
 create mode 100644 linux-x86_64/gnu-efi/include/efi/protocol/adapterdebug.h
 create mode 100644 linux-x86_64/gnu-efi/include/efi/protocol/eficonsplit.h
 create mode 100644 linux-x86_64/gnu-efi/include/efi/protocol/efidbg.h
 create mode 100644 linux-x86_64/gnu-efi/include/efi/protocol/efivar.h
 create mode 100644 linux-x86_64/gnu-efi/include/efi/protocol/intload.h
 create mode 100644 linux-x86_64/gnu-efi/include/efi/protocol/legacyboot.h
 create mode 100644 linux-x86_64/gnu-efi/include/efi/protocol/piflash64.h
 create mode 100644 linux-x86_64/gnu-efi/include/efi/protocol/vgaclass.h
 create mode 100644 linux-x86_64/gnu-efi/include/efi/romload.h
 create mode 100644 linux-x86_64/gnu-efi/include/efi/x86_64/efibind.h
 create mode 100644 linux-x86_64/gnu-efi/include/efi/x86_64/efilibplat.h
 create mode 100644 linux-x86_64/gnu-efi/include/efi/x86_64/pe.h
 create mode 100644 linux-x86_64/gnu-efi/lib/crt0-efi-x86_64.o
 create mode 100644 linux-x86_64/gnu-efi/lib/elf_x86_64_efi.lds
 create mode 100644 linux-x86_64/gnu-efi/lib/libefi.a
 create mode 100644 linux-x86_64/gnu-efi/lib/libgnuefi.a

diff --git a/linux-x86/gnu-efi/include/efi/efi.h b/linux-x86/gnu-efi/include/efi/efi.h
new file mode 100644
index 0000000..e9de37b
--- /dev/null
+++ b/linux-x86/gnu-efi/include/efi/efi.h
@@ -0,0 +1,50 @@
+/*++
+
+Copyright (c) 1998  Intel Corporation
+
+Module Name:
+
+    efi.h
+
+Abstract:
+
+    Public EFI header files
+
+
+
+Revision History
+
+--*/
+
+//
+// Build flags on input
+//  EFI32
+//  EFI_DEBUG               - Enable debugging code
+//  EFI_NT_EMULATOR         - Building for running under NT
+//
+
+
+#ifndef _EFI_INCLUDE_
+#define _EFI_INCLUDE_
+
+#define EFI_FIRMWARE_VENDOR         L"INTEL"
+#define EFI_FIRMWARE_MAJOR_REVISION 12
+#define EFI_FIRMWARE_MINOR_REVISION 33
+#define EFI_FIRMWARE_REVISION ((EFI_FIRMWARE_MAJOR_REVISION <<16) | (EFI_FIRMWARE_MINOR_REVISION))
+
+#include "efibind.h"
+#include "efidef.h"
+#include "efidevp.h"
+#include "efipciio.h"
+#include "efiprot.h"
+#include "eficon.h"
+#include "efiser.h"
+#include "efi_nii.h"
+#include "efipxebc.h"
+#include "efinet.h"
+#include "efiapi.h"
+#include "efifs.h"
+#include "efierr.h"
+#include "efiui.h"
+
+#endif
diff --git a/linux-x86/gnu-efi/include/efi/efi_nii.h b/linux-x86/gnu-efi/include/efi/efi_nii.h
new file mode 100644
index 0000000..ba7a5b2
--- /dev/null
+++ b/linux-x86/gnu-efi/include/efi/efi_nii.h
@@ -0,0 +1,74 @@
+#ifndef _EFI_NII_H
+#define _EFI_NII_H
+
+/*++
+Copyright (c) 2000  Intel Corporation
+
+Module name:
+    efi_nii.h
+
+Abstract:
+
+Revision history:
+    2000-Feb-18 M(f)J   GUID updated.
+                Structure order changed for machine word alignment.
+                Added StringId[4] to structure.
+                
+    2000-Feb-14 M(f)J   Genesis.
+--*/
+
+#define EFI_NETWORK_INTERFACE_IDENTIFIER_PROTOCOL \
+    { 0xE18541CD, 0xF755, 0x4f73, {0x92, 0x8D, 0x64, 0x3C, 0x8A, 0x79, 0xB2, 0x29} }
+
+#define EFI_NETWORK_INTERFACE_IDENTIFIER_INTERFACE_REVISION 0x00010000
+
+typedef enum {
+    EfiNetworkInterfaceUndi = 1
+} EFI_NETWORK_INTERFACE_TYPE;
+
+typedef struct {
+
+    UINT64 Revision;
+    // Revision of the network interface identifier protocol interface.
+
+    UINT64 ID;
+    // Address of the first byte of the identifying structure for this
+    // network interface.  This is set to zero if there is no structure.
+    //
+    // For PXE/UNDI this is the first byte of the !PXE structure.
+
+    UINT64 ImageAddr;
+    // Address of the UNrelocated driver/ROM image.  This is set
+    // to zero if there is no driver/ROM image.
+    //
+    // For 16-bit UNDI, this is the first byte of the option ROM in
+    // upper memory.
+    //
+    // For 32/64-bit S/W UNDI, this is the first byte of the EFI ROM
+    // image.
+    //
+    // For H/W UNDI, this is set to zero.
+
+    UINT32 ImageSize;
+    // Size of the UNrelocated driver/ROM image of this network interface.
+    // This is set to zero if there is no driver/ROM image.
+
+    CHAR8 StringId[4];
+    // 4 char ASCII string to go in class identifier (option 60) in DHCP
+    // and Boot Server discover packets.
+    // For EfiNetworkInterfaceUndi this field is "UNDI".
+    // For EfiNetworkInterfaceSnp this field is "SNPN".
+
+    UINT8 Type;
+    UINT8 MajorVer;
+    UINT8 MinorVer;
+    // Information to be placed into the PXE DHCP and Discover packets.
+    // This is the network interface type and version number that will
+    // be placed into DHCP option 94 (client network interface identifier).
+    BOOLEAN Ipv6Supported;
+	UINT8   IfNum;	// interface number to be used with pxeid structure
+} EFI_NETWORK_INTERFACE_IDENTIFIER_INTERFACE;
+
+extern EFI_GUID NetworkInterfaceIdentifierProtocol;
+
+#endif // _EFI_NII_H
diff --git a/linux-x86/gnu-efi/include/efi/efi_pxe.h b/linux-x86/gnu-efi/include/efi/efi_pxe.h
new file mode 100644
index 0000000..d24251f
--- /dev/null
+++ b/linux-x86/gnu-efi/include/efi/efi_pxe.h
@@ -0,0 +1,1743 @@
+#ifndef _EFI_PXE_H
+#define _EFI_PXE_H
+
+
+/*++
+Copyright (c) Intel  1999
+
+Module name:
+    efi_pxe.h
+
+32/64-bit PXE specification:
+    alpha-4, 99-Dec-17
+
+Abstract:
+    This header file contains all of the PXE type definitions,
+    structure prototypes, global variables and constants that
+    are needed for porting PXE to EFI.
+--*/
+
+#pragma pack(1)
+
+#define PXE_INTEL_ORDER         1   // Intel order
+//#define PXE_NETWORK_ORDER         1   // network order
+
+#define PXE_UINT64_SUPPORT          1   // UINT64 supported
+//#define PXE_NO_UINT64_SUPPORT     1   // UINT64 not supported
+
+#define PXE_BUSTYPE(a,b,c,d)            \
+((((PXE_UINT32)(d) & 0xFF) << 24) | \
+(((PXE_UINT32)(c) & 0xFF) << 16) |  \
+(((PXE_UINT32)(b) & 0xFF) << 8) |       \
+((PXE_UINT32)(a) & 0xFF))
+
+//
+// UNDI ROM ID and devive ID signature
+//
+#define PXE_BUSTYPE_PXE         PXE_BUSTYPE('!', 'P', 'X', 'E')
+
+//
+// BUS ROM ID signatures
+//
+#define PXE_BUSTYPE_PCI         PXE_BUSTYPE('P', 'C', 'I', 'R')
+#define PXE_BUSTYPE_PC_CARD     PXE_BUSTYPE('P', 'C', 'C', 'R')
+#define PXE_BUSTYPE_USB         PXE_BUSTYPE('U', 'S', 'B', 'R')
+#define PXE_BUSTYPE_1394        PXE_BUSTYPE('1', '3', '9', '4')
+
+#define PXE_SWAP_UINT16(n)          \
+((((PXE_UINT16)(n) & 0x00FF) << 8) |    \
+(((PXE_UINT16)(n) & 0xFF00) >> 8))
+
+#define PXE_SWAP_UINT32(n)              \
+((((PXE_UINT32)(n) & 0x000000FF) << 24) |   \
+(((PXE_UINT32)(n) & 0x0000FF00) << 8) |     \
+(((PXE_UINT32)(n) & 0x00FF0000) >> 8) |     \
+(((PXE_UINT32)(n) & 0xFF000000) >> 24))
+
+#if PXE_UINT64_SUPPORT != 0
+#define PXE_SWAP_UINT64(n)                  \
+((((PXE_UINT64)(n) & 0x00000000000000FF) << 56) |   \
+(((PXE_UINT64)(n) & 0x000000000000FF00) << 40) |    \
+(((PXE_UINT64)(n) & 0x0000000000FF0000) << 24) |    \
+(((PXE_UINT64)(n) & 0x00000000FF000000) << 8) | \
+(((PXE_UINT64)(n) & 0x000000FF00000000) >> 8) | \
+(((PXE_UINT64)(n) & 0x0000FF0000000000) >> 24) |    \
+(((PXE_UINT64)(n) & 0x00FF000000000000) >> 40) |    \
+(((PXE_UINT64)(n) & 0xFF00000000000000) >> 56))
+#endif // PXE_UINT64_SUPPORT
+
+#if PXE_NO_UINT64_SUPPORT != 0
+#define PXE_SWAP_UINT64(n)                      \
+{                                       \
+PXE_UINT32 tmp = (PXE_UINT64)(n)[1];                \
+(PXE_UINT64)(n)[1] = PXE_SWAP_UINT32((PXE_UINT64)(n)[0]);   \
+(PXE_UINT64)(n)[0] = tmp;                       \
+}
+#endif // PXE_NO_UINT64_SUPPORT
+
+#define PXE_CPBSIZE_NOT_USED            0   // zero
+#define PXE_DBSIZE_NOT_USED         0   // zero
+#define PXE_CPBADDR_NOT_USED        (PXE_UINT64)0       // zero
+#define PXE_DBADDR_NOT_USED     (PXE_UINT64)0       // zero
+
+#define PXE_CONST const
+
+#define PXE_VOLATILE volatile
+
+typedef void PXE_VOID;
+
+typedef unsigned char PXE_UINT8;
+
+typedef unsigned short PXE_UINT16;
+
+typedef unsigned PXE_UINT32;
+
+#if PXE_UINT64_SUPPORT != 0
+// typedef unsigned long PXE_UINT64;
+typedef UINT64 PXE_UINT64;
+#endif // PXE_UINT64_SUPPORT
+
+#if PXE_NO_UINT64_SUPPORT != 0
+typedef PXE_UINT32 PXE_UINT64[2];
+#endif // PXE_NO_UINT64_SUPPORT
+
+typedef unsigned PXE_UINTN;
+
+typedef PXE_UINT8 PXE_BOOL;
+
+#define PXE_FALSE               0   // zero
+#define PXE_TRUE                    (!PXE_FALSE)
+
+typedef PXE_UINT16 PXE_OPCODE;
+
+//
+// Return UNDI operational state.
+//
+#define PXE_OPCODE_GET_STATE                    0x0000
+
+//
+// Change UNDI operational state from Stopped to Started.
+//
+#define PXE_OPCODE_START                    0x0001
+
+//
+// Change UNDI operational state from Started to Stopped.
+//
+#define PXE_OPCODE_STOP                     0x0002
+
+//
+// Get UNDI initialization information.
+//
+#define PXE_OPCODE_GET_INIT_INFO                0x0003
+
+//
+// Get NIC configuration information.
+//
+#define PXE_OPCODE_GET_CONFIG_INFO              0x0004
+
+//
+// Changed UNDI operational state from Started to Initialized.
+//
+#define PXE_OPCODE_INITIALIZE                   0x0005
+
+//
+// Re-initialize the NIC H/W.
+//
+#define PXE_OPCODE_RESET                    0x0006
+
+//
+// Change the UNDI operational state from Initialized to Started.
+//
+#define PXE_OPCODE_SHUTDOWN                 0x0007
+
+//
+// Read & change state of external interrupt enables.
+//
+#define PXE_OPCODE_INTERRUPT_ENABLES                0x0008
+
+//
+// Read & change state of packet receive filters.
+//
+#define PXE_OPCODE_RECEIVE_FILTERS              0x0009
+
+//
+// Read & change station MAC address.
+//
+#define PXE_OPCODE_STATION_ADDRESS              0x000A
+
+//
+// Read traffic statistics.
+//
+#define PXE_OPCODE_STATISTICS                   0x000B
+
+//
+// Convert multicast IP address to multicast MAC address.
+//
+#define PXE_OPCODE_MCAST_IP_TO_MAC              0x000C
+
+//
+// Read or change non-volatile storage on the NIC.
+//
+#define PXE_OPCODE_NVDATA                   0x000D
+
+//
+// Get & clear interrupt status.
+//
+#define PXE_OPCODE_GET_STATUS                   0x000E
+
+//
+// Fill media header in packet for transmit.
+//
+#define PXE_OPCODE_FILL_HEADER              0x000F
+
+//
+// Transmit packet(s).
+//
+#define PXE_OPCODE_TRANSMIT                 0x0010
+
+//
+// Receive packet.
+//
+#define PXE_OPCODE_RECEIVE                  0x0011
+
+// last valid opcode:
+#define PXE_OPCODE_VALID_MAX                    0x0011
+
+//
+// Last valid PXE UNDI OpCode number.
+//
+#define PXE_OPCODE_LAST_VALID                   0x0011
+
+typedef PXE_UINT16 PXE_OPFLAGS;
+
+#define PXE_OPFLAGS_NOT_USED                    0x0000
+
+////////////////////////////////////////
+// UNDI Get State
+//
+
+// No OpFlags
+
+////////////////////////////////////////
+// UNDI Start
+//
+
+// No OpFlags
+
+////////////////////////////////////////
+// UNDI Stop
+//
+
+// No OpFlags
+
+////////////////////////////////////////
+// UNDI Get Init Info
+//
+
+// No Opflags
+
+////////////////////////////////////////
+// UNDI Get Config Info
+//
+
+// No Opflags
+
+////////////////////////////////////////
+// UNDI Initialize
+//
+
+#define PXE_OPFLAGS_INITIALIZE_CABLE_DETECT_MASK    0x0001
+#define PXE_OPFLAGS_INITIALIZE_DETECT_CABLE         0x0000
+#define PXE_OPFLAGS_INITIALIZE_DO_NOT_DETECT_CABLE  0x0001
+
+////////////////////////////////////////
+// UNDI Reset
+//
+
+#define PXE_OPFLAGS_RESET_DISABLE_INTERRUPTS        0x0001
+#define PXE_OPFLAGS_RESET_DISABLE_FILTERS           0x0002
+
+////////////////////////////////////////
+// UNDI Shutdown
+//
+
+// No OpFlags
+
+////////////////////////////////////////
+// UNDI Interrupt Enables
+//
+
+//
+// Select whether to enable or disable external interrupt signals.
+// Setting both enable and disable will return PXE_STATCODE_INVALID_OPFLAGS.
+//
+#define PXE_OPFLAGS_INTERRUPT_OPMASK                0xC000
+#define PXE_OPFLAGS_INTERRUPT_ENABLE                0x8000
+#define PXE_OPFLAGS_INTERRUPT_DISABLE           0x4000
+#define PXE_OPFLAGS_INTERRUPT_READ              0x0000
+
+//
+// Enable receive interrupts.  An external interrupt will be generated
+// after a complete non-error packet has been received.
+//
+#define PXE_OPFLAGS_INTERRUPT_RECEIVE           0x0001
+
+//
+// Enable transmit interrupts.  An external interrupt will be generated
+// after a complete non-error packet has been transmitted.
+//
+#define PXE_OPFLAGS_INTERRUPT_TRANSMIT          0x0002
+
+//
+// Enable command interrupts.  An external interrupt will be generated
+// when command execution stops.
+//
+#define PXE_OPFLAGS_INTERRUPT_COMMAND           0x0004
+
+//
+// Generate software interrupt.  Setting this bit generates an external
+// interrupt, if it is supported by the hardware.
+//
+#define PXE_OPFLAGS_INTERRUPT_SOFTWARE          0x0008
+
+////////////////////////////////////////
+// UNDI Receive Filters
+//
+
+//
+// Select whether to enable or disable receive filters.
+// Setting both enable and disable will return PXE_STATCODE_INVALID_OPCODE.
+//
+#define PXE_OPFLAGS_RECEIVE_FILTER_OPMASK           0xC000
+#define PXE_OPFLAGS_RECEIVE_FILTER_ENABLE           0x8000
+#define PXE_OPFLAGS_RECEIVE_FILTER_DISABLE          0x4000
+#define PXE_OPFLAGS_RECEIVE_FILTER_READ         0x0000
+
+//
+// To reset the contents of the multicast MAC address filter list,
+// set this OpFlag:
+//
+#define PXE_OPFLAGS_RECEIVE_FILTER_RESET_MCAST_LIST 0x2000
+
+//
+// Enable unicast packet receiving.  Packets sent to the current station
+// MAC address will be received.
+//
+#define PXE_OPFLAGS_RECEIVE_FILTER_UNICAST          0x0001
+
+//
+// Enable broadcast packet receiving.  Packets sent to the broadcast 
+// MAC address will be received.
+//
+#define PXE_OPFLAGS_RECEIVE_FILTER_BROADCAST        0x0002
+
+//
+// Enable filtered multicast packet receiving.  Packets sent to any
+// of the multicast MAC addresses in the multicast MAC address filter
+// list will be received.  If the filter list is empty, no multicast
+//
+#define PXE_OPFLAGS_RECEIVE_FILTER_FILTERED_MULTICAST   0x0004
+
+//
+// Enable promiscuous packet receiving.  All packets will be received.
+//
+#define PXE_OPFLAGS_RECEIVE_FILTER_PROMISCUOUS      0x0008
+
+//
+// Enable promiscuous multicast packet receiving.  All multicast
+// packets will be received.
+//
+#define PXE_OPFLAGS_RECEIVE_FILTER_ALL_MULTICAST        0x0010
+
+////////////////////////////////////////
+// UNDI Station Address
+//
+
+#define PXE_OPFLAGS_STATION_ADDRESS_READ            0x0000
+#define PXE_OPFLAGS_STATION_ADDRESS_RESET           0x0001
+
+////////////////////////////////////////
+// UNDI Statistics
+//
+
+#define PXE_OPFLAGS_STATISTICS_READ             0x0000
+#define PXE_OPFLAGS_STATISTICS_RESET                0x0001
+
+////////////////////////////////////////
+// UNDI MCast IP to MAC
+//
+
+//
+// Identify the type of IP address in the CPB.
+//
+#define PXE_OPFLAGS_MCAST_IP_TO_MAC_OPMASK          0x0003
+#define PXE_OPFLAGS_MCAST_IPV4_TO_MAC           0x0000
+#define PXE_OPFLAGS_MCAST_IPV6_TO_MAC           0x0001
+
+////////////////////////////////////////
+// UNDI NvData
+//
+
+//
+// Select the type of non-volatile data operation.
+//
+#define PXE_OPFLAGS_NVDATA_OPMASK               0x0001
+#define PXE_OPFLAGS_NVDATA_READ             0x0000
+#define PXE_OPFLAGS_NVDATA_WRITE                0x0001
+
+////////////////////////////////////////
+// UNDI Get Status
+//
+
+//
+// Return current interrupt status.  This will also clear any interrupts
+// that are currently set.  This can be used in a polling routine.  The
+// interrupt flags are still set and cleared even when the interrupts
+// are disabled.
+//
+#define PXE_OPFLAGS_GET_INTERRUPT_STATUS            0x0001
+
+//
+// Return list of transmitted buffers for recycling.  Transmit buffers
+// must not be changed or unallocated until they have recycled.  After
+// issuing a transmit command, wait for a transmit complete interrupt.
+// When a transmit complete interrupt is received, read the transmitted
+// buffers.  Do not plan on getting one buffer per interrupt.  Some
+// NICs and UNDIs may transmit multiple buffers per interrupt.
+//
+#define PXE_OPFLAGS_GET_TRANSMITTED_BUFFERS         0x0002
+
+////////////////////////////////////////
+// UNDI Fill Header
+//
+
+#define PXE_OPFLAGS_FILL_HEADER_OPMASK          0x0001
+#define PXE_OPFLAGS_FILL_HEADER_FRAGMENTED          0x0001
+#define PXE_OPFLAGS_FILL_HEADER_WHOLE           0x0000
+
+////////////////////////////////////////
+// UNDI Transmit
+//
+
+//
+// S/W UNDI only.  Return after the packet has been transmitted.  A
+// transmit complete interrupt will still be generated and the transmit
+// buffer will have to be recycled.
+//
+#define PXE_OPFLAGS_SWUNDI_TRANSMIT_OPMASK          0x0001
+#define PXE_OPFLAGS_TRANSMIT_BLOCK              0x0001
+#define PXE_OPFLAGS_TRANSMIT_DONT_BLOCK         0x0000
+
+//
+//
+//
+#define PXE_OPFLAGS_TRANSMIT_OPMASK             0x0002
+#define PXE_OPFLAGS_TRANSMIT_FRAGMENTED         0x0002
+#define PXE_OPFLAGS_TRANSMIT_WHOLE              0x0000
+
+////////////////////////////////////////
+// UNDI Receive
+//
+
+// No OpFlags
+
+typedef PXE_UINT16 PXE_STATFLAGS;
+
+#define PXE_STATFLAGS_INITIALIZE                0x0000
+
+////////////////////////////////////////
+// Common StatFlags that can be returned by all commands.
+//
+
+//
+// The COMMAND_COMPLETE and COMMAND_FAILED status flags must be
+// implemented by all UNDIs.  COMMAND_QUEUED is only needed by UNDIs
+// that support command queuing.
+//
+#define PXE_STATFLAGS_STATUS_MASK               0xC000
+#define PXE_STATFLAGS_COMMAND_COMPLETE          0xC000
+#define PXE_STATFLAGS_COMMAND_FAILED                0x8000
+#define PXE_STATFLAGS_COMMAND_QUEUED                0x4000
+//#define PXE_STATFLAGS_INITIALIZE              0x0000
+
+#define PXE_STATFLAGS_DB_WRITE_TRUNCATED            0x2000
+
+////////////////////////////////////////
+// UNDI Get State
+//
+
+#define PXE_STATFLAGS_GET_STATE_MASK                0x0003
+#define PXE_STATFLAGS_GET_STATE_INITIALIZED         0x0002
+#define PXE_STATFLAGS_GET_STATE_STARTED         0x0001
+#define PXE_STATFLAGS_GET_STATE_STOPPED         0x0000
+
+////////////////////////////////////////
+// UNDI Start
+//
+
+// No additional StatFlags
+
+////////////////////////////////////////
+// UNDI Get Init Info
+//
+
+#define PXE_STATFLAGS_CABLE_DETECT_MASK          0x0001
+#define PXE_STATFLAGS_CABLE_DETECT_NOT_SUPPORTED 0x0000
+#define PXE_STATFLAGS_CABLE_DETECT_SUPPORTED     0x0001
+
+
+////////////////////////////////////////
+// UNDI Initialize
+//
+
+#define PXE_STATFLAGS_INITIALIZED_NO_MEDIA          0x0001
+
+////////////////////////////////////////
+// UNDI Reset
+//
+
+#define PXE_STATFLAGS_RESET_NO_MEDIA                0x0001
+
+////////////////////////////////////////
+// UNDI Shutdown
+//
+
+// No additional StatFlags
+
+////////////////////////////////////////
+// UNDI Interrupt Enables
+//
+
+//
+// If set, receive interrupts are enabled.
+//
+#define PXE_STATFLAGS_INTERRUPT_RECEIVE         0x0001
+
+//
+// If set, transmit interrupts are enabled.
+//
+#define PXE_STATFLAGS_INTERRUPT_TRANSMIT            0x0002
+
+//
+// If set, command interrupts are enabled.
+//
+#define PXE_STATFLAGS_INTERRUPT_COMMAND         0x0004
+
+
+////////////////////////////////////////
+// UNDI Receive Filters
+//
+
+//
+// If set, unicast packets will be received.
+//
+#define PXE_STATFLAGS_RECEIVE_FILTER_UNICAST        0x0001
+
+//
+// If set, broadcast packets will be received.
+//
+#define PXE_STATFLAGS_RECEIVE_FILTER_BROADCAST      0x0002
+
+//
+// If set, multicast packets that match up with the multicast address
+// filter list will be received.
+//
+#define PXE_STATFLAGS_RECEIVE_FILTER_FILTERED_MULTICAST 0x0004
+
+//
+// If set, all packets will be received.
+//
+#define PXE_STATFLAGS_RECEIVE_FILTER_PROMISCUOUS        0x0008
+
+//
+// If set, all multicast packets will be received.
+//
+#define PXE_STATFLAGS_RECEIVE_FILTER_ALL_MULTICAST  0x0010
+
+////////////////////////////////////////
+// UNDI Station Address
+//
+
+// No additional StatFlags
+
+////////////////////////////////////////
+// UNDI Statistics
+//
+
+// No additional StatFlags
+
+////////////////////////////////////////
+// UNDI MCast IP to MAC
+//
+
+// No additional StatFlags
+
+////////////////////////////////////////
+// UNDI NvData
+//
+
+// No additional StatFlags
+
+
+////////////////////////////////////////
+// UNDI Get Status
+//
+
+//
+// Use to determine if an interrupt has occurred.
+//
+#define PXE_STATFLAGS_GET_STATUS_INTERRUPT_MASK     0x000F
+#define PXE_STATFLAGS_GET_STATUS_NO_INTERRUPTS      0x0000
+
+//
+// If set, at least one receive interrupt occurred.
+//
+#define PXE_STATFLAGS_GET_STATUS_RECEIVE            0x0001
+
+//
+// If set, at least one transmit interrupt occurred.
+//
+#define PXE_STATFLAGS_GET_STATUS_TRANSMIT           0x0002
+
+//
+// If set, at least one command interrupt occurred.
+//
+#define PXE_STATFLAGS_GET_STATUS_COMMAND            0x0004
+
+//
+// If set, at least one software interrupt occurred.
+//
+#define PXE_STATFLAGS_GET_STATUS_SOFTWARE           0x0008
+
+//
+// This flag is set if the transmitted buffer queue is empty.  This flag
+// will be set if all transmitted buffer addresses get written into the DB.
+//
+#define PXE_STATFLAGS_GET_STATUS_TXBUF_QUEUE_EMPTY  0x0010
+
+//
+// This flag is set if no transmitted buffer addresses were written
+// into the DB.  (This could be because DBsize was too small.)
+//
+#define PXE_STATFLAGS_GET_STATUS_NO_TXBUFS_WRITTEN  0x0020
+
+////////////////////////////////////////
+// UNDI Fill Header
+//
+
+// No additional StatFlags
+
+////////////////////////////////////////
+// UNDI Transmit
+//
+
+// No additional StatFlags.
+
+////////////////////////////////////////
+// UNDI Receive
+//
+
+// No additional StatFlags.
+
+typedef PXE_UINT16 PXE_STATCODE;
+
+#define PXE_STATCODE_INITIALIZE             0x0000
+
+////////////////////////////////////////
+// Common StatCodes returned by all UNDI commands, UNDI protocol functions
+// and BC protocol functions.
+//
+
+#define PXE_STATCODE_SUCCESS                    0x0000
+
+#define PXE_STATCODE_INVALID_CDB                0x0001
+#define PXE_STATCODE_INVALID_CPB                0x0002
+#define PXE_STATCODE_BUSY                   	0x0003
+#define PXE_STATCODE_QUEUE_FULL             	0x0004
+#define PXE_STATCODE_ALREADY_STARTED            0x0005
+#define PXE_STATCODE_NOT_STARTED                0x0006
+#define PXE_STATCODE_NOT_SHUTDOWN               0x0007
+#define PXE_STATCODE_ALREADY_INITIALIZED        0x0008
+#define PXE_STATCODE_NOT_INITIALIZED            0x0009
+#define PXE_STATCODE_DEVICE_FAILURE             0x000A
+#define PXE_STATCODE_NVDATA_FAILURE             0x000B
+#define PXE_STATCODE_UNSUPPORTED                0x000C
+#define PXE_STATCODE_BUFFER_FULL                0x000D
+#define PXE_STATCODE_INVALID_PARAMETER		0x000E
+#define PXE_STATCODE_INVALID_UNDI		0x000F
+#define PXE_STATCODE_IPV4_NOT_SUPPORTED		0x0010
+#define PXE_STATCODE_IPV6_NOT_SUPPORTED		0x0011
+#define PXE_STATCODE_NOT_ENOUGH_MEMORY		0x0012
+#define PXE_STATCODE_NO_DATA			0x0013
+
+
+typedef PXE_UINT16 PXE_IFNUM;
+
+//
+// This interface number must be passed to the S/W UNDI Start command.
+//
+#define PXE_IFNUM_START                     0x0000
+
+//
+// This interface number is returned by the S/W UNDI Get State and
+// Start commands if information in the CDB, CPB or DB is invalid.
+//
+#define PXE_IFNUM_INVALID                   0x0000
+
+typedef PXE_UINT16 PXE_CONTROL;
+
+//
+// Setting this flag directs the UNDI to queue this command for later
+// execution if the UNDI is busy and it supports command queuing.
+// If queuing is not supported, a PXE_STATCODE_INVALID_CONTROL error
+// is returned.  If the queue is full, a PXE_STATCODE_CDB_QUEUE_FULL 
+// error is returned.
+//
+#define PXE_CONTROL_QUEUE_IF_BUSY               0x0002
+
+//
+// These two bit values are used to determine if there are more UNDI
+// CDB structures following this one.  If the link bit is set, there
+// must be a CDB structure following this one.  Execution will start
+// on the next CDB structure as soon as this one completes successfully.
+// If an error is generated by this command, execution will stop.
+//
+#define PXE_CONTROL_LINK                    0x0001
+#define PXE_CONTROL_LAST_CDB_IN_LIST                0x0000
+
+typedef PXE_UINT8 PXE_FRAME_TYPE;
+
+#define PXE_FRAME_TYPE_NONE                 0x00
+#define PXE_FRAME_TYPE_UNICAST              0x01
+#define PXE_FRAME_TYPE_BROADCAST                0x02
+#define PXE_FRAME_TYPE_MULTICAST            0x03
+#define PXE_FRAME_TYPE_PROMISCUOUS              0x04
+
+typedef PXE_UINT32 PXE_IPV4;
+
+typedef PXE_UINT32 PXE_IPV6[4];
+#define PXE_MAC_LENGTH 32
+
+typedef PXE_UINT8 PXE_MAC_ADDR[PXE_MAC_LENGTH];
+
+typedef PXE_UINT8 PXE_IFTYPE;
+typedef PXE_UINT16 PXE_MEDIA_PROTOCOL;
+
+//
+// This information is from the ARP section of RFC 1700.
+//
+//     1 Ethernet (10Mb)                                    [JBP]
+//     2 Experimental Ethernet (3Mb)                        [JBP]
+//     3 Amateur Radio AX.25                                [PXK]
+//     4 Proteon ProNET Token Ring                          [JBP]
+//     5 Chaos                                              [GXP]
+//     6 IEEE 802 Networks                                  [JBP]
+//     7 ARCNET                                             [JBP]
+//     8 Hyperchannel                                       [JBP]
+//     9 Lanstar                                             [TU]
+//    10 Autonet Short Address                             [MXB1]
+//    11 LocalTalk                                         [JKR1]
+//    12 LocalNet (IBM PCNet or SYTEK LocalNET)             [JXM]
+//    13 Ultra link                                        [RXD2]
+//    14 SMDS                                              [GXC1]
+//    15 Frame Relay                                        [AGM]
+//    16 Asynchronous Transmission Mode (ATM)              [JXB2]
+//    17 HDLC                                               [JBP]
+//    18 Fibre Channel                            [Yakov Rekhter]
+//    19 Asynchronous Transmission Mode (ATM)      [Mark Laubach]
+//    20 Serial Line                                        [JBP]
+//    21 Asynchronous Transmission Mode (ATM)              [MXB1]
+//
+
+#define PXE_IFTYPE_ETHERNET                 0x01
+#define PXE_IFTYPE_TOKENRING                    0x04
+#define PXE_IFTYPE_FIBRE_CHANNEL                0x12
+
+typedef struct s_pxe_hw_undi {
+PXE_UINT32 Signature;       // PXE_ROMID_SIGNATURE
+PXE_UINT8 Len;          // sizeof(PXE_HW_UNDI)
+PXE_UINT8 Fudge;            // makes 8-bit cksum equal zero
+PXE_UINT8 Rev;          // PXE_ROMID_REV
+PXE_UINT8 IFcnt;            // physical connector count
+PXE_UINT8 MajorVer;         // PXE_ROMID_MAJORVER
+PXE_UINT8 MinorVer;         // PXE_ROMID_MINORVER
+PXE_UINT16 reserved;        // zero, not used
+PXE_UINT32 Implementation;      // implementation flags
+// reserved             // vendor use
+// PXE_UINT32 Status;       // status port
+// PXE_UINT32 Command;      // command port
+// PXE_UINT64 CDBaddr;      // CDB address port
+} PXE_HW_UNDI;
+
+//
+// Status port bit definitions
+//
+
+//
+// UNDI operation state
+//
+#define PXE_HWSTAT_STATE_MASK                   0xC0000000
+#define PXE_HWSTAT_BUSY                     0xC0000000
+#define PXE_HWSTAT_INITIALIZED              0x80000000
+#define PXE_HWSTAT_STARTED                  0x40000000
+#define PXE_HWSTAT_STOPPED                  0x00000000
+
+//
+// If set, last command failed
+//
+#define PXE_HWSTAT_COMMAND_FAILED               0x20000000
+
+//
+// If set, identifies enabled receive filters
+//
+#define PXE_HWSTAT_PROMISCUOUS_MULTICAST_RX_ENABLED 0x00001000
+#define PXE_HWSTAT_PROMISCUOUS_RX_ENABLED           0x00000800
+#define PXE_HWSTAT_BROADCAST_RX_ENABLED         0x00000400
+#define PXE_HWSTAT_MULTICAST_RX_ENABLED         0x00000200
+#define PXE_HWSTAT_UNICAST_RX_ENABLED           0x00000100
+
+//
+// If set, identifies enabled external interrupts
+//
+#define PXE_HWSTAT_SOFTWARE_INT_ENABLED         0x00000080
+#define PXE_HWSTAT_TX_COMPLETE_INT_ENABLED          0x00000040
+#define PXE_HWSTAT_PACKET_RX_INT_ENABLED            0x00000020
+#define PXE_HWSTAT_CMD_COMPLETE_INT_ENABLED         0x00000010
+
+//
+// If set, identifies pending interrupts
+//
+#define PXE_HWSTAT_SOFTWARE_INT_PENDING         0x00000008
+#define PXE_HWSTAT_TX_COMPLETE_INT_PENDING          0x00000004
+#define PXE_HWSTAT_PACKET_RX_INT_PENDING            0x00000002
+#define PXE_HWSTAT_CMD_COMPLETE_INT_PENDING         0x00000001
+
+//
+// Command port definitions
+//
+
+//
+// If set, CDB identified in CDBaddr port is given to UNDI.
+// If not set, other bits in this word will be processed.
+//
+#define PXE_HWCMD_ISSUE_COMMAND             0x80000000
+#define PXE_HWCMD_INTS_AND_FILTS                0x00000000
+
+//
+// Use these to enable/disable receive filters.
+//
+#define PXE_HWCMD_PROMISCUOUS_MULTICAST_RX_ENABLE       0x00001000
+#define PXE_HWCMD_PROMISCUOUS_RX_ENABLE         0x00000800
+#define PXE_HWCMD_BROADCAST_RX_ENABLE           0x00000400
+#define PXE_HWCMD_MULTICAST_RX_ENABLE           0x00000200
+#define PXE_HWCMD_UNICAST_RX_ENABLE             0x00000100
+
+//
+// Use these to enable/disable external interrupts
+//
+#define PXE_HWCMD_SOFTWARE_INT_ENABLE           0x00000080
+#define PXE_HWCMD_TX_COMPLETE_INT_ENABLE            0x00000040
+#define PXE_HWCMD_PACKET_RX_INT_ENABLE          0x00000020
+#define PXE_HWCMD_CMD_COMPLETE_INT_ENABLE           0x00000010
+
+//
+// Use these to clear pending external interrupts
+//
+#define PXE_HWCMD_CLEAR_SOFTWARE_INT                0x00000008
+#define PXE_HWCMD_CLEAR_TX_COMPLETE_INT         0x00000004
+#define PXE_HWCMD_CLEAR_PACKET_RX_INT           0x00000002
+#define PXE_HWCMD_CLEAR_CMD_COMPLETE_INT            0x00000001
+
+typedef struct s_pxe_sw_undi {
+PXE_UINT32 Signature;       // PXE_ROMID_SIGNATURE
+PXE_UINT8 Len;          // sizeof(PXE_SW_UNDI)
+PXE_UINT8 Fudge;            // makes 8-bit cksum zero
+PXE_UINT8 Rev;          // PXE_ROMID_REV
+PXE_UINT8 IFcnt;            // physical connector count
+PXE_UINT8 MajorVer;         // PXE_ROMID_MAJORVER
+PXE_UINT8 MinorVer;         // PXE_ROMID_MINORVER
+PXE_UINT16 reserved1;       // zero, not used
+PXE_UINT32 Implementation;      // Implementation flags
+PXE_UINT64 EntryPoint;      // API entry point
+PXE_UINT8 reserved2[3];     // zero, not used
+PXE_UINT8 BusCnt;           // number of bustypes supported
+PXE_UINT32 BusType[1];      // list of supported bustypes
+} PXE_SW_UNDI;
+
+typedef union u_pxe_undi {
+PXE_HW_UNDI hw;
+PXE_SW_UNDI sw;
+} PXE_UNDI;
+
+//
+// Signature of !PXE structure
+//
+#define PXE_ROMID_SIGNATURE     PXE_BUSTYPE('!', 'P', 'X', 'E')
+
+//
+// !PXE structure format revision
+//
+#define PXE_ROMID_REV                       0x02
+
+//
+// UNDI command interface revision.  These are the values that get sent
+// in option 94 (Client Network Interface Identifier) in the DHCP Discover
+// and PXE Boot Server Request packets.
+//
+#define PXE_ROMID_MAJORVER                  0x03
+#define PXE_ROMID_MINORVER                  0x00
+
+//
+// Implementation flags
+//
+#define PXE_ROMID_IMP_HW_UNDI                   0x80000000
+#define PXE_ROMID_IMP_SW_VIRT_ADDR              0x40000000
+#define PXE_ROMID_IMP_64BIT_DEVICE              0x00010000
+#define PXE_ROMID_IMP_FRAG_SUPPORTED                0x00008000
+#define PXE_ROMID_IMP_CMD_LINK_SUPPORTED            0x00004000
+#define PXE_ROMID_IMP_CMD_QUEUE_SUPPORTED           0x00002000
+#define PXE_ROMID_IMP_MULTI_FRAME_SUPPORTED         0x00001000
+#define PXE_ROMID_IMP_NVDATA_SUPPORT_MASK           0x00000C00
+#define PXE_ROMID_IMP_NVDATA_BULK_WRITABLE          0x00000C00
+#define PXE_ROMID_IMP_NVDATA_SPARSE_WRITABLE        0x00000800
+#define PXE_ROMID_IMP_NVDATA_READ_ONLY          0x00000400
+#define PXE_ROMID_IMP_NVDATA_NOT_AVAILABLE          0x00000000
+#define PXE_ROMID_IMP_STATISTICS_SUPPORTED          0x00000200
+#define PXE_ROMID_IMP_STATION_ADDR_SETTABLE         0x00000100
+#define PXE_ROMID_IMP_PROMISCUOUS_MULTICAST_RX_SUPPORTED    0x00000080
+#define PXE_ROMID_IMP_PROMISCUOUS_RX_SUPPORTED      0x00000040
+#define PXE_ROMID_IMP_BROADCAST_RX_SUPPORTED        0x00000020
+#define PXE_ROMID_IMP_FILTERED_MULTICAST_RX_SUPPORTED   0x00000010
+#define PXE_ROMID_IMP_SOFTWARE_INT_SUPPORTED        0x00000008
+#define PXE_ROMID_IMP_TX_COMPLETE_INT_SUPPORTED     0x00000004
+#define PXE_ROMID_IMP_PACKET_RX_INT_SUPPORTED       0x00000002
+#define PXE_ROMID_IMP_CMD_COMPLETE_INT_SUPPORTED        0x00000001
+
+ 
+typedef struct s_pxe_cdb {
+PXE_OPCODE OpCode;
+PXE_OPFLAGS OpFlags;
+PXE_UINT16 CPBsize;
+PXE_UINT16 DBsize;
+UINT64 CPBaddr;
+UINT64 DBaddr;
+PXE_STATCODE StatCode;
+PXE_STATFLAGS StatFlags;
+PXE_UINT16 IFnum;
+PXE_CONTROL Control;
+} PXE_CDB;
+
+
+typedef union u_pxe_ip_addr {
+PXE_IPV6 IPv6;
+PXE_IPV4 IPv4;
+} PXE_IP_ADDR;
+
+typedef union pxe_device {
+//
+// PCI and PC Card NICs are both identified using bus, device
+// and function numbers.  For PC Card, this may require PC
+// Card services to be loaded in the BIOS or preboot
+// environment.
+//
+struct {
+//
+// See S/W UNDI ROMID structure definition for PCI and
+// PCC BusType definitions.
+//
+PXE_UINT32 BusType;
+
+//
+// Bus, device & function numbers that locate this device.
+//
+PXE_UINT16 Bus;
+PXE_UINT8 Device;
+PXE_UINT8 Function;
+} PCI, PCC;
+
+//
+// %%TBD - More information is needed about enumerating
+// USB and 1394 devices.
+//
+struct {
+PXE_UINT32 BusType;
+PXE_UINT32 tdb;
+} USB, _1394;
+} PXE_DEVICE;
+
+// cpb and db definitions
+
+#define MAX_PCI_CONFIG_LEN 64   // # of dwords
+#define MAX_EEPROM_LEN 128       // #of dwords
+#define MAX_XMIT_BUFFERS    32  // recycling Q length for xmit_done
+#define MAX_MCAST_ADDRESS_CNT 8
+
+typedef struct s_pxe_cpb_start {
+    //
+    // PXE_VOID Delay(PXE_UINT64 microseconds);
+    //
+    // UNDI will never request a delay smaller than 10 microseconds
+    // and will always request delays in increments of 10 microseconds.
+    // The Delay() CallBack routine must delay between n and n + 10 
+    // microseconds before returning control to the UNDI.
+    //
+    // This field cannot be set to zero.
+    //
+    PXE_UINT64 Delay;
+
+    //
+    // PXE_VOID Block(PXE_UINT32 enable);
+    //
+    // UNDI may need to block multi-threaded/multi-processor access to
+    // critical code sections when programming or accessing the network
+    // device.  To this end, a blocking service is needed by the UNDI.
+    // When UNDI needs a block, it will call Block() passing a non-zero
+    // value.  When UNDI no longer needs a block, it will call Block()
+    // with a zero value.  When called, if the Block() is already enabled,
+    // do not return control to the UNDI until the previous Block() is
+    // disabled.
+    //
+    // This field cannot be set to zero.
+    //
+    PXE_UINT64 Block;
+
+    //
+    // PXE_VOID Virt2Phys(PXE_UINT64 virtual, PXE_UINT64 physical_ptr);
+    //
+    // UNDI will pass the virtual address of a buffer and the virtual
+    // address of a 64-bit physical buffer.  Convert the virtual address
+    // to a physical address and write the result to the physical address
+    // buffer.  If virtual and physical addresses are the same, just
+    // copy the virtual address to the physical address buffer.
+    //
+    // This field can be set to zero if virtual and physical addresses 
+    // are equal.
+    //
+    PXE_UINT64 Virt2Phys;
+    //
+    // PXE_VOID Mem_IO(PXE_UINT8 read_write, PXE_UINT8 len, PXE_UINT64 port, 
+    //              PXE_UINT64 buf_addr);
+    //
+    // UNDI will read or write the device io space using this call back 
+    // function. It passes the number of bytes as the len parameter and it 
+    // will be either 1,2,4 or 8.
+    //
+    // This field can not be set to zero.
+    //
+    PXE_UINT64 Mem_IO;
+} PXE_CPB_START;
+
+#define PXE_DELAY_MILLISECOND                   1000
+#define PXE_DELAY_SECOND                    1000000
+#define PXE_IO_READ                     0
+#define PXE_IO_WRITE                        1
+#define PXE_MEM_READ                        2
+#define PXE_MEM_WRITE                       4
+
+
+typedef struct s_pxe_db_get_init_info {
+    //
+    // Minimum length of locked memory buffer that must be given to
+    // the Initialize command. Giving UNDI more memory will generally
+    // give better performance.
+    //
+    // If MemoryRequired is zero, the UNDI does not need and will not
+    // use system memory to receive and transmit packets.
+    //
+    PXE_UINT32 MemoryRequired;
+
+    //
+    // Maximum frame data length for Tx/Rx excluding the media header.
+    //
+    PXE_UINT32 FrameDataLen;
+
+    //
+    // Supported link speeds are in units of mega bits.  Common ethernet
+    // values are 10, 100 and 1000.  Unused LinkSpeeds[] entries are zero
+    // filled.
+    //
+    PXE_UINT32 LinkSpeeds[4];
+
+    //
+    // Number of non-volatile storage items.
+    //
+    PXE_UINT32 NvCount;
+
+    //
+    // Width of non-volatile storage item in bytes.  0, 1, 2 or 4
+    //
+    PXE_UINT16 NvWidth;
+
+    //
+    // Media header length.  This is the typical media header length for
+    // this UNDI.  This information is needed when allocating receive
+    // and transmit buffers.
+    //
+    PXE_UINT16 MediaHeaderLen;
+
+    //
+    // Number of bytes in the NIC hardware (MAC) address.
+    //
+    PXE_UINT16 HWaddrLen;
+
+    //
+    // Maximum number of multicast MAC addresses in the multicast
+    // MAC address filter list.
+    //
+    PXE_UINT16 MCastFilterCnt;
+
+    //
+    // Default number and size of transmit and receive buffers that will 
+    // be allocated by the UNDI.  If MemoryRequired is non-zero, this 
+    // allocation will come out of the memory buffer given to the Initialize 
+    // command.  If MemoryRequired is zero, this allocation will come out of 
+    // memory on the NIC.
+    //
+    PXE_UINT16 TxBufCnt;
+    PXE_UINT16 TxBufSize;
+    PXE_UINT16 RxBufCnt;
+    PXE_UINT16 RxBufSize;
+
+    //
+    // Hardware interface types defined in the Assigned Numbers RFC
+    // and used in DHCP and ARP packets.
+    // See the PXE_IFTYPE typedef and PXE_IFTYPE_xxx macros.
+    //
+    PXE_UINT8 IFtype;
+
+    //
+    // Supported duplex.  See PXE_DUPLEX_xxxxx #defines below.
+    //
+    PXE_UINT8 Duplex;
+
+    //
+    // Supported loopback options.  See PXE_LOOPBACK_xxxxx #defines below.
+    //
+    PXE_UINT8 LoopBack;
+} PXE_DB_GET_INIT_INFO;
+
+#define PXE_MAX_TXRX_UNIT_ETHER             1500
+
+#define PXE_HWADDR_LEN_ETHER                    0x0006
+#define PXE_MAC_HEADER_LEN_ETHER                0x000E
+
+#define PXE_DUPLEX_ENABLE_FULL_SUPPORTED            1
+#define PXE_DUPLEX_FORCE_FULL_SUPPORTED         2
+
+#define PXE_LOOPBACK_INTERNAL_SUPPORTED         1
+#define PXE_LOOPBACK_EXTERNAL_SUPPORTED         2
+
+
+typedef struct s_pxe_pci_config_info {
+    //
+    // This is the flag field for the PXE_DB_GET_CONFIG_INFO union.
+    // For PCI bus devices, this field is set to PXE_BUSTYPE_PCI.
+    //
+    PXE_UINT32 BusType;
+
+    //
+    // This identifies the PCI network device that this UNDI interface
+    // is bound to.
+    //
+    PXE_UINT16 Bus;
+    PXE_UINT8 Device;
+    PXE_UINT8 Function;
+
+    //
+    // This is a copy of the PCI configuration space for this 
+    // network device.
+    //
+    union {
+        PXE_UINT8 Byte[256];
+        PXE_UINT16 Word[128];
+        PXE_UINT32 Dword[64];
+    } Config;
+} PXE_PCI_CONFIG_INFO;
+
+
+typedef struct s_pxe_pcc_config_info {
+    //
+    // This is the flag field for the PXE_DB_GET_CONFIG_INFO union.
+    // For PCC bus devices, this field is set to PXE_BUSTYPE_PCC.
+    //
+    PXE_UINT32 BusType;
+    
+    //
+    // This identifies the PCC network device that this UNDI interface
+    // is bound to.
+    //
+    PXE_UINT16 Bus;
+    PXE_UINT8 Device;
+    PXE_UINT8 Function;
+
+    //
+    // This is a copy of the PCC configuration space for this 
+    // network device.
+    //
+    union {
+        PXE_UINT8 Byte[256];
+        PXE_UINT16 Word[128];
+        PXE_UINT32 Dword[64];
+    } Config;
+} PXE_PCC_CONFIG_INFO;
+
+
+typedef struct s_pxe_usb_config_info {
+    PXE_UINT32 BusType;
+    // %%TBD What should we return here...
+} PXE_USB_CONFIG_INFO;
+
+
+typedef struct s_pxe_1394_config_info {
+    PXE_UINT32 BusType;
+    // %%TBD What should we return here...
+} PXE_1394_CONFIG_INFO;
+
+
+typedef union u_pxe_db_get_config_info {
+    PXE_PCI_CONFIG_INFO pci;
+    PXE_PCC_CONFIG_INFO pcc;
+    PXE_USB_CONFIG_INFO usb;
+    PXE_1394_CONFIG_INFO _1394;
+} PXE_DB_GET_CONFIG_INFO;
+
+
+typedef struct s_pxe_cpb_initialize {
+    //
+    // Address of first (lowest) byte of the memory buffer.  This buffer must
+    // be in contiguous physical memory and cannot be swapped out.  The UNDI
+    // will be using this for transmit and receive buffering.
+    //
+    PXE_UINT64 MemoryAddr;
+
+    //
+    // MemoryLength must be greater than or equal to MemoryRequired
+    // returned by the Get Init Info command.
+    //
+    PXE_UINT32 MemoryLength;
+
+    //
+    // Desired link speed in Mbit/sec.  Common ethernet values are 10, 100
+    // and 1000.  Setting a value of zero will auto-detect and/or use the
+    // default link speed (operation depends on UNDI/NIC functionality).
+    //
+    PXE_UINT32 LinkSpeed;
+
+    //
+    // Suggested number and size of receive and transmit buffers to
+    // allocate.  If MemoryAddr and MemoryLength are non-zero, this
+    // allocation comes out of the supplied memory buffer.  If MemoryAddr 
+    // and MemoryLength are zero, this allocation comes out of memory
+    // on the NIC.
+    //
+    // If these fields are set to zero, the UNDI will allocate buffer
+    // counts and sizes as it sees fit.
+    //
+    PXE_UINT16 TxBufCnt;
+    PXE_UINT16 TxBufSize;
+    PXE_UINT16 RxBufCnt;
+    PXE_UINT16 RxBufSize;
+
+    //
+    // The following configuration parameters are optional and must be zero 
+    // to use the default values.
+    //
+    PXE_UINT8 Duplex; 
+
+    PXE_UINT8 LoopBack;
+} PXE_CPB_INITIALIZE;
+
+
+#define PXE_DUPLEX_DEFAULT                  0x00
+#define PXE_FORCE_FULL_DUPLEX                   0x01
+#define PXE_ENABLE_FULL_DUPLEX              0x02
+
+#define LOOPBACK_NORMAL 0
+#define LOOPBACK_INTERNAL 1
+#define LOOPBACK_EXTERNAL 2
+
+
+typedef struct s_pxe_db_initialize {
+    //
+    // Actual amount of memory used from the supplied memory buffer.  This
+    // may be less that the amount of memory suppllied and may be zero if
+    // the UNDI and network device do not use external memory buffers.
+    //
+    // Memory used by the UNDI and network device is allocated from the 
+    // lowest memory buffer address.
+    //
+    PXE_UINT32 MemoryUsed;
+
+    //
+    // Actual number and size of receive and transmit buffers that were
+    // allocated.
+    //
+    PXE_UINT16 TxBufCnt;
+    PXE_UINT16 TxBufSize;
+    PXE_UINT16 RxBufCnt;
+    PXE_UINT16 RxBufSize;
+} PXE_DB_INITIALIZE;
+
+
+typedef struct s_pxe_cpb_receive_filters {
+    //
+    // List of multicast MAC addresses.  This list, if present, will
+    // replace the existing multicast MAC address filter list.
+    //
+    PXE_MAC_ADDR MCastList[MAX_MCAST_ADDRESS_CNT];
+} PXE_CPB_RECEIVE_FILTERS;
+
+
+typedef struct s_pxe_db_receive_filters {
+    //
+    // Filtered multicast MAC address list.
+    //
+    PXE_MAC_ADDR MCastList[MAX_MCAST_ADDRESS_CNT];
+} PXE_DB_RECEIVE_FILTERS;
+
+
+typedef struct s_pxe_cpb_station_address {
+    //
+    // If supplied and supported, the current station MAC address
+    // will be changed.
+    //
+    PXE_MAC_ADDR StationAddr;
+} PXE_CPB_STATION_ADDRESS;
+
+
+typedef struct s_pxe_dpb_station_address {
+    //
+    // Current station MAC address.
+    //
+    PXE_MAC_ADDR StationAddr;
+
+    //
+    // Station broadcast MAC address.
+    //
+    PXE_MAC_ADDR BroadcastAddr;
+
+    //
+    // Permanent station MAC address.
+    //
+    PXE_MAC_ADDR PermanentAddr;
+} PXE_DB_STATION_ADDRESS;
+
+
+typedef struct s_pxe_db_statistics {
+    //
+    // Bit field identifying what statistic data is collected by the 
+    // UNDI/NIC.
+    // If bit 0x00 is set, Data[0x00] is collected.
+    // If bit 0x01 is set, Data[0x01] is collected.
+    // If bit 0x20 is set, Data[0x20] is collected.
+    // If bit 0x21 is set, Data[0x21] is collected.
+    // Etc.
+    //
+    PXE_UINT64 Supported;
+
+    //
+    // Statistic data.
+    //
+    PXE_UINT64 Data[64];
+} PXE_DB_STATISTICS;
+
+//
+// Total number of frames received.  Includes frames with errors and
+// dropped frames.
+//
+#define PXE_STATISTICS_RX_TOTAL_FRAMES          0x00
+
+//
+// Number of valid frames received and copied into receive buffers.
+//
+#define PXE_STATISTICS_RX_GOOD_FRAMES           0x01
+
+//
+// Number of frames below the minimum length for the media.
+// This would be <64 for ethernet.
+//
+#define PXE_STATISTICS_RX_UNDERSIZE_FRAMES          0x02
+
+//
+// Number of frames longer than the maxminum length for the
+// media.  This would be >1500 for ethernet.
+//
+#define PXE_STATISTICS_RX_OVERSIZE_FRAMES           0x03
+
+//
+// Valid frames that were dropped because receive buffers were full.
+//
+#define PXE_STATISTICS_RX_DROPPED_FRAMES            0x04
+
+//
+// Number of valid unicast frames received and not dropped.
+//
+#define PXE_STATISTICS_RX_UNICAST_FRAMES            0x05
+
+//
+// Number of valid broadcast frames received and not dropped.
+//
+#define PXE_STATISTICS_RX_BROADCAST_FRAMES          0x06
+
+//
+// Number of valid mutlicast frames received and not dropped.
+//
+#define PXE_STATISTICS_RX_MULTICAST_FRAMES          0x07
+
+//
+// Number of frames w/ CRC or alignment errors.
+//
+#define PXE_STATISTICS_RX_CRC_ERROR_FRAMES          0x08
+
+//
+// Total number of bytes received.  Includes frames with errors
+// and dropped frames.
+//
+#define PXE_STATISTICS_RX_TOTAL_BYTES           0x09
+
+//
+// Transmit statistics.
+//
+#define PXE_STATISTICS_TX_TOTAL_FRAMES          0x0A
+#define PXE_STATISTICS_TX_GOOD_FRAMES           0x0B
+#define PXE_STATISTICS_TX_UNDERSIZE_FRAMES          0x0C
+#define PXE_STATISTICS_TX_OVERSIZE_FRAMES           0x0D
+#define PXE_STATISTICS_TX_DROPPED_FRAMES            0x0E
+#define PXE_STATISTICS_TX_UNICAST_FRAMES            0x0F
+#define PXE_STATISTICS_TX_BROADCAST_FRAMES          0x10
+#define PXE_STATISTICS_TX_MULTICAST_FRAMES          0x11
+#define PXE_STATISTICS_TX_CRC_ERROR_FRAMES          0x12
+#define PXE_STATISTICS_TX_TOTAL_BYTES           0x13
+
+//
+// Number of collisions detection on this subnet.
+//
+#define PXE_STATISTICS_COLLISIONS               0x14
+
+//
+// Number of frames destined for unsupported protocol.
+//
+#define PXE_STATISTICS_UNSUPPORTED_PROTOCOL         0x15
+
+
+typedef struct s_pxe_cpb_mcast_ip_to_mac {
+    //
+    // Multicast IP address to be converted to multicast MAC address.
+    //
+    PXE_IP_ADDR IP;
+} PXE_CPB_MCAST_IP_TO_MAC;
+
+
+typedef struct s_pxe_db_mcast_ip_to_mac {
+    //
+    // Multicast MAC address.
+    //
+    PXE_MAC_ADDR MAC;
+} PXE_DB_MCAST_IP_TO_MAC;
+
+
+typedef struct s_pxe_cpb_nvdata_sparse {
+    //
+    // NvData item list.  Only items in this list will be updated.
+    //
+    struct {
+        //  Non-volatile storage address to be changed.
+        PXE_UINT32 Addr;
+
+        // Data item to write into above storage address.
+    
+        union {
+            PXE_UINT8 Byte;
+            PXE_UINT16 Word;
+            PXE_UINT32 Dword;
+        } Data;
+    } Item[MAX_EEPROM_LEN];
+} PXE_CPB_NVDATA_SPARSE;
+
+
+//
+// When using bulk update, the size of the CPB structure must be
+// the same size as the non-volatile NIC storage.
+//
+typedef union u_pxe_cpb_nvdata_bulk {
+    //
+    // Array of byte-wide data items.
+    //
+    PXE_UINT8 Byte[MAX_EEPROM_LEN << 2];
+
+    //
+    // Array of word-wide data items.
+    //
+    PXE_UINT16 Word[MAX_EEPROM_LEN << 1];
+
+    //
+    // Array of dword-wide data items.
+    //
+    PXE_UINT32 Dword[MAX_EEPROM_LEN];
+} PXE_CPB_NVDATA_BULK;
+
+typedef struct s_pxe_db_nvdata {
+
+    // Arrays of data items from non-volatile storage.
+
+    union {
+        //
+        // Array of byte-wide data items.
+        //
+        PXE_UINT8 Byte[MAX_EEPROM_LEN << 2];
+
+        //
+        // Array of word-wide data items.
+        //
+        PXE_UINT16 Word[MAX_EEPROM_LEN << 1];
+
+        // Array of dword-wide data items.
+
+        PXE_UINT32 Dword[MAX_EEPROM_LEN];
+    } Data;
+} PXE_DB_NVDATA;
+
+
+typedef struct s_pxe_db_get_status {
+    //
+    // Length of next receive frame (header + data).  If this is zero,
+    // there is no next receive frame available.
+    //
+    PXE_UINT32 RxFrameLen;
+
+    //
+    // Reserved, set to zero.
+    //
+    PXE_UINT32 reserved;
+
+    //
+    //  Addresses of transmitted buffers that need to be recycled.
+    //
+    PXE_UINT64 TxBuffer[MAX_XMIT_BUFFERS];
+} PXE_DB_GET_STATUS;
+
+
+
+typedef struct s_pxe_cpb_fill_header {
+    //
+    // Source and destination MAC addresses.  These will be copied into
+    // the media header without doing byte swapping.
+    //
+    PXE_MAC_ADDR SrcAddr;
+    PXE_MAC_ADDR DestAddr;
+
+    //
+    // Address of first byte of media header.  The first byte of packet data
+    // follows the last byte of the media header.
+    //
+    PXE_UINT64 MediaHeader;
+
+    //
+    // Length of packet data in bytes (not including the media header).
+    //
+    PXE_UINT32 PacketLen;
+
+    //
+    // Protocol type.  This will be copied into the media header without
+    // doing byte swapping.  Protocol type numbers can be obtained from
+    // the Assigned Numbers RFC 1700.
+    //
+    PXE_UINT16 Protocol;
+
+    //
+    // Length of the media header in bytes.
+    //
+    PXE_UINT16 MediaHeaderLen;
+} PXE_CPB_FILL_HEADER;
+
+
+#define PXE_PROTOCOL_ETHERNET_IP                0x0800
+#define PXE_PROTOCOL_ETHERNET_ARP               0x0806
+#define MAX_XMIT_FRAGMENTS 16
+
+typedef struct s_pxe_cpb_fill_header_fragmented {
+    //
+    // Source and destination MAC addresses.  These will be copied into
+    // the media header without doing byte swapping.
+    //
+    PXE_MAC_ADDR SrcAddr;
+    PXE_MAC_ADDR DestAddr;
+
+    //
+    // Length of packet data in bytes (not including the media header).
+    //
+    PXE_UINT32 PacketLen;
+
+    //
+    // Protocol type.  This will be copied into the media header without
+    // doing byte swapping.  Protocol type numbers can be obtained from
+    // the Assigned Numbers RFC 1700.
+    //
+    PXE_MEDIA_PROTOCOL Protocol;
+
+    //
+    // Length of the media header in bytes.
+    //
+    PXE_UINT16 MediaHeaderLen;
+
+    //
+    // Number of packet fragment descriptors.
+    //
+    PXE_UINT16 FragCnt;
+
+    //
+    // Reserved, must be set to zero.
+    //
+    PXE_UINT16 reserved;
+
+    //
+    // Array of packet fragment descriptors.  The first byte of the media
+    // header is the first byte of the first fragment.
+    //
+    struct {
+        //
+        // Address of this packet fragment.
+        //
+        PXE_UINT64 FragAddr;
+
+        //
+        // Length of this packet fragment.
+        //
+        PXE_UINT32 FragLen;
+
+        //
+        // Reserved, must be set to zero.
+        //
+        PXE_UINT32 reserved;
+    } FragDesc[MAX_XMIT_FRAGMENTS];
+} PXE_CPB_FILL_HEADER_FRAGMENTED;
+
+
+
+typedef struct s_pxe_cpb_transmit {
+    //
+    // Address of first byte of frame buffer.  This is also the first byte
+    // of the media header.
+    //
+    PXE_UINT64 FrameAddr;
+
+    //
+    // Length of the data portion of the frame buffer in bytes.  Do not
+    // include the length of the media header.
+    //
+    PXE_UINT32 DataLen;
+
+    //
+    // Length of the media header in bytes.
+    //
+    PXE_UINT16 MediaheaderLen;
+
+    //
+    // Reserved, must be zero.
+    //
+    PXE_UINT16 reserved;
+} PXE_CPB_TRANSMIT;
+
+
+
+typedef struct s_pxe_cpb_transmit_fragments {
+    //
+    // Length of packet data in bytes (not including the media header).
+    //
+    PXE_UINT32 FrameLen;
+
+    //
+    // Length of the media header in bytes.
+    //
+    PXE_UINT16 MediaheaderLen;
+
+    //
+    // Number of packet fragment descriptors.
+    //
+    PXE_UINT16 FragCnt;
+
+    //
+    // Array of frame fragment descriptors.  The first byte of the first
+    // fragment is also the first byte of the media header.
+    //
+    struct {
+        //
+        // Address of this frame fragment.
+        //
+        PXE_UINT64 FragAddr;
+
+        //
+        // Length of this frame fragment.
+        //
+        PXE_UINT32 FragLen;
+
+        //
+        // Reserved, must be set to zero.
+        //
+        PXE_UINT32 reserved;
+    } FragDesc[MAX_XMIT_FRAGMENTS];
+} PXE_CPB_TRANSMIT_FRAGMENTS;
+
+
+typedef struct s_pxe_cpb_receive {
+    //
+    // Address of first byte of receive buffer.  This is also the first byte
+    // of the frame header.
+    //
+    PXE_UINT64 BufferAddr;
+
+    //
+    // Length of receive buffer.  This must be large enough to hold the
+    // received frame (media header + data).  If the length of smaller than
+    // the received frame, data will be lost.
+    //
+    PXE_UINT32 BufferLen;
+
+    //
+    // Reserved, must be set to zero.
+    //
+    PXE_UINT32 reserved;
+} PXE_CPB_RECEIVE;
+
+
+typedef struct s_pxe_db_receive {
+    //
+    // Source and destination MAC addresses from media header.
+    //
+    PXE_MAC_ADDR SrcAddr;
+    PXE_MAC_ADDR DestAddr;
+
+    //
+    // Length of received frame.  May be larger than receive buffer size.
+    // The receive buffer will not be overwritten.  This is how to tell
+    // if data was lost because the receive buffer was too small.
+    //
+    PXE_UINT32 FrameLen;
+
+    //
+    // Protocol type from media header.
+    //
+    PXE_MEDIA_PROTOCOL Protocol;
+
+    //
+    // Length of media header in received frame.
+    //
+    PXE_UINT16 MediaHeaderLen;
+
+    //
+    // Type of receive frame.
+    //
+    PXE_FRAME_TYPE Type;
+
+    //
+    // Reserved, must be zero.
+    //
+    PXE_UINT8 reserved[7];
+
+} PXE_DB_RECEIVE;
+
+#pragma pack()
+
+/* EOF - efi_pxe.h */
+#endif /* _EFI_PXE_H */
+
diff --git a/linux-x86/gnu-efi/include/efi/efiapi.h b/linux-x86/gnu-efi/include/efi/efiapi.h
new file mode 100644
index 0000000..5e47324
--- /dev/null
+++ b/linux-x86/gnu-efi/include/efi/efiapi.h
@@ -0,0 +1,890 @@
+#ifndef _EFI_API_H
+#define _EFI_API_H
+
+/*++
+
+Copyright (c) 1998  Intel Corporation
+
+Module Name:
+
+    efiapi.h
+
+Abstract:
+
+    Global EFI runtime & boot service interfaces
+
+
+
+
+Revision History
+
+--*/
+
+//
+// EFI Specification Revision
+//
+
+#define EFI_SPECIFICATION_MAJOR_REVISION 1
+#define EFI_SPECIFICATION_MINOR_REVISION 02
+
+//
+// Declare forward referenced data structures
+//
+
+INTERFACE_DECL(_EFI_SYSTEM_TABLE);
+
+//
+// EFI Memory
+//
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_ALLOCATE_PAGES) (
+    IN EFI_ALLOCATE_TYPE            Type,
+    IN EFI_MEMORY_TYPE              MemoryType,
+    IN UINTN                        NoPages,
+    OUT EFI_PHYSICAL_ADDRESS        *Memory
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_FREE_PAGES) (
+    IN EFI_PHYSICAL_ADDRESS         Memory,
+    IN UINTN                        NoPages
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_GET_MEMORY_MAP) (
+    IN OUT UINTN                    *MemoryMapSize,
+    IN OUT EFI_MEMORY_DESCRIPTOR    *MemoryMap,
+    OUT UINTN                       *MapKey,
+    OUT UINTN                       *DescriptorSize,
+    OUT UINT32                      *DescriptorVersion
+    );
+
+#define NextMemoryDescriptor(Ptr,Size)  ((EFI_MEMORY_DESCRIPTOR *) (((UINT8 *) Ptr) + Size))
+
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_ALLOCATE_POOL) (
+    IN EFI_MEMORY_TYPE              PoolType,
+    IN UINTN                        Size,
+    OUT VOID                        **Buffer
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_FREE_POOL) (
+    IN VOID                         *Buffer
+    );
+
+typedef 
+EFI_STATUS
+(EFIAPI *EFI_SET_VIRTUAL_ADDRESS_MAP) (
+    IN UINTN                        MemoryMapSize,
+    IN UINTN                        DescriptorSize,
+    IN UINT32                       DescriptorVersion,
+    IN EFI_MEMORY_DESCRIPTOR        *VirtualMap
+    );
+
+
+#define EFI_OPTIONAL_PTR            0x00000001
+#define EFI_INTERNAL_FNC            0x00000002      // Pointer to internal runtime fnc
+#define EFI_INTERNAL_PTR            0x00000004      // Pointer to internal runtime data
+
+
+typedef 
+EFI_STATUS
+(EFIAPI *EFI_CONVERT_POINTER) (
+    IN UINTN                        DebugDisposition,
+    IN OUT VOID                     **Address
+    );
+
+
+//
+// EFI Events
+//
+
+
+
+#define EVT_TIMER                           0x80000000
+#define EVT_RUNTIME                         0x40000000
+#define EVT_RUNTIME_CONTEXT                 0x20000000
+
+#define EVT_NOTIFY_WAIT                     0x00000100
+#define EVT_NOTIFY_SIGNAL                   0x00000200
+
+#define EVT_SIGNAL_EXIT_BOOT_SERVICES       0x00000201
+#define EVT_SIGNAL_VIRTUAL_ADDRESS_CHANGE   0x60000202
+
+#define EVT_EFI_SIGNAL_MASK                 0x000000FF
+#define EVT_EFI_SIGNAL_MAX                  2
+
+typedef
+VOID
+(EFIAPI *EFI_EVENT_NOTIFY) (
+    IN EFI_EVENT                Event,
+    IN VOID                     *Context
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_CREATE_EVENT) (
+    IN UINT32                       Type,
+    IN EFI_TPL                      NotifyTpl,
+    IN EFI_EVENT_NOTIFY             NotifyFunction,
+    IN VOID                         *NotifyContext,
+    OUT EFI_EVENT                   *Event
+    );
+
+typedef enum {
+    TimerCancel,
+    TimerPeriodic,
+    TimerRelative,
+    TimerTypeMax
+} EFI_TIMER_DELAY;
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_SET_TIMER) (
+    IN EFI_EVENT                Event,
+    IN EFI_TIMER_DELAY          Type,
+    IN UINT64                   TriggerTime
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_SIGNAL_EVENT) (
+    IN EFI_EVENT                Event
+    );
+
+typedef 
+EFI_STATUS
+(EFIAPI *EFI_WAIT_FOR_EVENT) (
+    IN UINTN                    NumberOfEvents,
+    IN EFI_EVENT                *Event,
+    OUT UINTN                   *Index
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_CLOSE_EVENT) (
+    IN EFI_EVENT                Event
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_CHECK_EVENT) (
+    IN EFI_EVENT                Event
+    );
+
+//
+// Task priority level
+//
+
+#define TPL_APPLICATION    4
+#define TPL_CALLBACK       8
+#define TPL_NOTIFY        16 
+#define TPL_HIGH_LEVEL    31 
+
+typedef
+EFI_TPL
+(EFIAPI *EFI_RAISE_TPL) (
+    IN EFI_TPL      NewTpl
+    );
+
+typedef
+VOID
+(EFIAPI *EFI_RESTORE_TPL) (
+    IN EFI_TPL      OldTpl
+    );
+
+
+//
+// EFI platform varibles
+//
+
+#define EFI_GLOBAL_VARIABLE     \
+    { 0x8BE4DF61, 0x93CA, 0x11d2, {0xAA, 0x0D, 0x00, 0xE0, 0x98, 0x03, 0x2B, 0x8C} }
+
+// Variable attributes
+#define EFI_VARIABLE_NON_VOLATILE           0x00000001
+#define EFI_VARIABLE_BOOTSERVICE_ACCESS     0x00000002
+#define EFI_VARIABLE_RUNTIME_ACCESS         0x00000004
+
+// Variable size limitation
+#define EFI_MAXIMUM_VARIABLE_SIZE           1024
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_GET_VARIABLE) (
+    IN CHAR16                       *VariableName,
+    IN EFI_GUID                     *VendorGuid,
+    OUT UINT32                      *Attributes OPTIONAL,
+    IN OUT UINTN                    *DataSize,
+    OUT VOID                        *Data
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_GET_NEXT_VARIABLE_NAME) (
+    IN OUT UINTN                    *VariableNameSize,
+    IN OUT CHAR16                   *VariableName,
+    IN OUT EFI_GUID                 *VendorGuid
+    );
+
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_SET_VARIABLE) (
+    IN CHAR16                       *VariableName,
+    IN EFI_GUID                     *VendorGuid,
+    IN UINT32                       Attributes,
+    IN UINTN                        DataSize,
+    IN VOID                         *Data
+    );
+
+
+//
+// EFI Time
+//
+
+typedef struct {
+        UINT32                      Resolution;     // 1e-6 parts per million
+        UINT32                      Accuracy;       // hertz
+        BOOLEAN                     SetsToZero;     // Set clears sub-second time
+} EFI_TIME_CAPABILITIES;
+
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_GET_TIME) (
+    OUT EFI_TIME                    *Time,
+    OUT EFI_TIME_CAPABILITIES       *Capabilities OPTIONAL
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_SET_TIME) (
+    IN EFI_TIME                     *Time
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_GET_WAKEUP_TIME) (
+    OUT BOOLEAN                     *Enabled,
+    OUT BOOLEAN                     *Pending,
+    OUT EFI_TIME                    *Time
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_SET_WAKEUP_TIME) (
+    IN BOOLEAN                      Enable,
+    IN EFI_TIME                     *Time OPTIONAL
+    );
+
+
+//
+// Image functions
+//
+
+
+// PE32+ Subsystem type for EFI images
+
+#if !defined(IMAGE_SUBSYSTEM_EFI_APPLICATION)
+#define IMAGE_SUBSYSTEM_EFI_APPLICATION             10
+#define IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER     11
+#define IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER          12
+#endif
+
+// PE32+ Machine type for EFI images
+
+#if !defined(EFI_IMAGE_MACHINE_IA32)
+#define EFI_IMAGE_MACHINE_IA32      0x014c
+#endif
+
+#if !defined(EFI_IMAGE_MACHINE_IA64)
+#define EFI_IMAGE_MACHINE_IA64      0x0200
+#endif
+
+// Image Entry prototype
+
+typedef 
+EFI_STATUS
+(EFIAPI *EFI_IMAGE_ENTRY_POINT) (
+    IN EFI_HANDLE                   ImageHandle,
+    IN struct _EFI_SYSTEM_TABLE     *SystemTable
+    );
+
+typedef 
+EFI_STATUS
+(EFIAPI *EFI_IMAGE_LOAD) (
+    IN BOOLEAN                      BootPolicy,
+    IN EFI_HANDLE                   ParentImageHandle,
+    IN EFI_DEVICE_PATH              *FilePath,
+    IN VOID                         *SourceBuffer   OPTIONAL,
+    IN UINTN                        SourceSize,
+    OUT EFI_HANDLE                  *ImageHandle
+    );
+
+typedef 
+EFI_STATUS
+(EFIAPI *EFI_IMAGE_START) (
+    IN EFI_HANDLE                   ImageHandle,
+    OUT UINTN                       *ExitDataSize,
+    OUT CHAR16                      **ExitData  OPTIONAL
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_EXIT) (
+    IN EFI_HANDLE                   ImageHandle,
+    IN EFI_STATUS                   ExitStatus,
+    IN UINTN                        ExitDataSize,
+    IN CHAR16                       *ExitData OPTIONAL
+    );
+
+typedef 
+EFI_STATUS
+(EFIAPI *EFI_IMAGE_UNLOAD) (
+    IN EFI_HANDLE                   ImageHandle
+    );
+
+
+// Image handle
+#define LOADED_IMAGE_PROTOCOL      \
+    { 0x5B1B31A1, 0x9562, 0x11d2, {0x8E, 0x3F, 0x00, 0xA0, 0xC9, 0x69, 0x72, 0x3B} }
+
+#define EFI_IMAGE_INFORMATION_REVISION      0x1000
+typedef struct {
+    UINT32                          Revision;
+    EFI_HANDLE                      ParentHandle;
+    struct _EFI_SYSTEM_TABLE        *SystemTable;
+
+    // Source location of image
+    EFI_HANDLE                      DeviceHandle;
+    EFI_DEVICE_PATH                 *FilePath;
+    VOID                            *Reserved;
+
+    // Images load options
+    UINT32                          LoadOptionsSize;
+    VOID                            *LoadOptions;
+
+    // Location of where image was loaded
+    VOID                            *ImageBase;
+    UINT64                          ImageSize;
+    EFI_MEMORY_TYPE                 ImageCodeType;
+    EFI_MEMORY_TYPE                 ImageDataType;
+
+    // If the driver image supports a dynamic unload request
+    EFI_IMAGE_UNLOAD                Unload;
+
+} EFI_LOADED_IMAGE;
+
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_EXIT_BOOT_SERVICES) (
+    IN EFI_HANDLE                   ImageHandle,
+    IN UINTN                        MapKey
+    );
+
+//
+// Misc
+//
+
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_STALL) (
+    IN UINTN                    Microseconds
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_SET_WATCHDOG_TIMER) (
+    IN UINTN                    Timeout,
+    IN UINT64                   WatchdogCode,
+    IN UINTN                    DataSize,
+    IN CHAR16                   *WatchdogData OPTIONAL
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_CONNECT_CONTROLLER) (
+    IN EFI_HANDLE               ControllerHandle,
+    IN EFI_HANDLE               *DriverImageHandle OPTIONAL,
+    IN EFI_DEVICE_PATH          *RemainingDevicePath OPTIONAL,
+    IN BOOLEAN                  Recursive
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_DISCONNECT_CONTROLLER) (
+    IN EFI_HANDLE               ControllerHandle,
+    IN EFI_HANDLE               DriverImageHandle OPTIONAL,
+    IN EFI_HANDLE               ChildHandle OPTIONAL
+    );
+
+#define EFI_OPEN_PROTOCOL_BY_HANDLE_PROTOCOL  0x00000001
+#define EFI_OPEN_PROTOCOL_GET_PROTOCOL        0x00000002
+#define EFI_OPEN_PROTOCOL_TEST_PROTOCOL       0x00000004
+#define EFI_OPEN_PROTOCOL_BY_CHILD_CONTROLLER 0x00000008
+#define EFI_OPEN_PROTOCOL_BY_DRIVER           0x00000010
+#define EFI_OPEN_PROTOCOL_EXCLUSIVE           0x00000020
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_OPEN_PROTOCOL) (
+    IN EFI_HANDLE               Handle,
+    IN EFI_GUID                 *Protocol,
+    OUT VOID                    **Interface OPTIONAL,
+    IN EFI_HANDLE               AgentHandle,
+    IN EFI_HANDLE               ControllerHandle,
+    IN UINT32                   Attributes
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_CLOSE_PROTOCOL) (
+    IN EFI_HANDLE               Handle,
+    IN EFI_GUID                 *Protocol,
+    IN EFI_HANDLE               AgentHandle,
+    IN EFI_HANDLE               ControllerHandle
+    );
+
+typedef struct {
+    EFI_HANDLE                  AgentHandle;
+    EFI_HANDLE                  ControllerHandle;
+    UINT32                      Attributes;
+    UINT32                      OpenCount;
+} EFI_OPEN_PROTOCOL_INFORMATION_ENTRY;
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_OPEN_PROTOCOL_INFORMATION) (
+    IN EFI_HANDLE               Handle,
+    IN EFI_GUID                 *Protocol,
+    OUT EFI_OPEN_PROTOCOL_INFORMATION_ENTRY **EntryBuffer,
+    OUT UINTN                   *EntryCount
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PROTOCOLS_PER_HANDLE) (
+    IN EFI_HANDLE               Handle,
+    OUT EFI_GUID                ***ProtocolBuffer,
+    OUT UINTN                   *ProtocolBufferCount
+    );
+
+typedef enum {
+    AllHandles,
+    ByRegisterNotify,
+    ByProtocol
+} EFI_LOCATE_SEARCH_TYPE;
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_LOCATE_HANDLE_BUFFER) (
+    IN EFI_LOCATE_SEARCH_TYPE   SearchType,
+    IN EFI_GUID                 *Protocol OPTIONAL,
+    IN VOID                     *SearchKey OPTIONAL,
+    IN OUT UINTN                *NoHandles,
+    OUT EFI_HANDLE              **Buffer
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_LOCATE_PROTOCOL) (
+    IN EFI_GUID                 *Protocol,
+    IN VOID                     *Registration OPTIONAL,
+    OUT VOID                    **Interface
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_INSTALL_MULTIPLE_PROTOCOL_INTERFACES) (
+    IN OUT EFI_HANDLE           *Handle,
+    ...
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_UNINSTALL_MULTIPLE_PROTOCOL_INTERFACES) (
+    IN OUT EFI_HANDLE           Handle,
+    ...
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_CALCULATE_CRC32) (
+    IN VOID                     *Data,
+    IN UINTN                    DataSize,
+    OUT UINT32                  *Crc32
+    );
+
+typedef
+VOID
+(EFIAPI *EFI_COPY_MEM) (
+    IN VOID                     *Destination,
+    IN VOID                     *Source,
+    IN UINTN                    Length
+    );
+
+typedef
+VOID
+(EFIAPI *EFI_SET_MEM) (
+    IN VOID                     *Buffer,
+    IN UINTN                    Size,
+    IN UINT8                    Value
+    );
+
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_CREATE_EVENT_EX) (
+    IN UINT32                   Type,
+    IN EFI_TPL                  NotifyTpl,
+    IN EFI_EVENT_NOTIFY         NotifyFunction OPTIONAL,
+    IN const VOID               *NotifyContext OPTIONAL,
+    IN const EFI_GUID           EventGroup OPTIONAL,
+    OUT EFI_EVENT               *Event
+    );
+
+typedef enum {
+    EfiResetCold,
+    EfiResetWarm,
+    EfiResetShutdown
+} EFI_RESET_TYPE;
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_RESET_SYSTEM) (
+    IN EFI_RESET_TYPE           ResetType,
+    IN EFI_STATUS               ResetStatus,
+    IN UINTN                    DataSize,
+    IN CHAR16                   *ResetData OPTIONAL
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_GET_NEXT_MONOTONIC_COUNT) (
+    OUT UINT64                  *Count
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_GET_NEXT_HIGH_MONO_COUNT) (
+    OUT UINT32                  *HighCount
+    );
+
+//
+// Protocol handler functions
+//
+
+typedef enum {
+    EFI_NATIVE_INTERFACE,
+    EFI_PCODE_INTERFACE
+} EFI_INTERFACE_TYPE;
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_INSTALL_PROTOCOL_INTERFACE) (
+    IN OUT EFI_HANDLE           *Handle,
+    IN EFI_GUID                 *Protocol,
+    IN EFI_INTERFACE_TYPE       InterfaceType,
+    IN VOID                     *Interface
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_REINSTALL_PROTOCOL_INTERFACE) (
+    IN EFI_HANDLE               Handle,
+    IN EFI_GUID                 *Protocol,
+    IN VOID                     *OldInterface,
+    IN VOID                     *NewInterface
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_UNINSTALL_PROTOCOL_INTERFACE) (
+    IN EFI_HANDLE               Handle,
+    IN EFI_GUID                 *Protocol,
+    IN VOID                     *Interface
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_HANDLE_PROTOCOL) (
+    IN EFI_HANDLE               Handle,
+    IN EFI_GUID                 *Protocol,
+    OUT VOID                    **Interface
+    );
+
+typedef
+EFI_STATUS 
+(EFIAPI *EFI_REGISTER_PROTOCOL_NOTIFY) (
+    IN EFI_GUID                 *Protocol,
+    IN EFI_EVENT                Event,
+    OUT VOID                    **Registration
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_LOCATE_HANDLE) (
+    IN EFI_LOCATE_SEARCH_TYPE   SearchType,
+    IN EFI_GUID                 *Protocol OPTIONAL,
+    IN VOID                     *SearchKey OPTIONAL,
+    IN OUT UINTN                *BufferSize,
+    OUT EFI_HANDLE              *Buffer
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_LOCATE_DEVICE_PATH) (
+    IN EFI_GUID                 *Protocol,
+    IN OUT EFI_DEVICE_PATH      **DevicePath,
+    OUT EFI_HANDLE              *Device
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_INSTALL_CONFIGURATION_TABLE) (
+    IN EFI_GUID                 *Guid,
+    IN VOID                     *Table
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_RESERVED_SERVICE) (
+    );
+
+//
+// Standard EFI table header
+//
+
+typedef struct _EFI_TABLE_HEARDER {
+    UINT64                      Signature;
+    UINT32                      Revision;
+    UINT32                      HeaderSize;
+    UINT32                      CRC32;
+    UINT32                      Reserved;
+} EFI_TABLE_HEADER;
+
+
+//
+// EFI Runtime Serivces Table
+//
+
+#define EFI_RUNTIME_SERVICES_SIGNATURE  0x56524553544e5552
+#define EFI_RUNTIME_SERVICES_REVISION   (EFI_SPECIFICATION_MAJOR_REVISION<<16) | (EFI_SPECIFICATION_MINOR_REVISION)
+
+typedef struct  {
+    EFI_TABLE_HEADER                Hdr;
+
+    //
+    // Time services
+    //
+
+    EFI_GET_TIME                    GetTime;
+    EFI_SET_TIME                    SetTime;
+    EFI_GET_WAKEUP_TIME             GetWakeupTime;
+    EFI_SET_WAKEUP_TIME             SetWakeupTime;
+
+    //
+    // Virtual memory services
+    //
+
+    EFI_SET_VIRTUAL_ADDRESS_MAP     SetVirtualAddressMap;
+    EFI_CONVERT_POINTER             ConvertPointer;
+
+    //
+    // Variable serviers
+    //
+
+    EFI_GET_VARIABLE                GetVariable;
+    EFI_GET_NEXT_VARIABLE_NAME      GetNextVariableName;
+    EFI_SET_VARIABLE                SetVariable;
+
+    //
+    // Misc
+    //
+
+    EFI_GET_NEXT_HIGH_MONO_COUNT    GetNextHighMonotonicCount;
+    EFI_RESET_SYSTEM                ResetSystem;
+
+} EFI_RUNTIME_SERVICES;
+
+
+//
+// EFI Boot Services Table
+//
+
+#define EFI_BOOT_SERVICES_SIGNATURE     0x56524553544f4f42
+#define EFI_BOOT_SERVICES_REVISION      (EFI_SPECIFICATION_MAJOR_REVISION<<16) | (EFI_SPECIFICATION_MINOR_REVISION)
+
+typedef struct _EFI_BOOT_SERVICES {
+
+    EFI_TABLE_HEADER                Hdr;
+
+    //
+    // Task priority functions
+    //
+
+    EFI_RAISE_TPL                   RaiseTPL;
+    EFI_RESTORE_TPL                 RestoreTPL;
+
+    //
+    // Memory functions
+    //
+
+    EFI_ALLOCATE_PAGES              AllocatePages;
+    EFI_FREE_PAGES                  FreePages;
+    EFI_GET_MEMORY_MAP              GetMemoryMap;
+    EFI_ALLOCATE_POOL               AllocatePool;
+    EFI_FREE_POOL                   FreePool;
+
+    //
+    // Event & timer functions
+    //
+
+    EFI_CREATE_EVENT                CreateEvent;
+    EFI_SET_TIMER                   SetTimer;
+    EFI_WAIT_FOR_EVENT              WaitForEvent;
+    EFI_SIGNAL_EVENT                SignalEvent;
+    EFI_CLOSE_EVENT                 CloseEvent;
+    EFI_CHECK_EVENT                 CheckEvent;
+
+    //
+    // Protocol handler functions
+    //
+
+    EFI_INSTALL_PROTOCOL_INTERFACE  InstallProtocolInterface;
+    EFI_REINSTALL_PROTOCOL_INTERFACE ReinstallProtocolInterface;
+    EFI_UNINSTALL_PROTOCOL_INTERFACE UninstallProtocolInterface;
+    EFI_HANDLE_PROTOCOL             HandleProtocol;
+    EFI_HANDLE_PROTOCOL             PCHandleProtocol;
+    EFI_REGISTER_PROTOCOL_NOTIFY    RegisterProtocolNotify;
+    EFI_LOCATE_HANDLE               LocateHandle;
+    EFI_LOCATE_DEVICE_PATH          LocateDevicePath;
+    EFI_INSTALL_CONFIGURATION_TABLE InstallConfigurationTable;
+
+    //
+    // Image functions
+    //
+
+    EFI_IMAGE_LOAD                  LoadImage;
+    EFI_IMAGE_START                 StartImage;
+    EFI_EXIT                        Exit;
+    EFI_IMAGE_UNLOAD                UnloadImage;
+    EFI_EXIT_BOOT_SERVICES          ExitBootServices;
+
+    //
+    // Misc functions
+    //
+
+    EFI_GET_NEXT_MONOTONIC_COUNT    GetNextMonotonicCount;
+    EFI_STALL                       Stall;
+    EFI_SET_WATCHDOG_TIMER          SetWatchdogTimer;
+
+    //
+    // DriverSupport Services
+    //
+
+    EFI_CONNECT_CONTROLLER          ConnectController;
+    EFI_DISCONNECT_CONTROLLER       DisconnectController;
+
+    //
+    // Open and Close Protocol Services
+    //
+    EFI_OPEN_PROTOCOL               OpenProtocol;
+    EFI_CLOSE_PROTOCOL              CloseProtocol;
+    EFI_OPEN_PROTOCOL_INFORMATION   OpenProtocolInformation;
+
+    //
+    // Library Services
+    //
+    EFI_PROTOCOLS_PER_HANDLE        ProtocolsPerHandle;
+    EFI_LOCATE_HANDLE_BUFFER        LocateHandleBuffer;
+    EFI_LOCATE_PROTOCOL             LocateProtocol;
+    EFI_INSTALL_MULTIPLE_PROTOCOL_INTERFACES InstallMultipleProtocolInterfaces;
+    EFI_UNINSTALL_MULTIPLE_PROTOCOL_INTERFACES UninstallMultipleProtocolInterfaces;
+
+    //
+    // 32-bit CRC Services
+    //
+    EFI_CALCULATE_CRC32             CalculateCrc32;
+
+    //
+    // Misc Services
+    //
+    EFI_COPY_MEM                    CopyMem;
+    EFI_SET_MEM                     SetMem;
+    EFI_CREATE_EVENT_EX             CreateEventEx;
+} EFI_BOOT_SERVICES;
+
+
+//
+// EFI Configuration Table and GUID definitions
+//
+
+#define MPS_TABLE_GUID    \
+    { 0xeb9d2d2f, 0x2d88, 0x11d3, {0x9a, 0x16, 0x0, 0x90, 0x27, 0x3f, 0xc1, 0x4d} }
+
+#define ACPI_TABLE_GUID    \
+    { 0xeb9d2d30, 0x2d88, 0x11d3, {0x9a, 0x16, 0x0, 0x90, 0x27, 0x3f, 0xc1, 0x4d} }
+
+#define ACPI_20_TABLE_GUID  \
+    { 0x8868e871, 0xe4f1, 0x11d3, {0xbc, 0x22, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81} }
+
+#define SMBIOS_TABLE_GUID    \
+    { 0xeb9d2d31, 0x2d88, 0x11d3, {0x9a, 0x16, 0x0, 0x90, 0x27, 0x3f, 0xc1, 0x4d} }
+
+#define SAL_SYSTEM_TABLE_GUID    \
+    { 0xeb9d2d32, 0x2d88, 0x11d3, {0x9a, 0x16, 0x0, 0x90, 0x27, 0x3f, 0xc1, 0x4d} }
+
+
+typedef struct _EFI_CONFIGURATION_TABLE {
+    EFI_GUID                VendorGuid;
+    VOID                    *VendorTable;
+} EFI_CONFIGURATION_TABLE;
+
+
+//
+// EFI System Table
+//
+
+
+
+
+#define EFI_SYSTEM_TABLE_SIGNATURE      0x5453595320494249
+#define EFI_SYSTEM_TABLE_REVISION      (EFI_SPECIFICATION_MAJOR_REVISION<<16) | (EFI_SPECIFICATION_MINOR_REVISION)
+
+typedef struct _EFI_SYSTEM_TABLE {
+    EFI_TABLE_HEADER                Hdr;
+
+    CHAR16                          *FirmwareVendor;
+    UINT32                          FirmwareRevision;
+
+    EFI_HANDLE                      ConsoleInHandle;
+    SIMPLE_INPUT_INTERFACE          *ConIn;
+
+    EFI_HANDLE                      ConsoleOutHandle;
+    SIMPLE_TEXT_OUTPUT_INTERFACE    *ConOut;
+
+    EFI_HANDLE                      StandardErrorHandle;
+    SIMPLE_TEXT_OUTPUT_INTERFACE    *StdErr;
+
+    EFI_RUNTIME_SERVICES            *RuntimeServices;
+    EFI_BOOT_SERVICES               *BootServices;
+
+    UINTN                           NumberOfTableEntries;
+    EFI_CONFIGURATION_TABLE         *ConfigurationTable;
+
+} EFI_SYSTEM_TABLE;
+
+#endif
+
diff --git a/linux-x86/gnu-efi/include/efi/eficon.h b/linux-x86/gnu-efi/include/efi/eficon.h
new file mode 100644
index 0000000..089db98
--- /dev/null
+++ b/linux-x86/gnu-efi/include/efi/eficon.h
@@ -0,0 +1,302 @@
+#ifndef _EFI_CON_H
+#define _EFI_CON_H
+
+/*++
+
+Copyright (c) 1998  Intel Corporation
+
+Module Name:
+
+    eficon.h
+
+Abstract:
+
+    EFI console protocols
+
+
+
+Revision History
+
+--*/
+
+//
+// Text output protocol
+//
+
+#define SIMPLE_TEXT_OUTPUT_PROTOCOL \
+    { 0x387477c2, 0x69c7, 0x11d2, {0x8e, 0x39, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b} }
+
+INTERFACE_DECL(_SIMPLE_TEXT_OUTPUT_INTERFACE);
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_TEXT_RESET) (
+    IN struct _SIMPLE_TEXT_OUTPUT_INTERFACE     *This,
+    IN BOOLEAN                      ExtendedVerification
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_TEXT_OUTPUT_STRING) (
+    IN struct _SIMPLE_TEXT_OUTPUT_INTERFACE     *This,
+    IN CHAR16                       *String
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_TEXT_TEST_STRING) (
+    IN struct _SIMPLE_TEXT_OUTPUT_INTERFACE     *This,
+    IN CHAR16                       *String
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_TEXT_QUERY_MODE) (
+    IN struct _SIMPLE_TEXT_OUTPUT_INTERFACE     *This,
+    IN UINTN                        ModeNumber,
+    OUT UINTN                       *Columns,
+    OUT UINTN                       *Rows
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_TEXT_SET_MODE) (
+    IN struct _SIMPLE_TEXT_OUTPUT_INTERFACE     *This,
+    IN UINTN                        ModeNumber
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_TEXT_SET_ATTRIBUTE) (
+    IN struct _SIMPLE_TEXT_OUTPUT_INTERFACE     *This,
+    IN UINTN                        Attribute
+    );
+
+#define EFI_BLACK   0x00
+#define EFI_BLUE    0x01
+#define EFI_GREEN   0x02
+#define EFI_CYAN            (EFI_BLUE | EFI_GREEN)
+#define EFI_RED     0x04
+#define EFI_MAGENTA         (EFI_BLUE | EFI_RED)
+#define EFI_BROWN           (EFI_GREEN | EFI_RED)
+#define EFI_LIGHTGRAY       (EFI_BLUE | EFI_GREEN | EFI_RED)
+#define EFI_BRIGHT  0x08
+#define EFI_DARKGRAY        (EFI_BRIGHT)
+#define EFI_LIGHTBLUE       (EFI_BLUE | EFI_BRIGHT)
+#define EFI_LIGHTGREEN      (EFI_GREEN | EFI_BRIGHT)
+#define EFI_LIGHTCYAN       (EFI_CYAN | EFI_BRIGHT)
+#define EFI_LIGHTRED        (EFI_RED | EFI_BRIGHT)
+#define EFI_LIGHTMAGENTA    (EFI_MAGENTA | EFI_BRIGHT)
+#define EFI_YELLOW          (EFI_BROWN | EFI_BRIGHT)
+#define EFI_WHITE           (EFI_BLUE | EFI_GREEN | EFI_RED | EFI_BRIGHT)
+
+#define EFI_TEXT_ATTR(f,b)  ((f) | ((b) << 4))
+
+#define EFI_BACKGROUND_BLACK        0x00
+#define EFI_BACKGROUND_BLUE         0x10
+#define EFI_BACKGROUND_GREEN        0x20
+#define EFI_BACKGROUND_CYAN         (EFI_BACKGROUND_BLUE | EFI_BACKGROUND_GREEN)
+#define EFI_BACKGROUND_RED          0x40
+#define EFI_BACKGROUND_MAGENTA      (EFI_BACKGROUND_BLUE | EFI_BACKGROUND_RED)
+#define EFI_BACKGROUND_BROWN        (EFI_BACKGROUND_GREEN | EFI_BACKGROUND_RED)
+#define EFI_BACKGROUND_LIGHTGRAY    (EFI_BACKGROUND_BLUE | EFI_BACKGROUND_GREEN | EFI_BACKGROUND_RED)
+
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_TEXT_CLEAR_SCREEN) (
+    IN struct _SIMPLE_TEXT_OUTPUT_INTERFACE     *This
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_TEXT_SET_CURSOR_POSITION) (
+    IN struct _SIMPLE_TEXT_OUTPUT_INTERFACE     *This,
+    IN UINTN                        Column,
+    IN UINTN                        Row
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_TEXT_ENABLE_CURSOR) (
+    IN struct _SIMPLE_TEXT_OUTPUT_INTERFACE     *This,
+    IN BOOLEAN                      Enable
+    );
+
+typedef struct {
+    INT32                           MaxMode;
+    // current settings
+    INT32                           Mode;
+    INT32                           Attribute;
+    INT32                           CursorColumn;
+    INT32                           CursorRow;
+    BOOLEAN                         CursorVisible;
+} SIMPLE_TEXT_OUTPUT_MODE;
+
+typedef struct _SIMPLE_TEXT_OUTPUT_INTERFACE {
+    EFI_TEXT_RESET                  Reset;
+
+    EFI_TEXT_OUTPUT_STRING          OutputString;
+    EFI_TEXT_TEST_STRING            TestString;
+
+    EFI_TEXT_QUERY_MODE             QueryMode;
+    EFI_TEXT_SET_MODE               SetMode;
+    EFI_TEXT_SET_ATTRIBUTE          SetAttribute;
+
+    EFI_TEXT_CLEAR_SCREEN           ClearScreen;
+    EFI_TEXT_SET_CURSOR_POSITION    SetCursorPosition;
+    EFI_TEXT_ENABLE_CURSOR          EnableCursor;
+
+    // Current mode
+    SIMPLE_TEXT_OUTPUT_MODE         *Mode;
+} SIMPLE_TEXT_OUTPUT_INTERFACE;
+
+//
+// Define's for required EFI Unicode Box Draw character
+//
+
+#define BOXDRAW_HORIZONTAL                  0x2500
+#define BOXDRAW_VERTICAL                    0x2502
+#define BOXDRAW_DOWN_RIGHT                  0x250c
+#define BOXDRAW_DOWN_LEFT                   0x2510
+#define BOXDRAW_UP_RIGHT                    0x2514
+#define BOXDRAW_UP_LEFT                     0x2518
+#define BOXDRAW_VERTICAL_RIGHT              0x251c
+#define BOXDRAW_VERTICAL_LEFT               0x2524
+#define BOXDRAW_DOWN_HORIZONTAL             0x252c
+#define BOXDRAW_UP_HORIZONTAL               0x2534
+#define BOXDRAW_VERTICAL_HORIZONTAL         0x253c
+
+#define BOXDRAW_DOUBLE_HORIZONTAL           0x2550
+#define BOXDRAW_DOUBLE_VERTICAL             0x2551
+#define BOXDRAW_DOWN_RIGHT_DOUBLE           0x2552
+#define BOXDRAW_DOWN_DOUBLE_RIGHT           0x2553
+#define BOXDRAW_DOUBLE_DOWN_RIGHT           0x2554
+
+#define BOXDRAW_DOWN_LEFT_DOUBLE            0x2555
+#define BOXDRAW_DOWN_DOUBLE_LEFT            0x2556
+#define BOXDRAW_DOUBLE_DOWN_LEFT            0x2557
+
+#define BOXDRAW_UP_RIGHT_DOUBLE             0x2558
+#define BOXDRAW_UP_DOUBLE_RIGHT             0x2559
+#define BOXDRAW_DOUBLE_UP_RIGHT             0x255a
+
+#define BOXDRAW_UP_LEFT_DOUBLE              0x255b
+#define BOXDRAW_UP_DOUBLE_LEFT              0x255c
+#define BOXDRAW_DOUBLE_UP_LEFT              0x255d
+
+#define BOXDRAW_VERTICAL_RIGHT_DOUBLE       0x255e
+#define BOXDRAW_VERTICAL_DOUBLE_RIGHT       0x255f
+#define BOXDRAW_DOUBLE_VERTICAL_RIGHT       0x2560
+
+#define BOXDRAW_VERTICAL_LEFT_DOUBLE        0x2561
+#define BOXDRAW_VERTICAL_DOUBLE_LEFT        0x2562
+#define BOXDRAW_DOUBLE_VERTICAL_LEFT        0x2563
+
+#define BOXDRAW_DOWN_HORIZONTAL_DOUBLE      0x2564
+#define BOXDRAW_DOWN_DOUBLE_HORIZONTAL      0x2565
+#define BOXDRAW_DOUBLE_DOWN_HORIZONTAL      0x2566
+
+#define BOXDRAW_UP_HORIZONTAL_DOUBLE        0x2567
+#define BOXDRAW_UP_DOUBLE_HORIZONTAL        0x2568
+#define BOXDRAW_DOUBLE_UP_HORIZONTAL        0x2569
+
+#define BOXDRAW_VERTICAL_HORIZONTAL_DOUBLE  0x256a
+#define BOXDRAW_VERTICAL_DOUBLE_HORIZONTAL  0x256b
+#define BOXDRAW_DOUBLE_VERTICAL_HORIZONTAL  0x256c
+
+//
+// EFI Required Block Elements Code Chart
+//
+
+#define BLOCKELEMENT_FULL_BLOCK             0x2588
+#define BLOCKELEMENT_LIGHT_SHADE            0x2591
+//
+// EFI Required Geometric Shapes Code Chart
+//
+
+#define GEOMETRICSHAPE_UP_TRIANGLE           0x25b2
+#define GEOMETRICSHAPE_RIGHT_TRIANGLE        0x25ba
+#define GEOMETRICSHAPE_DOWN_TRIANGLE         0x25bc
+#define GEOMETRICSHAPE_LEFT_TRIANGLE         0x25c4
+
+//
+// EFI Required Arrow shapes
+//
+
+#define ARROW_UP                            0x2191
+#define ARROW_DOWN                          0x2193
+
+//
+// Text input protocol
+//
+
+#define SIMPLE_TEXT_INPUT_PROTOCOL  \
+    { 0x387477c1, 0x69c7, 0x11d2, {0x8e, 0x39, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b} }
+
+INTERFACE_DECL(_SIMPLE_INPUT_INTERFACE);
+
+typedef struct {
+    UINT16                              ScanCode;
+    CHAR16                              UnicodeChar;
+} EFI_INPUT_KEY;
+
+//
+// Baseline unicode control chars
+//
+
+#define CHAR_NULL                       0x0000
+#define CHAR_BACKSPACE                  0x0008
+#define CHAR_TAB                        0x0009
+#define CHAR_LINEFEED                   0x000A
+#define CHAR_CARRIAGE_RETURN            0x000D
+
+//
+// Scan codes for base line keys
+//
+
+#define SCAN_NULL                       0x0000
+#define SCAN_UP                         0x0001
+#define SCAN_DOWN                       0x0002
+#define SCAN_RIGHT                      0x0003
+#define SCAN_LEFT                       0x0004
+#define SCAN_HOME                       0x0005
+#define SCAN_END                        0x0006
+#define SCAN_INSERT                     0x0007
+#define SCAN_DELETE                     0x0008
+#define SCAN_PAGE_UP                    0x0009
+#define SCAN_PAGE_DOWN                  0x000A
+#define SCAN_F1                         0x000B
+#define SCAN_F2                         0x000C
+#define SCAN_F3                         0x000D
+#define SCAN_F4                         0x000E
+#define SCAN_F5                         0x000F
+#define SCAN_F6                         0x0010
+#define SCAN_F7                         0x0011
+#define SCAN_F8                         0x0012
+#define SCAN_F9                         0x0013
+#define SCAN_F10                        0x0014
+#define SCAN_ESC                        0x0017
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_INPUT_RESET) (
+    IN struct _SIMPLE_INPUT_INTERFACE   *This,
+    IN BOOLEAN                          ExtendedVerification
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_INPUT_READ_KEY) (
+    IN struct _SIMPLE_INPUT_INTERFACE   *This,
+    OUT EFI_INPUT_KEY                   *Key
+    );
+
+typedef struct _SIMPLE_INPUT_INTERFACE {
+    EFI_INPUT_RESET                     Reset;
+    EFI_INPUT_READ_KEY                  ReadKeyStroke;
+    EFI_EVENT                           WaitForKey;
+} SIMPLE_INPUT_INTERFACE;
+
+#endif
+
diff --git a/linux-x86/gnu-efi/include/efi/efidebug.h b/linux-x86/gnu-efi/include/efi/efidebug.h
new file mode 100644
index 0000000..f95d492
--- /dev/null
+++ b/linux-x86/gnu-efi/include/efi/efidebug.h
@@ -0,0 +1,110 @@
+#ifndef _EFI_DEBUG_H
+#define _EFI_DEBUG_H
+
+/*++
+
+Copyright (c) 1998  Intel Corporation
+
+Module Name:
+
+    efidebug.h
+
+Abstract:
+
+    EFI library debug functions
+
+
+
+Revision History
+
+--*/
+
+extern UINTN     EFIDebug;
+
+#if EFI_DEBUG
+
+    #define DBGASSERT(a)        DbgAssert(__FILE__, __LINE__, #a)
+    #define DEBUG(a)            DbgPrint a
+    
+#else
+
+    #define DBGASSERT(a)
+    #define DEBUG(a)
+    
+#endif
+
+#if EFI_DEBUG_CLEAR_MEMORY
+
+    #define DBGSETMEM(a,l)      SetMem(a,l,(CHAR8)BAD_POINTER)
+
+#else
+
+    #define DBGSETMEM(a,l)
+
+#endif
+
+#define D_INIT        0x00000001          // Initialization style messages
+#define D_WARN        0x00000002          // Warnings
+#define D_LOAD        0x00000004          // Load events
+#define D_FS          0x00000008          // EFI File system
+#define D_POOL        0x00000010          // Alloc & Free's
+#define D_PAGE        0x00000020          // Alloc & Free's
+#define D_INFO        0x00000040          // Verbose
+#define D_VAR         0x00000100          // Variable
+#define D_PARSE       0x00000200          // Command parsing
+#define D_BM          0x00000400          // Boot manager
+#define D_BLKIO       0x00001000          // BlkIo Driver
+#define D_BLKIO_ULTRA 0x00002000          // BlkIo Driver
+#define D_NET         0x00004000          // SNI Driver
+#define D_NET_ULTRA   0x00008000          // SNI Driver
+#define D_TXTIN       0x00010000          // Simple Input Driver
+#define D_TXTOUT      0x00020000          // Simple Text Output Driver
+#define D_ERROR_ATA	  0x00040000		  		// ATA error messages 
+#define D_ERROR       0x80000000          // Error
+
+#define D_RESERVED    0x7fffC880          // Bits not reserved above
+
+//
+// Current Debug level of the system, value of EFIDebug
+//
+//#define EFI_DBUG_MASK   (D_ERROR | D_WARN | D_LOAD | D_BLKIO | D_INIT)
+#define EFI_DBUG_MASK   (D_ERROR)
+
+//
+//
+//
+
+#if EFI_DEBUG
+
+    #define ASSERT(a)               if(!(a))       DBGASSERT(a)
+    #define ASSERT_LOCKED(l)        if(!(l)->Lock) DBGASSERT(l not locked)
+    #define ASSERT_STRUCT(p,t)      DBGASSERT(t not structure), p
+
+#else
+
+    #define ASSERT(a)               
+    #define ASSERT_LOCKED(l)        
+    #define ASSERT_STRUCT(p,t)      
+
+#endif
+
+//
+// Prototypes
+//
+
+INTN
+DbgAssert (
+    CHAR8   *file,
+    INTN    lineno,
+    CHAR8   *string
+    );
+
+INTN
+DbgPrint (
+    INTN    mask,
+    CHAR8   *format,
+    ...
+    );
+
+#endif
+
diff --git a/linux-x86/gnu-efi/include/efi/efidef.h b/linux-x86/gnu-efi/include/efi/efidef.h
new file mode 100644
index 0000000..07fdf0d
--- /dev/null
+++ b/linux-x86/gnu-efi/include/efi/efidef.h
@@ -0,0 +1,196 @@
+#ifndef _EFI_DEF_H
+#define _EFI_DEF_H
+
+/*++
+
+Copyright (c) 1998  Intel Corporation
+
+Module Name:
+
+    efidef.h
+
+Abstract:
+
+    EFI definitions
+
+
+
+
+Revision History
+
+--*/
+
+typedef UINT16          CHAR16;
+typedef UINT8           CHAR8;
+typedef UINT8           BOOLEAN;
+
+#ifndef TRUE
+    #define TRUE    ((BOOLEAN) 1)
+    #define FALSE   ((BOOLEAN) 0)
+#endif
+
+#ifndef NULL
+    #define NULL    ((VOID *) 0)
+#endif
+
+typedef UINTN           EFI_STATUS;
+typedef UINT64          EFI_LBA;
+typedef UINTN           EFI_TPL;
+typedef VOID            *EFI_HANDLE;
+typedef VOID            *EFI_EVENT;
+
+
+//
+// Prototype argument decoration for EFI parameters to indicate
+// their direction
+//
+// IN - argument is passed into the function
+// OUT - argument (pointer) is returned from the function
+// OPTIONAL - argument is optional
+//
+
+#ifndef IN
+    #define IN
+    #define OUT
+    #define OPTIONAL
+#endif
+
+
+//
+// A GUID
+//
+
+typedef struct {          
+    UINT32  Data1;
+    UINT16  Data2;
+    UINT16  Data3;
+    UINT8   Data4[8]; 
+} EFI_GUID;
+
+
+//
+// Time
+//
+
+typedef struct {          
+    UINT16      Year;       // 1998 - 20XX
+    UINT8       Month;      // 1 - 12
+    UINT8       Day;        // 1 - 31
+    UINT8       Hour;       // 0 - 23
+    UINT8       Minute;     // 0 - 59
+    UINT8       Second;     // 0 - 59
+    UINT8       Pad1;
+    UINT32      Nanosecond; // 0 - 999,999,999
+    INT16       TimeZone;   // -1440 to 1440 or 2047
+    UINT8       Daylight;
+    UINT8       Pad2;
+} EFI_TIME;
+
+// Bit definitions for EFI_TIME.Daylight
+#define EFI_TIME_ADJUST_DAYLIGHT    0x01
+#define EFI_TIME_IN_DAYLIGHT        0x02
+
+// Value definition for EFI_TIME.TimeZone
+#define EFI_UNSPECIFIED_TIMEZONE    0x07FF
+
+
+
+//
+// Networking
+//
+
+typedef struct {
+    UINT8                   Addr[4];
+} EFI_IPv4_ADDRESS;
+
+typedef struct {
+    UINT8                   Addr[16];
+} EFI_IPv6_ADDRESS;
+
+typedef struct {
+    UINT8                   Addr[32];
+} EFI_MAC_ADDRESS;
+
+//
+// Memory
+//
+
+typedef UINT64          EFI_PHYSICAL_ADDRESS;
+typedef UINT64          EFI_VIRTUAL_ADDRESS;
+
+typedef enum {
+    AllocateAnyPages,
+    AllocateMaxAddress,
+    AllocateAddress,
+    MaxAllocateType
+} EFI_ALLOCATE_TYPE;
+
+//Preseve the attr on any range supplied.
+//ConventialMemory must have WB,SR,SW when supplied.
+//When allocating from ConventialMemory always make it WB,SR,SW
+//When returning to ConventialMemory always make it WB,SR,SW
+//When getting the memory map, or on RT for runtime types
+
+
+typedef enum {
+    EfiReservedMemoryType,
+    EfiLoaderCode,
+    EfiLoaderData,
+    EfiBootServicesCode,
+    EfiBootServicesData,
+    EfiRuntimeServicesCode,
+    EfiRuntimeServicesData,
+    EfiConventionalMemory,
+    EfiUnusableMemory,
+    EfiACPIReclaimMemory,
+    EfiACPIMemoryNVS,
+    EfiMemoryMappedIO,
+    EfiMemoryMappedIOPortSpace,
+    EfiPalCode,
+    EfiMaxMemoryType
+} EFI_MEMORY_TYPE;
+
+// possible caching types for the memory range
+#define EFI_MEMORY_UC           0x0000000000000001
+#define EFI_MEMORY_WC           0x0000000000000002
+#define EFI_MEMORY_WT           0x0000000000000004
+#define EFI_MEMORY_WB           0x0000000000000008
+#define EFI_MEMORY_UCE          0x0000000000000010  
+
+// physical memory protection on range 
+#define EFI_MEMORY_WP           0x0000000000001000
+#define EFI_MEMORY_RP           0x0000000000002000
+#define EFI_MEMORY_XP           0x0000000000004000
+
+// range requires a runtime mapping
+#define EFI_MEMORY_RUNTIME      0x8000000000000000
+
+#define EFI_MEMORY_DESCRIPTOR_VERSION  1
+typedef struct {
+    UINT32                          Type;           // Field size is 32 bits followed by 32 bit pad
+    UINT32                          Pad;
+    EFI_PHYSICAL_ADDRESS            PhysicalStart;  // Field size is 64 bits
+    EFI_VIRTUAL_ADDRESS             VirtualStart;   // Field size is 64 bits
+    UINT64                          NumberOfPages;  // Field size is 64 bits
+    UINT64                          Attribute;      // Field size is 64 bits
+} EFI_MEMORY_DESCRIPTOR;
+
+//
+// International Language
+//
+
+typedef UINT8   ISO_639_2;
+#define ISO_639_2_ENTRY_SIZE    3
+
+//
+//
+//
+
+#define EFI_PAGE_SIZE   4096
+#define EFI_PAGE_MASK   0xFFF
+#define EFI_PAGE_SHIFT  12
+
+#define EFI_SIZE_TO_PAGES(a)  \
+    ( ((a) >> EFI_PAGE_SHIFT) + ((a) & EFI_PAGE_MASK ? 1 : 0) )
+
+#endif
diff --git a/linux-x86/gnu-efi/include/efi/efidevp.h b/linux-x86/gnu-efi/include/efi/efidevp.h
new file mode 100644
index 0000000..beb5785
--- /dev/null
+++ b/linux-x86/gnu-efi/include/efi/efidevp.h
@@ -0,0 +1,402 @@
+#ifndef _DEVPATH_H
+#define _DEVPATH_H
+
+/*++
+
+Copyright (c) 1998  Intel Corporation
+
+Module Name:
+
+    devpath.h
+
+Abstract:
+
+    Defines for parsing the EFI Device Path structures
+
+
+
+Revision History
+
+--*/
+
+//
+// Device Path structures - Section C
+//
+
+typedef struct _EFI_DEVICE_PATH {
+        UINT8                           Type;
+        UINT8                           SubType;
+        UINT8                           Length[2];
+} EFI_DEVICE_PATH;
+
+#define EFI_DP_TYPE_MASK                    0x7F
+#define EFI_DP_TYPE_UNPACKED                0x80
+
+//#define END_DEVICE_PATH_TYPE                0xff
+#define END_DEVICE_PATH_TYPE                0x7f
+//#define END_DEVICE_PATH_TYPE_UNPACKED       0x7f
+
+#define END_ENTIRE_DEVICE_PATH_SUBTYPE      0xff
+#define END_INSTANCE_DEVICE_PATH_SUBTYPE    0x01
+#define END_DEVICE_PATH_LENGTH              (sizeof(EFI_DEVICE_PATH))
+
+
+#define DP_IS_END_TYPE(a)
+#define DP_IS_END_SUBTYPE(a)        ( ((a)->SubType == END_ENTIRE_DEVICE_PATH_SUBTYPE )
+
+#define DevicePathType(a)           ( ((a)->Type) & EFI_DP_TYPE_MASK )
+#define DevicePathSubType(a)        ( (a)->SubType )
+#define DevicePathNodeLength(a)     ( ((a)->Length[0]) | ((a)->Length[1] << 8) )
+#define NextDevicePathNode(a)       ( (EFI_DEVICE_PATH *) ( ((UINT8 *) (a)) + DevicePathNodeLength(a)))
+//#define IsDevicePathEndType(a)      ( DevicePathType(a) == END_DEVICE_PATH_TYPE_UNPACKED )
+#define IsDevicePathEndType(a)      ( DevicePathType(a) == END_DEVICE_PATH_TYPE )
+#define IsDevicePathEndSubType(a)   ( (a)->SubType == END_ENTIRE_DEVICE_PATH_SUBTYPE )
+#define IsDevicePathEnd(a)          ( IsDevicePathEndType(a) && IsDevicePathEndSubType(a) )
+#define IsDevicePathUnpacked(a)     ( (a)->Type & EFI_DP_TYPE_UNPACKED )
+
+
+#define SetDevicePathNodeLength(a,l) {                  \
+            (a)->Length[0] = (UINT8) (l);               \
+            (a)->Length[1] = (UINT8) ((l) >> 8);        \
+            }
+
+#define SetDevicePathEndNode(a)  {                      \
+            (a)->Type = END_DEVICE_PATH_TYPE;           \
+            (a)->SubType = END_ENTIRE_DEVICE_PATH_SUBTYPE;     \
+            (a)->Length[0] = sizeof(EFI_DEVICE_PATH);   \
+            (a)->Length[1] = 0;                         \
+            }
+
+
+
+/*
+ *
+ */
+#define HARDWARE_DEVICE_PATH            0x01
+
+#define HW_PCI_DP                       0x01
+typedef struct _PCI_DEVICE_PATH {
+        EFI_DEVICE_PATH                 Header;
+        UINT8                           Function;
+        UINT8                           Device;
+} PCI_DEVICE_PATH;
+
+#define HW_PCCARD_DP                    0x02
+typedef struct _PCCARD_DEVICE_PATH {
+        EFI_DEVICE_PATH                 Header;
+        UINT8                           SocketNumber;
+} PCCARD_DEVICE_PATH;
+
+#define HW_MEMMAP_DP                    0x03
+typedef struct _MEMMAP_DEVICE_PATH {
+        EFI_DEVICE_PATH                 Header;
+        UINT32                          MemoryType;
+        EFI_PHYSICAL_ADDRESS            StartingAddress;
+        EFI_PHYSICAL_ADDRESS            EndingAddress;
+} MEMMAP_DEVICE_PATH;
+
+#define HW_VENDOR_DP                    0x04
+typedef struct _VENDOR_DEVICE_PATH {
+        EFI_DEVICE_PATH                 Header;
+        EFI_GUID                        Guid;
+} VENDOR_DEVICE_PATH;
+
+#define UNKNOWN_DEVICE_GUID \
+    { 0xcf31fac5, 0xc24e, 0x11d2,  {0x85, 0xf3, 0x0, 0xa0, 0xc9, 0x3e, 0xc9, 0x3b}  }
+
+typedef struct _UKNOWN_DEVICE_VENDOR_DP {
+    VENDOR_DEVICE_PATH      DevicePath;
+    UINT8                   LegacyDriveLetter;
+} UNKNOWN_DEVICE_VENDOR_DEVICE_PATH;
+
+#define HW_CONTROLLER_DP            0x05
+typedef struct _CONTROLLER_DEVICE_PATH {
+        EFI_DEVICE_PATH     Header;
+        UINT32              Controller;
+} CONTROLLER_DEVICE_PATH;
+
+/*
+ *
+ */
+#define ACPI_DEVICE_PATH                 0x02
+
+#define ACPI_DP                         0x01
+typedef struct _ACPI_HID_DEVICE_PATH {
+        EFI_DEVICE_PATH                 Header;
+        UINT32                          HID;
+        UINT32                          UID;
+} ACPI_HID_DEVICE_PATH;
+
+#define EXPANDED_ACPI_DP		0x02
+typedef struct _EXPANDED_ACPI_HID_DEVICE_PATH {
+	EFI_DEVICE_PATH			Header;
+	UINT32				HID;
+	UINT32				UID;
+	UINT32				CID;
+	UINT8				HidStr[1];
+} EXPANDED_ACPI_HID_DEVICE_PATH;
+
+//
+// EISA ID Macro
+// EISA ID Definition 32-bits
+//  bits[15:0] - three character compressed ASCII EISA ID.
+//  bits[31:16] - binary number
+//   Compressed ASCII is 5 bits per character 0b00001 = 'A' 0b11010 = 'Z'
+//
+#define PNP_EISA_ID_CONST       0x41d0    
+#define EISA_ID(_Name, _Num)    ((UINT32) ((_Name) | (_Num) << 16))   
+#define EISA_PNP_ID(_PNPId)     (EISA_ID(PNP_EISA_ID_CONST, (_PNPId)))
+
+#define PNP_EISA_ID_MASK        0xffff
+#define EISA_ID_TO_NUM(_Id)     ((_Id) >> 16)
+/*
+ *
+ */
+#define MESSAGING_DEVICE_PATH           0x03 
+
+#define MSG_ATAPI_DP                    0x01
+typedef struct _ATAPI_DEVICE_PATH {
+        EFI_DEVICE_PATH                 Header;
+        UINT8                           PrimarySecondary;
+        UINT8                           SlaveMaster;
+        UINT16                          Lun;
+} ATAPI_DEVICE_PATH;
+
+#define MSG_SCSI_DP                     0x02
+typedef struct _SCSI_DEVICE_PATH {
+        EFI_DEVICE_PATH                 Header;
+        UINT16                          Pun;
+        UINT16                          Lun; 
+} SCSI_DEVICE_PATH;
+
+#define MSG_FIBRECHANNEL_DP             0x03
+typedef struct _FIBRECHANNEL_DEVICE_PATH {
+        EFI_DEVICE_PATH                 Header;
+        UINT32                          Reserved;
+        UINT64                          WWN;
+        UINT64                          Lun;
+} FIBRECHANNEL_DEVICE_PATH;
+
+#define MSG_1394_DP                     0x04
+typedef struct _F1394_DEVICE_PATH {
+        EFI_DEVICE_PATH                 Header;
+        UINT32                          Reserved;
+        UINT64                          Guid;
+} F1394_DEVICE_PATH;
+
+#define MSG_USB_DP                      0x05
+typedef struct _USB_DEVICE_PATH {
+        EFI_DEVICE_PATH                 Header;
+        UINT8                           Port;
+        UINT8                           Endpoint;
+} USB_DEVICE_PATH;
+
+#define MSG_USB_CLASS_DP                0x0F
+typedef struct _USB_CLASS_DEVICE_PATH {
+        EFI_DEVICE_PATH                 Header;
+        UINT16                          VendorId;
+        UINT16                          ProductId;
+        UINT8                           DeviceClass;
+        UINT8                           DeviceSubclass;
+        UINT8                           DeviceProtocol;
+} USB_CLASS_DEVICE_PATH;
+
+#define MSG_I2O_DP                      0x06
+typedef struct _I2O_DEVICE_PATH {
+        EFI_DEVICE_PATH                 Header;
+        UINT32                          Tid;
+} I2O_DEVICE_PATH;
+
+#define MSG_MAC_ADDR_DP                 0x0b
+typedef struct _MAC_ADDR_DEVICE_PATH {
+        EFI_DEVICE_PATH                 Header;
+        EFI_MAC_ADDRESS                 MacAddress;
+        UINT8                           IfType;
+} MAC_ADDR_DEVICE_PATH;
+
+#define MSG_IPv4_DP                     0x0c
+typedef struct _IPv4_DEVICE_PATH {
+        EFI_DEVICE_PATH                 Header;
+        EFI_IPv4_ADDRESS                LocalIpAddress;
+        EFI_IPv4_ADDRESS                RemoteIpAddress;
+        UINT16                          LocalPort;
+        UINT16                          RemotePort;
+        UINT16                          Protocol;
+        BOOLEAN                         StaticIpAddress;
+} IPv4_DEVICE_PATH;
+
+#define MSG_IPv6_DP                     0x0d
+typedef struct _IPv6_DEVICE_PATH {
+        EFI_DEVICE_PATH                 Header;
+        EFI_IPv6_ADDRESS                LocalIpAddress;
+        EFI_IPv6_ADDRESS                RemoteIpAddress;
+        UINT16                          LocalPort;
+        UINT16                          RemotePort;
+        UINT16                          Protocol;
+        BOOLEAN                         StaticIpAddress;
+} IPv6_DEVICE_PATH;
+
+#define MSG_INFINIBAND_DP               0x09
+typedef struct _INFINIBAND_DEVICE_PATH {
+        EFI_DEVICE_PATH                 Header;
+        UINT32                          Reserved;
+        UINT64                          NodeGuid;
+        UINT64                          IocGuid;
+        UINT64                          DeviceId;
+} INFINIBAND_DEVICE_PATH;
+
+#define MSG_UART_DP                     0x0e
+typedef struct _UART_DEVICE_PATH {
+        EFI_DEVICE_PATH                 Header;
+        UINT32                          Reserved;
+        UINT64                          BaudRate;
+        UINT8                           DataBits;
+        UINT8                           Parity;
+        UINT8                           StopBits;
+} UART_DEVICE_PATH;
+
+#define MSG_VENDOR_DP                   0x0A
+/* Use VENDOR_DEVICE_PATH struct */
+
+#define DEVICE_PATH_MESSAGING_PC_ANSI \
+    { 0xe0c14753, 0xf9be, 0x11d2,  {0x9a, 0x0c, 0x00, 0x90, 0x27, 0x3f, 0xc1, 0x4d}  }
+
+#define DEVICE_PATH_MESSAGING_VT_100 \
+    { 0xdfa66065, 0xb419, 0x11d3,  {0x9a, 0x2d, 0x00, 0x90, 0x27, 0x3f, 0xc1, 0x4d}  }
+
+
+
+#define MEDIA_DEVICE_PATH               0x04
+
+#define MEDIA_HARDDRIVE_DP              0x01
+typedef struct _HARDDRIVE_DEVICE_PATH {
+        EFI_DEVICE_PATH                 Header;
+        UINT32                          PartitionNumber;
+        UINT64                          PartitionStart;
+        UINT64                          PartitionSize;
+        UINT8                           Signature[16];
+        UINT8                           MBRType;
+        UINT8                           SignatureType;
+} HARDDRIVE_DEVICE_PATH;
+
+#define MBR_TYPE_PCAT                       0x01
+#define MBR_TYPE_EFI_PARTITION_TABLE_HEADER 0x02
+
+#define SIGNATURE_TYPE_MBR                  0x01
+#define SIGNATURE_TYPE_GUID                 0x02
+
+#define MEDIA_CDROM_DP                  0x02
+typedef struct _CDROM_DEVICE_PATH {
+        EFI_DEVICE_PATH                 Header;
+        UINT32                          BootEntry;
+        UINT64                          PartitionStart;
+        UINT64                          PartitionSize;
+} CDROM_DEVICE_PATH;
+
+#define MEDIA_VENDOR_DP                 0x03
+/* Use VENDOR_DEVICE_PATH struct */
+
+#define MEDIA_FILEPATH_DP               0x04
+typedef struct _FILEPATH_DEVICE_PATH {
+        EFI_DEVICE_PATH                 Header;
+        CHAR16                          PathName[1];
+} FILEPATH_DEVICE_PATH;
+
+#define SIZE_OF_FILEPATH_DEVICE_PATH EFI_FIELD_OFFSET(FILEPATH_DEVICE_PATH,PathName)
+
+#define MEDIA_PROTOCOL_DP               0x05
+typedef struct _MEDIA_PROTOCOL_DEVICE_PATH {
+        EFI_DEVICE_PATH                 Header;
+        EFI_GUID                        Protocol;
+} MEDIA_PROTOCOL_DEVICE_PATH;
+
+
+#define BBS_DEVICE_PATH                 0x05
+#define BBS_BBS_DP                      0x01
+typedef struct _BBS_BBS_DEVICE_PATH {
+        EFI_DEVICE_PATH                 Header;
+        UINT16                          DeviceType;
+        UINT16                          StatusFlag;
+        CHAR8                           String[1];
+} BBS_BBS_DEVICE_PATH;
+
+/* DeviceType definitions - from BBS specification */
+#define BBS_TYPE_FLOPPY                 0x01
+#define BBS_TYPE_HARDDRIVE              0x02
+#define BBS_TYPE_CDROM                  0x03
+#define BBS_TYPE_PCMCIA                 0x04
+#define BBS_TYPE_USB                    0x05
+#define BBS_TYPE_EMBEDDED_NETWORK       0x06
+#define BBS_TYPE_DEV                    0x80
+#define BBS_TYPE_UNKNOWN                0xFF
+
+typedef union {
+    EFI_DEVICE_PATH                      DevPath;
+    PCI_DEVICE_PATH                      Pci;
+    PCCARD_DEVICE_PATH                   PcCard;
+    MEMMAP_DEVICE_PATH                   MemMap;
+    VENDOR_DEVICE_PATH                   Vendor;
+    UNKNOWN_DEVICE_VENDOR_DEVICE_PATH    UnknownVendor;   
+    CONTROLLER_DEVICE_PATH               Controller;
+    ACPI_HID_DEVICE_PATH                 Acpi;
+
+    ATAPI_DEVICE_PATH                    Atapi;
+    SCSI_DEVICE_PATH                     Scsi;
+    FIBRECHANNEL_DEVICE_PATH             FibreChannel;
+
+    F1394_DEVICE_PATH                    F1394;
+    USB_DEVICE_PATH                      Usb;
+    USB_CLASS_DEVICE_PATH                UsbClass;
+    I2O_DEVICE_PATH                      I2O;
+    MAC_ADDR_DEVICE_PATH                 MacAddr;
+    IPv4_DEVICE_PATH                     Ipv4;
+    IPv6_DEVICE_PATH                     Ipv6;
+    INFINIBAND_DEVICE_PATH               InfiniBand;
+    UART_DEVICE_PATH                     Uart;
+
+    HARDDRIVE_DEVICE_PATH                HardDrive;
+    CDROM_DEVICE_PATH                    CD;
+
+    FILEPATH_DEVICE_PATH                 FilePath;
+    MEDIA_PROTOCOL_DEVICE_PATH           MediaProtocol;
+
+    BBS_BBS_DEVICE_PATH                  Bbs;
+
+} EFI_DEV_PATH;
+
+typedef union {
+    EFI_DEVICE_PATH                      *DevPath;
+    PCI_DEVICE_PATH                      *Pci;
+    PCCARD_DEVICE_PATH                   *PcCard;
+    MEMMAP_DEVICE_PATH                   *MemMap;
+    VENDOR_DEVICE_PATH                   *Vendor;
+    UNKNOWN_DEVICE_VENDOR_DEVICE_PATH    *UnknownVendor;   
+    CONTROLLER_DEVICE_PATH               *Controller;
+    ACPI_HID_DEVICE_PATH                 *Acpi;
+
+    ATAPI_DEVICE_PATH                    *Atapi;
+    SCSI_DEVICE_PATH                     *Scsi;
+    FIBRECHANNEL_DEVICE_PATH             *FibreChannel;
+
+    F1394_DEVICE_PATH                    *F1394;
+    USB_DEVICE_PATH                      *Usb;
+    USB_CLASS_DEVICE_PATH                *UsbClass;
+    I2O_DEVICE_PATH                      *I2O;
+    MAC_ADDR_DEVICE_PATH                 *MacAddr;
+    IPv4_DEVICE_PATH                     *Ipv4;
+    IPv6_DEVICE_PATH                     *Ipv6;
+    INFINIBAND_DEVICE_PATH               *InfiniBand;
+    UART_DEVICE_PATH                     *Uart;
+
+    HARDDRIVE_DEVICE_PATH                *HardDrive;
+
+    FILEPATH_DEVICE_PATH                 *FilePath;
+    MEDIA_PROTOCOL_DEVICE_PATH           *MediaProtocol;
+
+    CDROM_DEVICE_PATH                    *CD;
+    BBS_BBS_DEVICE_PATH                  *Bbs;
+
+} EFI_DEV_PATH_PTR;
+
+
+#endif
diff --git a/linux-x86/gnu-efi/include/efi/efierr.h b/linux-x86/gnu-efi/include/efi/efierr.h
new file mode 100644
index 0000000..669d7ba
--- /dev/null
+++ b/linux-x86/gnu-efi/include/efi/efierr.h
@@ -0,0 +1,60 @@
+#ifndef _EFI_ERR_H
+#define _EFI_ERR_H
+
+/*++
+
+Copyright (c) 1998  Intel Corporation
+
+Module Name:
+
+    efierr.h
+
+Abstract:
+
+    EFI error codes
+
+
+
+
+Revision History
+
+--*/
+
+
+#define EFIWARN(a)                            (a)
+#define EFI_ERROR(a)              (((INTN) a) < 0)
+
+
+#define EFI_SUCCESS                             0
+#define EFI_LOAD_ERROR                  EFIERR(1)
+#define EFI_INVALID_PARAMETER           EFIERR(2)
+#define EFI_UNSUPPORTED                 EFIERR(3)
+#define EFI_BAD_BUFFER_SIZE             EFIERR(4)
+#define EFI_BUFFER_TOO_SMALL            EFIERR(5)
+#define EFI_NOT_READY                   EFIERR(6)
+#define EFI_DEVICE_ERROR                EFIERR(7)
+#define EFI_WRITE_PROTECTED             EFIERR(8)
+#define EFI_OUT_OF_RESOURCES            EFIERR(9)
+#define EFI_VOLUME_CORRUPTED            EFIERR(10)
+#define EFI_VOLUME_FULL                 EFIERR(11)
+#define EFI_NO_MEDIA                    EFIERR(12)
+#define EFI_MEDIA_CHANGED               EFIERR(13)
+#define EFI_NOT_FOUND                   EFIERR(14)
+#define EFI_ACCESS_DENIED               EFIERR(15)
+#define EFI_NO_RESPONSE                 EFIERR(16)
+#define EFI_NO_MAPPING                  EFIERR(17)
+#define EFI_TIMEOUT                     EFIERR(18)
+#define EFI_NOT_STARTED                 EFIERR(19)
+#define EFI_ALREADY_STARTED             EFIERR(20)
+#define EFI_ABORTED                     EFIERR(21)
+#define EFI_ICMP_ERROR                  EFIERR(22)
+#define EFI_TFTP_ERROR                  EFIERR(23)
+#define EFI_PROTOCOL_ERROR              EFIERR(24)
+
+#define EFI_WARN_UNKOWN_GLYPH           EFIWARN(1)
+#define EFI_WARN_DELETE_FAILURE         EFIWARN(2)
+#define EFI_WARN_WRITE_FAILURE          EFIWARN(3)
+#define EFI_WARN_BUFFER_TOO_SMALL       EFIWARN(4)
+
+#endif
+
diff --git a/linux-x86/gnu-efi/include/efi/efifs.h b/linux-x86/gnu-efi/include/efi/efifs.h
new file mode 100644
index 0000000..fc595d1
--- /dev/null
+++ b/linux-x86/gnu-efi/include/efi/efifs.h
@@ -0,0 +1,116 @@
+#ifndef _EFI_FS_H
+#define _EFI_FS_H
+
+/*++
+
+Copyright (c) 1998  Intel Corporation
+
+Module Name:
+
+    efifs.h
+
+Abstract:
+
+    EFI File System structures
+
+
+
+Revision History
+
+--*/
+
+
+//
+// EFI Partition header (normaly starts in LBA 1)
+//
+
+#define EFI_PARTITION_SIGNATURE         0x5053595320494249
+#define EFI_PARTITION_REVISION          0x00010001
+#define MIN_EFI_PARTITION_BLOCK_SIZE    512
+#define EFI_PARTITION_LBA               1
+
+typedef struct _EFI_PARTITION_HEADER {
+    EFI_TABLE_HEADER    Hdr;
+    UINT32              DirectoryAllocationNumber;
+    UINT32              BlockSize;
+    EFI_LBA             FirstUsableLba;
+    EFI_LBA             LastUsableLba;
+    EFI_LBA             UnusableSpace;
+    EFI_LBA             FreeSpace;
+    EFI_LBA             RootFile;
+    EFI_LBA             SecutiryFile;
+} EFI_PARTITION_HEADER;
+
+
+//
+// File header
+//
+
+#define EFI_FILE_HEADER_SIGNATURE   0x454c494620494249
+#define EFI_FILE_HEADER_REVISION    0x00010000
+#define EFI_FILE_STRING_SIZE        260
+
+typedef struct _EFI_FILE_HEADER {
+    EFI_TABLE_HEADER    Hdr;
+    UINT32              Class;
+    UINT32              LBALOffset;
+    EFI_LBA             Parent;
+    UINT64              FileSize;
+    UINT64              FileAttributes;
+    EFI_TIME            FileCreateTime;
+    EFI_TIME            FileModificationTime;
+    EFI_GUID            VendorGuid;
+    CHAR16              FileString[EFI_FILE_STRING_SIZE];
+} EFI_FILE_HEADER;
+
+
+//
+// Return the file's first LBAL which is in the same
+// logical block as the file header
+//
+
+#define EFI_FILE_LBAL(a)    ((EFI_LBAL *) (((CHAR8 *) (a)) + (a)->LBALOffset))
+
+#define EFI_FILE_CLASS_FREE_SPACE   1
+#define EFI_FILE_CLASS_EMPTY        2
+#define EFI_FILE_CLASS_NORMAL       3
+
+
+//
+// Logical Block Address List - the fundemental block
+// description structure
+//
+
+#define EFI_LBAL_SIGNATURE      0x4c41424c20494249
+#define EFI_LBAL_REVISION       0x00010000
+
+typedef struct _EFI_LBAL {
+    EFI_TABLE_HEADER    Hdr;
+    UINT32              Class;
+    EFI_LBA             Parent;
+    EFI_LBA             Next;
+    UINT32              ArraySize;
+    UINT32              ArrayCount;
+} EFI_LBAL;
+
+// Array size 
+#define EFI_LBAL_ARRAY_SIZE(lbal,offs,blks)  \
+        (((blks) - (offs) - (lbal)->Hdr.HeaderSize) / sizeof(EFI_RL))
+
+//
+// Logical Block run-length
+//
+
+typedef struct {
+    EFI_LBA     Start;
+    UINT64      Length;
+} EFI_RL;
+
+//
+// Return the run-length structure from an LBAL header
+//
+
+#define EFI_LBAL_RL(a)      ((EFI_RL*) (((CHAR8 *) (a)) + (a)->Hdr.HeaderSize))
+
+#endif
+
diff --git a/linux-x86/gnu-efi/include/efi/efigpt.h b/linux-x86/gnu-efi/include/efi/efigpt.h
new file mode 100644
index 0000000..d1694ae
--- /dev/null
+++ b/linux-x86/gnu-efi/include/efi/efigpt.h
@@ -0,0 +1,68 @@
+#ifndef _EFI_GPT_H
+#define _EFI_GPT_H
+/*++
+
+Copyright (c) 1998  Intel Corporation
+
+Module Name:
+
+    EfiGpt.h
+    
+Abstract:
+    Include file for EFI partitioning scheme
+
+
+
+Revision History
+
+--*/
+
+#define PRIMARY_PART_HEADER_LBA         1
+
+typedef struct {
+    EFI_TABLE_HEADER    Header;
+    EFI_LBA             MyLBA;
+    EFI_LBA             AlternateLBA;
+    EFI_LBA             FirstUsableLBA;
+    EFI_LBA             LastUsableLBA;
+    EFI_GUID            DiskGUID;
+    EFI_LBA             PartitionEntryLBA;
+    UINT32              NumberOfPartitionEntries;
+    UINT32              SizeOfPartitionEntry;
+    UINT32              PartitionEntryArrayCRC32;
+} EFI_PARTITION_TABLE_HEADER;
+
+#define EFI_PTAB_HEADER_ID  "EFI PART"
+
+typedef struct {
+    EFI_GUID    PartitionTypeGUID;
+    EFI_GUID    UniquePartitionGUID;
+    EFI_LBA     StartingLBA;
+    EFI_LBA     EndingLBA;
+    UINT64      Attributes;
+    CHAR16      PartitionName[36];
+} EFI_PARTITION_ENTRY;
+
+//
+// EFI Partition Attributes
+//
+#define EFI_PART_USED_BY_EFI            0x0000000000000001
+#define EFI_PART_REQUIRED_TO_FUNCTION   0x0000000000000002
+#define EFI_PART_USED_BY_OS             0x0000000000000004
+#define EFI_PART_REQUIRED_BY_OS         0x0000000000000008
+#define EFI_PART_BACKUP_REQUIRED        0x0000000000000010
+#define EFI_PART_USER_DATA              0x0000000000000020
+#define EFI_PART_CRITICAL_USER_DATA     0x0000000000000040
+#define EFI_PART_REDUNDANT_PARTITION    0x0000000000000080
+
+#define EFI_PART_TYPE_UNUSED_GUID   \
+    { 0x00000000, 0x0000, 0x0000, {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00} }
+    
+#define EFI_PART_TYPE_EFI_SYSTEM_PART_GUID  \
+    { 0xc12a7328, 0xf81f, 0x11d2, {0xba, 0x4b, 0x00, 0xa0, 0xc9, 0x3e, 0xc9, 0x3b} }
+
+#define EFI_PART_TYPE_LEGACY_MBR_GUID   \
+    { 0x024dee41, 0x33e7, 0x11d3, {0x9d, 0x69, 0x00, 0x08, 0xc7, 0x81, 0xf3, 0x9f} }
+
+#endif
+
diff --git a/linux-x86/gnu-efi/include/efi/efilib.h b/linux-x86/gnu-efi/include/efi/efilib.h
new file mode 100644
index 0000000..740c2ff
--- /dev/null
+++ b/linux-x86/gnu-efi/include/efi/efilib.h
@@ -0,0 +1,880 @@
+#ifndef _EFILIB_INCLUDE_
+#define _EFILIB_INCLUDE_
+
+/*++
+
+Copyright (c) 2000  Intel Corporation
+
+Module Name:
+
+    efilib.h
+
+Abstract:
+
+    EFI library functions
+
+
+
+Revision History
+
+--*/
+
+#include "efidebug.h"
+#include "efipart.h"
+#include "efilibplat.h"
+#include "efilink.h"
+#include "efirtlib.h"
+#include "pci22.h"
+#include "libsmbios.h"
+
+//
+// Public read-only data in the EFI library
+//
+
+extern EFI_SYSTEM_TABLE         *ST;
+extern EFI_BOOT_SERVICES        *BS;
+extern EFI_RUNTIME_SERVICES     *RT;
+
+extern EFI_GUID DevicePathProtocol;
+extern EFI_GUID LoadedImageProtocol;
+extern EFI_GUID TextInProtocol;
+extern EFI_GUID TextOutProtocol;
+extern EFI_GUID BlockIoProtocol;
+extern EFI_GUID DiskIoProtocol;
+extern EFI_GUID FileSystemProtocol;
+extern EFI_GUID LoadFileProtocol;
+extern EFI_GUID DeviceIoProtocol;
+extern EFI_GUID VariableStoreProtocol;
+extern EFI_GUID LegacyBootProtocol;
+extern EFI_GUID UnicodeCollationProtocol;
+extern EFI_GUID SerialIoProtocol;
+extern EFI_GUID VgaClassProtocol;
+extern EFI_GUID TextOutSpliterProtocol;
+extern EFI_GUID ErrorOutSpliterProtocol;
+extern EFI_GUID TextInSpliterProtocol;
+extern EFI_GUID SimpleNetworkProtocol;
+extern EFI_GUID PxeBaseCodeProtocol;
+extern EFI_GUID PxeCallbackProtocol;
+extern EFI_GUID NetworkInterfaceIdentifierProtocol;
+extern EFI_GUID UiProtocol;
+extern EFI_GUID InternalShellProtocol;
+extern EFI_GUID PciIoProtocol;
+
+extern EFI_GUID EfiGlobalVariable;
+extern EFI_GUID GenericFileInfo;
+extern EFI_GUID FileSystemInfo;
+extern EFI_GUID FileSystemVolumeLabelInfo;
+extern EFI_GUID PcAnsiProtocol;
+extern EFI_GUID Vt100Protocol;
+extern EFI_GUID NullGuid;
+extern EFI_GUID UnknownDevice;
+
+extern EFI_GUID EfiPartTypeSystemPartitionGuid;
+extern EFI_GUID EfiPartTypeLegacyMbrGuid;
+
+extern EFI_GUID MpsTableGuid;
+extern EFI_GUID AcpiTableGuid;
+extern EFI_GUID SMBIOSTableGuid;
+extern EFI_GUID SalSystemTableGuid;
+
+//
+// EFI Variable strings
+//
+#define LOAD_OPTION_ACTIVE      0x00000001
+
+#define VarLanguageCodes       L"LangCodes"
+#define VarLanguage            L"Lang"
+#define VarTimeout             L"Timeout"
+#define VarConsoleInp          L"ConIn"
+#define VarConsoleOut          L"ConOut"
+#define VarErrorOut            L"ErrOut"
+#define VarBootOption          L"Boot%04x"
+#define VarBootOrder           L"BootOrder"
+#define VarBootNext            L"BootNext"
+#define VarBootCurrent         L"BootCurrent"
+#define VarDriverOption        L"Driver%04x"
+#define VarDriverOrder         L"DriverOrder"
+#define VarConsoleInpDev       L"ConInDev"
+#define VarConsoleOutDev       L"ConOutDev"
+#define VarErrorOutDev         L"ErrOutDev"
+
+#define LanguageCodeEnglish    "eng"
+
+extern EFI_DEVICE_PATH RootDevicePath[];
+extern EFI_DEVICE_PATH EndDevicePath[];
+extern EFI_DEVICE_PATH EndInstanceDevicePath[];
+
+//
+// Other public data in the EFI library
+//
+
+extern EFI_MEMORY_TYPE PoolAllocationType;
+
+//
+// STATIC - Name is internal to the module
+// INTERNAL - Name is internal to the component (i.e., directory)
+// BOOTSERVCE - Name of a boot service function
+//
+
+#define STATIC
+#define INTERNAL
+#define BOOTSERVICE
+
+//
+// Prototypes
+//
+
+VOID
+InitializeLib (
+    IN EFI_HANDLE           ImageHandle,
+    IN EFI_SYSTEM_TABLE     *SystemTable
+    );
+
+VOID
+InitializeUnicodeSupport (
+    CHAR8 *LangCode
+    );
+
+VOID
+EFIDebugVariable (
+    VOID
+    );
+
+VOID
+SetCrc (
+    IN OUT EFI_TABLE_HEADER *Hdr
+    );
+
+VOID
+SetCrcAltSize (
+    IN UINTN                 Size,
+    IN OUT EFI_TABLE_HEADER *Hdr
+    );
+
+BOOLEAN
+CheckCrc (
+    IN UINTN                 MaxSize,
+    IN OUT EFI_TABLE_HEADER *Hdr
+    );
+
+BOOLEAN
+CheckCrcAltSize (
+    IN UINTN                 MaxSize,
+    IN UINTN                 Size,
+    IN OUT EFI_TABLE_HEADER *Hdr
+    );
+
+UINT32
+CalculateCrc (
+    UINT8 *pt,
+    UINTN Size
+    );
+
+VOID
+ZeroMem (
+    IN VOID     *Buffer,
+    IN UINTN     Size
+    );
+
+VOID
+SetMem (
+    IN VOID     *Buffer,
+    IN UINTN    Size,
+    IN UINT8    Value    
+    );
+
+VOID
+CopyMem (
+    IN VOID     *Dest,
+    IN VOID     *Src,
+    IN UINTN    len
+    );
+
+INTN
+CompareMem (
+    IN VOID     *Dest,
+    IN VOID     *Src,
+    IN UINTN    len
+    );
+
+INTN
+StrCmp (
+    IN CHAR16   *s1,
+    IN CHAR16   *s2
+    );
+
+INTN
+StrnCmp (
+    IN CHAR16   *s1,
+    IN CHAR16   *s2,
+    IN UINTN    len
+    );
+
+INTN
+StriCmp (
+    IN CHAR16   *s1,
+    IN CHAR16   *s2
+    );
+
+VOID
+StrLwr (
+    IN CHAR16   *Str
+    );
+
+VOID
+StrUpr (
+    IN CHAR16   *Str
+    );
+
+VOID
+StrCpy (
+    IN CHAR16   *Dest,
+    IN CHAR16    *Src
+    );
+
+VOID
+StrCat (
+    IN CHAR16   *Dest,
+    IN CHAR16   *Src
+    );
+
+UINTN
+StrLen (
+    IN CHAR16   *s1
+    );
+
+UINTN
+StrSize (
+    IN CHAR16   *s1
+    );
+
+CHAR16 *
+StrDuplicate (
+    IN CHAR16   *Src
+    );
+
+UINTN
+strlena (
+    IN CHAR8    *s1
+    );
+    
+UINTN
+strcmpa (
+    IN CHAR8    *s1,
+    IN CHAR8    *s2
+    );
+
+UINTN
+strncmpa (
+    IN CHAR8    *s1,
+    IN CHAR8    *s2,
+    IN UINTN    len
+    );
+
+UINTN
+xtoi (
+    CHAR16      *str
+    );
+
+UINTN
+Atoi (
+    CHAR16  *str
+    );
+
+BOOLEAN 
+MetaMatch (
+    IN CHAR16   *String,
+    IN CHAR16   *Pattern
+    );
+
+BOOLEAN 
+MetaiMatch (
+    IN CHAR16   *String,
+    IN CHAR16   *Pattern
+    );
+
+UINT64
+LShiftU64 (
+    IN UINT64   Operand,
+    IN UINTN    Count
+    );
+
+UINT64
+RShiftU64 (
+    IN UINT64   Operand,
+    IN UINTN    Count
+    );
+
+UINT64
+MultU64x32 (
+    IN UINT64   Multiplicand,
+    IN UINTN    Multiplier
+    );
+
+UINT64
+DivU64x32 (
+    IN UINT64   Dividend,
+    IN UINTN    Divisor,
+    OUT UINTN   *Remainder OPTIONAL
+    );
+
+VOID
+InitializeLock (
+    IN OUT FLOCK    *Lock,
+    IN EFI_TPL  Priority
+    );
+
+VOID
+AcquireLock (
+    IN FLOCK    *Lock
+    );
+
+VOID
+ReleaseLock (
+    IN FLOCK    *Lock
+    );
+
+
+INTN
+CompareGuid(
+    IN EFI_GUID     *Guid1,
+    IN EFI_GUID     *Guid2
+    );
+
+VOID *
+AllocatePool (
+    IN UINTN     Size
+    );
+
+VOID *
+AllocateZeroPool (
+    IN UINTN     Size
+    );
+
+VOID *
+ReallocatePool (
+    IN VOID                 *OldPool,
+    IN UINTN                OldSize,
+    IN UINTN                NewSize
+    );
+
+VOID
+FreePool (
+    IN VOID     *p
+    );
+
+
+VOID
+Output (
+    IN CHAR16   *Str
+    );
+
+VOID
+Input (
+    IN CHAR16   *Prompt OPTIONAL,
+    OUT CHAR16  *InStr,
+    IN UINTN    StrLen
+    );
+
+VOID
+IInput (
+    IN SIMPLE_TEXT_OUTPUT_INTERFACE     *ConOut,
+    IN SIMPLE_INPUT_INTERFACE           *ConIn,
+    IN CHAR16                           *Prompt OPTIONAL,
+    OUT CHAR16                          *InStr,
+    IN UINTN                            StrLen
+    );
+
+UINTN
+Print (
+    IN CHAR16   *fmt,
+    ...
+    );
+
+UINTN
+SPrint (
+    OUT CHAR16  *Str,
+    IN UINTN    StrSize,
+    IN CHAR16   *fmt,
+    ...
+    );
+
+CHAR16 *
+PoolPrint (
+    IN CHAR16           *fmt,
+    ...
+    );
+
+typedef struct {
+    CHAR16      *str;
+    UINTN       len;
+    UINTN       maxlen;
+} POOL_PRINT;
+
+CHAR16 *
+CatPrint (
+    IN OUT POOL_PRINT   *Str,
+    IN CHAR16           *fmt,
+    ...
+    );
+
+UINTN
+PrintAt (
+    IN UINTN    Column,
+    IN UINTN    Row,
+    IN CHAR16   *fmt,
+    ...
+    );
+
+UINTN
+IPrint (
+    IN SIMPLE_TEXT_OUTPUT_INTERFACE    *Out,
+    IN CHAR16                          *fmt,
+    ...
+    );
+
+UINTN
+IPrintAt (
+    IN SIMPLE_TEXT_OUTPUT_INTERFACE     *Out,
+    IN UINTN                            Column,
+    IN UINTN                            Row,
+    IN CHAR16                           *fmt,
+    ...
+    );
+
+UINTN
+APrint (
+    IN CHAR8    *fmt,
+    ...
+    );
+
+VOID
+ValueToHex (
+    IN CHAR16   *Buffer,
+    IN UINT64   v
+    );
+
+VOID
+ValueToString (
+    IN CHAR16   *Buffer,
+    IN BOOLEAN  Comma,
+    IN INT64    v
+    );
+
+VOID
+TimeToString (
+    OUT CHAR16      *Buffer,
+    IN EFI_TIME     *Time
+    );
+
+VOID
+GuidToString (
+    OUT CHAR16      *Buffer,
+    IN EFI_GUID     *Guid
+    );
+
+VOID
+StatusToString (
+    OUT CHAR16      *Buffer,
+    EFI_STATUS      Status
+    );
+
+VOID
+DumpHex (
+    IN UINTN        Indent,
+    IN UINTN        Offset,
+    IN UINTN        DataSize,
+    IN VOID         *UserData
+    );
+
+BOOLEAN
+GrowBuffer(
+    IN OUT EFI_STATUS   *Status,
+    IN OUT VOID         **Buffer,
+    IN UINTN            BufferSize
+    );
+
+EFI_MEMORY_DESCRIPTOR *
+LibMemoryMap (
+    OUT UINTN               *NoEntries,
+    OUT UINTN               *MapKey,
+    OUT UINTN               *DescriptorSize,
+    OUT UINT32              *DescriptorVersion
+    );
+
+VOID *
+LibGetVariable (
+    IN CHAR16               *Name,
+    IN EFI_GUID             *VendorGuid
+    );
+
+VOID *
+LibGetVariableAndSize (
+    IN CHAR16               *Name,
+    IN EFI_GUID             *VendorGuid,
+    OUT UINTN               *VarSize
+    );
+
+EFI_STATUS
+LibDeleteVariable (
+    IN CHAR16   *VarName,
+    IN EFI_GUID *VarGuid
+    );
+
+EFI_STATUS
+LibInsertToTailOfBootOrder (
+    IN  UINT16  BootOption,
+    IN  BOOLEAN OnlyInsertIfEmpty
+    );
+
+EFI_STATUS
+LibLocateProtocol (
+    IN  EFI_GUID    *ProtocolGuid,
+    OUT VOID        **Interface
+    );
+
+EFI_STATUS
+LibLocateHandle (
+    IN EFI_LOCATE_SEARCH_TYPE   SearchType,
+    IN EFI_GUID                 *Protocol OPTIONAL,
+    IN VOID                     *SearchKey OPTIONAL,
+    IN OUT UINTN                *NoHandles,
+    OUT EFI_HANDLE              **Buffer
+    );
+
+EFI_STATUS
+LibLocateHandleByDiskSignature (
+    IN UINT8                        MBRType,
+    IN UINT8                        SignatureType,
+    IN VOID                         *Signature,
+    IN OUT UINTN                    *NoHandles,
+    OUT EFI_HANDLE                  **Buffer
+    );
+
+EFI_STATUS
+LibInstallProtocolInterfaces (
+    IN OUT EFI_HANDLE       *Handle,
+    ...
+    );
+
+VOID
+LibUninstallProtocolInterfaces (
+    IN EFI_HANDLE           Handle,
+    ...
+    );
+
+EFI_STATUS
+LibReinstallProtocolInterfaces (
+    IN OUT EFI_HANDLE           *Handle,
+    ...
+    );
+
+EFI_EVENT
+LibCreateProtocolNotifyEvent (
+    IN EFI_GUID             *ProtocolGuid,
+    IN EFI_TPL              NotifyTpl,
+    IN EFI_EVENT_NOTIFY     NotifyFunction,
+    IN VOID                 *NotifyContext,
+    OUT VOID                *Registration
+    );
+
+EFI_STATUS
+WaitForSingleEvent (
+    IN EFI_EVENT        Event,
+    IN UINT64           Timeout OPTIONAL
+    );
+
+VOID
+WaitForEventWithTimeout (
+    IN  EFI_EVENT       Event,
+    IN  UINTN           Timeout,
+    IN  UINTN           Row,
+    IN  UINTN           Column,
+    IN  CHAR16          *String,
+    IN  EFI_INPUT_KEY   TimeoutKey,
+    OUT EFI_INPUT_KEY   *Key
+    );
+
+EFI_FILE_HANDLE
+LibOpenRoot (
+    IN EFI_HANDLE           DeviceHandle
+    );
+
+EFI_FILE_INFO *
+LibFileInfo (
+    IN EFI_FILE_HANDLE      FHand
+    );
+
+EFI_FILE_SYSTEM_INFO *
+LibFileSystemInfo (
+    IN EFI_FILE_HANDLE      FHand
+    );
+
+EFI_FILE_SYSTEM_VOLUME_LABEL_INFO *
+LibFileSystemVolumeLabelInfo (
+    IN EFI_FILE_HANDLE      FHand
+    );
+
+BOOLEAN
+ValidMBR(
+    IN  MASTER_BOOT_RECORD  *Mbr,
+    IN  EFI_BLOCK_IO        *BlkIo
+    );
+
+BOOLEAN
+LibMatchDevicePaths (
+    IN  EFI_DEVICE_PATH *Multi,
+    IN  EFI_DEVICE_PATH *Single
+    );
+
+EFI_DEVICE_PATH *
+LibDuplicateDevicePathInstance (
+    IN EFI_DEVICE_PATH  *DevPath
+    );
+
+EFI_DEVICE_PATH *
+DevicePathFromHandle (
+    IN EFI_HANDLE           Handle
+    );
+
+EFI_DEVICE_PATH *
+DevicePathInstance (
+    IN OUT EFI_DEVICE_PATH  **DevicePath,
+    OUT UINTN               *Size
+    );
+
+UINTN
+DevicePathInstanceCount (
+    IN EFI_DEVICE_PATH      *DevicePath
+    );
+
+EFI_DEVICE_PATH *
+AppendDevicePath (
+    IN EFI_DEVICE_PATH      *Src1,
+    IN EFI_DEVICE_PATH      *Src2
+    );
+
+EFI_DEVICE_PATH *
+AppendDevicePathNode (
+    IN EFI_DEVICE_PATH      *Src1,
+    IN EFI_DEVICE_PATH      *Src2
+    );
+
+EFI_DEVICE_PATH*
+AppendDevicePathInstance (
+    IN EFI_DEVICE_PATH  *Src,
+    IN EFI_DEVICE_PATH  *Instance
+    );
+
+EFI_DEVICE_PATH *
+FileDevicePath (
+    IN EFI_HANDLE           Device  OPTIONAL,
+    IN CHAR16               *FileName
+    );
+
+UINTN
+DevicePathSize (
+    IN EFI_DEVICE_PATH      *DevPath
+    );
+
+EFI_DEVICE_PATH *
+DuplicateDevicePath (
+    IN EFI_DEVICE_PATH      *DevPath
+    );
+
+EFI_DEVICE_PATH *
+UnpackDevicePath (
+    IN EFI_DEVICE_PATH      *DevPath
+    );
+
+EFI_STATUS
+LibDevicePathToInterface (
+    IN EFI_GUID             *Protocol,
+    IN EFI_DEVICE_PATH      *FilePath,
+    OUT VOID                **Interface
+    );
+
+CHAR16 *
+DevicePathToStr (
+    EFI_DEVICE_PATH         *DevPath
+    );
+
+//
+// BugBug: I need my own include files
+//
+typedef struct {
+    UINT8   Register;
+    UINT8   Function;
+    UINT8   Device;
+    UINT8   Bus;
+    UINT32  Reserved;
+} EFI_ADDRESS;
+
+typedef union {
+    UINT64          Address;
+    EFI_ADDRESS     EfiAddress;
+} EFI_PCI_ADDRESS_UNION;
+
+
+EFI_STATUS
+PciFindDeviceClass (
+    IN  OUT EFI_PCI_ADDRESS_UNION   *Address,
+    IN      UINT8                   BaseClass,
+    IN      UINT8                   SubClass
+    );
+
+EFI_STATUS
+PciFindDevice (
+    IN  OUT EFI_PCI_ADDRESS_UNION   *DeviceAddress,
+    IN      UINT16                  VendorId,
+    IN      UINT16                  DeviceId,
+    IN OUT  PCI_TYPE00              *Pci
+    );
+
+//
+// SIMPLE_READ_FILE object used to access files
+//
+
+typedef VOID        *SIMPLE_READ_FILE;
+
+EFI_STATUS
+OpenSimpleReadFile (
+    IN BOOLEAN                  BootPolicy,
+    IN VOID                     *SourceBuffer   OPTIONAL,
+    IN UINTN                    SourceSize,
+    IN OUT EFI_DEVICE_PATH      **FilePath,
+    OUT EFI_HANDLE              *DeviceHandle,    
+    OUT SIMPLE_READ_FILE        *SimpleReadHandle
+    );
+
+EFI_STATUS
+ReadSimpleReadFile (
+    IN SIMPLE_READ_FILE     SimpleReadHandle,
+    IN UINTN                Offset,
+    IN OUT UINTN            *ReadSize,
+    OUT VOID                *Buffer
+    );
+
+
+VOID
+CloseSimpleReadFile (
+    IN SIMPLE_READ_FILE     SimpleReadHandle
+    );
+
+VOID
+InitializeGuid (
+    VOID
+    );
+
+UINT8
+DecimaltoBCD(
+    IN  UINT8 DecValue
+    );
+
+UINT8
+BCDtoDecimal(
+    IN  UINT8 BcdValue
+    );
+
+EFI_STATUS
+LibGetSystemConfigurationTable(
+    IN EFI_GUID *TableGuid,
+    IN OUT VOID **Table
+    );
+
+BOOLEAN
+LibIsValidTextGraphics (
+    IN  CHAR16  Graphic,   
+    OUT CHAR8   *PcAnsi,    OPTIONAL
+    OUT CHAR8   *Ascii      OPTIONAL
+    );
+
+BOOLEAN
+IsValidAscii (
+    IN  CHAR16  Ascii
+    );
+
+BOOLEAN
+IsValidEfiCntlChar (
+    IN  CHAR16  c
+    );
+
+CHAR16 *
+LibGetUiString (
+    IN  EFI_HANDLE      Handle,
+    IN  UI_STRING_TYPE  StringType,
+    IN  ISO_639_2       *LangCode,
+    IN  BOOLEAN         ReturnDevicePathStrOnMismatch
+    );
+
+CHAR8*
+LibGetSmbiosString (
+    IN  SMBIOS_STRUCTURE_POINTER    *Smbios,
+    IN  UINT16                      StringNumber
+    );
+
+EFI_STATUS
+LibGetSmbiosSystemGuidAndSerialNumber (
+    IN  EFI_GUID    *SystemGuid,
+    OUT CHAR8       **SystemSerialNumber
+    );
+
+
+EFI_STATUS
+InitializeGlobalIoDevice (
+        IN  EFI_DEVICE_PATH             *DevicePath,
+        IN  EFI_GUID                    *Protocol,
+        IN  CHAR8                       *ErrorStr,
+        OUT EFI_DEVICE_IO_INTERFACE     **GlobalIoFncs 
+        );
+
+UINT32 
+ReadPort (
+        IN  EFI_DEVICE_IO_INTERFACE     *GlobalIoFncs, 
+        IN  EFI_IO_WIDTH                Width,
+        IN  UINTN                       Port
+        );
+
+UINT32 
+WritePort (
+        IN  EFI_DEVICE_IO_INTERFACE     *GlobalIoFncs, 
+        IN  EFI_IO_WIDTH                Width,
+        IN  UINTN                       Port,
+        IN  UINTN                       Data
+        );
+
+UINT32 
+ReadPciConfig (
+        IN  EFI_DEVICE_IO_INTERFACE     *GlobalIoFncs, 
+        IN  EFI_IO_WIDTH                Width,
+        IN  UINTN                       Port
+        );
+
+UINT32 
+WritePciConfig (
+        IN  EFI_DEVICE_IO_INTERFACE     *GlobalIoFncs, 
+        IN  EFI_IO_WIDTH                Width,
+        IN  UINTN                       Port,
+        IN  UINTN                       Data
+        );
+
+extern EFI_DEVICE_IO_INTERFACE  *GlobalIoFncs;
+
+#define outp(_Port, _DataByte)  (UINT8)WritePort(GlobalIoFncs,  IO_UINT8,  (UINTN)_Port, (UINTN)_DataByte)
+#define inp(_Port)              (UINT8)ReadPort(GlobalIoFncs,   IO_UINT8,  (UINTN)_Port)
+#define outpw(_Port, _DataByte) (UINT16)WritePort(GlobalIoFncs, IO_UINT16, (UINTN)_Port, (UINTN)_DataByte)
+#define inpw(_Port)             (UINT16)ReadPort(GlobalIoFncs,  IO_UINT16, (UINTN)_Port)
+#define outpd(_Port, _DataByte) (UINT32)WritePort(GlobalIoFncs, IO_UINT32, (UINTN)_Port, (UINTN)_DataByte)
+#define inpd(_Port)             (UINT32)ReadPort(GlobalIoFncs,  IO_UINT32, (UINTN)_Port)
+
+#define writepci8(_Addr, _DataByte)  (UINT8)WritePciConfig(GlobalIoFncs,  IO_UINT8,  (UINTN)_Addr, (UINTN)_DataByte)
+#define readpci8(_Addr)              (UINT8)ReadPciConfig(GlobalIoFncs,   IO_UINT8,  (UINTN)_Addr)
+#define writepci16(_Addr, _DataByte) (UINT16)WritePciConfig(GlobalIoFncs, IO_UINT16, (UINTN)_Addr, (UINTN)_DataByte)
+#define readpci16(_Addr)             (UINT16)ReadPciConfig(GlobalIoFncs,  IO_UINT16, (UINTN)_Addr)
+#define writepci32(_Addr, _DataByte) (UINT32)WritePciConfig(GlobalIoFncs, IO_UINT32, (UINTN)_Addr, (UINTN)_DataByte)
+#define readpci32(_Addr)             (UINT32)ReadPciConfig(GlobalIoFncs,  IO_UINT32, (UINTN)_Addr)
+
+#define Pause()             WaitForSingleEvent (ST->ConIn->WaitForKey, 0)
+#define Port80(_PostCode)   GlobalIoFncs->Io.Write (GlobalIoFncs, IO_UINT16, (UINT64)0x80, 1, &(_PostCode))
+
+#endif
diff --git a/linux-x86/gnu-efi/include/efi/efilink.h b/linux-x86/gnu-efi/include/efi/efilink.h
new file mode 100644
index 0000000..b2ff4fa
--- /dev/null
+++ b/linux-x86/gnu-efi/include/efi/efilink.h
@@ -0,0 +1,177 @@
+#ifndef _EFI_LINK_H
+#define _EFI_LINK_H
+
+/*++
+
+Copyright (c) 1998  Intel Corporation
+
+Module Name:
+
+    link.h (renamed efilink.h to avoid conflicts)
+
+Abstract:
+
+    EFI link list macro's
+
+
+
+Revision History
+
+--*/
+
+#ifndef EFI_NT_EMUL
+
+//
+// List entry - doubly linked list
+//
+
+typedef struct _LIST_ENTRY {
+    struct _LIST_ENTRY  *Flink;
+    struct _LIST_ENTRY  *Blink;
+} LIST_ENTRY;
+
+#endif 
+
+
+//
+//  VOID
+//  InitializeListHead(
+//      LIST_ENTRY *ListHead
+//      );
+//
+
+#define InitializeListHead(ListHead) \
+    (ListHead)->Flink = ListHead;    \
+    (ListHead)->Blink = ListHead;
+
+//
+//  BOOLEAN
+//  IsListEmpty(
+//      PLIST_ENTRY ListHead
+//      );
+//
+
+#define IsListEmpty(ListHead) \
+    ((ListHead)->Flink == (ListHead))
+
+//
+//  VOID
+//  RemoveEntryList(
+//      PLIST_ENTRY Entry
+//      );
+//
+
+#define _RemoveEntryList(Entry) {       \
+        LIST_ENTRY *_Blink, *_Flink;    \
+        _Flink = (Entry)->Flink;        \
+        _Blink = (Entry)->Blink;        \
+        _Blink->Flink = _Flink;         \
+        _Flink->Blink = _Blink;         \
+        }
+
+#if EFI_DEBUG
+    #define RemoveEntryList(Entry)                      \
+        _RemoveEntryList(Entry);                        \
+        (Entry)->Flink = (LIST_ENTRY *) BAD_POINTER;    \
+        (Entry)->Blink = (LIST_ENTRY *) BAD_POINTER; 
+#else
+    #define RemoveEntryList(Entry)      \
+        _RemoveEntryList(Entry);
+#endif
+
+//
+//  VOID
+//  InsertTailList(
+//      PLIST_ENTRY ListHead,
+//      PLIST_ENTRY Entry
+//      );
+//
+
+#define InsertTailList(ListHead,Entry) {\
+    LIST_ENTRY *_ListHead, *_Blink;     \
+    _ListHead = (ListHead);             \
+    _Blink = _ListHead->Blink;          \
+    (Entry)->Flink = _ListHead;         \
+    (Entry)->Blink = _Blink;            \
+    _Blink->Flink = (Entry);            \
+    _ListHead->Blink = (Entry);         \
+    }
+
+//
+//  VOID
+//  InsertHeadList(
+//      PLIST_ENTRY ListHead,
+//      PLIST_ENTRY Entry
+//      );
+//
+
+#define InsertHeadList(ListHead,Entry) {\
+    LIST_ENTRY *_ListHead, *_Flink;     \
+    _ListHead = (ListHead);             \
+    _Flink = _ListHead->Flink;          \
+    (Entry)->Flink = _Flink;            \
+    (Entry)->Blink = _ListHead;         \
+    _Flink->Blink = (Entry);            \
+    _ListHead->Flink = (Entry);         \
+    }
+
+//  VOID
+//  SwapListEntries(
+//      PLIST_ENTRY Entry1,
+//      PLIST_ENTRY Entry2
+//      );
+//
+// Put Entry2 before Entry1
+//
+#define SwapListEntries(Entry1,Entry2) {\
+    LIST_ENTRY *Entry1Flink, *Entry1Blink;     \
+    LIST_ENTRY *Entry2Flink, *Entry2Blink;     \
+    Entry2Flink = (Entry2)->Flink;             \
+    Entry2Blink = (Entry2)->Blink;             \
+    Entry1Flink = (Entry1)->Flink;             \
+    Entry1Blink = (Entry1)->Blink;             \
+    Entry2Blink->Flink = Entry2Flink;       \
+    Entry2Flink->Blink = Entry2Blink;        \
+    (Entry2)->Flink = Entry1;               \
+    (Entry2)->Blink = Entry1Blink;          \
+    Entry1Blink->Flink = (Entry2);            \
+    (Entry1)->Blink = (Entry2);             \
+    }
+
+//
+//  EFI_FIELD_OFFSET - returns the byte offset to a field within a structure
+//
+
+#define EFI_FIELD_OFFSET(TYPE,Field) ((UINTN)(&(((TYPE *) 0)->Field)))
+
+//
+//  CONTAINING_RECORD - returns a pointer to the structure
+//      from one of it's elements.
+//
+
+#define _CR(Record, TYPE, Field)  \
+    ((TYPE *) ( (CHAR8 *)(Record) - (CHAR8 *) &(((TYPE *) 0)->Field)))
+
+#if EFI_DEBUG
+    #define CR(Record, TYPE, Field, Sig)     \
+        _CR(Record, TYPE, Field)->Signature != Sig ?        \
+            (TYPE *) ASSERT_STRUCT(_CR(Record, TYPE, Field), Record) : \
+            _CR(Record, TYPE, Field)
+#else
+    #define CR(Record, TYPE, Field, Signature)   \
+        _CR(Record, TYPE, Field)                           
+#endif
+
+
+//
+// A lock structure
+//
+
+typedef struct _FLOCK {
+    EFI_TPL     Tpl;
+    EFI_TPL     OwnerTpl;
+    UINTN       Lock;
+} FLOCK;
+
+#endif
+
diff --git a/linux-x86/gnu-efi/include/efi/efinet.h b/linux-x86/gnu-efi/include/efi/efinet.h
new file mode 100644
index 0000000..b2e5aa8
--- /dev/null
+++ b/linux-x86/gnu-efi/include/efi/efinet.h
@@ -0,0 +1,340 @@
+#ifndef _EFINET_H
+#define _EFINET_H
+
+
+/*++
+Copyright (c) 1999  Intel Corporation
+
+Module Name:
+    efinet.h
+
+Abstract:
+    EFI Simple Network protocol
+
+Revision History
+--*/
+
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//      Simple Network Protocol
+//
+
+#define EFI_SIMPLE_NETWORK_PROTOCOL \
+    { 0xA19832B9, 0xAC25, 0x11D3, {0x9A, 0x2D, 0x00, 0x90, 0x27, 0x3F, 0xC1, 0x4D} }
+
+
+INTERFACE_DECL(_EFI_SIMPLE_NETWORK);
+
+///////////////////////////////////////////////////////////////////////////////
+//
+
+typedef struct {
+    //
+    // Total number of frames received.  Includes frames with errors and
+    // dropped frames.
+    //
+    UINT64  RxTotalFrames;
+
+    //
+    // Number of valid frames received and copied into receive buffers.
+    //
+    UINT64  RxGoodFrames;
+
+    //
+    // Number of frames below the minimum length for the media.
+    // This would be <64 for ethernet.
+    //
+    UINT64  RxUndersizeFrames;
+
+    //
+    // Number of frames longer than the maxminum length for the
+    // media.  This would be >1500 for ethernet.
+    //
+    UINT64  RxOversizeFrames;
+
+    //
+    // Valid frames that were dropped because receive buffers were full.
+    //
+    UINT64  RxDroppedFrames;
+
+    //
+    // Number of valid unicast frames received and not dropped.
+    //
+    UINT64  RxUnicastFrames;
+
+    //
+    // Number of valid broadcast frames received and not dropped.
+    //
+    UINT64  RxBroadcastFrames;
+
+    //
+    // Number of valid mutlicast frames received and not dropped.
+    //
+    UINT64  RxMulticastFrames;
+
+    //
+    // Number of frames w/ CRC or alignment errors.
+    //
+    UINT64  RxCrcErrorFrames;
+
+    //
+    // Total number of bytes received.  Includes frames with errors
+    // and dropped frames.
+    //
+    UINT64  RxTotalBytes;
+
+    //
+    // Transmit statistics.
+    //
+    UINT64  TxTotalFrames;
+    UINT64  TxGoodFrames;
+    UINT64  TxUndersizeFrames;
+    UINT64  TxOversizeFrames;
+    UINT64  TxDroppedFrames;
+    UINT64  TxUnicastFrames;
+    UINT64  TxBroadcastFrames;
+    UINT64  TxMulticastFrames;
+    UINT64  TxCrcErrorFrames;
+    UINT64  TxTotalBytes;
+
+    //
+    // Number of collisions detection on this subnet.
+    //
+    UINT64  Collisions;
+
+    //
+    // Number of frames destined for unsupported protocol.
+    //
+    UINT64  UnsupportedProtocol;
+
+} EFI_NETWORK_STATISTICS;
+
+///////////////////////////////////////////////////////////////////////////////
+//
+
+typedef enum {
+    EfiSimpleNetworkStopped,
+    EfiSimpleNetworkStarted,
+    EfiSimpleNetworkInitialized,
+    EfiSimpleNetworkMaxState
+} EFI_SIMPLE_NETWORK_STATE;
+
+///////////////////////////////////////////////////////////////////////////////
+//
+
+#define EFI_SIMPLE_NETWORK_RECEIVE_UNICAST               0x01
+#define EFI_SIMPLE_NETWORK_RECEIVE_MULTICAST             0x02
+#define EFI_SIMPLE_NETWORK_RECEIVE_BROADCAST             0x04
+#define EFI_SIMPLE_NETWORK_RECEIVE_PROMISCUOUS           0x08
+#define EFI_SIMPLE_NETWORK_RECEIVE_PROMISCUOUS_MULTICAST 0x10
+
+///////////////////////////////////////////////////////////////////////////////
+//
+
+#define EFI_SIMPLE_NETWORK_RECEIVE_INTERRUPT        0x01
+#define EFI_SIMPLE_NETWORK_TRANSMIT_INTERRUPT       0x02
+#define EFI_SIMPLE_NETWORK_COMMAND_INTERRUPT        0x04
+#define EFI_SIMPLE_NETWORK_SOFTWARE_INTERRUPT       0x08
+
+///////////////////////////////////////////////////////////////////////////////
+//
+#define MAX_MCAST_FILTER_CNT    16
+typedef struct {
+    UINT32                      State;
+    UINT32                      HwAddressSize;
+    UINT32                      MediaHeaderSize;
+    UINT32                      MaxPacketSize;
+    UINT32                      NvRamSize;
+    UINT32                      NvRamAccessSize;
+    UINT32                      ReceiveFilterMask;
+    UINT32                      ReceiveFilterSetting;
+    UINT32                      MaxMCastFilterCount;
+    UINT32                      MCastFilterCount;
+    EFI_MAC_ADDRESS             MCastFilter[MAX_MCAST_FILTER_CNT];
+    EFI_MAC_ADDRESS             CurrentAddress;
+    EFI_MAC_ADDRESS             BroadcastAddress;
+    EFI_MAC_ADDRESS             PermanentAddress;
+    UINT8                       IfType;
+    BOOLEAN                     MacAddressChangeable;
+    BOOLEAN                     MultipleTxSupported;
+    BOOLEAN                     MediaPresentSupported;
+    BOOLEAN                     MediaPresent;
+} EFI_SIMPLE_NETWORK_MODE;
+
+///////////////////////////////////////////////////////////////////////////////
+//
+
+typedef 
+EFI_STATUS 
+(EFIAPI *EFI_SIMPLE_NETWORK_START) (
+    IN struct _EFI_SIMPLE_NETWORK  *This
+);
+
+///////////////////////////////////////////////////////////////////////////////
+//
+
+typedef 
+EFI_STATUS 
+(EFIAPI *EFI_SIMPLE_NETWORK_STOP) (
+    IN struct _EFI_SIMPLE_NETWORK  *This
+);
+
+///////////////////////////////////////////////////////////////////////////////
+//
+
+typedef 
+EFI_STATUS 
+(EFIAPI *EFI_SIMPLE_NETWORK_INITIALIZE) (
+    IN struct _EFI_SIMPLE_NETWORK  *This,
+    IN UINTN                       ExtraRxBufferSize  OPTIONAL,
+    IN UINTN                       ExtraTxBufferSize  OPTIONAL
+);
+
+///////////////////////////////////////////////////////////////////////////////
+//
+
+typedef 
+EFI_STATUS 
+(EFIAPI *EFI_SIMPLE_NETWORK_RESET) (
+    IN struct _EFI_SIMPLE_NETWORK   *This,
+    IN BOOLEAN                      ExtendedVerification
+);
+
+///////////////////////////////////////////////////////////////////////////////
+//
+
+typedef 
+EFI_STATUS 
+(EFIAPI *EFI_SIMPLE_NETWORK_SHUTDOWN) (
+    IN struct _EFI_SIMPLE_NETWORK  *This
+);
+
+///////////////////////////////////////////////////////////////////////////////
+//
+
+typedef 
+EFI_STATUS 
+(EFIAPI *EFI_SIMPLE_NETWORK_RECEIVE_FILTERS) (
+    IN struct _EFI_SIMPLE_NETWORK   *This,
+    IN UINT32                       Enable,
+    IN UINT32                       Disable,
+    IN BOOLEAN                      ResetMCastFilter,
+    IN UINTN                        MCastFilterCnt     OPTIONAL,
+    IN EFI_MAC_ADDRESS              *MCastFilter       OPTIONAL
+);
+
+///////////////////////////////////////////////////////////////////////////////
+//
+
+typedef 
+EFI_STATUS 
+(EFIAPI *EFI_SIMPLE_NETWORK_STATION_ADDRESS) (
+    IN struct _EFI_SIMPLE_NETWORK   *This,
+    IN BOOLEAN                      Reset,
+    IN EFI_MAC_ADDRESS              *New      OPTIONAL
+);
+
+///////////////////////////////////////////////////////////////////////////////
+//
+
+typedef 
+EFI_STATUS 
+(EFIAPI *EFI_SIMPLE_NETWORK_STATISTICS) (
+    IN struct _EFI_SIMPLE_NETWORK   *This,
+    IN BOOLEAN                      Reset,
+    IN OUT UINTN                    *StatisticsSize   OPTIONAL,
+    OUT EFI_NETWORK_STATISTICS      *StatisticsTable  OPTIONAL
+);
+
+///////////////////////////////////////////////////////////////////////////////
+//
+
+typedef 
+EFI_STATUS 
+(EFIAPI *EFI_SIMPLE_NETWORK_MCAST_IP_TO_MAC) (
+    IN struct _EFI_SIMPLE_NETWORK   *This,
+    IN BOOLEAN                      IPv6,
+    IN EFI_IP_ADDRESS               *IP,
+    OUT EFI_MAC_ADDRESS             *MAC
+);
+
+///////////////////////////////////////////////////////////////////////////////
+//
+
+typedef 
+EFI_STATUS 
+(EFIAPI *EFI_SIMPLE_NETWORK_NVDATA) (
+    IN struct _EFI_SIMPLE_NETWORK  *This,
+    IN BOOLEAN                     ReadWrite,
+    IN UINTN                       Offset,
+    IN UINTN                       BufferSize,
+    IN OUT VOID                    *Buffer
+);
+
+///////////////////////////////////////////////////////////////////////////////
+//
+
+typedef 
+EFI_STATUS 
+(EFIAPI *EFI_SIMPLE_NETWORK_GET_STATUS) (
+    IN struct _EFI_SIMPLE_NETWORK  *This,
+    OUT UINT32                     *InterruptStatus  OPTIONAL,
+    OUT VOID                       **TxBuf           OPTIONAL
+);
+
+///////////////////////////////////////////////////////////////////////////////
+//
+
+typedef 
+EFI_STATUS 
+(EFIAPI *EFI_SIMPLE_NETWORK_TRANSMIT) (
+    IN struct _EFI_SIMPLE_NETWORK   *This,
+    IN UINTN                        HeaderSize,
+    IN UINTN                        BufferSize,
+    IN VOID                         *Buffer,
+    IN EFI_MAC_ADDRESS              *SrcAddr     OPTIONAL,
+    IN EFI_MAC_ADDRESS              *DestAddr    OPTIONAL,
+    IN UINT16                       *Protocol    OPTIONAL
+);
+
+///////////////////////////////////////////////////////////////////////////////
+//
+
+typedef 
+EFI_STATUS 
+(EFIAPI *EFI_SIMPLE_NETWORK_RECEIVE) (
+    IN struct _EFI_SIMPLE_NETWORK   *This,
+    OUT UINTN                       *HeaderSize  OPTIONAL,
+    IN OUT UINTN                    *BufferSize,
+    OUT VOID                        *Buffer,
+    OUT EFI_MAC_ADDRESS             *SrcAddr     OPTIONAL,
+    OUT EFI_MAC_ADDRESS             *DestAddr    OPTIONAL,
+    OUT UINT16                      *Protocol    OPTIONAL
+);
+
+///////////////////////////////////////////////////////////////////////////////
+//
+
+#define EFI_SIMPLE_NETWORK_INTERFACE_REVISION   0x00010000
+
+typedef struct _EFI_SIMPLE_NETWORK {
+    UINT64                              Revision;
+    EFI_SIMPLE_NETWORK_START            Start;
+    EFI_SIMPLE_NETWORK_STOP             Stop;
+    EFI_SIMPLE_NETWORK_INITIALIZE       Initialize;
+    EFI_SIMPLE_NETWORK_RESET            Reset;
+    EFI_SIMPLE_NETWORK_SHUTDOWN         Shutdown;
+    EFI_SIMPLE_NETWORK_RECEIVE_FILTERS  ReceiveFilters;
+    EFI_SIMPLE_NETWORK_STATION_ADDRESS  StationAddress;
+    EFI_SIMPLE_NETWORK_STATISTICS       Statistics;
+    EFI_SIMPLE_NETWORK_MCAST_IP_TO_MAC  MCastIpToMac;
+    EFI_SIMPLE_NETWORK_NVDATA           NvData;
+    EFI_SIMPLE_NETWORK_GET_STATUS       GetStatus;
+    EFI_SIMPLE_NETWORK_TRANSMIT         Transmit;
+    EFI_SIMPLE_NETWORK_RECEIVE          Receive;
+    EFI_EVENT                           WaitForPacket;
+    EFI_SIMPLE_NETWORK_MODE             *Mode;
+} EFI_SIMPLE_NETWORK;
+
+#endif /* _EFINET_H */
diff --git a/linux-x86/gnu-efi/include/efi/efipart.h b/linux-x86/gnu-efi/include/efi/efipart.h
new file mode 100644
index 0000000..d4c5573
--- /dev/null
+++ b/linux-x86/gnu-efi/include/efi/efipart.h
@@ -0,0 +1,61 @@
+#ifndef _EFI_PART_H
+#define _EFI_PART_H
+
+/*++
+
+Copyright (c) 1998  Intel Corporation
+
+Module Name:
+
+    efipart.h
+    
+Abstract:   
+    Info about disk partitions and Master Boot Records
+
+
+
+
+Revision History
+
+--*/
+
+//
+//
+//
+
+#define EFI_PARTITION   0xef
+#define MBR_SIZE        512
+
+#pragma pack(1)
+
+typedef struct {
+    UINT8       BootIndicator;
+    UINT8       StartHead;
+    UINT8       StartSector;
+    UINT8       StartTrack;
+    UINT8       OSIndicator;
+    UINT8       EndHead;
+    UINT8       EndSector;
+    UINT8       EndTrack;
+    UINT8       StartingLBA[4];
+    UINT8       SizeInLBA[4];
+} MBR_PARTITION_RECORD;
+
+#define EXTRACT_UINT32(D) (UINT32)(D[0] | (D[1] << 8) | (D[2] << 16) | (D[3] << 24))
+
+#define MBR_SIGNATURE           0xaa55
+#define MIN_MBR_DEVICE_SIZE     0x80000
+#define MBR_ERRATA_PAD          0x40000 // 128 MB
+
+#define MAX_MBR_PARTITIONS  4   
+typedef struct {
+    UINT8                   BootStrapCode[440];
+    UINT8                   UniqueMbrSignature[4];
+    UINT8                   Unknown[2];
+    MBR_PARTITION_RECORD    Partition[MAX_MBR_PARTITIONS];
+    UINT16                  Signature;
+} MASTER_BOOT_RECORD;
+#pragma pack()
+
+
+#endif
diff --git a/linux-x86/gnu-efi/include/efi/efipciio.h b/linux-x86/gnu-efi/include/efi/efipciio.h
new file mode 100644
index 0000000..0724f95
--- /dev/null
+++ b/linux-x86/gnu-efi/include/efi/efipciio.h
@@ -0,0 +1,219 @@
+#ifndef _EFI_PCI_IO_H
+#define _EFI_PCI_IO_H
+
+#define EFI_PCI_IO_PROTOCOL \
+    { 0x4cf5b200, 0x68b8, 0x4ca5, {0x9e, 0xec, 0xb2, 0x3e, 0x3f, 0x50, 0x02, 0x9a} }
+
+INTERFACE_DECL(_EFI_PCI_IO);
+
+typedef enum {
+    EfiPciIoWidthUint8,
+    EfiPciIoWidthUint16,
+    EfiPciIoWidthUint32,
+    EfiPciIoWidthUint64,
+    EfiPciIoWidthFifoUint8,
+    EfiPciIoWidthFifoUint16,
+    EfiPciIoWidthFifoUint32,
+    EfiPciIoWidthFifoUint64,
+    EfiPciIoWidthFillUint8,
+    EfiPciIoWidthFillUint16,
+    EfiPciIoWidthFillUint32,
+    EfiPciIoWidthFillUint64,
+    EfiPciIoWidthMaximum
+} EFI_PCI_IO_PROTOCOL_WIDTH;
+
+#define EFI_PCI_IO_PASS_THROUGH_BAR 0xff
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PCI_IO_PROTOCOL_POLL_IO_MEM) (
+  IN struct _EFI_PCI_IO *This,
+  IN EFI_PCI_IO_PROTOCOL_WIDTH  Width,
+  IN UINT8                      BarIndex,
+  IN UINT64                     Offset,
+  IN UINT64                     Mask,
+  IN UINT64                     Value,
+  IN UINT64                     Delay,
+  OUT UINT64                    *Result
+  );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PCI_IO_PROTOCOL_IO_MEM) (
+  IN struct _EFI_PCI_IO *This,
+  IN EFI_PCI_IO_PROTOCOL_WIDTH  Width,
+  IN UINT8                      BarIndex,
+  IN UINT64                     Offset,
+  IN UINTN                      Count,
+  IN OUT VOID                   *Buffer
+);
+
+typedef struct {
+  EFI_PCI_IO_PROTOCOL_IO_MEM    Read;
+  EFI_PCI_IO_PROTOCOL_IO_MEM    Write;
+} EFI_PCI_IO_PROTOCOL_ACCESS;
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PCI_IO_PROTOCOL_CONFIG) (
+  IN struct _EFI_PCI_IO *This,
+  IN EFI_PCI_IO_PROTOCOL_WIDTH  Width,
+  IN UINT32                     Offset,
+  IN UINTN                      Count,
+  IN OUT VOID                   *Buffer
+);
+
+typedef struct {
+  EFI_PCI_IO_PROTOCOL_CONFIG Read;
+  EFI_PCI_IO_PROTOCOL_CONFIG Write;
+} EFI_PCI_IO_PROTOCOL_CONFIG_ACCESS;
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PCI_IO_PROTOCOL_COPY_MEM) (
+  IN struct _EFI_PCI_IO *This,
+  IN EFI_PCI_IO_PROTOCOL_WIDTH  Width,
+  IN UINT8                      DestBarIndex,
+  IN UINT64                     DestOffset,
+  IN UINT8                      SrcBarIndex,
+  IN UINT64                     SrcOffset,
+  IN UINTN                      Count
+  );
+
+typedef enum {
+    EfiPciIoOperationBusMasterRead,
+    EfiPciIoOperationBusMasterWrite,
+    EfiPciIoOperationBusMasterCommonBuffer,
+    EfiPciIoOperationMaximum
+} EFI_PCI_IO_PROTOCOL_OPERATION;
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PCI_IO_PROTOCOL_MAP) (
+  IN struct _EFI_PCI_IO    *This,
+  IN EFI_PCI_IO_PROTOCOL_OPERATION Operation,
+  IN VOID                          *HostAddress,
+  IN OUT UINTN                     *NumberOfBytes,
+  OUT EFI_PHYSICAL_ADDRESS         *DeviceAddress,
+  OUT VOID                         **Mapping
+  );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PCI_IO_PROTOCOL_UNMAP) (
+  IN struct _EFI_PCI_IO *This,
+  IN VOID                       *Mapping
+);
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PCI_IO_PROTOCOL_ALLOCATE_BUFFER) (
+  IN struct _EFI_PCI_IO *This,
+  IN EFI_ALLOCATE_TYPE          Type,
+  IN EFI_MEMORY_TYPE            MemoryType,
+  IN UINTN                      Pages,
+  OUT VOID                      **HostAddress,
+  IN UINT64                     Attributes
+  );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PCI_IO_PROTOCOL_FREE_BUFFER) (
+  IN struct _EFI_PCI_IO *This,
+  IN UINTN                      Pages,
+  IN VOID                       *HostAddress
+  );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PCI_IO_PROTOCOL_FLUSH) (
+  IN struct _EFI_PCI_IO *This
+  );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PCI_IO_PROTOCOL_GET_LOCATION) (
+  IN struct _EFI_PCI_IO *This,
+  OUT UINTN                     *SegmentNumber,
+  OUT UINTN                     *BusNumber,
+  OUT UINTN                     *DeviceNumber,
+  OUT UINTN                     *FunctionNumber
+  );
+
+#define EFI_PCI_IO_ATTRIBUTE_ISA_IO               0x0002
+#define EFI_PCI_IO_ATTRIBUTE_VGA_PALETTE_IO       0x0004
+#define EFI_PCI_IO_ATTRIBUTE_VGA_MEMORY           0x0008
+#define EFI_PCI_IO_ATTRIBUTE_VGA_IO               0x0010
+#define EFI_PCI_IO_ATTRIBUTE_IDE_PRIMARY_IO       0x0020
+#define EFI_PCI_IO_ATTRIBUTE_IDE_SECONDARY_IO     0x0040
+#define EFI_PCI_IO_ATTRIBUTE_MEMORY_WRITE_COMBINE 0x0080
+#define EFI_PCI_IO_ATTRIBUTE_IO                   0x0100
+#define EFI_PCI_IO_ATTRIBUTE_MEMORY               0x0200
+#define EFI_PCI_IO_ATTRIBUTE_BUS_MASTER           0x0400
+#define EFI_PCI_IO_ATTRIBUTE_MEMORY_CACHED        0x0800
+#define EFI_PCI_IO_ATTRIBUTE_MEMORY_DISABLE       0x1000
+#define EFI_PCI_IO_ATTRIBUTE_EMBEDDED_DEVICE      0x2000
+#define EFI_PCI_IO_ATTRIBUTE_EMBEDDED_ROM         0x4000
+#define EFI_PCI_IO_ATTRIBUTE_DUAL_ADDRESS_CYCLE   0x8000
+#define EFI_PCI_IO_ATTRIBUTE_ISA_IO_16            0x10000
+#define EFI_PCI_IO_ATTRIBUTE_VGA_PALETTE_IO_16    0x20000
+#define EFI_PCI_IO_ATTRIBUTE_VGA_IO_16            0x40000
+
+typedef enum {
+    EfiPciIoAttributeOperationGet,
+    EfiPciIoAttributeOperationSet,
+    EfiPciIoAttributeOperationEnable,
+    EfiPciIoAttributeOperationDisable,
+    EfiPciIoAttributeOperationSupported,
+    EfiPciIoAttributeOperationMaximum
+} EFI_PCI_IO_PROTOCOL_ATTRIBUTE_OPERATION;
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PCI_IO_PROTOCOL_ATTRIBUTES) (
+  IN struct _EFI_PCI_IO             *This,
+  IN EFI_PCI_IO_PROTOCOL_ATTRIBUTE_OPERATION Operation,
+  IN UINT64                                  Attributes,
+  OUT UINT64                                 *Result OPTIONAL
+  );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PCI_IO_PROTOCOL_GET_BAR_ATTRIBUTES) (
+  IN struct _EFI_PCI_IO *This,
+  IN UINT8                      BarIndex,
+  OUT UINT64                    *Supports OPTIONAL,
+  OUT VOID                      **Resources OPTIONAL
+  );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PCI_IO_PROTOCOL_SET_BAR_ATTRIBUTES) (
+  IN struct _EFI_PCI_IO *This,
+  IN UINT64                     Attributes,
+  IN UINT8                      BarIndex,
+  IN OUT UINT64                 *Offset,
+  IN OUT UINT64                 *Length
+  );
+
+typedef struct _EFI_PCI_IO {
+  EFI_PCI_IO_PROTOCOL_POLL_IO_MEM        PollMem;
+  EFI_PCI_IO_PROTOCOL_POLL_IO_MEM        PollIo;
+  EFI_PCI_IO_PROTOCOL_ACCESS             Mem;
+  EFI_PCI_IO_PROTOCOL_ACCESS             Io;
+  EFI_PCI_IO_PROTOCOL_CONFIG_ACCESS      Pci;
+  EFI_PCI_IO_PROTOCOL_COPY_MEM           CopyMem;
+  EFI_PCI_IO_PROTOCOL_MAP                Map;
+  EFI_PCI_IO_PROTOCOL_UNMAP              Unmap;
+  EFI_PCI_IO_PROTOCOL_ALLOCATE_BUFFER    AllocateBuffer;
+  EFI_PCI_IO_PROTOCOL_FREE_BUFFER        FreeBuffer;
+  EFI_PCI_IO_PROTOCOL_FLUSH              Flush;
+  EFI_PCI_IO_PROTOCOL_GET_LOCATION       GetLocation;
+  EFI_PCI_IO_PROTOCOL_ATTRIBUTES         Attributes;
+  EFI_PCI_IO_PROTOCOL_GET_BAR_ATTRIBUTES GetBarAttributes;
+  EFI_PCI_IO_PROTOCOL_SET_BAR_ATTRIBUTES SetBarAttributes;
+  UINT64                                 RomSize;
+  VOID                                   *RomImage;
+} EFI_PCI_IO;
+
+#endif /* _EFI_PCI_IO_H */
diff --git a/linux-x86/gnu-efi/include/efi/efiprot.h b/linux-x86/gnu-efi/include/efi/efiprot.h
new file mode 100644
index 0000000..a6df337
--- /dev/null
+++ b/linux-x86/gnu-efi/include/efi/efiprot.h
@@ -0,0 +1,736 @@
+#ifndef _EFI_PROT_H
+#define _EFI_PROT_H
+
+/*++
+
+Copyright (c) 1998  Intel Corporation
+
+Module Name:
+
+    efiprot.h
+
+Abstract:
+
+    EFI Protocols
+
+
+
+Revision History
+
+--*/
+
+//
+//  FPSWA library protocol
+//
+#define FPSWA_PROTOCOL          \
+    { 0xc41b6531, 0x97b9, 0x11d3, {0x9a, 0x29, 0x0, 0x90, 0x27, 0x3f, 0xc1, 0x4d} }
+
+//
+// Device Path protocol
+//
+
+#define DEVICE_PATH_PROTOCOL    \
+    { 0x9576e91, 0x6d3f, 0x11d2, {0x8e, 0x39, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b} }
+
+
+//
+// Block IO protocol
+//
+
+#define BLOCK_IO_PROTOCOL \
+    { 0x964e5b21, 0x6459, 0x11d2, {0x8e, 0x39, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b} }
+#define EFI_BLOCK_IO_INTERFACE_REVISION   0x00010000
+#define EFI_BLOCK_IO_INTERFACE_REVISION2  0x00020001
+#define EFI_BLOCK_IO_INTERFACE_REVISION3  ((2<<16) | 31)
+
+INTERFACE_DECL(_EFI_BLOCK_IO);
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_BLOCK_RESET) (
+    IN struct _EFI_BLOCK_IO     *This,
+    IN BOOLEAN                  ExtendedVerification
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_BLOCK_READ) (
+    IN struct _EFI_BLOCK_IO     *This,
+    IN UINT32                   MediaId,
+    IN EFI_LBA                  LBA,
+    IN UINTN                    BufferSize,
+    OUT VOID                    *Buffer
+    );
+
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_BLOCK_WRITE) (
+    IN struct _EFI_BLOCK_IO     *This,
+    IN UINT32                   MediaId,
+    IN EFI_LBA                  LBA,
+    IN UINTN                    BufferSize,
+    IN VOID                     *Buffer
+    );
+
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_BLOCK_FLUSH) (
+    IN struct _EFI_BLOCK_IO     *This
+    );
+
+
+
+typedef struct {
+    UINT32              MediaId;
+    BOOLEAN             RemovableMedia;
+    BOOLEAN             MediaPresent;
+
+    BOOLEAN             LogicalPartition;
+    BOOLEAN             ReadOnly;
+    BOOLEAN             WriteCaching;
+
+    UINT32              BlockSize;
+    UINT32              IoAlign;
+
+    EFI_LBA             LastBlock;
+
+    /* revision 2 */
+    EFI_LBA             LowestAlignedLba;
+    UINT32              LogicalBlocksPerPhysicalBlock;
+    /* revision 3 */
+    UINT32              OptimalTransferLengthGranularity;
+} EFI_BLOCK_IO_MEDIA;
+
+typedef struct _EFI_BLOCK_IO {
+    UINT64                  Revision;
+
+    EFI_BLOCK_IO_MEDIA      *Media;
+
+    EFI_BLOCK_RESET         Reset;
+    EFI_BLOCK_READ          ReadBlocks;
+    EFI_BLOCK_WRITE         WriteBlocks;
+    EFI_BLOCK_FLUSH         FlushBlocks;
+
+} EFI_BLOCK_IO;
+
+
+
+//
+// Disk Block IO protocol
+//
+
+#define DISK_IO_PROTOCOL \
+    { 0xce345171, 0xba0b, 0x11d2,  {0x8e, 0x4f, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b} }
+#define EFI_DISK_IO_INTERFACE_REVISION   0x00010000
+
+INTERFACE_DECL(_EFI_DISK_IO);
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_DISK_READ) (
+    IN struct _EFI_DISK_IO      *This,
+    IN UINT32                   MediaId,
+    IN UINT64                   Offset,
+    IN UINTN                    BufferSize,
+    OUT VOID                    *Buffer
+    );
+
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_DISK_WRITE) (
+    IN struct _EFI_DISK_IO      *This,
+    IN UINT32                   MediaId,
+    IN UINT64                   Offset,
+    IN UINTN                    BufferSize,
+    IN VOID                     *Buffer
+    );
+
+
+typedef struct _EFI_DISK_IO {
+    UINT64              Revision;
+    EFI_DISK_READ       ReadDisk;
+    EFI_DISK_WRITE      WriteDisk;
+} EFI_DISK_IO;
+
+
+//
+// Simple file system protocol
+//
+
+#define SIMPLE_FILE_SYSTEM_PROTOCOL \
+    { 0x964e5b22, 0x6459, 0x11d2, {0x8e, 0x39, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b} }
+
+INTERFACE_DECL(_EFI_FILE_IO_INTERFACE);
+INTERFACE_DECL(_EFI_FILE_HANDLE);
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_VOLUME_OPEN) (
+    IN struct _EFI_FILE_IO_INTERFACE    *This,
+    OUT struct _EFI_FILE_HANDLE         **Root
+    );
+
+#define EFI_FILE_IO_INTERFACE_REVISION   0x00010000
+
+typedef struct _EFI_FILE_IO_INTERFACE {
+    UINT64                  Revision;
+    EFI_VOLUME_OPEN         OpenVolume;
+} EFI_FILE_IO_INTERFACE;
+
+//
+//
+//
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_FILE_OPEN) (
+    IN struct _EFI_FILE_HANDLE  *File,
+    OUT struct _EFI_FILE_HANDLE **NewHandle,
+    IN CHAR16                   *FileName,
+    IN UINT64                   OpenMode,
+    IN UINT64                   Attributes
+    );
+
+// Open modes
+#define EFI_FILE_MODE_READ      0x0000000000000001
+#define EFI_FILE_MODE_WRITE     0x0000000000000002
+#define EFI_FILE_MODE_CREATE    0x8000000000000000
+
+// File attributes
+#define EFI_FILE_READ_ONLY      0x0000000000000001
+#define EFI_FILE_HIDDEN         0x0000000000000002
+#define EFI_FILE_SYSTEM         0x0000000000000004
+#define EFI_FILE_RESERVIED      0x0000000000000008
+#define EFI_FILE_DIRECTORY      0x0000000000000010
+#define EFI_FILE_ARCHIVE        0x0000000000000020
+#define EFI_FILE_VALID_ATTR     0x0000000000000037
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_FILE_CLOSE) (
+    IN struct _EFI_FILE_HANDLE  *File
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_FILE_DELETE) (
+    IN struct _EFI_FILE_HANDLE  *File
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_FILE_READ) (
+    IN struct _EFI_FILE_HANDLE  *File,
+    IN OUT UINTN                *BufferSize,
+    OUT VOID                    *Buffer
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_FILE_WRITE) (
+    IN struct _EFI_FILE_HANDLE  *File,
+    IN OUT UINTN                *BufferSize,
+    IN VOID                     *Buffer
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_FILE_SET_POSITION) (
+    IN struct _EFI_FILE_HANDLE  *File,
+    IN UINT64                   Position
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_FILE_GET_POSITION) (
+    IN struct _EFI_FILE_HANDLE  *File,
+    OUT UINT64                  *Position
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_FILE_GET_INFO) (
+    IN struct _EFI_FILE_HANDLE  *File,
+    IN EFI_GUID                 *InformationType,
+    IN OUT UINTN                *BufferSize,
+    OUT VOID                    *Buffer
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_FILE_SET_INFO) (
+    IN struct _EFI_FILE_HANDLE  *File,
+    IN EFI_GUID                 *InformationType,
+    IN UINTN                    BufferSize,
+    IN VOID                     *Buffer
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_FILE_FLUSH) (
+    IN struct _EFI_FILE_HANDLE  *File
+    );
+
+
+
+#define EFI_FILE_HANDLE_REVISION         0x00010000
+typedef struct _EFI_FILE_HANDLE {
+    UINT64                  Revision;
+    EFI_FILE_OPEN           Open;
+    EFI_FILE_CLOSE          Close;
+    EFI_FILE_DELETE         Delete;
+    EFI_FILE_READ           Read;
+    EFI_FILE_WRITE          Write;
+    EFI_FILE_GET_POSITION   GetPosition;
+    EFI_FILE_SET_POSITION   SetPosition;
+    EFI_FILE_GET_INFO       GetInfo;
+    EFI_FILE_SET_INFO       SetInfo;
+    EFI_FILE_FLUSH          Flush;
+} EFI_FILE, *EFI_FILE_HANDLE;
+
+
+//
+// File information types
+//
+
+#define EFI_FILE_INFO_ID   \
+    { 0x9576e92, 0x6d3f, 0x11d2, {0x8e, 0x39, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b} }
+
+typedef struct {
+    UINT64                  Size;
+    UINT64                  FileSize;
+    UINT64                  PhysicalSize;
+    EFI_TIME                CreateTime;
+    EFI_TIME                LastAccessTime;
+    EFI_TIME                ModificationTime;
+    UINT64                  Attribute;
+    CHAR16                  FileName[1];
+} EFI_FILE_INFO;
+
+//
+// The FileName field of the EFI_FILE_INFO data structure is variable length.
+// Whenever code needs to know the size of the EFI_FILE_INFO data structure, it needs to
+// be the size of the data structure without the FileName field.  The following macro 
+// computes this size correctly no matter how big the FileName array is declared.
+// This is required to make the EFI_FILE_INFO data structure ANSI compilant. 
+//
+
+#define SIZE_OF_EFI_FILE_INFO EFI_FIELD_OFFSET(EFI_FILE_INFO,FileName)
+
+#define EFI_FILE_SYSTEM_INFO_ID    \
+    { 0x9576e93, 0x6d3f, 0x11d2, {0x8e, 0x39, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b} }
+
+typedef struct {
+    UINT64                  Size;
+    BOOLEAN                 ReadOnly;
+    UINT64                  VolumeSize;
+    UINT64                  FreeSpace;
+    UINT32                  BlockSize;
+    CHAR16                  VolumeLabel[1];
+} EFI_FILE_SYSTEM_INFO;
+
+//
+// The VolumeLabel field of the EFI_FILE_SYSTEM_INFO data structure is variable length.
+// Whenever code needs to know the size of the EFI_FILE_SYSTEM_INFO data structure, it needs
+// to be the size of the data structure without the VolumeLable field.  The following macro 
+// computes this size correctly no matter how big the VolumeLable array is declared.
+// This is required to make the EFI_FILE_SYSTEM_INFO data structure ANSI compilant. 
+//
+
+#define SIZE_OF_EFI_FILE_SYSTEM_INFO EFI_FIELD_OFFSET(EFI_FILE_SYSTEM_INFO,VolumeLabel)
+
+#define EFI_FILE_SYSTEM_VOLUME_LABEL_INFO_ID    \
+    { 0xDB47D7D3,0xFE81, 0x11d3, {0x9A, 0x35, 0x00, 0x90, 0x27, 0x3F, 0xC1, 0x4D} }
+
+typedef struct {
+    CHAR16                  VolumeLabel[1];
+} EFI_FILE_SYSTEM_VOLUME_LABEL_INFO;
+
+#define SIZE_OF_EFI_FILE_SYSTEM_VOLUME_LABEL_INFO EFI_FIELD_OFFSET(EFI_FILE_SYSTEM_VOLUME_LABEL_INFO,VolumeLabel)
+
+//
+// Load file protocol
+//
+
+
+#define LOAD_FILE_PROTOCOL \
+    { 0x56EC3091, 0x954C, 0x11d2, {0x8E, 0x3F, 0x00, 0xA0, 0xC9, 0x69, 0x72, 0x3B} }
+
+INTERFACE_DECL(_EFI_LOAD_FILE_INTERFACE);
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_LOAD_FILE) (
+    IN struct _EFI_LOAD_FILE_INTERFACE  *This,
+    IN EFI_DEVICE_PATH                  *FilePath,
+    IN BOOLEAN                          BootPolicy,
+    IN OUT UINTN                        *BufferSize,
+    IN VOID                             *Buffer OPTIONAL
+    );
+
+typedef struct _EFI_LOAD_FILE_INTERFACE {
+    EFI_LOAD_FILE                       LoadFile;
+} EFI_LOAD_FILE_INTERFACE;
+
+
+//
+// Device IO protocol
+//
+
+#define DEVICE_IO_PROTOCOL \
+    { 0xaf6ac311, 0x84c3, 0x11d2, {0x8e, 0x3c, 0x00, 0xa0, 0xc9, 0x69, 0x72, 0x3b} }
+
+INTERFACE_DECL(_EFI_DEVICE_IO_INTERFACE);
+
+typedef enum {
+    IO_UINT8,
+    IO_UINT16,
+    IO_UINT32,
+    IO_UINT64,
+//
+// Specification Change: Copy from MMIO to MMIO vs. MMIO to buffer, buffer to MMIO
+//
+    MMIO_COPY_UINT8,
+    MMIO_COPY_UINT16,
+    MMIO_COPY_UINT32,
+    MMIO_COPY_UINT64
+} EFI_IO_WIDTH;
+
+#define EFI_PCI_ADDRESS(_bus,_dev,_func) \
+    ( (UINT64) ( (((UINTN)_bus) << 24) + (((UINTN)_dev) << 16) + (((UINTN)_func) << 8) ) )
+
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_DEVICE_IO) (
+    IN struct _EFI_DEVICE_IO_INTERFACE *This,
+    IN EFI_IO_WIDTH                 Width,
+    IN UINT64                       Address,
+    IN UINTN                        Count,
+    IN OUT VOID                     *Buffer
+    );
+
+typedef struct {
+    EFI_DEVICE_IO                   Read;
+    EFI_DEVICE_IO                   Write;
+} EFI_IO_ACCESS;
+
+typedef 
+EFI_STATUS
+(EFIAPI *EFI_PCI_DEVICE_PATH) (
+    IN struct _EFI_DEVICE_IO_INTERFACE  *This,
+    IN UINT64                           Address,
+    IN OUT EFI_DEVICE_PATH              **PciDevicePath
+    );
+
+typedef enum {
+    EfiBusMasterRead,
+    EfiBusMasterWrite,
+    EfiBusMasterCommonBuffer
+} EFI_IO_OPERATION_TYPE;
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_IO_MAP) (
+    IN struct _EFI_DEVICE_IO_INTERFACE  *This,
+    IN EFI_IO_OPERATION_TYPE            Operation,
+    IN EFI_PHYSICAL_ADDRESS             *HostAddress,
+    IN OUT UINTN                        *NumberOfBytes,
+    OUT EFI_PHYSICAL_ADDRESS            *DeviceAddress,
+    OUT VOID                            **Mapping
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_IO_UNMAP) (
+    IN struct _EFI_DEVICE_IO_INTERFACE  *This,
+    IN VOID                             *Mapping
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_IO_ALLOCATE_BUFFER) (
+    IN struct _EFI_DEVICE_IO_INTERFACE  *This,
+    IN EFI_ALLOCATE_TYPE                Type,
+    IN EFI_MEMORY_TYPE                  MemoryType,
+    IN UINTN                            Pages,
+    IN OUT EFI_PHYSICAL_ADDRESS         *HostAddress
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_IO_FLUSH) (
+    IN struct _EFI_DEVICE_IO_INTERFACE  *This
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_IO_FREE_BUFFER) (
+    IN struct _EFI_DEVICE_IO_INTERFACE  *This,
+    IN UINTN                            Pages,
+    IN EFI_PHYSICAL_ADDRESS             HostAddress
+    );
+
+typedef struct _EFI_DEVICE_IO_INTERFACE {
+    EFI_IO_ACCESS                       Mem;
+    EFI_IO_ACCESS                       Io;
+    EFI_IO_ACCESS                       Pci;
+    EFI_IO_MAP                          Map;
+    EFI_PCI_DEVICE_PATH                 PciDevicePath;
+    EFI_IO_UNMAP                        Unmap;
+    EFI_IO_ALLOCATE_BUFFER              AllocateBuffer;
+    EFI_IO_FLUSH                        Flush;
+    EFI_IO_FREE_BUFFER                  FreeBuffer;
+} EFI_DEVICE_IO_INTERFACE;
+
+
+//
+// Unicode Collation protocol
+//
+
+#define UNICODE_COLLATION_PROTOCOL \
+    { 0x1d85cd7f, 0xf43d, 0x11d2, {0x9a, 0xc,  0x0, 0x90, 0x27, 0x3f, 0xc1, 0x4d} }
+
+#define UNICODE_BYTE_ORDER_MARK       (CHAR16)(0xfeff)
+
+INTERFACE_DECL(_EFI_UNICODE_COLLATION_INTERFACE);
+
+typedef
+INTN
+(EFIAPI *EFI_UNICODE_STRICOLL) (
+    IN struct _EFI_UNICODE_COLLATION_INTERFACE  *This,
+    IN CHAR16                         *s1,
+    IN CHAR16                         *s2
+    );
+
+typedef
+BOOLEAN
+(EFIAPI *EFI_UNICODE_METAIMATCH) (
+    IN struct _EFI_UNICODE_COLLATION_INTERFACE  *This,
+    IN CHAR16                         *String,
+    IN CHAR16                         *Pattern
+    );
+
+typedef
+VOID
+(EFIAPI *EFI_UNICODE_STRLWR) (
+    IN struct _EFI_UNICODE_COLLATION_INTERFACE  *This,
+    IN OUT CHAR16                       *Str
+    );
+
+typedef
+VOID
+(EFIAPI *EFI_UNICODE_STRUPR) (
+    IN struct _EFI_UNICODE_COLLATION_INTERFACE  *This,
+    IN OUT CHAR16                       *Str
+    );
+
+typedef
+VOID
+(EFIAPI *EFI_UNICODE_FATTOSTR) (
+    IN struct _EFI_UNICODE_COLLATION_INTERFACE  *This,
+    IN UINTN                            FatSize,
+    IN CHAR8                            *Fat,
+    OUT CHAR16                          *String
+    );
+
+typedef
+BOOLEAN
+(EFIAPI *EFI_UNICODE_STRTOFAT) (
+    IN struct _EFI_UNICODE_COLLATION_INTERFACE  *This,
+    IN CHAR16                           *String,
+    IN UINTN                            FatSize,
+    OUT CHAR8                           *Fat
+    );
+
+
+typedef struct _EFI_UNICODE_COLLATION_INTERFACE {
+
+    // general
+    EFI_UNICODE_STRICOLL                StriColl;
+    EFI_UNICODE_METAIMATCH              MetaiMatch;
+    EFI_UNICODE_STRLWR                  StrLwr;
+    EFI_UNICODE_STRUPR                  StrUpr;
+
+    // for supporting fat volumes
+    EFI_UNICODE_FATTOSTR                FatToStr;
+    EFI_UNICODE_STRTOFAT                StrToFat;
+
+    CHAR8                               *SupportedLanguages;
+} EFI_UNICODE_COLLATION_INTERFACE;
+
+/* Graphics output protocol */
+#define EFI_GRAPHICS_OUTPUT_PROTOCOL_GUID \
+  { \
+    0x9042a9de, 0x23dc, 0x4a38, {0x96, 0xfb, 0x7a, 0xde, 0xd0, 0x80, 0x51, 0x6a } \
+  }
+
+typedef struct _EFI_GRAPHICS_OUTPUT_PROTOCOL EFI_GRAPHICS_OUTPUT_PROTOCOL;
+
+typedef struct {
+  UINT32            RedMask;
+  UINT32            GreenMask;
+  UINT32            BlueMask;
+  UINT32            ReservedMask;
+} EFI_PIXEL_BITMASK;
+
+typedef enum {
+  PixelRedGreenBlueReserved8BitPerColor,
+  PixelBlueGreenRedReserved8BitPerColor,
+  PixelBitMask,
+  PixelBltOnly,
+  PixelFormatMax
+} EFI_GRAPHICS_PIXEL_FORMAT;
+
+typedef struct {
+  UINT32                     Version;
+  UINT32                     HorizontalResolution;
+  UINT32                     VerticalResolution;
+  EFI_GRAPHICS_PIXEL_FORMAT  PixelFormat;
+  EFI_PIXEL_BITMASK          PixelInformation;
+  UINT32                     PixelsPerScanLine;
+} EFI_GRAPHICS_OUTPUT_MODE_INFORMATION;
+
+/**
+  Return the current video mode information.
+
+  @param  This       Protocol instance pointer.
+  @param  ModeNumber The mode number to return information on.
+  @param  SizeOfInfo A pointer to the size, in bytes, of the Info buffer.
+  @param  Info       A pointer to callee allocated buffer that returns information about ModeNumber.
+
+  @retval EFI_SUCCESS           Mode information returned.
+  @retval EFI_BUFFER_TOO_SMALL  The Info buffer was too small.
+  @retval EFI_DEVICE_ERROR      A hardware error occurred trying to retrieve the video mode.
+  @retval EFI_NOT_STARTED       Video display is not initialized. Call SetMode ()
+  @retval EFI_INVALID_PARAMETER One of the input args was NULL.
+
+**/
+typedef
+EFI_STATUS
+(EFIAPI *EFI_GRAPHICS_OUTPUT_PROTOCOL_QUERY_MODE) (
+  IN  EFI_GRAPHICS_OUTPUT_PROTOCOL          *This,
+  IN  UINT32                                ModeNumber,
+  OUT UINTN                                 *SizeOfInfo,
+  OUT EFI_GRAPHICS_OUTPUT_MODE_INFORMATION  **Info
+  )
+;
+
+/**
+  Return the current video mode information.
+
+  @param  This              Protocol instance pointer.
+  @param  ModeNumber        The mode number to be set.
+
+  @retval EFI_SUCCESS       Graphics mode was changed.
+  @retval EFI_DEVICE_ERROR  The device had an error and could not complete the request.
+  @retval EFI_UNSUPPORTED   ModeNumber is not supported by this device.
+
+**/
+typedef
+EFI_STATUS
+(EFIAPI *EFI_GRAPHICS_OUTPUT_PROTOCOL_SET_MODE) (
+  IN  EFI_GRAPHICS_OUTPUT_PROTOCOL *This,
+  IN  UINT32                       ModeNumber
+  )
+;
+
+typedef struct {
+  UINT8 Blue;
+  UINT8 Green;
+  UINT8 Red;
+  UINT8 Reserved;
+} EFI_GRAPHICS_OUTPUT_BLT_PIXEL;
+
+typedef union {
+  EFI_GRAPHICS_OUTPUT_BLT_PIXEL Pixel;
+  UINT32                        Raw;
+} EFI_GRAPHICS_OUTPUT_BLT_PIXEL_UNION;
+
+typedef enum {
+  EfiBltVideoFill,
+  EfiBltVideoToBltBuffer,
+  EfiBltBufferToVideo, 
+  EfiBltVideoToVideo,
+  EfiGraphicsOutputBltOperationMax
+} EFI_GRAPHICS_OUTPUT_BLT_OPERATION;
+
+/**
+  The following table defines actions for BltOperations:
+
+  <B>EfiBltVideoFill</B> - Write data from the  BltBuffer pixel (SourceX, SourceY) 
+  directly to every pixel of the video display rectangle 
+  (DestinationX, DestinationY) (DestinationX + Width, DestinationY + Height). 
+  Only one pixel will be used from the BltBuffer. Delta is NOT used.
+
+  <B>EfiBltVideoToBltBuffer</B> - Read data from the video display rectangle 
+  (SourceX, SourceY) (SourceX + Width, SourceY + Height) and place it in 
+  the BltBuffer rectangle (DestinationX, DestinationY ) 
+  (DestinationX + Width, DestinationY + Height). If DestinationX or 
+  DestinationY is not zero then Delta must be set to the length in bytes 
+  of a row in the BltBuffer.
+
+  <B>EfiBltBufferToVideo</B> - Write data from the  BltBuffer rectangle 
+  (SourceX, SourceY) (SourceX + Width, SourceY + Height) directly to the 
+  video display rectangle (DestinationX, DestinationY) 
+  (DestinationX + Width, DestinationY + Height). If SourceX or SourceY is 
+  not zero then Delta must be set to the length in bytes of a row in the 
+  BltBuffer.
+
+  <B>EfiBltVideoToVideo</B> - Copy from the video display rectangle (SourceX, SourceY)
+  (SourceX + Width, SourceY + Height) .to the video display rectangle 
+  (DestinationX, DestinationY) (DestinationX + Width, DestinationY + Height). 
+  The BltBuffer and Delta  are not used in this mode.
+
+  @param  This         Protocol instance pointer.
+  @param  BltBuffer    Buffer containing data to blit into video buffer. This
+                       buffer has a size of Width*Height*sizeof(EFI_GRAPHICS_OUTPUT_BLT_PIXEL)
+  @param  BltOperation Operation to perform on BlitBuffer and video memory
+  @param  SourceX      X coordinate of source for the BltBuffer.
+  @param  SourceY      Y coordinate of source for the BltBuffer.
+  @param  DestinationX X coordinate of destination for the BltBuffer.
+  @param  DestinationY Y coordinate of destination for the BltBuffer.
+  @param  Width        Width of rectangle in BltBuffer in pixels.
+  @param  Height       Hight of rectangle in BltBuffer in pixels.
+  @param  Delta        OPTIONAL
+
+  @retval EFI_SUCCESS           The Blt operation completed.
+  @retval EFI_INVALID_PARAMETER BltOperation is not valid.
+  @retval EFI_DEVICE_ERROR      A hardware error occured writting to the video buffer.
+
+**/
+typedef
+EFI_STATUS
+(EFIAPI *EFI_GRAPHICS_OUTPUT_PROTOCOL_BLT) (
+  IN  EFI_GRAPHICS_OUTPUT_PROTOCOL            *This,
+  IN  EFI_GRAPHICS_OUTPUT_BLT_PIXEL           *BltBuffer,   OPTIONAL
+  IN  EFI_GRAPHICS_OUTPUT_BLT_OPERATION       BltOperation,
+  IN  UINTN                                   SourceX,
+  IN  UINTN                                   SourceY,
+  IN  UINTN                                   DestinationX,
+  IN  UINTN                                   DestinationY,
+  IN  UINTN                                   Width,
+  IN  UINTN                                   Height,
+  IN  UINTN                                   Delta         OPTIONAL
+  );
+
+typedef struct {
+  UINT32                                 MaxMode;
+  UINT32                                 Mode;
+  EFI_GRAPHICS_OUTPUT_MODE_INFORMATION   *Info;
+  UINTN                                  SizeOfInfo;
+  EFI_PHYSICAL_ADDRESS                   FrameBufferBase;
+  UINTN                                  FrameBufferSize;
+} EFI_GRAPHICS_OUTPUT_PROTOCOL_MODE;
+
+struct _EFI_GRAPHICS_OUTPUT_PROTOCOL {
+  EFI_GRAPHICS_OUTPUT_PROTOCOL_QUERY_MODE  QueryMode;
+  EFI_GRAPHICS_OUTPUT_PROTOCOL_SET_MODE    SetMode;
+  EFI_GRAPHICS_OUTPUT_PROTOCOL_BLT         Blt;
+  EFI_GRAPHICS_OUTPUT_PROTOCOL_MODE        *Mode;
+};
+#endif
+
diff --git a/linux-x86/gnu-efi/include/efi/efipxebc.h b/linux-x86/gnu-efi/include/efi/efipxebc.h
new file mode 100644
index 0000000..792d323
--- /dev/null
+++ b/linux-x86/gnu-efi/include/efi/efipxebc.h
@@ -0,0 +1,463 @@
+#ifndef _EFIPXEBC_H
+#define _EFIPXEBC_H
+
+/*++
+
+Copyright (c) 1998  Intel Corporation
+
+Module Name:
+
+    efipxebc.h
+
+Abstract:
+
+    EFI PXE Base Code Protocol
+
+
+
+Revision History
+
+--*/
+
+//
+// PXE Base Code protocol
+//
+
+#define EFI_PXE_BASE_CODE_PROTOCOL \
+    { 0x03c4e603, 0xac28, 0x11d3, {0x9a, 0x2d, 0x00, 0x90, 0x27, 0x3f, 0xc1, 0x4d} }
+
+INTERFACE_DECL(_EFI_PXE_BASE_CODE);
+
+#define DEFAULT_TTL 4
+#define DEFAULT_ToS 0
+//
+// Address definitions
+//
+
+typedef union {
+    UINT32      Addr[4];
+    EFI_IPv4_ADDRESS    v4;
+    EFI_IPv6_ADDRESS    v6;
+} EFI_IP_ADDRESS;
+
+typedef UINT16 EFI_PXE_BASE_CODE_UDP_PORT;
+
+//
+// Packet definitions
+//
+
+typedef struct {
+    UINT8                           BootpOpcode;
+    UINT8                           BootpHwType;
+    UINT8                           BootpHwAddrLen;
+    UINT8                           BootpGateHops;
+    UINT32                          BootpIdent;
+    UINT16                          BootpSeconds;
+    UINT16                          BootpFlags;
+    UINT8                           BootpCiAddr[4];
+    UINT8                           BootpYiAddr[4];
+    UINT8                           BootpSiAddr[4];
+    UINT8                           BootpGiAddr[4];
+    UINT8                           BootpHwAddr[16];
+    UINT8                           BootpSrvName[64];
+    UINT8                           BootpBootFile[128];
+    UINT32                          DhcpMagik;
+    UINT8                           DhcpOptions[56];
+} EFI_PXE_BASE_CODE_DHCPV4_PACKET;
+
+// TBD in EFI v1.1
+//typedef struct {
+//    UINT8                           reserved;
+//} EFI_PXE_BASE_CODE_DHCPV6_PACKET;
+
+typedef union {
+    UINT8                               Raw[1472];
+    EFI_PXE_BASE_CODE_DHCPV4_PACKET     Dhcpv4;
+//    EFI_PXE_BASE_CODE_DHCPV6_PACKET     Dhcpv6;
+} EFI_PXE_BASE_CODE_PACKET;
+
+typedef struct {
+    UINT8                   Type;
+    UINT8                   Code;
+    UINT16                  Checksum;
+    union {
+        UINT32              reserved;
+        UINT32              Mtu;
+        UINT32              Pointer;
+        struct {
+            UINT16          Identifier;
+            UINT16          Sequence;
+        } Echo;
+    } u;
+    UINT8                   Data[494];
+} EFI_PXE_BASE_CODE_ICMP_ERROR;
+
+typedef struct {
+    UINT8                   ErrorCode;
+    CHAR8                   ErrorString[127];
+} EFI_PXE_BASE_CODE_TFTP_ERROR;
+
+//
+// IP Receive Filter definitions
+//
+#define EFI_PXE_BASE_CODE_MAX_IPCNT             8
+typedef struct {
+    UINT8                       Filters;
+    UINT8                       IpCnt;
+    UINT16                      reserved;
+    EFI_IP_ADDRESS              IpList[EFI_PXE_BASE_CODE_MAX_IPCNT];
+} EFI_PXE_BASE_CODE_IP_FILTER;
+
+#define EFI_PXE_BASE_CODE_IP_FILTER_STATION_IP             0x0001
+#define EFI_PXE_BASE_CODE_IP_FILTER_BROADCAST              0x0002
+#define EFI_PXE_BASE_CODE_IP_FILTER_PROMISCUOUS            0x0004
+#define EFI_PXE_BASE_CODE_IP_FILTER_PROMISCUOUS_MULTICAST  0x0008
+
+//
+// ARP Cache definitions
+//
+
+typedef struct {
+    EFI_IP_ADDRESS       IpAddr;
+    EFI_MAC_ADDRESS      MacAddr;
+} EFI_PXE_BASE_CODE_ARP_ENTRY;
+
+typedef struct {
+    EFI_IP_ADDRESS       IpAddr;
+    EFI_IP_ADDRESS       SubnetMask;
+    EFI_IP_ADDRESS       GwAddr;
+} EFI_PXE_BASE_CODE_ROUTE_ENTRY;
+
+//
+// UDP definitions
+//
+
+#define EFI_PXE_BASE_CODE_UDP_OPFLAGS_ANY_SRC_IP    0x0001
+#define EFI_PXE_BASE_CODE_UDP_OPFLAGS_ANY_SRC_PORT  0x0002
+#define EFI_PXE_BASE_CODE_UDP_OPFLAGS_ANY_DEST_IP   0x0004
+#define EFI_PXE_BASE_CODE_UDP_OPFLAGS_ANY_DEST_PORT 0x0008
+#define EFI_PXE_BASE_CODE_UDP_OPFLAGS_USE_FILTER    0x0010
+#define EFI_PXE_BASE_CODE_UDP_OPFLAGS_MAY_FRAGMENT  0x0020
+
+//
+// Discover() definitions
+//
+
+#define EFI_PXE_BASE_CODE_BOOT_TYPE_BOOTSTRAP           0   
+#define EFI_PXE_BASE_CODE_BOOT_TYPE_MS_WINNT_RIS        1
+#define EFI_PXE_BASE_CODE_BOOT_TYPE_INTEL_LCM           2
+#define EFI_PXE_BASE_CODE_BOOT_TYPE_DOSUNDI             3
+#define EFI_PXE_BASE_CODE_BOOT_TYPE_NEC_ESMPRO          4
+#define EFI_PXE_BASE_CODE_BOOT_TYPE_IBM_WSoD            5
+#define EFI_PXE_BASE_CODE_BOOT_TYPE_IBM_LCCM            6
+#define EFI_PXE_BASE_CODE_BOOT_TYPE_CA_UNICENTER_TNG    7
+#define EFI_PXE_BASE_CODE_BOOT_TYPE_HP_OPENVIEW         8
+#define EFI_PXE_BASE_CODE_BOOT_TYPE_ALTIRIS_9           9
+#define EFI_PXE_BASE_CODE_BOOT_TYPE_ALTIRIS_10          10
+#define EFI_PXE_BASE_CODE_BOOT_TYPE_ALTIRIS_11          11
+#define EFI_PXE_BASE_CODE_BOOT_TYPE_NOT_USED_12         12
+#define EFI_PXE_BASE_CODE_BOOT_TYPE_REDHAT_INSTALL      13
+#define EFI_PXE_BASE_CODE_BOOT_TYPE_REDHAT_BOOT         14
+#define EFI_PXE_BASE_CODE_BOOT_TYPE_REMBO               15
+#define EFI_PXE_BASE_CODE_BOOT_TYPE_BEOBOOT             16
+//
+// 17 through 32767 are reserved
+// 32768 through 65279 are for vendor use
+// 65280 through 65534 are reserved
+//
+#define EFI_PXE_BASE_CODE_BOOT_TYPE_PXETEST             65535
+
+#define EFI_PXE_BASE_CODE_BOOT_LAYER_MASK               0x7FFF
+#define EFI_PXE_BASE_CODE_BOOT_LAYER_INITIAL            0x0000
+
+
+typedef struct {
+    UINT16                      Type;
+    BOOLEAN                     AcceptAnyResponse;
+    UINT8                       Reserved;
+    EFI_IP_ADDRESS              IpAddr;
+} EFI_PXE_BASE_CODE_SRVLIST;
+
+typedef struct {
+    BOOLEAN                     UseMCast;
+    BOOLEAN                     UseBCast;
+    BOOLEAN                     UseUCast;
+    BOOLEAN                     MustUseList;
+    EFI_IP_ADDRESS              ServerMCastIp;
+    UINT16                      IpCnt;
+    EFI_PXE_BASE_CODE_SRVLIST   SrvList[1];
+} EFI_PXE_BASE_CODE_DISCOVER_INFO;
+
+//
+// Mtftp() definitions
+//
+
+typedef enum {
+    EFI_PXE_BASE_CODE_TFTP_FIRST,
+    EFI_PXE_BASE_CODE_TFTP_GET_FILE_SIZE,
+    EFI_PXE_BASE_CODE_TFTP_READ_FILE,
+    EFI_PXE_BASE_CODE_TFTP_WRITE_FILE,
+    EFI_PXE_BASE_CODE_TFTP_READ_DIRECTORY,
+    EFI_PXE_BASE_CODE_MTFTP_GET_FILE_SIZE,
+    EFI_PXE_BASE_CODE_MTFTP_READ_FILE,
+    EFI_PXE_BASE_CODE_MTFTP_READ_DIRECTORY,
+    EFI_PXE_BASE_CODE_MTFTP_LAST
+} EFI_PXE_BASE_CODE_TFTP_OPCODE;
+
+typedef struct {
+    EFI_IP_ADDRESS   MCastIp;
+    EFI_PXE_BASE_CODE_UDP_PORT  CPort;
+    EFI_PXE_BASE_CODE_UDP_PORT  SPort;
+    UINT16                      ListenTimeout;
+    UINT16                      TransmitTimeout;
+} EFI_PXE_BASE_CODE_MTFTP_INFO;
+
+//
+// PXE Base Code Mode structure
+//
+
+#define EFI_PXE_BASE_CODE_MAX_ARP_ENTRIES       8
+#define EFI_PXE_BASE_CODE_MAX_ROUTE_ENTRIES     8
+
+typedef struct {
+    BOOLEAN                         Started;
+    BOOLEAN                         Ipv6Available;
+    BOOLEAN                         Ipv6Supported;
+    BOOLEAN                         UsingIpv6;
+    BOOLEAN                         BisSupported;
+    BOOLEAN                         BisDetected;
+    BOOLEAN                         AutoArp;
+    BOOLEAN                         SendGUID;
+    BOOLEAN                         DhcpDiscoverValid;
+    BOOLEAN                         DhcpAckReceived;
+    BOOLEAN                         ProxyOfferReceived;
+    BOOLEAN                         PxeDiscoverValid;
+    BOOLEAN                         PxeReplyReceived;
+    BOOLEAN                         PxeBisReplyReceived;
+    BOOLEAN                         IcmpErrorReceived;
+    BOOLEAN                         TftpErrorReceived;
+    BOOLEAN                         MakeCallbacks;
+    UINT8                           TTL;
+    UINT8                           ToS;
+    EFI_IP_ADDRESS                  StationIp;
+    EFI_IP_ADDRESS                  SubnetMask;
+    EFI_PXE_BASE_CODE_PACKET        DhcpDiscover;
+    EFI_PXE_BASE_CODE_PACKET        DhcpAck;
+    EFI_PXE_BASE_CODE_PACKET        ProxyOffer;
+    EFI_PXE_BASE_CODE_PACKET        PxeDiscover;
+    EFI_PXE_BASE_CODE_PACKET        PxeReply;
+    EFI_PXE_BASE_CODE_PACKET        PxeBisReply;
+    EFI_PXE_BASE_CODE_IP_FILTER     IpFilter;
+    UINT32                          ArpCacheEntries;
+    EFI_PXE_BASE_CODE_ARP_ENTRY     ArpCache[EFI_PXE_BASE_CODE_MAX_ARP_ENTRIES];
+    UINT32                          RouteTableEntries;
+    EFI_PXE_BASE_CODE_ROUTE_ENTRY   RouteTable[EFI_PXE_BASE_CODE_MAX_ROUTE_ENTRIES];
+    EFI_PXE_BASE_CODE_ICMP_ERROR    IcmpError;
+    EFI_PXE_BASE_CODE_TFTP_ERROR    TftpError;
+} EFI_PXE_BASE_CODE_MODE;
+
+//
+// PXE Base Code Interface Function definitions
+//
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PXE_BASE_CODE_START) (
+    IN struct _EFI_PXE_BASE_CODE    *This,
+    IN BOOLEAN                      UseIpv6
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PXE_BASE_CODE_STOP) (
+    IN struct _EFI_PXE_BASE_CODE    *This
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PXE_BASE_CODE_DHCP) (
+    IN struct _EFI_PXE_BASE_CODE    *This,
+    IN BOOLEAN                      SortOffers
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PXE_BASE_CODE_DISCOVER) (
+    IN struct _EFI_PXE_BASE_CODE            *This,
+    IN UINT16                               Type,
+    IN UINT16                               *Layer,
+    IN BOOLEAN                              UseBis,
+    IN OUT EFI_PXE_BASE_CODE_DISCOVER_INFO  *Info   OPTIONAL
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PXE_BASE_CODE_MTFTP) (
+    IN struct _EFI_PXE_BASE_CODE        *This,
+    IN EFI_PXE_BASE_CODE_TFTP_OPCODE    Operation,
+    IN OUT VOID                         *BufferPtr  OPTIONAL,
+    IN BOOLEAN                          Overwrite,
+    IN OUT UINTN                        *BufferSize,
+    IN UINTN                            *BlockSize  OPTIONAL,
+    IN EFI_IP_ADDRESS                   *ServerIp,
+    IN UINT8                            *Filename,
+    IN EFI_PXE_BASE_CODE_MTFTP_INFO     *Info       OPTIONAL,
+    IN BOOLEAN                          DontUseBuffer
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PXE_BASE_CODE_UDP_WRITE) (
+    IN struct _EFI_PXE_BASE_CODE        *This,
+    IN UINT16                           OpFlags,
+    IN EFI_IP_ADDRESS                   *DestIp,
+    IN EFI_PXE_BASE_CODE_UDP_PORT       *DestPort,
+    IN EFI_IP_ADDRESS                   *GatewayIp,  OPTIONAL
+    IN EFI_IP_ADDRESS                   *SrcIp,      OPTIONAL
+    IN OUT EFI_PXE_BASE_CODE_UDP_PORT   *SrcPort,    OPTIONAL
+    IN UINTN                            *HeaderSize, OPTIONAL
+    IN VOID                             *HeaderPtr,  OPTIONAL
+    IN UINTN                            *BufferSize,
+    IN VOID                             *BufferPtr
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PXE_BASE_CODE_UDP_READ) (
+    IN struct _EFI_PXE_BASE_CODE        *This,
+    IN UINT16                           OpFlags,
+    IN OUT EFI_IP_ADDRESS               *DestIp,      OPTIONAL
+    IN OUT EFI_PXE_BASE_CODE_UDP_PORT   *DestPort,    OPTIONAL
+    IN OUT EFI_IP_ADDRESS               *SrcIp,       OPTIONAL
+    IN OUT EFI_PXE_BASE_CODE_UDP_PORT   *SrcPort,     OPTIONAL
+    IN UINTN                            *HeaderSize,  OPTIONAL
+    IN VOID                             *HeaderPtr,   OPTIONAL
+    IN OUT UINTN                        *BufferSize,
+    IN VOID                             *BufferPtr
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PXE_BASE_CODE_SET_IP_FILTER) (
+    IN struct _EFI_PXE_BASE_CODE    *This,
+    IN EFI_PXE_BASE_CODE_IP_FILTER  *NewFilter
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PXE_BASE_CODE_ARP) (
+    IN struct _EFI_PXE_BASE_CODE    *This,
+    IN EFI_IP_ADDRESS               *IpAddr,      
+    IN EFI_MAC_ADDRESS              *MacAddr      OPTIONAL
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PXE_BASE_CODE_SET_PARAMETERS) (
+    IN struct _EFI_PXE_BASE_CODE    *This,
+    IN BOOLEAN                      *NewAutoArp,    OPTIONAL
+    IN BOOLEAN                      *NewSendGUID,   OPTIONAL
+    IN UINT8                        *NewTTL,        OPTIONAL
+    IN UINT8                        *NewToS,        OPTIONAL
+    IN BOOLEAN                      *NewMakeCallback    OPTIONAL
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PXE_BASE_CODE_SET_STATION_IP) (
+    IN struct _EFI_PXE_BASE_CODE    *This,
+    IN EFI_IP_ADDRESS               *NewStationIp,  OPTIONAL
+    IN EFI_IP_ADDRESS               *NewSubnetMask  OPTIONAL
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PXE_BASE_CODE_SET_PACKETS) (
+    IN struct _EFI_PXE_BASE_CODE    *This,
+    BOOLEAN                         *NewDhcpDiscoverValid,  OPTIONAL
+    BOOLEAN                         *NewDhcpAckReceived,    OPTIONAL
+    BOOLEAN                         *NewProxyOfferReceived, OPTIONAL
+    BOOLEAN                         *NewPxeDiscoverValid,   OPTIONAL
+    BOOLEAN                         *NewPxeReplyReceived,   OPTIONAL
+    BOOLEAN                         *NewPxeBisReplyReceived,OPTIONAL
+    IN EFI_PXE_BASE_CODE_PACKET     *NewDhcpDiscover, OPTIONAL
+    IN EFI_PXE_BASE_CODE_PACKET     *NewDhcpAck,      OPTIONAL
+    IN EFI_PXE_BASE_CODE_PACKET     *NewProxyOffer,   OPTIONAL
+    IN EFI_PXE_BASE_CODE_PACKET     *NewPxeDiscover,  OPTIONAL
+    IN EFI_PXE_BASE_CODE_PACKET     *NewPxeReply,     OPTIONAL
+    IN EFI_PXE_BASE_CODE_PACKET     *NewPxeBisReply   OPTIONAL
+    );
+
+//
+// PXE Base Code Protocol structure
+//
+
+#define EFI_PXE_BASE_CODE_INTERFACE_REVISION    0x00010000
+
+typedef struct _EFI_PXE_BASE_CODE {
+    UINT64                              Revision;
+    EFI_PXE_BASE_CODE_START             Start;
+    EFI_PXE_BASE_CODE_STOP              Stop;
+    EFI_PXE_BASE_CODE_DHCP              Dhcp;
+    EFI_PXE_BASE_CODE_DISCOVER          Discover;
+    EFI_PXE_BASE_CODE_MTFTP             Mtftp;
+    EFI_PXE_BASE_CODE_UDP_WRITE         UdpWrite;
+    EFI_PXE_BASE_CODE_UDP_READ          UdpRead;
+    EFI_PXE_BASE_CODE_SET_IP_FILTER     SetIpFilter;
+    EFI_PXE_BASE_CODE_ARP               Arp;
+    EFI_PXE_BASE_CODE_SET_PARAMETERS    SetParameters;
+    EFI_PXE_BASE_CODE_SET_STATION_IP    SetStationIp;
+    EFI_PXE_BASE_CODE_SET_PACKETS       SetPackets;
+    EFI_PXE_BASE_CODE_MODE              *Mode;
+} EFI_PXE_BASE_CODE;
+
+//
+// Call Back Definitions
+//
+
+#define EFI_PXE_BASE_CODE_CALLBACK_PROTOCOL \
+    { 0x245dca21, 0xfb7b, 0x11d3, {0x8f, 0x01, 0x00, 0xa0, 0xc9, 0x69, 0x72, 0x3b} }
+
+//
+// Revision Number
+//
+
+#define EFI_PXE_BASE_CODE_CALLBACK_INTERFACE_REVISION   0x00010000
+
+INTERFACE_DECL(_EFI_PXE_BASE_CODE_CALLBACK);
+
+typedef enum {
+    EFI_PXE_BASE_CODE_FUNCTION_FIRST,
+    EFI_PXE_BASE_CODE_FUNCTION_DHCP,
+    EFI_PXE_BASE_CODE_FUNCTION_DISCOVER,
+    EFI_PXE_BASE_CODE_FUNCTION_MTFTP,
+    EFI_PXE_BASE_CODE_FUNCTION_UDP_WRITE,
+    EFI_PXE_BASE_CODE_FUNCTION_UDP_READ,
+    EFI_PXE_BASE_CODE_FUNCTION_ARP,
+    EFI_PXE_BASE_CODE_FUNCTION_IGMP,
+    EFI_PXE_BASE_CODE_PXE_FUNCTION_LAST
+} EFI_PXE_BASE_CODE_FUNCTION;
+
+typedef enum {
+    EFI_PXE_BASE_CODE_CALLBACK_STATUS_FIRST,
+    EFI_PXE_BASE_CODE_CALLBACK_STATUS_CONTINUE,
+    EFI_PXE_BASE_CODE_CALLBACK_STATUS_ABORT,
+    EFI_PXE_BASE_CODE_CALLBACK_STATUS_LAST
+} EFI_PXE_BASE_CODE_CALLBACK_STATUS;
+
+typedef
+EFI_PXE_BASE_CODE_CALLBACK_STATUS 
+(EFIAPI *EFI_PXE_CALLBACK) (
+    IN struct _EFI_PXE_BASE_CODE_CALLBACK   *This,
+    IN EFI_PXE_BASE_CODE_FUNCTION           Function,
+    IN BOOLEAN                              Received,
+    IN UINT32                               PacketLen,
+    IN EFI_PXE_BASE_CODE_PACKET             *Packet     OPTIONAL
+    );
+
+typedef struct _EFI_PXE_BASE_CODE_CALLBACK {
+    UINT64                      Revision;
+    EFI_PXE_CALLBACK            Callback;
+} EFI_PXE_BASE_CODE_CALLBACK;
+
+#endif /* _EFIPXEBC_H */
diff --git a/linux-x86/gnu-efi/include/efi/efirtlib.h b/linux-x86/gnu-efi/include/efi/efirtlib.h
new file mode 100644
index 0000000..0100180
--- /dev/null
+++ b/linux-x86/gnu-efi/include/efi/efirtlib.h
@@ -0,0 +1,141 @@
+#ifndef _EFI_RT_LIB_INCLUDE_
+#define _EFI_RT_LIB_INCLUDE_
+/*++
+
+Copyright (c) 1998  Intel Corporation
+
+Module Name:
+
+    efilib.h
+
+Abstract:
+
+    EFI Runtime library functions
+
+
+
+Revision History
+
+--*/
+
+#include "efidebug.h"
+#include "efipart.h"
+#include "efilibplat.h"
+
+
+VOID
+RUNTIMEFUNCTION
+RtZeroMem (
+    IN VOID     *Buffer,
+    IN UINTN     Size
+    );
+
+VOID
+RUNTIMEFUNCTION
+RtSetMem (
+    IN VOID     *Buffer,
+    IN UINTN    Size,
+    IN UINT8    Value    
+    );
+
+VOID
+RUNTIMEFUNCTION
+RtCopyMem (
+    IN VOID     *Dest,
+    IN VOID     *Src,
+    IN UINTN    len
+    );
+
+INTN
+RUNTIMEFUNCTION
+RtCompareMem (
+    IN VOID     *Dest,
+    IN VOID     *Src,
+    IN UINTN    len
+    );
+
+INTN
+RUNTIMEFUNCTION
+RtStrCmp (
+    IN CHAR16   *s1,
+    IN CHAR16   *s2
+    );
+
+
+VOID
+RUNTIMEFUNCTION
+RtStrCpy (
+    IN CHAR16   *Dest,
+    IN CHAR16    *Src
+    );
+
+VOID
+RUNTIMEFUNCTION
+RtStrCat (
+    IN CHAR16   *Dest,
+    IN CHAR16   *Src
+    );
+
+UINTN
+RUNTIMEFUNCTION
+RtStrLen (
+    IN CHAR16   *s1
+    );
+
+UINTN
+RUNTIMEFUNCTION
+RtStrSize (
+    IN CHAR16   *s1
+    );
+
+INTN
+RUNTIMEFUNCTION
+RtCompareGuid (
+    IN EFI_GUID     *Guid1,
+    IN EFI_GUID     *Guid2
+    );
+
+UINT8
+RUNTIMEFUNCTION
+RtDecimaltoBCD(
+    IN  UINT8 BcdValue
+    );
+
+UINT8
+RUNTIMEFUNCTION
+RtBCDtoDecimal(
+    IN  UINT8 BcdValue
+    );
+
+//
+// Virtual mapping transition support.  (Only used during
+// the virtual address change transisition)
+//
+
+VOID
+RUNTIMEFUNCTION
+RtLibEnableVirtualMappings (
+    VOID
+    );
+
+VOID
+RUNTIMEFUNCTION
+RtConvertList (
+    IN UINTN            DebugDisposition,
+    IN OUT LIST_ENTRY   *ListHead
+    );
+
+VOID
+RUNTIMEFUNCTION
+RtAcquireLock (
+    IN FLOCK    *Lock
+    );
+
+VOID
+RUNTIMEFUNCTION
+RtReleaseLock (
+    IN FLOCK    *Lock
+    );
+
+
+#endif
diff --git a/linux-x86/gnu-efi/include/efi/efiser.h b/linux-x86/gnu-efi/include/efi/efiser.h
new file mode 100644
index 0000000..fcc97a1
--- /dev/null
+++ b/linux-x86/gnu-efi/include/efi/efiser.h
@@ -0,0 +1,132 @@
+#ifndef _EFI_SER_H
+#define _EFI_SER_H
+
+/*++
+
+Copyright (c) 1998  Intel Corporation
+
+Module Name:
+
+    efiser.h
+
+Abstract:
+
+    EFI serial protocol
+
+Revision History
+
+--*/
+
+//
+// Serial protocol
+//
+
+#define SERIAL_IO_PROTOCOL \
+    { 0xBB25CF6F, 0xF1D4, 0x11D2, {0x9A, 0x0C, 0x00, 0x90, 0x27, 0x3F, 0xC1, 0xFD} }
+
+INTERFACE_DECL(_SERIAL_IO_INTERFACE);
+
+typedef enum {
+    DefaultParity,      
+    NoParity,           
+    EvenParity,
+    OddParity,
+    MarkParity,
+    SpaceParity
+} EFI_PARITY_TYPE;
+
+typedef enum {
+    DefaultStopBits,        
+    OneStopBit,         // 1 stop bit
+    OneFiveStopBits,    // 1.5 stop bits
+    TwoStopBits         // 2 stop bits
+} EFI_STOP_BITS_TYPE;
+
+#define EFI_SERIAL_CLEAR_TO_SEND                   0x0010  // RO
+#define EFI_SERIAL_DATA_SET_READY                  0x0020  // RO
+#define EFI_SERIAL_RING_INDICATE                   0x0040  // RO
+#define EFI_SERIAL_CARRIER_DETECT                  0x0080  // RO
+#define EFI_SERIAL_REQUEST_TO_SEND                 0x0002  // WO
+#define EFI_SERIAL_DATA_TERMINAL_READY             0x0001  // WO
+#define EFI_SERIAL_INPUT_BUFFER_EMPTY              0x0100  // RO
+#define EFI_SERIAL_OUTPUT_BUFFER_EMPTY             0x0200  // RO
+#define EFI_SERIAL_HARDWARE_LOOPBACK_ENABLE        0x1000  // RW
+#define EFI_SERIAL_SOFTWARE_LOOPBACK_ENABLE        0x2000  // RW
+#define EFI_SERIAL_HARDWARE_FLOW_CONTROL_ENABLE    0x4000  // RW
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_SERIAL_RESET) (
+    IN struct _SERIAL_IO_INTERFACE  *This
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_SERIAL_SET_ATTRIBUTES) (
+    IN struct _SERIAL_IO_INTERFACE  *This,
+    IN UINT64                       BaudRate,
+    IN UINT32                       ReceiveFifoDepth,
+    IN UINT32                       Timeout,
+    IN EFI_PARITY_TYPE              Parity,
+    IN UINT8                        DataBits,
+    IN EFI_STOP_BITS_TYPE           StopBits
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_SERIAL_SET_CONTROL_BITS) (
+    IN struct _SERIAL_IO_INTERFACE  *This,
+    IN UINT32                       Control
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_SERIAL_GET_CONTROL_BITS) (
+    IN struct _SERIAL_IO_INTERFACE  *This,
+    OUT UINT32                      *Control
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_SERIAL_WRITE) (
+    IN struct _SERIAL_IO_INTERFACE  *This,
+    IN OUT UINTN                    *BufferSize,
+    IN VOID                         *Buffer
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_SERIAL_READ) (
+    IN struct _SERIAL_IO_INTERFACE  *This,
+    IN OUT UINTN                    *BufferSize,
+    OUT VOID                        *Buffer
+    );
+
+typedef struct {
+    UINT32                  ControlMask;
+
+    // current Attributes
+    UINT32                  Timeout;
+    UINT64                  BaudRate;
+    UINT32                  ReceiveFifoDepth;
+    UINT32                  DataBits;
+    UINT32                  Parity;
+    UINT32                  StopBits;
+} SERIAL_IO_MODE;
+
+#define SERIAL_IO_INTERFACE_REVISION    0x00010000
+
+typedef struct _SERIAL_IO_INTERFACE {
+    UINT32                       Revision;
+    EFI_SERIAL_RESET             Reset;
+    EFI_SERIAL_SET_ATTRIBUTES    SetAttributes;
+    EFI_SERIAL_SET_CONTROL_BITS  SetControl;
+    EFI_SERIAL_GET_CONTROL_BITS  GetControl;
+    EFI_SERIAL_WRITE             Write;
+    EFI_SERIAL_READ              Read;
+
+    SERIAL_IO_MODE               *Mode;
+} SERIAL_IO_INTERFACE;
+
+#endif
+
diff --git a/linux-x86/gnu-efi/include/efi/efistdarg.h b/linux-x86/gnu-efi/include/efi/efistdarg.h
new file mode 100644
index 0000000..8a96b94
--- /dev/null
+++ b/linux-x86/gnu-efi/include/efi/efistdarg.h
@@ -0,0 +1,33 @@
+#ifndef _EFISTDARG_H_
+#define _EFISTDARG_H_
+
+/*++
+
+Copyright (c) 1998  Intel Corporation
+
+Module Name:
+
+    devpath.h
+
+Abstract:
+
+    Defines for parsing the EFI Device Path structures
+
+
+
+Revision History
+
+--*/
+#ifdef __GNUC__
+#include "stdarg.h"
+#else
+#define _INTSIZEOF(n)   ( (sizeof(n) + sizeof(UINTN) - 1) & ~(sizeof(UINTN) - 1) )
+
+typedef CHAR8 * va_list;
+
+#define va_start(ap,v)  ( ap = (va_list)&v + _INTSIZEOF(v) )
+#define va_arg(ap,t)    ( *(t *)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)) )
+#define va_end(ap)  ( ap = (va_list)0 )
+#endif
+
+#endif  /* _INC_STDARG */
diff --git a/linux-x86/gnu-efi/include/efi/efiui.h b/linux-x86/gnu-efi/include/efi/efiui.h
new file mode 100644
index 0000000..7341943
--- /dev/null
+++ b/linux-x86/gnu-efi/include/efi/efiui.h
@@ -0,0 +1,54 @@
+#ifndef _EFI_UI_H
+#define _EFI_UI_H
+
+/*++
+
+Copyright (c) 200  Intel Corporation
+
+Module Name:
+
+    EfiUi.h
+    
+Abstract:   
+    Protocol used to build User Interface (UI) stuff.
+
+    This protocol is just data. It is a multi dimentional array.
+    For each string there is an array of UI_STRING_ENTRY. Each string
+    is for a different language translation of the same string. The list 
+    is terminated by a NULL UiString. There can be any number of 
+    UI_STRING_ENTRY arrays. A NULL array terminates the list. A NULL array
+    entry contains all zeros.  
+
+    Thus the shortest possible EFI_UI_PROTOCOL has three UI_STRING_ENTRY.
+    The String, it's NULL terminator, and the NULL terminator for the entire 
+    thing.
+
+
+Revision History
+
+--*/
+
+#define EFI_UI_PROTOCOL \
+    { 0x32dd7981, 0x2d27, 0x11d4, {0xbc, 0x8b, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81} }
+
+
+typedef enum {
+    UiDeviceString,
+    UiVendorString,
+    UiMaxString
+} UI_STRING_TYPE;
+
+typedef struct {
+    ISO_639_2   *LangCode;
+    CHAR16      *UiString;
+} UI_STRING_ENTRY;
+
+#define EFI_UI_VERSION      0x00010000
+
+typedef struct _UI_INTERFACE {
+    UINT32          Version;
+    UI_STRING_ENTRY *Entry;
+} UI_INTERFACE;
+
+
+#endif
diff --git a/linux-x86/gnu-efi/include/efi/ia32/efibind.h b/linux-x86/gnu-efi/include/efi/ia32/efibind.h
new file mode 100644
index 0000000..0201ca1
--- /dev/null
+++ b/linux-x86/gnu-efi/include/efi/ia32/efibind.h
@@ -0,0 +1,282 @@
+/*++
+
+Copyright (c) 1998  Intel Corporation
+
+Module Name:
+
+    efefind.h
+
+Abstract:
+
+    EFI to compile bindings
+
+
+
+
+Revision History
+
+--*/
+
+#ifndef __GNUC__
+#pragma pack()
+#endif
+
+//
+// Basic int types of various widths
+//
+
+#if !defined(__STDC_VERSION__) || (__STDC_VERSION__ < 199901L )
+
+    // No ANSI C 1999/2000 stdint.h integer width declarations 
+
+    #if defined(_MSC_EXTENSIONS)
+
+        // Use Microsoft C compiler integer width declarations 
+
+        typedef unsigned __int64    uint64_t;
+        typedef __int64             int64_t;
+        typedef unsigned __int32    uint32_t;
+        typedef __int32             int32_t;
+        typedef unsigned short      uint16_t;
+        typedef short               int16_t;
+        typedef unsigned char       uint8_t;
+        typedef char                int8_t;
+    #elif defined(__GNUC__)
+        typedef unsigned long long  uint64_t __attribute__((aligned (8)));
+        typedef long long           int64_t __attribute__((aligned (8)));
+        typedef unsigned int        uint32_t;
+        typedef int                 int32_t;
+        typedef unsigned short      uint16_t;
+        typedef short               int16_t;
+        typedef unsigned char       uint8_t;
+        typedef char                int8_t;
+    #elif defined(UNIX_LP64)
+
+        /*  Use LP64 programming model from C_FLAGS for integer width declarations */
+
+       typedef unsigned long       uint64_t;
+       typedef long                int64_t;
+       typedef unsigned int        uint32_t;
+       typedef int                 int32_t;
+       typedef unsigned short      uint16_t;
+       typedef short               int16_t;
+       typedef unsigned char       uint8_t;
+       typedef char                int8_t;
+    #else
+
+       /*  Assume P64 programming model from C_FLAGS for integer width declarations */
+
+       typedef unsigned long long  uint64_t __attribute__((aligned (8)));
+       typedef long long           int64_t __attribute__((aligned (8)));
+       typedef unsigned int        uint32_t;
+       typedef int                 int32_t;
+       typedef unsigned short      uint16_t;
+       typedef short               int16_t;
+       typedef unsigned char       uint8_t;
+       typedef char                int8_t;
+    #endif
+#endif
+
+//
+// Basic EFI types of various widths
+//
+
+#ifndef __WCHAR_TYPE__
+# define __WCHAR_TYPE__ short
+#endif
+
+typedef uint64_t   UINT64;
+typedef int64_t    INT64;
+
+#ifndef _BASETSD_H_
+    typedef uint32_t   UINT32;
+    typedef int32_t    INT32;
+#endif
+
+typedef uint16_t   UINT16;
+typedef int16_t    INT16;
+typedef uint8_t    UINT8;
+typedef int8_t     INT8;
+typedef __WCHAR_TYPE__ WCHAR;
+
+#undef VOID
+#define VOID    void
+
+
+typedef int32_t    INTN;
+typedef uint32_t   UINTN;
+
+#ifdef EFI_NT_EMULATOR
+    #define POST_CODE(_Data)
+#else    
+    #ifdef EFI_DEBUG
+#define POST_CODE(_Data)    __asm mov eax,(_Data) __asm out 0x80,al
+    #else
+        #define POST_CODE(_Data)
+    #endif  
+#endif
+
+#define EFIERR(a)           (0x80000000 | a)
+#define EFI_ERROR_MASK      0x80000000
+#define EFIERR_OEM(a)       (0xc0000000 | a)      
+
+
+#define BAD_POINTER         0xFBFBFBFB
+#define MAX_ADDRESS         0xFFFFFFFF
+
+#ifdef EFI_NT_EMULATOR
+    #define BREAKPOINT()        __asm { int 3 }
+#else
+    #define BREAKPOINT()        while (TRUE);    // Make it hang on Bios[Dbg]32
+#endif
+
+//
+// Pointers must be aligned to these address to function
+//
+
+#define MIN_ALIGNMENT_SIZE  4
+
+#define ALIGN_VARIABLE(Value ,Adjustment) \
+            (UINTN)Adjustment = 0; \
+            if((UINTN)Value % MIN_ALIGNMENT_SIZE) \
+                (UINTN)Adjustment = MIN_ALIGNMENT_SIZE - ((UINTN)Value % MIN_ALIGNMENT_SIZE); \
+            Value = (UINTN)Value + (UINTN)Adjustment
+
+
+//
+// Define macros to build data structure signatures from characters.
+//
+
+#define EFI_SIGNATURE_16(A,B)             ((A) | (B<<8))
+#define EFI_SIGNATURE_32(A,B,C,D)         (EFI_SIGNATURE_16(A,B)     | (EFI_SIGNATURE_16(C,D)     << 16))
+#define EFI_SIGNATURE_64(A,B,C,D,E,F,G,H) (EFI_SIGNATURE_32(A,B,C,D) | ((UINT64)(EFI_SIGNATURE_32(E,F,G,H)) << 32))
+//
+// To export & import functions in the EFI emulator environment
+//
+
+#ifdef EFI_NT_EMULATOR
+    #define EXPORTAPI           __declspec( dllexport )
+#else
+    #define EXPORTAPI
+#endif
+
+
+//
+// EFIAPI - prototype calling convention for EFI function pointers
+// BOOTSERVICE - prototype for implementation of a boot service interface
+// RUNTIMESERVICE - prototype for implementation of a runtime service interface
+// RUNTIMEFUNCTION - prototype for implementation of a runtime function that is not a service
+// RUNTIME_CODE - pragma macro for declaring runtime code    
+//
+
+#ifndef EFIAPI                  // Forces EFI calling conventions reguardless of compiler options 
+    #ifdef _MSC_EXTENSIONS
+        #define EFIAPI __cdecl  // Force C calling convention for Microsoft C compiler 
+    #else
+        #define EFIAPI          // Substitute expresion to force C calling convention 
+    #endif
+#endif
+
+#define BOOTSERVICE
+//#define RUNTIMESERVICE(proto,a)    alloc_text("rtcode",a); proto a
+//#define RUNTIMEFUNCTION(proto,a)   alloc_text("rtcode",a); proto a
+#define RUNTIMESERVICE
+#define RUNTIMEFUNCTION
+
+
+#define RUNTIME_CODE(a)         alloc_text("rtcode", a)
+#define BEGIN_RUNTIME_DATA()    data_seg("rtdata")
+#define END_RUNTIME_DATA()      data_seg("")
+
+#define VOLATILE    volatile
+
+#define MEMORY_FENCE()    
+
+#ifdef EFI_NT_EMULATOR
+
+//
+// To help ensure proper coding of integrated drivers, they are
+// compiled as DLLs.  In NT they require a dll init entry pointer.
+// The macro puts a stub entry point into the DLL so it will load.
+//
+
+#define EFI_DRIVER_ENTRY_POINT(InitFunction)    \
+    UINTN                                       \
+    __stdcall                                   \
+    _DllMainCRTStartup (                        \
+        UINTN    Inst,                          \
+        UINTN    reason_for_call,               \
+        VOID    *rserved                        \
+        )                                       \
+    {                                           \
+        return 1;                               \
+    }                                           \
+                                                \
+    int                                         \
+    EXPORTAPI                                   \
+    __cdecl                                     \
+    InitializeDriver (                          \
+        void *ImageHandle,                      \
+        void *SystemTable                       \
+        )                                       \
+    {                                           \
+        return InitFunction(ImageHandle, SystemTable);       \
+    }
+
+
+    #define LOAD_INTERNAL_DRIVER(_if, type, name, entry)      \
+        (_if)->LoadInternal(type, name, NULL)             
+
+#else // EFI_NT_EMULATOR 
+
+//
+// When build similiar to FW, then link everything together as
+// one big module.
+//
+
+    #define EFI_DRIVER_ENTRY_POINT(InitFunction)    \
+        UINTN                                       \
+        InitializeDriver (                          \
+            VOID    *ImageHandle,                   \
+            VOID    *SystemTable                    \
+            )                                       \
+        {                                           \
+            return InitFunction(ImageHandle,        \
+                    SystemTable);                   \
+        }                                           \
+                                                    \
+        EFI_STATUS efi_main(                        \
+            EFI_HANDLE image,                       \
+            EFI_SYSTEM_TABLE *systab                \
+            ) __attribute__((weak,                  \
+                    alias ("InitializeDriver")));
+
+    #define LOAD_INTERNAL_DRIVER(_if, type, name, entry)    \
+            (_if)->LoadInternal(type, name, entry)
+
+#endif // EFI_FW_NT 
+
+//
+// Some compilers don't support the forward reference construct:
+//  typedef struct XXXXX
+//
+// The following macro provide a workaround for such cases.
+//
+#ifdef NO_INTERFACE_DECL
+#define INTERFACE_DECL(x)
+#else
+#ifdef __GNUC__
+#define INTERFACE_DECL(x) struct x
+#else
+#define INTERFACE_DECL(x) typedef struct x
+#endif
+#endif
+
+/* No efi call wrapper for IA32 architecture */
+#define uefi_call_wrapper(func, va_num, ...)	func(__VA_ARGS__)
+#define EFI_FUNCTION
+
+#ifdef _MSC_EXTENSIONS
+#pragma warning ( disable : 4731 )  // Suppress warnings about modification of EBP
+#endif
+
diff --git a/linux-x86/gnu-efi/include/efi/ia32/efilibplat.h b/linux-x86/gnu-efi/include/efi/ia32/efilibplat.h
new file mode 100644
index 0000000..3844578
--- /dev/null
+++ b/linux-x86/gnu-efi/include/efi/ia32/efilibplat.h
@@ -0,0 +1,26 @@
+/*++
+
+Copyright (c) 1998  Intel Corporation
+
+Module Name:
+
+    efilibplat.h
+
+Abstract:
+
+    EFI to compile bindings
+
+
+
+
+Revision History
+
+--*/
+
+VOID
+InitializeLibPlatform (
+    IN EFI_HANDLE           ImageHandle,
+    IN EFI_SYSTEM_TABLE     *SystemTable
+    );
+
+   
diff --git a/linux-x86/gnu-efi/include/efi/ia32/pe.h b/linux-x86/gnu-efi/include/efi/ia32/pe.h
new file mode 100644
index 0000000..16e40ef
--- /dev/null
+++ b/linux-x86/gnu-efi/include/efi/ia32/pe.h
@@ -0,0 +1,591 @@
+/* 
+    PE32+ header file
+ */
+#ifndef _PE_H
+#define _PE_H
+
+#define IMAGE_DOS_SIGNATURE                 0x5A4D      // MZ
+#define IMAGE_OS2_SIGNATURE                 0x454E      // NE
+#define IMAGE_OS2_SIGNATURE_LE              0x454C      // LE
+#define IMAGE_NT_SIGNATURE                  0x00004550  // PE00  
+#define IMAGE_EDOS_SIGNATURE                0x44454550  // PEED
+
+
+typedef struct _IMAGE_DOS_HEADER {      // DOS .EXE header
+    UINT16   e_magic;                     // Magic number
+    UINT16   e_cblp;                      // Bytes on last page of file
+    UINT16   e_cp;                        // Pages in file
+    UINT16   e_crlc;                      // Relocations
+    UINT16   e_cparhdr;                   // Size of header in paragraphs
+    UINT16   e_minalloc;                  // Minimum extra paragraphs needed
+    UINT16   e_maxalloc;                  // Maximum extra paragraphs needed
+    UINT16   e_ss;                        // Initial (relative) SS value
+    UINT16   e_sp;                        // Initial SP value
+    UINT16   e_csum;                      // Checksum
+    UINT16   e_ip;                        // Initial IP value
+    UINT16   e_cs;                        // Initial (relative) CS value
+    UINT16   e_lfarlc;                    // File address of relocation table
+    UINT16   e_ovno;                      // Overlay number
+    UINT16   e_res[4];                    // Reserved words
+    UINT16   e_oemid;                     // OEM identifier (for e_oeminfo)
+    UINT16   e_oeminfo;                   // OEM information; e_oemid specific
+    UINT16   e_res2[10];                  // Reserved words
+    UINT32   e_lfanew;                    // File address of new exe header
+  } IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;
+
+typedef struct _IMAGE_OS2_HEADER {      // OS/2 .EXE header
+    UINT16   ne_magic;                    // Magic number
+    UINT8    ne_ver;                      // Version number
+    UINT8    ne_rev;                      // Revision number
+    UINT16   ne_enttab;                   // Offset of Entry Table
+    UINT16   ne_cbenttab;                 // Number of bytes in Entry Table
+    UINT32   ne_crc;                      // Checksum of whole file
+    UINT16   ne_flags;                    // Flag UINT16
+    UINT16   ne_autodata;                 // Automatic data segment number
+    UINT16   ne_heap;                     // Initial heap allocation
+    UINT16   ne_stack;                    // Initial stack allocation
+    UINT32   ne_csip;                     // Initial CS:IP setting
+    UINT32   ne_sssp;                     // Initial SS:SP setting
+    UINT16   ne_cseg;                     // Count of file segments
+    UINT16   ne_cmod;                     // Entries in Module Reference Table
+    UINT16   ne_cbnrestab;                // Size of non-resident name table
+    UINT16   ne_segtab;                   // Offset of Segment Table
+    UINT16   ne_rsrctab;                  // Offset of Resource Table
+    UINT16   ne_restab;                   // Offset of resident name table
+    UINT16   ne_modtab;                   // Offset of Module Reference Table
+    UINT16   ne_imptab;                   // Offset of Imported Names Table
+    UINT32   ne_nrestab;                  // Offset of Non-resident Names Table
+    UINT16   ne_cmovent;                  // Count of movable entries
+    UINT16   ne_align;                    // Segment alignment shift count
+    UINT16   ne_cres;                     // Count of resource segments
+    UINT8    ne_exetyp;                   // Target Operating system
+    UINT8    ne_flagsothers;              // Other .EXE flags
+    UINT16   ne_pretthunks;               // offset to return thunks
+    UINT16   ne_psegrefbytes;             // offset to segment ref. bytes
+    UINT16   ne_swaparea;                 // Minimum code swap area size
+    UINT16   ne_expver;                   // Expected Windows version number
+  } IMAGE_OS2_HEADER, *PIMAGE_OS2_HEADER;
+
+//
+// File header format.
+//
+
+typedef struct _IMAGE_FILE_HEADER {
+    UINT16   Machine;
+    UINT16   NumberOfSections;
+    UINT32   TimeDateStamp;
+    UINT32   PointerToSymbolTable;
+    UINT32   NumberOfSymbols;
+    UINT16   SizeOfOptionalHeader;
+    UINT16   Characteristics;
+} IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;
+
+#define IMAGE_SIZEOF_FILE_HEADER             20
+
+#define IMAGE_FILE_RELOCS_STRIPPED           0x0001  // Relocation info stripped from file.
+#define IMAGE_FILE_EXECUTABLE_IMAGE          0x0002  // File is executable  (i.e. no unresolved externel references).
+#define IMAGE_FILE_LINE_NUMS_STRIPPED        0x0004  // Line nunbers stripped from file.
+#define IMAGE_FILE_LOCAL_SYMS_STRIPPED       0x0008  // Local symbols stripped from file.
+#define IMAGE_FILE_BYTES_REVERSED_LO         0x0080  // Bytes of machine word are reversed.
+#define IMAGE_FILE_32BIT_MACHINE             0x0100  // 32 bit word machine.
+#define IMAGE_FILE_DEBUG_STRIPPED            0x0200  // Debugging info stripped from file in .DBG file
+#define IMAGE_FILE_SYSTEM                    0x1000  // System File.
+#define IMAGE_FILE_DLL                       0x2000  // File is a DLL.
+#define IMAGE_FILE_BYTES_REVERSED_HI         0x8000  // Bytes of machine word are reversed.
+
+#define IMAGE_FILE_MACHINE_UNKNOWN           0
+#define IMAGE_FILE_MACHINE_I386              0x14c   // Intel 386.
+#define IMAGE_FILE_MACHINE_R3000             0x162   // MIPS little-endian, 0540 big-endian
+#define IMAGE_FILE_MACHINE_R4000             0x166   // MIPS little-endian
+#define IMAGE_FILE_MACHINE_ALPHA             0x184   // Alpha_AXP
+#define IMAGE_FILE_MACHINE_POWERPC           0x1F0   // IBM PowerPC Little-Endian
+#define IMAGE_FILE_MACHINE_TAHOE             0x7cc   // Intel EM machine
+//
+// Directory format.
+//
+
+typedef struct _IMAGE_DATA_DIRECTORY {
+    UINT32   VirtualAddress;
+    UINT32   Size;
+} IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;
+
+#define IMAGE_NUMBEROF_DIRECTORY_ENTRIES    16
+
+//
+// Optional header format.
+//
+
+typedef struct _IMAGE_OPTIONAL_HEADER {
+    //
+    // Standard fields.
+    //
+
+    UINT16    Magic;
+    UINT8     MajorLinkerVersion;
+    UINT8     MinorLinkerVersion;
+    UINT32    SizeOfCode;
+    UINT32    SizeOfInitializedData;
+    UINT32    SizeOfUninitializedData;
+    UINT32    AddressOfEntryPoint;
+    UINT32    BaseOfCode;
+    UINT32    BaseOfData;
+                
+    //
+    // NT additional fields.
+    //
+
+    UINT32   ImageBase;
+    UINT32   SectionAlignment;
+    UINT32   FileAlignment;
+    UINT16   MajorOperatingSystemVersion;
+    UINT16   MinorOperatingSystemVersion;
+    UINT16   MajorImageVersion;
+    UINT16   MinorImageVersion;
+    UINT16   MajorSubsystemVersion;
+    UINT16   MinorSubsystemVersion;
+    UINT32   Reserved1;
+    UINT32   SizeOfImage;
+    UINT32   SizeOfHeaders;
+    UINT32   CheckSum;
+    UINT16   Subsystem;
+    UINT16   DllCharacteristics;
+    UINT32   SizeOfStackReserve;
+    UINT32   SizeOfStackCommit;
+    UINT32   SizeOfHeapReserve;
+    UINT32   SizeOfHeapCommit;
+    UINT32   LoaderFlags;
+    UINT32   NumberOfRvaAndSizes;
+    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
+} IMAGE_OPTIONAL_HEADER, *PIMAGE_OPTIONAL_HEADER;
+
+typedef struct _IMAGE_ROM_OPTIONAL_HEADER {
+    UINT16  Magic;
+    UINT8   MajorLinkerVersion;
+    UINT8   MinorLinkerVersion;
+    UINT32  SizeOfCode;
+    UINT32  SizeOfInitializedData;
+    UINT32  SizeOfUninitializedData;
+    UINT32  AddressOfEntryPoint;
+    UINT32  BaseOfCode;
+    UINT32  BaseOfData;
+    UINT32  BaseOfBss;
+    UINT32  GprMask;
+    UINT32  CprMask[4];
+    UINT32  GpValue;
+} IMAGE_ROM_OPTIONAL_HEADER, *PIMAGE_ROM_OPTIONAL_HEADER;
+
+#define IMAGE_SIZEOF_ROM_OPTIONAL_HEADER      56
+#define IMAGE_SIZEOF_STD_OPTIONAL_HEADER      28
+#define IMAGE_SIZEOF_NT_OPTIONAL_HEADER      224
+
+#define IMAGE_NT_OPTIONAL_HDR_MAGIC        0x10b
+#define IMAGE_ROM_OPTIONAL_HDR_MAGIC       0x107
+
+typedef struct _IMAGE_NT_HEADERS {
+    UINT32 Signature;
+    IMAGE_FILE_HEADER FileHeader;
+    IMAGE_OPTIONAL_HEADER OptionalHeader;
+} IMAGE_NT_HEADERS, *PIMAGE_NT_HEADERS;
+
+typedef struct _IMAGE_ROM_HEADERS {
+    IMAGE_FILE_HEADER FileHeader;
+    IMAGE_ROM_OPTIONAL_HEADER OptionalHeader;
+} IMAGE_ROM_HEADERS, *PIMAGE_ROM_HEADERS;
+
+#define IMAGE_FIRST_SECTION( ntheader ) ((PIMAGE_SECTION_HEADER)        \
+    ((UINT32)ntheader +                                                  \
+     FIELD_OFFSET( IMAGE_NT_HEADERS, OptionalHeader ) +                 \
+     ((PIMAGE_NT_HEADERS)(ntheader))->FileHeader.SizeOfOptionalHeader   \
+    ))
+
+
+// Subsystem Values
+
+#define IMAGE_SUBSYSTEM_UNKNOWN              0   // Unknown subsystem.
+#define IMAGE_SUBSYSTEM_NATIVE               1   // Image doesn't require a subsystem.
+#define IMAGE_SUBSYSTEM_WINDOWS_GUI          2   // Image runs in the Windows GUI subsystem.
+#define IMAGE_SUBSYSTEM_WINDOWS_CUI          3   // Image runs in the Windows character subsystem.
+#define IMAGE_SUBSYSTEM_OS2_CUI              5   // image runs in the OS/2 character subsystem.
+#define IMAGE_SUBSYSTEM_POSIX_CUI            7   // image run  in the Posix character subsystem.
+
+
+// Directory Entries
+
+#define IMAGE_DIRECTORY_ENTRY_EXPORT         0   // Export Directory
+#define IMAGE_DIRECTORY_ENTRY_IMPORT         1   // Import Directory
+#define IMAGE_DIRECTORY_ENTRY_RESOURCE       2   // Resource Directory
+#define IMAGE_DIRECTORY_ENTRY_EXCEPTION      3   // Exception Directory
+#define IMAGE_DIRECTORY_ENTRY_SECURITY       4   // Security Directory
+#define IMAGE_DIRECTORY_ENTRY_BASERELOC      5   // Base Relocation Table
+#define IMAGE_DIRECTORY_ENTRY_DEBUG          6   // Debug Directory
+#define IMAGE_DIRECTORY_ENTRY_COPYRIGHT      7   // Description String
+#define IMAGE_DIRECTORY_ENTRY_GLOBALPTR      8   // Machine Value (MIPS GP)
+#define IMAGE_DIRECTORY_ENTRY_TLS            9   // TLS Directory
+#define IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG   10   // Load Configuration Directory
+
+//
+// Section header format.
+//
+
+#define IMAGE_SIZEOF_SHORT_NAME              8
+
+typedef struct _IMAGE_SECTION_HEADER {
+    UINT8   Name[IMAGE_SIZEOF_SHORT_NAME];
+    union {
+            UINT32   PhysicalAddress;
+            UINT32   VirtualSize;
+    } Misc;
+    UINT32   VirtualAddress;
+    UINT32   SizeOfRawData;
+    UINT32   PointerToRawData;
+    UINT32   PointerToRelocations;
+    UINT32   PointerToLinenumbers;
+    UINT16   NumberOfRelocations;
+    UINT16   NumberOfLinenumbers;
+    UINT32   Characteristics;
+} IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;
+
+#define IMAGE_SIZEOF_SECTION_HEADER          40
+
+#define IMAGE_SCN_TYPE_NO_PAD                0x00000008  // Reserved.
+
+#define IMAGE_SCN_CNT_CODE                   0x00000020  // Section contains code.
+#define IMAGE_SCN_CNT_INITIALIZED_DATA       0x00000040  // Section contains initialized data.
+#define IMAGE_SCN_CNT_UNINITIALIZED_DATA     0x00000080  // Section contains uninitialized data.
+
+#define IMAGE_SCN_LNK_OTHER                  0x00000100  // Reserved.
+#define IMAGE_SCN_LNK_INFO                   0x00000200  // Section contains comments or some other type of information.
+#define IMAGE_SCN_LNK_REMOVE                 0x00000800  // Section contents will not become part of image.
+#define IMAGE_SCN_LNK_COMDAT                 0x00001000  // Section contents comdat.
+
+#define IMAGE_SCN_ALIGN_1BYTES               0x00100000  //
+#define IMAGE_SCN_ALIGN_2BYTES               0x00200000  //
+#define IMAGE_SCN_ALIGN_4BYTES               0x00300000  //
+#define IMAGE_SCN_ALIGN_8BYTES               0x00400000  //
+#define IMAGE_SCN_ALIGN_16BYTES              0x00500000  // Default alignment if no others are specified.
+#define IMAGE_SCN_ALIGN_32BYTES              0x00600000  //
+#define IMAGE_SCN_ALIGN_64BYTES              0x00700000  //
+
+#define IMAGE_SCN_MEM_DISCARDABLE            0x02000000  // Section can be discarded.
+#define IMAGE_SCN_MEM_NOT_CACHED             0x04000000  // Section is not cachable.
+#define IMAGE_SCN_MEM_NOT_PAGED              0x08000000  // Section is not pageable.
+#define IMAGE_SCN_MEM_SHARED                 0x10000000  // Section is shareable.
+#define IMAGE_SCN_MEM_EXECUTE                0x20000000  // Section is executable.
+#define IMAGE_SCN_MEM_READ                   0x40000000  // Section is readable.
+#define IMAGE_SCN_MEM_WRITE                  0x80000000  // Section is writeable.
+
+//
+// Symbol format.
+//
+
+
+#define IMAGE_SIZEOF_SYMBOL                  18
+
+//
+// Section values.
+//
+// Symbols have a section number of the section in which they are
+// defined. Otherwise, section numbers have the following meanings:
+//
+
+#define IMAGE_SYM_UNDEFINED           (UINT16)0           // Symbol is undefined or is common.
+#define IMAGE_SYM_ABSOLUTE            (UINT16)-1          // Symbol is an absolute value.
+#define IMAGE_SYM_DEBUG               (UINT16)-2          // Symbol is a special debug item.
+
+//
+// Type (fundamental) values.
+//
+
+#define IMAGE_SYM_TYPE_NULL                  0           // no type.
+#define IMAGE_SYM_TYPE_VOID                  1           //
+#define IMAGE_SYM_TYPE_CHAR                  2           // type character.
+#define IMAGE_SYM_TYPE_SHORT                 3           // type short integer.
+#define IMAGE_SYM_TYPE_INT                   4           //
+#define IMAGE_SYM_TYPE_LONG                  5           //
+#define IMAGE_SYM_TYPE_FLOAT                 6           //
+#define IMAGE_SYM_TYPE_DOUBLE                7           //
+#define IMAGE_SYM_TYPE_STRUCT                8           //
+#define IMAGE_SYM_TYPE_UNION                 9           //
+#define IMAGE_SYM_TYPE_ENUM                  10          // enumeration.
+#define IMAGE_SYM_TYPE_MOE                   11          // member of enumeration.
+#define IMAGE_SYM_TYPE_BYTE                  12          //
+#define IMAGE_SYM_TYPE_WORD                  13          //
+#define IMAGE_SYM_TYPE_UINT                  14          //
+#define IMAGE_SYM_TYPE_DWORD                 15          //
+
+//
+// Type (derived) values.
+//
+
+#define IMAGE_SYM_DTYPE_NULL                 0           // no derived type.
+#define IMAGE_SYM_DTYPE_POINTER              1           // pointer.
+#define IMAGE_SYM_DTYPE_FUNCTION             2           // function.
+#define IMAGE_SYM_DTYPE_ARRAY                3           // array.
+
+//
+// Storage classes.
+//
+
+#define IMAGE_SYM_CLASS_END_OF_FUNCTION      (BYTE )-1
+#define IMAGE_SYM_CLASS_NULL                 0
+#define IMAGE_SYM_CLASS_AUTOMATIC            1
+#define IMAGE_SYM_CLASS_EXTERNAL             2
+#define IMAGE_SYM_CLASS_STATIC               3
+#define IMAGE_SYM_CLASS_REGISTER             4
+#define IMAGE_SYM_CLASS_EXTERNAL_DEF         5
+#define IMAGE_SYM_CLASS_LABEL                6
+#define IMAGE_SYM_CLASS_UNDEFINED_LABEL      7
+#define IMAGE_SYM_CLASS_MEMBER_OF_STRUCT     8
+#define IMAGE_SYM_CLASS_ARGUMENT             9
+#define IMAGE_SYM_CLASS_STRUCT_TAG           10
+#define IMAGE_SYM_CLASS_MEMBER_OF_UNION      11
+#define IMAGE_SYM_CLASS_UNION_TAG            12
+#define IMAGE_SYM_CLASS_TYPE_DEFINITION      13
+#define IMAGE_SYM_CLASS_UNDEFINED_STATIC     14
+#define IMAGE_SYM_CLASS_ENUM_TAG             15
+#define IMAGE_SYM_CLASS_MEMBER_OF_ENUM       16
+#define IMAGE_SYM_CLASS_REGISTER_PARAM       17
+#define IMAGE_SYM_CLASS_BIT_FIELD            18
+#define IMAGE_SYM_CLASS_BLOCK                100
+#define IMAGE_SYM_CLASS_FUNCTION             101
+#define IMAGE_SYM_CLASS_END_OF_STRUCT        102
+#define IMAGE_SYM_CLASS_FILE                 103
+// new
+#define IMAGE_SYM_CLASS_SECTION              104
+#define IMAGE_SYM_CLASS_WEAK_EXTERNAL        105
+
+// type packing constants
+
+#define N_BTMASK                            017
+#define N_TMASK                             060
+#define N_TMASK1                            0300
+#define N_TMASK2                            0360
+#define N_BTSHFT                            4
+#define N_TSHIFT                            2
+
+// MACROS
+
+//
+// Communal selection types.
+//
+
+#define IMAGE_COMDAT_SELECT_NODUPLICATES   1
+#define IMAGE_COMDAT_SELECT_ANY            2
+#define IMAGE_COMDAT_SELECT_SAME_SIZE      3
+#define IMAGE_COMDAT_SELECT_EXACT_MATCH    4
+#define IMAGE_COMDAT_SELECT_ASSOCIATIVE    5
+
+#define IMAGE_WEAK_EXTERN_SEARCH_NOLIBRARY 1
+#define IMAGE_WEAK_EXTERN_SEARCH_LIBRARY   2
+#define IMAGE_WEAK_EXTERN_SEARCH_ALIAS     3
+
+
+//
+// Relocation format.
+//
+
+typedef struct _IMAGE_RELOCATION {
+    UINT32   VirtualAddress;
+    UINT32   SymbolTableIndex;
+    UINT16    Type;
+} IMAGE_RELOCATION;
+
+#define IMAGE_SIZEOF_RELOCATION              10
+
+//
+// I386 relocation types.
+//
+
+#define IMAGE_REL_I386_ABSOLUTE              0           // Reference is absolute, no relocation is necessary
+#define IMAGE_REL_I386_DIR16                 01          // Direct 16-bit reference to the symbols virtual address
+#define IMAGE_REL_I386_REL16                 02          // PC-relative 16-bit reference to the symbols virtual address
+#define IMAGE_REL_I386_DIR32                 06          // Direct 32-bit reference to the symbols virtual address
+#define IMAGE_REL_I386_DIR32NB               07          // Direct 32-bit reference to the symbols virtual address, base not included
+#define IMAGE_REL_I386_SEG12                 011         // Direct 16-bit reference to the segment-selector bits of a 32-bit virtual address
+#define IMAGE_REL_I386_SECTION               012
+#define IMAGE_REL_I386_SECREL                013
+#define IMAGE_REL_I386_REL32                 024         // PC-relative 32-bit reference to the symbols virtual address
+
+//
+// MIPS relocation types.
+//
+
+#define IMAGE_REL_MIPS_ABSOLUTE              0           // Reference is absolute, no relocation is necessary
+#define IMAGE_REL_MIPS_REFHALF               01
+#define IMAGE_REL_MIPS_REFWORD               02
+#define IMAGE_REL_MIPS_JMPADDR               03
+#define IMAGE_REL_MIPS_REFHI                 04
+#define IMAGE_REL_MIPS_REFLO                 05
+#define IMAGE_REL_MIPS_GPREL                 06
+#define IMAGE_REL_MIPS_LITERAL               07
+#define IMAGE_REL_MIPS_SECTION               012
+#define IMAGE_REL_MIPS_SECREL                013
+#define IMAGE_REL_MIPS_REFWORDNB             042
+#define IMAGE_REL_MIPS_PAIR                  045
+
+//
+// Alpha Relocation types.
+//
+
+#define IMAGE_REL_ALPHA_ABSOLUTE             0x0
+#define IMAGE_REL_ALPHA_REFLONG              0x1
+#define IMAGE_REL_ALPHA_REFQUAD              0x2
+#define IMAGE_REL_ALPHA_GPREL32              0x3
+#define IMAGE_REL_ALPHA_LITERAL              0x4
+#define IMAGE_REL_ALPHA_LITUSE               0x5
+#define IMAGE_REL_ALPHA_GPDISP               0x6
+#define IMAGE_REL_ALPHA_BRADDR               0x7
+#define IMAGE_REL_ALPHA_HINT                 0x8
+#define IMAGE_REL_ALPHA_INLINE_REFLONG       0x9
+#define IMAGE_REL_ALPHA_REFHI                0xA
+#define IMAGE_REL_ALPHA_REFLO                0xB
+#define IMAGE_REL_ALPHA_PAIR                 0xC
+#define IMAGE_REL_ALPHA_MATCH                0xD
+#define IMAGE_REL_ALPHA_SECTION              0xE
+#define IMAGE_REL_ALPHA_SECREL               0xF
+#define IMAGE_REL_ALPHA_REFLONGNB            0x10
+
+//
+// IBM PowerPC relocation types.
+//
+
+#define IMAGE_REL_PPC_ABSOLUTE 0x0000  // NOP
+#define IMAGE_REL_PPC_ADDR64   0x0001  // 64-bit address
+#define IMAGE_REL_PPC_ADDR32   0x0002  // 32-bit address
+#define IMAGE_REL_PPC_ADDR24   0x0003  // 26-bit address, shifted left 2 (branch absolute)
+#define IMAGE_REL_PPC_ADDR16   0x0004  // 16-bit address
+#define IMAGE_REL_PPC_ADDR14   0x0005  // 16-bit address, shifted left 2 (load doubleword)
+#define IMAGE_REL_PPC_REL24    0x0006  // 26-bit PC-relative offset, shifted left 2 (branch relative)
+#define IMAGE_REL_PPC_REL14    0x0007  // 16-bit PC-relative offset, shifted left 2 (br cond relative)
+#define IMAGE_REL_PPC_TOCREL16 0x0008  // 16-bit offset from TOC base
+#define IMAGE_REL_PPC_TOCREL14 0x0009  // 16-bit offset from TOC base, shifted left 2 (load doubleword)
+
+#define IMAGE_REL_PPC_ADDR32NB 0x000A  // 32-bit addr w/o image base
+#define IMAGE_REL_PPC_SECREL   0x000B  // va of containing section (as in an image sectionhdr)
+#define IMAGE_REL_PPC_SECTION  0x000C  // sectionheader number
+#define IMAGE_REL_PPC_IFGLUE   0x000D  // substitute TOC restore instruction iff symbol is glue code
+#define IMAGE_REL_PPC_IMGLUE   0x000E  // symbol is glue code; virtual address is TOC restore instruction
+
+#define IMAGE_REL_PPC_TYPEMASK 0x00FF  // mask to isolate above values in IMAGE_RELOCATION.Type
+
+// Flag bits in IMAGE_RELOCATION.TYPE
+
+#define IMAGE_REL_PPC_NEG      0x0100  // subtract reloc value rather than adding it
+#define IMAGE_REL_PPC_BRTAKEN  0x0200  // fix branch prediction bit to predict branch taken
+#define IMAGE_REL_PPC_BRNTAKEN 0x0400  // fix branch prediction bit to predict branch not taken
+#define IMAGE_REL_PPC_TOCDEFN  0x0800  // toc slot defined in file (or, data in toc)
+
+//
+// Based relocation format.
+//
+
+typedef struct _IMAGE_BASE_RELOCATION {
+    UINT32   VirtualAddress;
+    UINT32   SizeOfBlock;
+//  UINT16    TypeOffset[1];
+} IMAGE_BASE_RELOCATION, *PIMAGE_BASE_RELOCATION;
+
+#define IMAGE_SIZEOF_BASE_RELOCATION         8
+
+//
+// Based relocation types.
+//
+
+#define IMAGE_REL_BASED_ABSOLUTE              0
+#define IMAGE_REL_BASED_HIGH                  1
+#define IMAGE_REL_BASED_LOW                   2
+#define IMAGE_REL_BASED_HIGHLOW               3
+#define IMAGE_REL_BASED_HIGHADJ               4
+#define IMAGE_REL_BASED_MIPS_JMPADDR          5
+#define IMAGE_REL_BASED_IA64_IMM64            9
+#define IMAGE_REL_BASED_DIR64                 10
+
+//
+// Line number format.
+//
+
+typedef struct _IMAGE_LINENUMBER {
+    union {
+        UINT32   SymbolTableIndex;               // Symbol table index of function name if Linenumber is 0.
+        UINT32   VirtualAddress;                 // Virtual address of line number.
+    } Type;
+    UINT16    Linenumber;                         // Line number.
+} IMAGE_LINENUMBER;
+
+#define IMAGE_SIZEOF_LINENUMBER              6
+
+//
+// Archive format.
+//
+
+#define IMAGE_ARCHIVE_START_SIZE             8
+#define IMAGE_ARCHIVE_START                  "!<arch>\n"
+#define IMAGE_ARCHIVE_END                    "`\n"
+#define IMAGE_ARCHIVE_PAD                    "\n"
+#define IMAGE_ARCHIVE_LINKER_MEMBER          "/               "
+#define IMAGE_ARCHIVE_LONGNAMES_MEMBER       "//              "
+
+typedef struct _IMAGE_ARCHIVE_MEMBER_HEADER {
+    UINT8     Name[16];                          // File member name - `/' terminated.
+    UINT8     Date[12];                          // File member date - decimal.
+    UINT8     UserID[6];                         // File member user id - decimal.
+    UINT8     GroupID[6];                        // File member group id - decimal.
+    UINT8     Mode[8];                           // File member mode - octal.
+    UINT8     Size[10];                          // File member size - decimal.
+    UINT8     EndHeader[2];                      // String to end header.
+} IMAGE_ARCHIVE_MEMBER_HEADER, *PIMAGE_ARCHIVE_MEMBER_HEADER;
+
+#define IMAGE_SIZEOF_ARCHIVE_MEMBER_HDR      60
+
+//
+// DLL support.
+//
+
+//
+// Export Format
+//
+
+typedef struct _IMAGE_EXPORT_DIRECTORY {
+    UINT32   Characteristics;
+    UINT32   TimeDateStamp;
+    UINT16   MajorVersion;
+    UINT16   MinorVersion;
+    UINT32   Name;
+    UINT32   Base;
+    UINT32   NumberOfFunctions;
+    UINT32   NumberOfNames;
+    UINT32   *AddressOfFunctions;
+    UINT32   *AddressOfNames;
+    UINT32   *AddressOfNameOrdinals;
+} IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;
+
+//
+// Import Format
+//
+
+typedef struct _IMAGE_IMPORT_BY_NAME {
+    UINT16    Hint;
+    UINT8     Name[1];
+} IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;
+
+typedef struct _IMAGE_THUNK_DATA {
+    union {
+        UINT32 Function;
+        UINT32 Ordinal;
+        PIMAGE_IMPORT_BY_NAME AddressOfData;
+    } u1;
+} IMAGE_THUNK_DATA, *PIMAGE_THUNK_DATA;
+
+#define IMAGE_ORDINAL_FLAG 0x80000000
+#define IMAGE_SNAP_BY_ORDINAL(Ordinal) ((Ordinal & IMAGE_ORDINAL_FLAG) != 0)
+#define IMAGE_ORDINAL(Ordinal) (Ordinal & 0xffff)
+
+typedef struct _IMAGE_IMPORT_DESCRIPTOR {
+    UINT32   Characteristics;
+    UINT32   TimeDateStamp;
+    UINT32   ForwarderChain;
+    UINT32   Name;
+    PIMAGE_THUNK_DATA FirstThunk;
+} IMAGE_IMPORT_DESCRIPTOR, *PIMAGE_IMPORT_DESCRIPTOR;
+
+#endif
diff --git a/linux-x86/gnu-efi/include/efi/libsmbios.h b/linux-x86/gnu-efi/include/efi/libsmbios.h
new file mode 100644
index 0000000..8f1a28e
--- /dev/null
+++ b/linux-x86/gnu-efi/include/efi/libsmbios.h
@@ -0,0 +1,132 @@
+#ifndef _LIB_SMBIOS_H
+#define _LIB_SMBIOS_H
+/*++
+
+Copyright (c) 2000  Intel Corporation
+
+Module Name:
+
+    LibSmbios.h
+    
+Abstract:
+
+    Lib include  for SMBIOS services. Used to get system serial number and GUID
+
+Revision History
+
+--*/
+
+//
+// Define SMBIOS tables.
+//
+#pragma pack(1)
+typedef struct {
+    UINT8   AnchorString[4];
+    UINT8   EntryPointStructureChecksum;
+    UINT8   EntryPointLength;
+    UINT8   MajorVersion;
+    UINT8   MinorVersion;
+    UINT16  MaxStructureSize;
+    UINT8   EntryPointRevision;
+    UINT8   FormattedArea[5];
+    UINT8   IntermediateAnchorString[5];
+    UINT8   IntermediateChecksum;
+    UINT16  TableLength;
+    UINT32  TableAddress;
+    UINT16  NumberOfSmbiosStructures;
+    UINT8   SmbiosBcdRevision;
+} SMBIOS_STRUCTURE_TABLE;
+
+//
+// Please note that SMBIOS structures can be odd byte aligned since the
+//  unformated section of each record is a set of arbitrary size strings.
+//
+
+typedef struct {
+    UINT8   Type;
+    UINT8   Length;
+    UINT8   Handle[2];
+} SMBIOS_HEADER;
+
+typedef UINT8   SMBIOS_STRING;
+
+typedef struct {
+    SMBIOS_HEADER   Hdr;
+    SMBIOS_STRING   Vendor;
+    SMBIOS_STRING   BiosVersion;
+    UINT8           BiosSegment[2];
+    SMBIOS_STRING   BiosReleaseDate;
+    UINT8           BiosSize;
+    UINT8           BiosCharacteristics[8];
+} SMBIOS_TYPE0;
+
+typedef struct {
+    SMBIOS_HEADER   Hdr;
+    SMBIOS_STRING   Manufacturer;
+    SMBIOS_STRING   ProductName;
+    SMBIOS_STRING   Version;
+    SMBIOS_STRING   SerialNumber;
+
+    //
+    // always byte copy this data to prevent alignment faults!
+    //
+    EFI_GUID        Uuid;
+    
+    UINT8           WakeUpType;
+} SMBIOS_TYPE1;
+
+typedef struct {
+    SMBIOS_HEADER   Hdr;
+    SMBIOS_STRING   Manufacturer;
+    SMBIOS_STRING   ProductName;
+    SMBIOS_STRING   Version;
+    SMBIOS_STRING   SerialNumber;
+} SMBIOS_TYPE2;
+
+typedef struct {
+    SMBIOS_HEADER   Hdr;
+    SMBIOS_STRING   Manufacturer;
+    UINT8           Type;
+    SMBIOS_STRING   Version;
+    SMBIOS_STRING   SerialNumber;
+    SMBIOS_STRING   AssetTag;
+    UINT8           BootupState;
+    UINT8           PowerSupplyState;
+    UINT8           ThermalState;
+    UINT8           SecurityStatus;
+    UINT8           OemDefined[4];
+} SMBIOS_TYPE3;
+
+typedef struct {
+    SMBIOS_HEADER   Hdr;
+    UINT8           Socket;
+    UINT8           ProcessorType;
+    UINT8           ProcessorFamily;
+    SMBIOS_STRING   ProcessorManufacture;
+    UINT8           ProcessorId[8];
+    SMBIOS_STRING   ProcessorVersion;
+    UINT8           Voltage;
+    UINT8           ExternalClock[2];
+    UINT8           MaxSpeed[2];
+    UINT8           CurrentSpeed[2];
+    UINT8           Status;
+    UINT8           ProcessorUpgrade;
+    UINT8           L1CacheHandle[2];
+    UINT8           L2CacheHandle[2];
+    UINT8           L3CacheHandle[2];
+} SMBIOS_TYPE4;
+
+typedef union {
+    SMBIOS_HEADER   *Hdr;
+    SMBIOS_TYPE0    *Type0;
+    SMBIOS_TYPE1    *Type1;
+    SMBIOS_TYPE2    *Type2;
+    SMBIOS_TYPE3    *Type3;
+    SMBIOS_TYPE4    *Type4;
+    UINT8           *Raw;
+} SMBIOS_STRUCTURE_POINTER;
+#pragma pack()
+
+
+#endif
+
diff --git a/linux-x86/gnu-efi/include/efi/pci22.h b/linux-x86/gnu-efi/include/efi/pci22.h
new file mode 100644
index 0000000..b94f519
--- /dev/null
+++ b/linux-x86/gnu-efi/include/efi/pci22.h
@@ -0,0 +1,193 @@
+#ifndef _PCI22_H
+#define _PCI22_H
+
+/*++
+
+Copyright (c) 1999  Intel Corporation
+
+Module Name:
+
+    pci22.h
+    
+Abstract:      
+    Support for PCI 2.2 standard.
+
+
+
+
+Revision History
+
+--*/
+
+#ifdef SOFT_SDV
+#define PCI_MAX_BUS     1
+#else
+#define PCI_MAX_BUS     255
+#endif
+
+#define PCI_MAX_DEVICE  31
+#define PCI_MAX_FUNC    7
+
+//
+// Command
+//
+#define PCI_VGA_PALETTE_SNOOP_DISABLED   0x20
+
+#pragma pack(1)
+typedef struct {
+    UINT16      VendorId;
+    UINT16      DeviceId;
+    UINT16      Command;
+    UINT16      Status;
+    UINT8       RevisionID;
+    UINT8       ClassCode[3];
+    UINT8       CacheLineSize;
+    UINT8       LaytencyTimer;
+    UINT8       HeaderType;
+    UINT8       BIST;
+} PCI_DEVICE_INDEPENDENT_REGION;
+
+typedef struct {
+    UINT32      Bar[6];
+    UINT32      CISPtr;
+    UINT16      SubsystemVendorID;
+    UINT16      SubsystemID;
+    UINT32      ExpansionRomBar;
+    UINT32      Reserved[2];
+    UINT8       InterruptLine;
+    UINT8       InterruptPin;
+    UINT8       MinGnt;
+    UINT8       MaxLat;     
+} PCI_DEVICE_HEADER_TYPE_REGION;
+
+typedef struct {
+    PCI_DEVICE_INDEPENDENT_REGION   Hdr;
+    PCI_DEVICE_HEADER_TYPE_REGION   Device;
+} PCI_TYPE00;
+
+typedef struct {              
+    UINT32      Bar[2];
+    UINT8       PrimaryBus;
+    UINT8       SecondaryBus;
+    UINT8       SubordinateBus;
+    UINT8       SecondaryLatencyTimer;
+    UINT8       IoBase;
+    UINT8       IoLimit;
+    UINT16      SecondaryStatus;
+    UINT16      MemoryBase;
+    UINT16      MemoryLimit;
+    UINT16      PrefetchableMemoryBase;
+    UINT16      PrefetchableMemoryLimit;
+    UINT32      PrefetchableBaseUpper32;
+    UINT32      PrefetchableLimitUpper32;
+    UINT16      IoBaseUpper16;
+    UINT16      IoLimitUpper16;
+    UINT32      Reserved;
+    UINT32      ExpansionRomBAR;
+    UINT8       InterruptLine;
+    UINT8       InterruptPin;
+    UINT16      BridgeControl;
+} PCI_BRIDGE_CONTROL_REGISTER;
+
+#define PCI_CLASS_DISPLAY_CTRL          0x03
+#define PCI_CLASS_VGA                   0x00
+
+#define PCI_CLASS_BRIDGE                0x06
+#define PCI_CLASS_ISA                   0x01
+#define PCI_CLASS_ISA_POSITIVE_DECODE   0x80
+
+#define PCI_CLASS_NETWORK               0x02 
+#define PCI_CLASS_ETHERNET              0x00
+        
+#define HEADER_TYPE_DEVICE              0x00
+#define HEADER_TYPE_PCI_TO_PCI_BRIDGE   0x01
+#define HEADER_TYPE_MULTI_FUNCTION      0x80
+#define HEADER_LAYOUT_CODE              0x7f
+
+#define IS_PCI_BRIDGE(_p) ((((_p)->Hdr.HeaderType) & HEADER_LAYOUT_CODE) == HEADER_TYPE_PCI_TO_PCI_BRIDGE)        
+#define IS_PCI_MULTI_FUNC(_p)   (((_p)->Hdr.HeaderType) & HEADER_TYPE_MULTI_FUNCTION)         
+
+typedef struct {
+    PCI_DEVICE_INDEPENDENT_REGION   Hdr;
+    PCI_BRIDGE_CONTROL_REGISTER     Bridge;
+} PCI_TYPE01;
+
+typedef struct {
+    UINT8   Register;
+    UINT8   Function;
+    UINT8   Device;
+    UINT8   Bus;
+    UINT8   Reserved[4];
+} DEFIO_PCI_ADDR;
+
+typedef struct {
+    UINT32  Reg     : 8;
+    UINT32  Func    : 3;
+    UINT32  Dev     : 5;
+    UINT32  Bus     : 8;
+    UINT32  Reserved: 7;
+    UINT32  Enable  : 1;
+} PCI_CONFIG_ACCESS_CF8;
+
+#pragma pack()
+
+#define EFI_ROOT_BRIDGE_LIST    'eprb'
+typedef struct {
+    UINTN           Signature;
+
+    UINT16          BridgeNumber;
+    UINT16          PrimaryBus;
+    UINT16          SubordinateBus;
+
+    EFI_DEVICE_PATH *DevicePath;
+
+    LIST_ENTRY      Link;
+} PCI_ROOT_BRIDGE_ENTRY;
+
+
+#define PCI_EXPANSION_ROM_HEADER_SIGNATURE        0xaa55
+#define EFI_PCI_EXPANSION_ROM_HEADER_EFISIGNATURE 0x0EF1
+#define PCI_DATA_STRUCTURE_SIGNATURE              EFI_SIGNATURE_32('P','C','I','R')
+
+#pragma pack(1)
+typedef struct {
+    UINT16          Signature;              // 0xaa55
+    UINT8           Reserved[0x16];
+    UINT16          PcirOffset;
+} PCI_EXPANSION_ROM_HEADER;
+
+
+typedef struct {
+    UINT16          Signature;              // 0xaa55
+    UINT16          InitializationSize;
+    UINT16          EfiSignature;           // 0x0EF1
+    UINT16          EfiSubsystem;
+    UINT16          EfiMachineType;
+    UINT8           Reserved[0x0A];
+    UINT16          EfiImageHeaderOffset;
+    UINT16          PcirOffset;
+} EFI_PCI_EXPANSION_ROM_HEADER;
+
+typedef struct {
+    UINT32          Signature;              // "PCIR" 
+    UINT16          VendorId;
+    UINT16          DeviceId;
+    UINT16          Reserved0;
+    UINT16          Length;
+    UINT8           Revision;
+    UINT8           ClassCode[3];
+    UINT16          ImageLength;
+    UINT16          CodeRevision;
+    UINT8           CodeType;
+    UINT8           Indicator;
+    UINT16          Reserved1;
+} PCI_DATA_STRUCTURE;
+#pragma pack()
+
+#endif
+    
+
+
+
+
+    
diff --git a/linux-x86/gnu-efi/include/efi/protocol/adapterdebug.h b/linux-x86/gnu-efi/include/efi/protocol/adapterdebug.h
new file mode 100644
index 0000000..d70af5d
--- /dev/null
+++ b/linux-x86/gnu-efi/include/efi/protocol/adapterdebug.h
@@ -0,0 +1,32 @@
+#ifndef _ADAPTER_DEBUG_H
+#define _ADAPTER_DEBUG_H
+
+/*++
+
+Copyright (c) 1999  Intel Corporation
+
+Module Name:
+
+    AdapterDebug.h
+    
+Abstract:
+
+    Protocol to debug the EDD 3.0 enablement of BIOS option ROMs
+
+
+
+Revision History
+
+--*/
+
+// {82F86881-282B-11d4-BC7D-0080C73C8881}
+#define ADAPTER_DEBUG_PROTOCOL \
+{ 0x82f86881, 0x282b, 0x11d4, {0xbc, 0x7d, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81} }
+
+//
+// This protocol points to the BIOS_LEGACY_DRIVE data structure
+//  see edd.h for more details
+//
+
+#endif
+
diff --git a/linux-x86/gnu-efi/include/efi/protocol/eficonsplit.h b/linux-x86/gnu-efi/include/efi/protocol/eficonsplit.h
new file mode 100644
index 0000000..15adb92
--- /dev/null
+++ b/linux-x86/gnu-efi/include/efi/protocol/eficonsplit.h
@@ -0,0 +1,32 @@
+#ifndef _EFI_CONFORK_H
+#define _EFI_CONFORK_H
+/*++
+
+Copyright (c) 1999  Intel Corporation
+
+Module Name:
+
+Abstract:
+
+
+
+Revision History
+
+--*/
+
+
+
+//
+// ConOut Forker Protocol
+//
+
+#define TEXT_OUT_SPLITER_PROTOCOL    \
+    { 0x56d830a0, 0x7e7a, 0x11d3, {0xbb, 0xa0, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b} }
+
+#define ERROR_OUT_SPLITER_PROTOCOL    \
+    { 0xf0ba9039, 0x68f1, 0x425e, {0xaa, 0x7f, 0xd9, 0xaa, 0xf9, 0x1b, 0x82, 0xa1}}
+
+#define TEXT_IN_SPLITER_PROTOCOL    \
+    { 0xf9a3c550, 0x7fb5, 0x11d3, {0xbb, 0xa0, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b} }
+
+#endif
diff --git a/linux-x86/gnu-efi/include/efi/protocol/efidbg.h b/linux-x86/gnu-efi/include/efi/protocol/efidbg.h
new file mode 100644
index 0000000..1f95a70
--- /dev/null
+++ b/linux-x86/gnu-efi/include/efi/protocol/efidbg.h
@@ -0,0 +1,210 @@
+/*
+ * Copyright (c) 1999, 2000
+ * Intel Corporation.
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ * 
+ *    This product includes software developed by Intel Corporation and
+ *    its contributors.
+ * 
+ * 4. Neither the name of Intel Corporation or its contributors may be
+ *    used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY INTEL CORPORATION AND CONTRIBUTORS ``AS IS''
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL INTEL CORPORATION OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * 
+ */
+
+
+#ifndef _EFIDBG_H_
+#define _EFIDBG_H_
+
+#include "eficontext.h"
+#include "efiser.h"
+
+typedef struct _DEBUGPORT_16550_CONFIG_DATA {
+        UINT32							PortAddress;
+        UINT64                          BaudRate;
+    	UINT32               			ReceiveFifoDepth;
+    	UINT32               			Timeout;
+        UINT8                           Parity;
+        UINT8                           DataBits;
+        UINT8                           StopBits;
+	    UINT32                       	ControlMask;
+        BOOLEAN							RtsCtsEnable;		// RTS, CTS control
+} DEBUGPORT_16550_CONFIG_DATA;
+
+typedef struct _DEBUGPORT_16550_DEVICE_PATH {
+        EFI_DEVICE_PATH                 Header;
+        DEBUGPORT_16550_CONFIG_DATA		ConfigData;
+} DEBUGPORT_16550_DEVICE_PATH;
+
+typedef union {
+    EFI_DEVICE_PATH                     DevPath;
+    DEBUGPORT_16550_DEVICE_PATH         Uart;
+    // add new types of debugport device paths to this union...
+} DEBUGPORT_DEV_PATH;
+
+
+//
+// Debug Support protocol {2755590C-6F3C-42FA-9EA4-A3BA543CDA25}
+//
+
+#define DEBUG_SUPPORT_PROTOCOL \
+{ 0x2755590C, 0x6F3C, 0x42fa, 0x9E, 0xA4, 0xA3, 0xBA, 0x54, 0x3C, 0xDA, 0x25 }
+
+
+typedef UINTN EXCEPTION_TYPE;
+
+typedef
+VOID
+(*EXCEPTION_HANDLER) (
+	IN EXCEPTION_TYPE ExceptionType,
+    IN SYSTEM_CONTEXT *SystemContext
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_REGISTER_TIMER_TICK_CALLBACK) (
+    IN struct _EFI_DEBUG_SUPPORT_INTERFACE  *This,
+    IN EXCEPTION_HANDLER	                TimerTickCallback
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_REGISTER_EXCEPTION_HANDLER) (
+    IN     struct _EFI_DEBUG_SUPPORT_INTERFACE  *This,
+    IN     EXCEPTION_HANDLER                    ExceptionHandler,
+    IN     EXCEPTION_TYPE                       ExceptionType
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_IP_CALL_TRACE) (
+    IN     struct _EFI_DEBUG_SUPPORT_INTERFACE  *This
+    );
+
+
+#define EFI_DEBUG_SUPPORT_INTERFACE_REVISION     0x00010000
+
+typedef struct _EFI_DEBUG_SUPPORT_INTERFACE {
+    UINT32                          	Revision;
+    EFI_REGISTER_TIMER_TICK_CALLBACK	RegisterTimerTickCallback;
+    EFI_REGISTER_EXCEPTION_HANDLER  	RegisterExceptionHandler;
+    EFI_IP_CALL_TRACE               	IpCallTrace;
+} EFI_DEBUG_SUPPORT_INTERFACE;
+
+
+//
+// Debugport io protocol {EBA4E8D2-3858-41EC-A281-2647BA9660D0}
+//
+
+#define DEBUGPORT_IO_PROTOCOL \
+{ 0XEBA4E8D2, 0X3858, 0X41EC, 0XA2, 0X81, 0X26, 0X47, 0XBA, 0X96, 0X60, 0XD0 }
+ 
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_DEBUGPORT_IO_RESET) (
+    IN struct _EFI_DEBUGPORT_IO_INTERFACE  	*This
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_DEBUGPORT_IO_READ) (
+    IN     struct _EFI_DEBUGPORT_IO_INTERFACE	*This,
+    IN OUT UINTN                    		*BufferSize,
+    OUT VOID                         		*Buffer
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_DEBUGPORT_IO_WRITE) (
+    IN     struct _EFI_DEBUGPORT_IO_INTERFACE *This,
+    IN OUT UINTN                    		*BufferSize,
+    IN VOID                         		*Buffer
+    );
+
+#define EFI_DEBUGPORT_IO_INTERFACE_REVISION   0x00010000
+
+typedef struct _EFI_DEBUGPORT_IO_INTERFACE {
+    UINT32                          		Revision;
+    EFI_DEBUGPORT_IO_READ					Read;
+    EFI_DEBUGPORT_IO_WRITE					Write;
+    EFI_DEBUGPORT_IO_RESET					Reset;
+} EFI_DEBUGPORT_IO_INTERFACE;
+
+
+//
+// Debugport UART16550 control protocol {628EA978-4C26-4605-BC02-A42A496917DD}
+//
+
+#define DEBUGPORT_UART16550_CONTROL_PROTOCOL \
+{ 0X628EA978, 0X4C26, 0X4605, 0XBC, 0X2, 0XA4, 0X2A, 0X49, 0X69, 0X17, 0XDD }
+ 
+// Note: The definitions for EFI_PARITY_TYPE, EFI_STOP_BITS_TYPE, and 
+// SERIAL_IO_MODE are included from efiser.h
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_UART16550_SET_ATTRIBUTES) (
+    IN struct _EFI_DEBUGPORT_UART16550_CONTROL_INTERFACE  	*This,
+    IN UINT64                       	BaudRate,
+    IN UINT32                       	ReceiveFifoDepth,
+    IN UINT32                       	Timeout,
+    IN EFI_PARITY_TYPE       			Parity,
+    IN UINT8                        	DataBits,
+    IN EFI_STOP_BITS_TYPE    			StopBits
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_UART16550_SET_CONTROL_BITS) (
+    IN struct _EFI_DEBUGPORT_UART16550_CONTROL_INTERFACE  	*This,
+    IN UINT32                       	Control
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_UART16550_GET_CONTROL_BITS) (
+    IN struct _EFI_DEBUGPORT_UART16550_CONTROL_INTERFACE	*This,
+    OUT UINT32                      	*Control
+    );
+
+#define EFI_DEBUGPORT_UART16550_CONTROL_INTERFACE_REVISION   0x00010000
+
+typedef struct _EFI_DEBUGPORT_UART16550_CONTROL_INTERFACE {
+    UINT32                          	Revision;
+	EFI_UART16550_SET_ATTRIBUTES		SetAttributes;
+	EFI_UART16550_SET_CONTROL_BITS		SetControl;
+	EFI_UART16550_GET_CONTROL_BITS 		GetControl;
+	DEBUGPORT_16550_CONFIG_DATA			*Mode;
+} EFI_DEBUGPORT_UART16550_CONTROL_INTERFACE;
+        
+
+#define DEVICE_PATH_DEBUGPORT DEBUGPORT_IO_PROTOCOL
+        
+#endif /* _EFIDBG_H_ */
diff --git a/linux-x86/gnu-efi/include/efi/protocol/efivar.h b/linux-x86/gnu-efi/include/efi/protocol/efivar.h
new file mode 100644
index 0000000..92dc506
--- /dev/null
+++ b/linux-x86/gnu-efi/include/efi/protocol/efivar.h
@@ -0,0 +1,133 @@
+/*++
+
+Copyright (c) 1998  Intel Corporation
+
+Module Name:
+
+Abstract:
+
+
+
+Revision History
+
+--*/
+
+
+
+//
+// The variable store protocol interface is specific to the reference
+// implementation.  The initialization code adds variable store devices
+// to the system, and the FW connects to the devices to provide the
+// variable store interfaces through these devices.
+//
+
+//
+// Variable Store Device protocol
+//
+
+#define VARIABLE_STORE_PROTOCOL    \
+    { 0xf088cd91, 0xa046, 0x11d2, {0x8e, 0x42, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b} }
+
+INTERFACE_DECL(_EFI_VARIABLE_STORE);
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_STORE_CLEAR) (
+    IN struct _EFI_VARIABLE_STORE   *This,
+    IN UINTN                        BankNo,
+    IN OUT VOID                     *Scratch
+    );
+
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_STORE_READ) (
+    IN struct _EFI_VARIABLE_STORE   *This,
+    IN UINTN                        BankNo,
+    IN UINTN                        Offset,
+    IN UINTN                        BufferSize,
+    OUT VOID                        *Buffer
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_STORE_UPDATE) (
+    IN struct _EFI_VARIABLE_STORE   *This,
+    IN UINTN                        BankNo,
+    IN UINTN                        Offset,
+    IN UINTN                        BufferSize,
+    IN VOID                         *Buffer
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_STORE_SIZE) (
+    IN struct _EFI_VARIABLE_STORE   *This,
+    IN UINTN                        NoBanks
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_TRANSACTION_UPDATE) (
+    IN struct _EFI_VARIABLE_STORE   *This,
+    IN UINTN                        BankNo,
+    IN VOID                         *NewContents
+    );
+
+typedef struct _EFI_VARIABLE_STORE {
+
+    //
+    // Number of banks and bank size
+    //
+
+    UINT32                      Attributes;
+    UINT32                      BankSize;
+    UINT32                      NoBanks;
+
+    //
+    // Functions to access the storage banks
+    //
+
+    EFI_STORE_CLEAR             ClearStore;
+    EFI_STORE_READ              ReadStore;
+    EFI_STORE_UPDATE            UpdateStore;
+    EFI_STORE_SIZE              SizeStore OPTIONAL;
+    EFI_TRANSACTION_UPDATE      TransactionUpdate OPTIONAL;
+
+} EFI_VARIABLE_STORE;
+
+
+//
+//
+// ClearStore()     - A function to clear the requested storage bank.  A cleared
+//      bank contains all "on" bits.
+//
+// ReadStore()      - Read data from the requested store.
+//
+// UpdateStore()    - Updates data on the requested store. The FW will only
+//      ever issue updates to clear bits in the store. Updates must be
+//      performed in LSb to MSb order of the update buffer.
+//
+// SizeStore()      - An optional function for non-runtime stores that can be
+//      dynamically sized.  The FW will only ever increase or decrease the store
+//      by 1 banksize at a time, and it is always adding or removing a bank from 
+//      the end of the store.
+//
+// By default the FW will update variables and storage banks in an
+// "atomic" manner by keeping 1 old copy of the data during an update,
+// and recovering appropiately if the power is lost during the middle
+// of an operation.  To do this the FW needs to have multiple banks
+// of storage dedicated to its use. If that's not possible, the driver 
+// can implement an atomic bank update function and the FW will allow 
+// 1 bank in this case.  (It will allow any number of banks,
+// but it won't require an "extra" bank to provide its bank transaction 
+// function).
+//
+// TransactionUpdate()  - An optional function that can clear & update an 
+//      entire bank in an "atomic" fashion.  If the operation fails in the 
+//      middle the driver is responsible for having either the previous copy 
+//      of the bank's data or the new copy.  A copy that's partially written
+//      is not valid as internal data settings may get lost.  Supply this
+//      function only when needed.
+//
+
diff --git a/linux-x86/gnu-efi/include/efi/protocol/intload.h b/linux-x86/gnu-efi/include/efi/protocol/intload.h
new file mode 100644
index 0000000..fb24e3f
--- /dev/null
+++ b/linux-x86/gnu-efi/include/efi/protocol/intload.h
@@ -0,0 +1,27 @@
+/*++
+
+Copyright (c) 1999 Intel Corporation
+
+Module Name:
+
+    intload
+
+Abstract:
+
+    EFI support for loading internally linked in apps
+
+
+
+Revision History
+
+--*/
+
+#ifndef _INTERNAL_LOAD_INCLUDE_
+#define _INTERNAL_LOAD_INCLUDE_
+
+// {D65A6B8C-71E5-4df0-A909-F0D2992B5AA9}
+#define INTERNAL_SHELL_GUID \
+    { 0xd65a6b8c, 0x71e5, 0x4df0, {0xa9, 0x09, 0xf0, 0xd2, 0x99, 0x2b, 0x5a, 0xa9} }
+
+
+#endif
diff --git a/linux-x86/gnu-efi/include/efi/protocol/legacyboot.h b/linux-x86/gnu-efi/include/efi/protocol/legacyboot.h
new file mode 100644
index 0000000..16e94e7
--- /dev/null
+++ b/linux-x86/gnu-efi/include/efi/protocol/legacyboot.h
@@ -0,0 +1,119 @@
+/*++
+
+Copyright (c) 1999 Intel Corporation
+
+Module Name:
+
+    legacyboot
+
+Abstract:
+
+    EFI support for legacy boot
+
+
+
+Revision History
+
+--*/
+
+#ifndef _LEGACY_BOOT_INCLUDE_
+#define _LEGACY_BOOT_INCLUDE_
+
+#define LEGACY_BOOT_PROTOCOL \
+    { 0x376e5eb2, 0x30e4, 0x11d3, { 0xba, 0xe5, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81 } }
+
+#pragma pack(1)
+
+//
+// BBS 1.01 (See Appendix A) IPL and BCV Table Entry Data structure.
+//  Seg:Off pointers have been converted to EFI pointers in this data structure
+//  This is the structure that also maps to the EFI device path for the boot selection
+//
+typedef struct {
+    UINT16  DeviceType;
+    UINT16  StatusFlag;
+    UINT32  Reserved;
+    VOID    *BootHandler;   // Not an EFI entry point
+    CHAR8   *DescString;
+} BBS_TABLE_ENTRY;
+#pragma pack()
+
+typedef
+EFI_STATUS
+(EFIAPI *LEGACY_BOOT_CALL) (
+    IN EFI_DEVICE_PATH      *DevicePath
+    );
+
+
+//
+// BBS support functions
+//  PnP Call numbers and BiosSelector hidden in implementation
+//
+
+typedef enum {
+    IplRelative,
+    BcvRelative
+} BBS_TYPE;
+
+INTERFACE_DECL(_LEGACY_BOOT_INTERFACE);
+
+//
+// == PnP Function 0x60 then BbsVersion == 0x0101 if this call fails then BbsVersion == 0x0000
+//
+
+//
+// == PnP Function 0x61
+//
+typedef
+EFI_STATUS
+(EFIAPI *GET_DEVICE_COUNT) (
+    IN  struct _LEGACY_BOOT_INTERFACE   *This,
+    IN  BBS_TYPE        *TableType,
+    OUT UINTN           *DeviceCount,
+    OUT UINTN           *MaxCount
+    );
+
+//
+// == PnP Function 0x62
+//
+typedef
+EFI_STATUS
+(EFIAPI *GET_PRIORITY_AND_TABLE) (
+    IN  struct _LEGACY_BOOT_INTERFACE   *This,
+    IN  BBS_TYPE        *TableType,
+    IN OUT  UINTN       *PrioritySize, // MaxCount * sizeof(UINT8)
+    OUT     UINTN       *Priority,
+    IN OUT  UINTN       *TableSize,    // MaxCount * sizeof(BBS_TABLE_ENTRY)
+    OUT BBS_TABLE_ENTRY *TableEntrySize
+    );
+
+//
+// == PnP Function 0x63
+//
+typedef
+EFI_STATUS
+(EFIAPI *SET_PRIORITY) (
+    IN  struct _LEGACY_BOOT_INTERFACE   *This,
+    IN  BBS_TYPE        *TableType,
+    IN OUT  UINTN       *PrioritySize,
+    OUT     UINTN       *Priority
+    );
+
+typedef struct _LEGACY_BOOT_INTERFACE {
+    LEGACY_BOOT_CALL    BootIt;
+
+    //
+    // New functions to allow BBS booting to be configured from EFI
+    //
+    UINTN                   BbsVersion;     // Currently 0x0101
+    GET_DEVICE_COUNT        GetDeviceCount;
+    GET_PRIORITY_AND_TABLE  GetPriorityAndTable;
+    SET_PRIORITY            SetPriority;   
+} LEGACY_BOOT_INTERFACE;
+
+EFI_STATUS
+PlInitializeLegacyBoot (
+    VOID
+    );
+
+#endif
diff --git a/linux-x86/gnu-efi/include/efi/protocol/piflash64.h b/linux-x86/gnu-efi/include/efi/protocol/piflash64.h
new file mode 100644
index 0000000..d521dfc
--- /dev/null
+++ b/linux-x86/gnu-efi/include/efi/protocol/piflash64.h
@@ -0,0 +1,121 @@
+#ifndef _PIFLASH64_H
+#define _PIFLASH64_H
+
+/*++
+
+Copyright (c) 1999  Intel Corporation
+
+Module Name:
+
+    PIflash64.h
+    
+Abstract:
+
+    Iflash64.efi protocol to abstract iflash from
+    the system.
+
+Revision History
+
+--*/
+
+//
+// Guid that identifies the IFLASH protocol
+//
+#define IFLASH64_PROTOCOL_PROTOCOL \
+    { 0x65cba110, 0x74ab, 0x11d3, 0xbb, 0x89, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81 };
+
+//
+// Unlock FLASH from StartAddress to EndAddress and return a LockKey
+//
+typedef
+EFI_STATUS
+(EFIAPI *UNLOCK_FLASH_API)(
+    IN struct _IFLASH64_PROTOCOL_INTERFACE  *This
+    );
+
+//
+// Lock the flash represented by the LockKey
+//
+typedef
+EFI_STATUS
+(EFIAPI *LOCK_FLASH_API)(
+    IN struct _IFLASH64_PROTOCOL_INTERFACE  *This
+    );
+
+//
+// Status callback for a utility like IFLASH64
+//
+//  Token would map to a list like Ted proposed. The utility has no idea what 
+//      happens on the other side.
+//  ErrorStatus - Level of Error or success. Independent of Token. If you 
+//      don't know the token you will at least know pass or fail.
+//  String - Optional extra information about the error. Could be used for 
+//      debug or future expansion
+//
+//  Attributes - Options screen attributes for String. Could allow the string to be different colors.
+//
+typedef
+EFI_STATUS
+(EFIAPI *UTILITY_PROGRESS_API)(
+    IN struct _IFLASH64_PROTOCOL_INTERFACE  *This,
+    IN  UINTN                               Token,
+    IN  EFI_STATUS                          ErrorStatus, 
+    IN  CHAR16                              *String,    OPTIONAL
+    IN  UINTN                               *Attributes OPTIONAL
+    );
+
+//
+// Token Values
+//
+// IFlash64 Token Codes
+#define IFLASH_TOKEN_IFLASHSTART    0xB0                // IFlash64 has started
+#define IFLASH_TOKEN_READINGFILE    0xB1                // Reading File
+#define IFLASH_TOKEN_INITVPP        0xB2                // Initializing Vpp
+#define IFLASH_TOKEN_DISABLEVPP     0x10                // Disable Vpp
+#define IFLASH_TOKEN_FLASHUNLOCK    0xB3                // Unlocking FLASH Devices
+#define IFLASH_TOKEN_FLASHERASE     0xB4                // Erasing FLASH Devices
+#define IFLASH_TOKEN_FLASHPROGRAM   0xB5                // Programming FLASH
+#define IFLASH_TOKEN_FLASHVERIFY    0xB6                // Verifying FLASH
+#define IFLASH_TOKEN_UPDATESUCCES   0xB7                // FLASH Updage Success!
+
+#define IFLASH_TOKEN_PROGRESS_READINGFILE   0x11        // % Reading File
+#define IFLASH_TOKEN_PROGRESS_FLASHUNLOCK   0x13        // % Unlocking FLASH Devices
+#define IFLASH_TOKEN_PROGRESS_FLASHERASE    0x14        // % Erasing FLASH Devices
+#define IFLASH_TOKEN_PROGRESS_FLASHPROGRAM  0x15        // % Programming FLASH
+#define IFLASH_TOKEN_PROGRESS_FLASHVERIFY   0x16        // % Verifying FLASH
+
+#define IFLASH_TOKEN_READINGFILE_ER 0xB8                // File Read Error
+#define IFLASH_TOKEN_INITVPP_ER     0xB9                // Initialization of IFB Error
+#define IFLASH_TOKEN_FLASHUNLOCK_ER 0xBA                // FLASH Unlock Error
+#define IFLASH_TOKEN_FLASHERASE_ER  0xBB                // FLASH Erase Error
+#define IFLASH_TOKEN_FLASHVERIFY_ER 0xBC                // FLASH Verify Error
+#define IFLASH_TOKEN_FLASHPROG_ER   0xBD                // FLASH Program Error
+
+#define IFLASH_TABLE_END            0x00
+
+//
+// If this number changes one of the existing API's has changes
+//
+#define IFLASH_PI_MAJOR_VERSION 0x01
+
+//
+// This number changes when new APIs or data variables get added to the end
+//  of the data structure
+//
+#define IFLASH_PI_MINOR_VERSION 0x01
+
+typedef struct _IFLASH64_PROTOCOL_INTERFACE {
+    UINT32                  MajorVersion;       
+    UINT32                  MinorVersion;   
+    UNLOCK_FLASH_API        UnlockFlash;
+    LOCK_FLASH_API          LockFlash;
+    UTILITY_PROGRESS_API    Progress;
+    
+    //
+    // Future expansion goes here
+    //
+
+} IFLASH64_PROTOCOL_INTERFACE;
+
+
+#endif
diff --git a/linux-x86/gnu-efi/include/efi/protocol/vgaclass.h b/linux-x86/gnu-efi/include/efi/protocol/vgaclass.h
new file mode 100644
index 0000000..d0deb5c
--- /dev/null
+++ b/linux-x86/gnu-efi/include/efi/protocol/vgaclass.h
@@ -0,0 +1,95 @@
+#ifndef _VGA_CLASS_H
+#define _VGA_CLASS_H
+
+/*++
+
+Copyright (c) 1999  Intel Corporation
+
+Module Name:
+
+    VgaClass.h
+    
+Abstract:
+
+    Vga Mini port binding to Vga Class protocol
+
+
+
+Revision History
+
+--*/
+
+//
+// VGA Device Structure
+//
+
+// {0E3D6310-6FE4-11d3-BB81-0080C73C8881}
+#define VGA_CLASS_DRIVER_PROTOCOL \
+    { 0xe3d6310, 0x6fe4, 0x11d3, {0xbb, 0x81, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81} }
+
+typedef 
+EFI_STATUS 
+(* INIT_VGA_CARD) (
+    IN  UINTN   VgaMode,
+    IN  VOID    *Context
+    );
+
+typedef struct {
+    UINTN   MaxColumns;
+    UINTN   MaxRows;
+} MAX_CONSOLE_GEOMETRY;
+
+#define VGA_CON_OUT_DEV_SIGNATURE   EFI_SIGNATURE_32('c','v','g','a')
+typedef struct {
+    UINTN                           Signature;
+
+    EFI_HANDLE                      Handle;
+    SIMPLE_TEXT_OUTPUT_INTERFACE    ConOut;
+    SIMPLE_TEXT_OUTPUT_MODE         ConOutMode;
+    EFI_DEVICE_PATH                 *DevicePath;
+
+    UINT8                           *Buffer;
+    EFI_DEVICE_IO_INTERFACE         *DeviceIo;
+
+    //
+    // Video Card Context
+    //
+    INIT_VGA_CARD                   InitVgaCard;
+    VOID                            *VgaCardContext;
+    MAX_CONSOLE_GEOMETRY            *Geometry;
+    //
+    // Video buffer normally 0xb8000
+    //
+    UINT64                          VideoBuffer;
+
+    //
+    // Clear Screen & Default Attribute
+    //
+    UINT32                          Attribute;
+
+    //
+    // -1 means search for active VGA device
+    //
+    EFI_PCI_ADDRESS_UNION           Pci;
+} VGA_CON_OUT_DEV;
+
+#define VGA_CON_OUT_DEV_FROM_THIS(a) CR(a, VGA_CON_OUT_DEV, ConOut, VGA_CON_OUT_DEV_SIGNATURE)
+
+//
+// Vga Class Driver Protocol. 
+// GUID defined in EFI Lib
+//
+
+typedef 
+EFI_STATUS
+(EFIAPI *INSTALL_VGA_DRIVER) (
+    IN  VGA_CON_OUT_DEV    *ConOutDev 
+    );
+
+typedef struct {
+    UINT32               Version;
+    INSTALL_VGA_DRIVER   InstallGenericVgaDriver;
+} INSTALL_VGA_DRIVER_INTERFACE;
+
+#endif
+
diff --git a/linux-x86/gnu-efi/include/efi/romload.h b/linux-x86/gnu-efi/include/efi/romload.h
new file mode 100644
index 0000000..0506011
--- /dev/null
+++ b/linux-x86/gnu-efi/include/efi/romload.h
@@ -0,0 +1,41 @@
+#ifndef _EFI_ROMLOAD_H
+#define _EFI_ROMLOAD_H
+
+#define ROM_SIGNATURE 0xaa55
+#define PCIDS_SIGNATURE "PCIR"
+#pragma pack(push)
+#pragma pack(1)
+typedef struct 
+{
+    UINT8    Pcids_Sig[4];
+    UINT16  VendId;
+    UINT16  DevId;
+    UINT16  Vpd_Off;
+    UINT16  Size;
+    UINT8 Rev;
+    UINT8 Class_Code[3];
+    UINT16  Image_Len;
+    UINT16  Rev_Lvl;
+    UINT8 Code_Type;
+    UINT8 Indi;
+    UINT16  Rsvd;
+}PciDataStructure;
+typedef struct
+{
+    UINT16 Size;
+    UINT32 Header_Sig;
+    UINT16 SubSystem;
+    UINT16 MachineType;
+    UINT8  Resvd[10];
+    UINT16 EfiOffset;
+}ArchData;
+typedef struct 
+{
+    UINT16 Rom_Sig;
+    ArchData Arch_Data;
+    UINT16 Pcids_Off;
+    UINT8 resvd[38];
+}RomHeader;
+#pragma pack(pop)
+
+#endif
diff --git a/linux-x86/gnu-efi/lib/crt0-efi-ia32.o b/linux-x86/gnu-efi/lib/crt0-efi-ia32.o
new file mode 100644
index 0000000000000000000000000000000000000000..bea9af3545fea37ccefe1a82a58ad74346508402
GIT binary patch
literal 868
zcma)4%Syvg5S_G*tyMwAg&?RKQ51rLD|O);3MzsKN`;WxXbVOmxq)^iE?o3){DeYR
zeu&VI5aKy$ZktvY4$M90%*>rkr}y>b?9?y}(Pl_i21?{3No>csCPm51b?Yk%C!?^?
zW$>oeF>}DTP7&wTW%oOZqH_7Y9hx!y?68W)Jj@E3o^mQc<@d0rneRSX%55mIs*ZBR
zssw>p48mXTd)NPWE}@LSV=O7>{F@0UaAMj5d^~2oV=pVR3|fHmKI_O=5{-0hRh+s9
z1DbDuvtHNLm`s_j<2>m-vo6_BT+JN&aOU)UcWBHw-Gs9r`3zit6I6WoE=gkgTf~eG
z0{0=>Kz<_+XTRx0r~9$_4&vH$Kdt}5;g`huhB`v!;vHE1%SJpyU;e5$WonSboQBK|
zX_3Vdy*i?|MzmONqpqYHdR|lPKsmmWlIJ|Shfd&%eSCXya9%nRJAQzUa>ae9+n!T@
bMxR-D2Fsr(Vu5^f8T^Us#0eZQ1N;2}jT=ZD

literal 0
HcmV?d00001

diff --git a/linux-x86/gnu-efi/lib/elf_ia32_efi.lds b/linux-x86/gnu-efi/lib/elf_ia32_efi.lds
new file mode 100644
index 0000000..975e36c
--- /dev/null
+++ b/linux-x86/gnu-efi/lib/elf_ia32_efi.lds
@@ -0,0 +1,75 @@
+OUTPUT_FORMAT("elf32-i386", "elf32-i386", "elf32-i386")
+OUTPUT_ARCH(i386)
+ENTRY(_start)
+SECTIONS
+{
+  . = 0;
+  ImageBase = .;
+  .hash : { *(.hash) }	/* this MUST come first! */
+  . = ALIGN(4096);
+  .text :
+  {
+   *(.text)
+   *(.text.*)
+   *(.gnu.linkonce.t.*)
+  }
+  . = ALIGN(4096);
+  .sdata :
+  {
+   *(.got.plt)
+   *(.got)
+   *(.srodata)
+   *(.sdata)
+   *(.sbss)
+   *(.scommon)
+  }
+  . = ALIGN(4096);
+  .data :
+  {
+   *(.rodata*)
+   *(.data)
+   *(.data1)
+   *(.data.*)
+   *(.sdata)
+   *(.got.plt)
+   *(.got)
+   /* the EFI loader doesn't seem to like a .bss section, so we stick
+      it all into .data: */
+   *(.sbss)
+   *(.scommon)
+   *(.dynbss)
+   *(.bss)
+   *(COMMON)
+  }
+  . = ALIGN(4096);
+  .dynamic  : { *(.dynamic) }
+  . = ALIGN(4096);
+  .rel :
+  {
+    *(.rel.data)
+    *(.rel.data.*)
+    *(.rel.got)
+    *(.rel.stab)
+    *(.data.rel.ro.local)
+    *(.data.rel.local)
+    *(.data.rel.ro)
+    *(.data.rel*)
+  }
+  . = ALIGN(4096);
+  .reloc :		/* This is the PECOFF .reloc section! */
+  {
+    *(.reloc)
+  }
+  . = ALIGN(4096);
+  .dynsym   : { *(.dynsym) }
+  . = ALIGN(4096);
+  .dynstr   : { *(.dynstr) }
+  . = ALIGN(4096);
+  /DISCARD/ :
+  {
+    *(.rel.reloc)
+    *(.eh_frame)
+    *(.note.GNU-stack)
+  }
+  .comment 0 : { *(.comment) }
+}
diff --git a/linux-x86/gnu-efi/lib/libefi.a b/linux-x86/gnu-efi/lib/libefi.a
new file mode 100644
index 0000000000000000000000000000000000000000..d6e9d08c67ac203a157983fa1fa9857aa6f88534
GIT binary patch
literal 89186
zcmeEv3w%`7wf>pO00CkqXr!@59c`jP0wx$~(5QKlhYc|10aU4El1#|Jkcr8Jhour6
zf=tJ>vDjYP+ge&}tF5<1#enz<uSBg@M10j3^->E)E2Y+=ZO#At_SyT)$;m|EUhcoQ
zzu(=-nRV7)Yp=cb<Ltf9+K+R7o~O0G>8f#;xQ4pyOE3H4jGUaDOQ*YBS%PH#b-8k8
zT&8=tYR74s_IFJ?<9oxe&wr$8>bhXDrkSscM{C+h*L1t4{i|Pv?`RsYvRnRlUthgg
z)6})@B~3G5-)z=2>-FQEns%bsR)mjrJ%KpQ*VFH6n)%xMiKd;(>s`e6|M{{_oTv@C
z&VN(0o$Bk-?V3$pmm@ywb@c<9?X#}ZZ)i4k&Hk}wi*;3=tJ!KEw_X*#y7IQU9>1@l
z+PflH+UjX(^3}I#3m5vP=T4ux$QxYPQok_R)ZV;gYTXL0rrB2?Xz*4C-1P;`ZN53J
z1#R^{pC%;?L1s4kikgG|q9#wPhDb`i!K$TozCc@5u+`VRXsFl9wxD-uX}hnXpt+&S
z+v@Z9XSXk{^R|wp#+>$GOM7r6YI%7xsrqk`$6w#>_XNE~t@R@XD5@-~_SE^kT2Yg?
zehC;0{J|>UO;KE{@&--bI;K^5{8d785t!<0RkI4q=Tt@Ug8CL;6r0u37DZ~Bmox{K
zHy3-C`RctIa?9;$4OXvg@m6>jdFofrs%sSzO$0qMviX9(K(ipv4Q6L$xmyFlKz+ck
z>7`<z1r45-ptrTyTi3qG@Ki;t=b_=v(l2kWYVrFJ!tkBh+8SsDr`4a_F}&w4@)Y?!
zZEZ$)JuQWSK+y1->p}S<v#WxER<Ge(-i&CQk)cgqzu)jJ@qtfd@!WvFeW|y?Q|I-U
zH#Y{fC`F*9-ey#rdio07UGFOo7-DLC#_eoxaCxA0iHNSzQ|~Qr@HPj1jXqPF-7CDP
zH2ykI{SqS>{0cp7-Xhd}!>`J>w8ih00;9g7`kEuxADN<nAGHw0W^n2yZ{n;7cp8`j
zgCm+q!>icWw!{>q&>yHb<FZ@~cD+;$lreZ4%9nZ;MI+JGaC?GH2HWg*zh70pQh%V%
z<5z{I&1`NcZ*B{En(MvMfb=zCl_+i#D%%Vr%lYV61>5U}`MU!Fe}Nw<68XeOK`X4%
zs;U{Fycu=g<HtkUpcU6GDrjr-wvN~UEJW-~&}<Z!e9T6A^cAZqU7GSMY-_{6fzI+a
z_&i1)DJD^1h|6FrDz2O}%fM>zv>FJirmxvo=xJ_<dbyWPHzPR)GRsq6(9nP;P$s5)
z+8pD)rmfDn&%Sg<G*F4JuGMRhs_NT(22v38v_!F@Ky$DaRg!J2j9`{`=`2r+fx7GK
zJ*`ni@kAM<G7ySeeaoUTv7Ix>bG^+CfmSVA1xi{2OUsaIw6IZ6RgGeJ6$RRxgC>8`
z78kdpZ9>&B*Smt27Q_{mDVhZnYNfM6pbu-oqx~6NhGwXDQMT$pv<91f(VtOO);H0(
zv$oFi1nZlkOl|awp}!GPRnQY`Z>tW-zHx-kS2V_Kf{b{ITD`~+RVQZ$(2}j3xeP7Z
zNY#Cw#}_OKv{s=9_Iq_s=_QbPJ|x1o)Ef}pr+VT<Q&1FG+Tv;Tiu)1tBh5$ykqTd1
zkV&uLBkh$nV1&R1n@Wu}VBt!(eO10i&B!ZMas-%z(r07Cd!y->_j<P>I)foT){X>3
zQ4G;u$0%k|Y-pv}-i<`A^o~r9wpn^3S{~4=#7Kox>Gd?Y186ViwW1RicfzaQho`mC
zw@CUMXjHyzN~_viS{QzWES_0XE`|a|V;&WNT)=oq6*$UkiB?d5W4o`_EAB@SSn2h9
z(JSigdczI1F%B7lzogZx)35Wk2GHDSvbFaT7XdM{qJL4KWhEh!Zx$=-AStD-f#rqm
zjg4r(pgVj5tt;7j0l`R9rI5o(j^l><5-o=6L9gPY4{8Crl<GjW$LF8Z$RW#|)&__d
zW8+zcm3YYOeM>$5V4$$5Si==WaS9(PUaxU_QMI?~eV7<k>ao}O)YDz%#t3-CQd-E2
z&^gN6_~b|=R-V?cK%-l?2qQ7gT~bj~Ri?SCW>yzeS66CocTIJX<}RJd-}362vzU-}
zjNHq-D>Pmbl}hocH=bRkpwzQmhXqn80SYj_)^UZ-HKCeFM3D!hKBm;Ti6#wN>$Kwb
zr7cv4&$2$EVx8yHJW?$p-NISq543qLen?o+QgmmrUt~aSCK+YJu?TZvC|a?+wWg(2
zQv^Wx5S6|~Eh~v3X#^GCW&%;!0FAa@YYVpez0DrNdNiPf&EjT7FyPY)_%q8J^oR~a
zDMJsR?qj;G44%jn88knWl|l8ORR-mgRT(s%E!>GFT|8(C5$!v;^~}?6kW&2yX&oUu
z1)Z57ZbUXz28TQ&l^7D5o}bDfa(-qrpO3k|)?mBGkEgc<-O`A!p47Z~86Hv9t5jl;
zfLdGWZR49nwY!4(r#wBrHj9^N`uL=%W{~V9%SGdl(X3WkZEgX5b#4sT8w0INwTh}H
zUt_RldX83U+|6qD(`Ut{)3jpWGI=*b-qZzFG_-n_PYp=ZoMDm6ak=pF2J4&gJAFF+
za;M>!u6Eq&nH42An+=9J-PyD_EsAMcR-EpiBS40hsErqNnB;^Dy_e+NT9K9<PE9-X
z_rbxzHM?Mt)55_tM<ke*8h(1s+uER}t@%VdAHJ*7;v=ilQo{bUg!Yoi1`5dTb#A@5
zvGe`l`HeFUx1TX^b=Q^)=^xtZXq>U5u{$``xwX*I*xB3uek3&wG98c*AAy9>?xbCf
z-Pyg6ovvxY%>!?B1uxV(2ZN)XJ%#r5V>&<D#)Jf)boNxnt)Dp1+fBN2YjK(*bjZ~h
zI=0aHo!(u}t<`Cc#?UA6!E+ir_XSgMdz$l(UVw4VJ9duUyG!aLWbLA67MH$ziaq_o
zRSD_8y(B69i3Q2&y$e#(U%ezXeb=hA^ewA0(|1nJN#8L!FMZEsclxtau1(**sxtk>
zORCaex}-Y&sY`0ow=I~PzIDO8^hXxVPv5`b%jqvHxGw$41=puPe#wIL$1eFw`lFZJ
zklwdyVS4|n+Vp2udD0(RRhQngsy_YURSoISPxhwoo7|ZG>&c7KpPSs2zIU=O{prbz
z(_fjqB>m;d{`B8WUZ4Kj#kZ$#p8P=ixi@T2PrB;S^z)YOPM?r>`}rw1Y&id{WlRk+
zc9&LKRCKv3qoxjZzWtI4U$dt*;L4dged?uCvfG8{Ws`JV(~@Nt*lw!SY^&mJXD2uu
z>yg(P@K2SrUl0~0CYOaqRjqT(y)~|+({3*sm+08j-?yu1yp{xV8LrK^cuz;T09P-r
zskrFq*COsT%^{&SwQc3npr;Nn*s8-Ob=T_kPYuF$piOP?1U=f+I=o*AkEtU(JX7lf
zOP6v$JGD6w^iD0ET{8uvF$_<pQk1u8VPmUjsaKo2s5Q{86j6G71`L8W!9?ft6OSta
z*LYk^3$OEVv6`yqDIfQL#HAe5Pj@!1vEokuIfMWyxTQQkag;^*coc*@`Pgdt5WX9J
z%DLptWI*yOJ_m)E9Ocnv;S%~uI{6fhbkgW%;o?2{>Egl1IFuue*IWse|D~3AmAu80
zPmyzQ)1d+ZDjgbeZ_XEOjHbEZ$9$nb`It_Yg-R=KwJnhMRo+Oa;w4mZl2khiKkz&a
zU>q*WW0_F4Szay5V;%gIQ}Pt9pxNJ{{RwSj)Wr>nnetUCb)Gnl%0yk9QEPO+IFV8_
zeMrtg9x}(|*wV8u()|M0>4^UVf$2Y|+ed3NOgPg$N8-ByCqO^u|7KjIF?<_fFD^d6
z#5L79)w4G|2}AJ0(uz5S1r-bDl$2n^xv;vRuwv%I|EhUdJ|{@*>CkH&Dn}k*917J1
zXos2=64pw{=hu$xZWAVDqib~?zi-XSWzTvdeXFWKY#Z2mTKm>{*}Zeo+a)-+2Gf!v
zpKI*=$k}s^Etv1@*<st;82Z!}yv*4XznxV|^lfXO3MR0R3-#JMa<%qj&Ym(G{LTpN
zv^CCnsr5|w1Gc|%!@^ymUVC^<b}#P4Pgf5$sF^qS@kCAQs515Bq4zSoiqU1G*NlY7
z6n5wxeP{2AhDb$PO7=(2tpyV!*QPkP9<#lSjyhbOmKrSY@~5Q^oTba{xXG5XyfD;<
z*l(P;EHeUzj>~PqL;Vmsh$kSNsf)Z~Ra)w@(<oH(F5jR1QD}E&_{jA)Ed0u@?nrT3
zerRWW_D6`qfxz*sbV?r(Q=L8eW2h-KPBr|i(~86Ps1yV_RsCHqWU2m+?Uh!L7=Nq1
zC^2DOoV{jTVtijgqNBfHeA&3Z#Q1{#L`T8+B6+82Zm`eC)q?ByxEQw6UXYk@Yg|EM
z(mF>;VsdEI?8JQgnsJHAMTtqfK!UvZe#qQYIR0jM?n+E5=u1q1<oJR;iD)XA9rsZd
zoY8Xpi}#gm$C(yhvHHpyQ-jL%)5Yp5Syq(Aww<zK^_3e<vcO{GA^S0NUpW$A7WgP)
zG$Vl{pHU9Lm3V7k`F#)=hjQfOW$i2bl>o`8P-|cLBnXcxVSq{pw$<hy!G-QXjUhg(
zuUw1toJe1ph4wNDaUZX*%pa|3KQrm4(qZxvw`TwU4Sgm1e>&zj`?hlc)$>cdh(zhw
zcV4FuK-Nw2Do4CSA%MhxXu(zIBf8F0I=vaYbG6PbqQhpaVtOow)k(eQYd1k}J07kM
zz;P)2+X3Uyk$e}>;ncME2$6Y{P@oPZw15z}3;yhTIp!zaOo%#EA82k1_`OD_d;C5(
z_k{c01UYC^eXbL&0_&L?84d0GQqWhq^nNd*Me;M*@t|WFbUQ-3Q?B3DwTyjcRp`Au
z^gi=Vy(ZpMt2=vxi3sjyhZIgu8?1D6MG%peJ&3+BGhC6D%D$R?Abr`L5k^YlRnLXj
zWJfqBZE&sweQkg*u2b>WdRnjnzvF^8;5R;)i{JB>ZAUz{p?7UFUT*spy3Yk&$ty$s
zw#Kl%vEQ*0T_m&?ng}fhZj<lHYvGp~`oM+|ZjrErw83i~hZo~5zOkEP^w6Q*d7}H(
z`|_drlK~OADt{m&33v`*0$>(ke8inb(abtIZV2tpxPBMgQ<rE{PgP&cepvOzQ<#zH
zD?|3#iLM3c9TOe9*#76?%EI+7E^B{V!2Y%<(QSV-F&Q23knWapSKxA?qLj$6l%3VC
z%jUDYk^XS1tv%^?)YgFh!pfJ||IhELtDtwRcU89I$LoI^`S3``e4vZf|IUX$<*{pI
z9>wZ^?=i^&i;<Vs{&yrkmMujv4m$FQhe}5cf7S)^seXDh5To2AjX`SUJ>}AE0bi_s
z`UcP_Pr0|u2s{<qD({tk2SB(-1p-t$G~?dfPv@g?a>0-Jhi22rKkGZ~dI%O{bnwur
zcnMXU^lv~L>w+hmXu}r4vSXaGdBmNjtwldwC+_qgCC}s~Zq5FuzMobtvmR^Qkes2u
z%#o-Y{tg^{$7Q>~ewy!q%AIZ>qfJr>AoJmB3tkAEb%5;#!<Sp=3xG2}**1`FbYS%w
z%)y_rj%b8#7<S@vvA{^qoSG+7b%I`=>~mSa+2@`K$Uc{C9Q~;?{aH81qP%YfWZ!!M
z^dvn4ko3y{8SX29?5kbiV_%#vA=?Jx-zP+UsBf(|`enZ59<Oh{G%M?b`)0Q+YSlN#
zdLOPr&ysBJX)Dr_V7E<=JOTx^ZRooOyTg6cY@r>t9e<2>_Vh*^w`Lzf-`IZmuY1vt
z?PBNG_2@<94!xI}-3xhX;RWcqD$-mgxv*d-qZiNU+y|?5N-%!L)5}sip9&^N$VwV~
zL%UOjxX8^({Uxk88oFzCcS271<|M^Dqo3?BD~k}zRQwn?q+sBnzx+zWIfem|`~>m3
zU7Y5McA6M%bVFZgnv5V8O;eyznn?wWDRdP|r~=a=bd~W92@F=oXLQbphY1<ceJ5+o
z@=Q<SAGcpS_Pb~8UOMKRA1-dW>?iey@A`JbozvF8mU#EJ*H@l<_{9V3U)}d_lPh}0
zKDO%qo5xJq_J`Zgd7`@^Y3n&hU7Ht|-T3gI-z<21?br7I_VWV=-&lI>L;FAM?|dON
zcccG|-g}lb-1KqXKi+%F`}H{sY{{?sN7vV1>HOp`r^R<Y>1w{>h9qCb!GhWsTW?(S
z<L3{?<(2MteCZ#Zr|nzv(72y`a?eAT`8PgL_|j94yq5p*qxb!%|CMR&3*MUf+-Wbp
z{^cv5|HXY-uU>e$_U5%6*S`GZM9<zQ9{O<0`Cr)m;N0(id;4?FpFFnh&TaOL`1PX}
zKJaQnU)tgE_uslIaLI&<run}($Ft+gDUChd1+Om~edBAkM_v0iUYzve2jR~9Z#?gz
zp3y%!_{0w{-M{V7kDnT|BIjex`Hg$VekWyP;_n_gZSm?US1yhJH-E$JwgvU?e0c4W
zC0Oc|`bw6!bGBA@^!;y-_J8#!wzGG97=O#W-Oj)Cy}H@!KD_nxcegzrS+)M*zrS_P
z8+GMVetYJhSG{nXw_^X_=6fEP^_y!Sx;&^ode_@okL)k_$y?XF{Own+T)O-DyZ`p#
zOD`-w>?`{FtIatj>lgjU-fgwNZJXjK{{1;|moBUr_w%P#o%TlFjicN@FR)*flr;YF
zb*_Y`(jRJ?_h4thHFkgF!#_Oe`Ay=-Z{D!+saGdmuyOC^E%&_K|G6t4{PLR9woJWZ
z!DCzh!@s@P725WG&x22VFX8Q;xbN+|KRBcG#dm+TeBTewyzn(gXyWT_r;o4y&$U-H
z+;P?7rKjC<-Qt_ZKbLs$2ZLibT=YwA-2Hcs`C9P?=aGGP#oyX=)OPNtJ4gGzGOzBh
zzh30+xN*AwtUrui(!A{K{huC~{6hG;n|_=0%r$Q;3cU63#~*+2_&16k-}<>1zp=UY
z&|NRRbn}Mif3$n&E4h_N-<tEMMUOncXx^hgePi@PSAS{x17*LReA+7&XOH{UN7uwn
zuf54pu<L``w`$&6bk7IhXwF{wxUb~42R*<3e5mo!P5T1r)8B5Y{PyyMXW~l7Kl1QI
z`vsR=II8CHE4J^+82{J<-@0zgWXIwM7yNAS<(=8j?R_Y6=c}3L{PNA~H}7ot_Y05K
zzxVyS7PpVvu+)C<=&|3wdV1nO=b|yKXUx+^-Ez$n-%h@1+uOgKeE(N-&+bY1_iya`
z)@hHw`1`FNyuRxEw_Y2+f8Pu13g6!Ur(+Mk(bOFJ?Rn2me0<II7e4&a@0M>4EHB-f
z^3HYf>suB(2cN!TbmM~Ywh4oGdcW!WW!<qC2A6ndKIfmf;_Y#p{<!b7m#agL**hPM
zo8h@|(a-)mv3BpQQeXLN%bTydX7TgCeEqtYUTqxzR{oJIUio6xFCV>k&z+CFx%#;W
zN)Hb{l$Cn)vB$o?bNka-8y>9s>0MjWMor(leZ%ONpPe-C&FUu>z50czH#I)E?HbQ+
z``JxjxnpwR;x9fve#?)(k+AFRw?<vp^?`lLsT!+ipmj-=EzC^9sND=h?~vnbi3u2g
z>*h1^mf>>a5|dR$iLTipN7cHxvRm!*FrS3!q?zNF?&^bmjWTJs-HYoIT>3iz0{HZC
zI_Y=NAAMauAxLGRxT<w_Pokr5m(Xboyz@a99fWv?0Fx&=&fm{)aB8e}(&PMp!uXzf
z5^H?VvHf_N7N#ebeQgo)LOIdJ0kMwnQy_%zN0f)5f-yc#$326qF=a0iBjYs91(eP@
zzVF3&#q3m&EO=6c8n=^A(a294-7H+ZCqLb8@WmRpTkUHfSmIUk7DEQ_nKrs3;5(?_
zieIHeBQW#0y&L&L9hfilCm+Xa)^YoOjH^z>zSaRDE+~RwoADmNGNEjh$GFutVMxsK
zP)?;o;R>4lPyM)^DUG_}<90dNlPsKzQa&@`$8mIWG`L24nz;;_?gB+e#&Ry|8sKhR
zY$q6=_P4#b*cK442V_C!OZ-N_eBgZ6^>I4}xAj;|bo>SVu}ALz#by2|F3pa*!ZdMi
z>Rdq1P1Q;NCh7lkK-$e-mHux@|BvX8F?<5jLOG`cQqB}W@|R2hInw_I`Xe$I<)Bhm
zNXR-ve4~WhBz%Psb)E(a^WguuWB+M6#?G(ftuv{X6*vcRaV~5;o|I`*elW0p$_o>|
zH&N@p=;|G_vMqR)1;50C@A)MAx!F7SP3Ziyw&|&>p1PvokF)H5xb%eyKk#Ys{cHaG
z!;H3zcbs=@--PX7(&^sXpT2e07Q{D2kFTn9$AQN`-Z$ZU2|B)}>DVokGxkq-^lMs2
zf8P2vZ{Azj{rVSjuldg3ZhCWX$F+;yd+z%9q17);cw`gg`C6}-(Y^i1pPFtc{Q2rv
zfBx~=xBO^R)+=*wx;aWus=qSvU;y|UUETvXG=K46)(aE1|6a#$e|G(ml1=+2e4|j8
zciWQdUi$rwM`qnS_Q<~PPQLEm7hW!XZOy09_cC3-4bAh$UcD6jGj#rMS#a%vzf^2%
z`bou|?>%tU)o%Ou)~tME+C@{4o`@dbvjv^MtNCl&oNskC<b8eR1C!2w`YUN){o4x@
zzG>6t#l5pTF5|vv{yaQw<B!r!c;LD8NA~~8$gh8_ezx<RD?c>wSrc|G{?)Fv&@WGy
zcYD@*b1S|L{AwM);QHC$`Eo;4{~NE(`OWz4z~|`n^DXq9%Y(W7z9|0=3;v_*v#+l+
z$-mu_AD*`kMxNfVZ^F+{(++Hmn|#}9n?qYYs9&m07u9j3pOaWK^BL1{!<MUX;fZ+G
zaHEa5K4m1OhWoR>#v^a67SNxuD4$B}`I1ldCFJWsd!U@+V|&TgUGZ@(g?W6T__Dym
zc+Gq+;L0h!On8|4%?`9(8PbnDycpl*xG0Zu>GmUDbDuyOuObNngc~%afga?cv-ZQ}
ztI|p0SMd>=MI@jt>_wv3Zc{Jn$F|$r4?hFq11j;LD|xsb;>`ZT`(ZPcd1=;!xG4fi
z9lmBn^{RT5Tr)zQ>8SGr$YcHBy~3HNE)&i*AXz4ycCLIAUX6RV315o)S`&U7?psXw
z_i*1~!tcd>w+Vk7_nS=ki@4ux!Uu5QYr^A@MSD&7=YbzE;gf+MG2vGMXJI4(F#XlM
zH{pwM?=s<Qai3+vH{d?sgx`gGw+X)=_q8VcQQWtfaN37EO!%L1-)+Ljpolk_@N<A~
zHsMo&_nPoh;CoH@eBcL6xDWUd6TS*Kl5M0v!g~|`@3?oF@L%9Q%Y<*oeZC3*4es40
z{CBvg)AKh@dlz`EiT-!ox8UM)!~8!TRXAwEUBFkE@JnPB*ZCb<K5*XieU9V4`H~J)
z#JR|Vue9J_2hKcD@&5og?{)m>;3f-x7jUKpS%~<6h{n18|F&li+qL<B+cU9|m%EEi
zJ1FJWng83K$ql&N5vz6~4BMWG^#(DvN|<&iL>c7f32yh0TYRwbb>t15cyQrt7|`$;
zw_T?9+qUWYySeR)^7#gA;8teSOV07$ak4M{BF?>_JN{aFuJfVO$6p!Ru(b!F_cCDI
z&oxa$^gGfJpab&(NucBaCIDsu#&?A%i!%j+f8bLseP%&b)y&FjS4ly6#mwT%UFn{T
z^oB`<>9fb3^s+bO{oA_EI|cD7`<<98lXkK!__LkN#YM-w7Va|!zcJTq|BKFrTjvd#
zcB`$7YouK8rws>PkjNvB$I@}JdZ2d^u0uivR9<pyM*idRu`DQ$anN<(qJ2*}C68rA
zK4nw;A?_88yrj`t=fdxTU#zh==NnZRhWibFOit0PbK!fzQ)c2*IyA%2{BGbz{;`gk
zZD7m~>sUSo5s3#x%2e?Zsyrd-LuBL;K$uSqTPWpQ$MOfEP&xdSQ}Pt9pxJ-;Sl%3S
ztg$*0XL7^WcU#Bu=A5BCzL7*-thsO%f_0TPuQQ_Tu(6HNE;ixJhkOez8_4<-*drfv
z0k^R&4|1ss=b|y~EasxK=!Y!e`v&b<E<oC&@(5ugZD_$3=#y!ir_GR)&&O|@@1W5Q
zPPNSwP$O8DD!+!VdrFBmzG#kzPSeI(Ck1|1Xg1a(@eiL1ZVat(j9xaiOYD;h^~SUD
z?+Wo{%aDT=R$=qhZDY4{tJ@KNb@FW+wt;W(cimS3ypBonS8(mewHMbjxQ^ixQ{fvb
zz%j6?YXhI6fsI`oCK7gcZD36pSl_h)ouoF<(Y2u%@NheViM8gOOE&dWNL5;>*8#=Q
zFD(YAp`uwm)7<-Kg>N~*@Ql=~L%xiE*$ITln!SftkS~~)h57MfOsr>OrauQ0_4!zM
zm+R~)nP8HgH){EKEGBUF+!oi179&!U5Sbf~HGE0oJ!4;NZ|w@*0a<DdA0TSAo(JJP
zT}8-CTHD*cxGVJZaLVa<w&0D<PzNYoq5T#*X7DqiVHPyY!M?X#tjF8c*sWKFE#ze-
zK*bswQ}8=bS1%4W!4?KY*#6C~&~Gi2feqbx_F!IK9QNIv+Z8%uAs@bxm1fI@@P?l6
zTB%i{ZiEh4{jZ?^u;=HPWE<&uFl9cfT309yPa{)tqWs05&9AT9%tVG3n_^<=cYH0)
zj=Vgp7kdv5yc6nmAy&j+C*=w5u8?0xvE`unG6%LRAOv$8+NDxU!8HTxE|$O96<S7K
zLD&7U8Nsxovg--tgcf5hNJQ1=n?_7ZbS+Da@YoF@ABeAyC}7B16mv$1=b7~i&-3?2
z4E~w%N8AaK{CHGPE@y$5`#wudEd95-M>Di@t4hc2kt8&BTicV0w6u<uqfkvhM3}A(
zhw$qx-rKR#0WbC`U6G0Sbr$c?b-NG<%T3fSYHV$`V(4d-Po6ojHK4K9C=;@C(9F2d
z<fNgg$%wQhMOK*CGI7ljR~toI;v*{(fF%G+GNPf0Me3NP^h4v|;^H4v+zeE!UEz;p
zd@=Nm)(09}jMNTMcu0MK!g}MSuT66Hple}y^yH7ybL~4L$r0tjcbOb>ovKL7f{aNW
zpV)%A9iP~P*E@UmL0}R*GborTO%RV!SLm1&Ey9a6!+O6Oai>^W?;FmFWDMt{xtOUo
ziL}&TECm~?uPajMh*ZWmUb(k`u?ElA)7^+JfRdoC6voBiJ$#OL97@u8ievH^`HOv3
zC}5Ty>qIIFnq`<}iXOdChO=jM=)mgGvAC`c>me_APUx7UYeP40PY)fl=|h9A&@J#l
z?e1!JbcMdpc-bXji?q;Dc0h9XRwnaT&jKt^pClV6rbY2V8))T%Hfd-bMXka*cl2M$
zVA0d|OU9wZ3_QzjeQ5ih(S@burgh=*`etwF#f9iuVJt*<&(Gf1+3PIl8gwiP4`Zjb
z$Us?tRr`!BU#2{XWOTmoT>BH`v$Ll??g<-8)Y(&G-|<fT*q3ml+5Q-Mdv)lO)$PuK
zuj=BkzCCzV7{s}8&Ys!!9dE~vecIWRXgeDE-RjWCtJ~iS|8>#_9XHzsA7<$}i=Pkk
zMY}kh8$P6(X>uU7taqs*SFr&dT|5VLn*M&S2^A5J`vp=5HiwU94~G9Za8Gvcz;@YR
z&YPS45uQo&+Pf}ncN-X|_Ph7luxl*~^?(};ggoqdKOEZa61(4a%|)5ShmQ_Sl>FG^
zjs#s}-*F&*?31>g&K|p{D68Aw!EU?3_5+iSb`?5qh_(l;Zzx$)UdrmnDAQQi!Z~`h
z;r^%s;XT15(Br{ts1-hhMrT+RiSC1No8mwP!afM++TS6oI^Ty}=h|Q6R&a#-kYR2W
zS6Ea`T|eiqf@!I?J}45zpiHWTjfH(Eh1B+nfz_yw$mmQ~L6BM7g~T|rQ(JxGgzZz|
zD=U6ZTBuKK8dL*uK}4PlF@T0D$oC)VfkJ<bhCn>3#zSw^S$$W8o)mZt97YnN*lPo)
zb(@{ce*`r*i7W$^|JlqRT|j>q`c0!2g!_Wa`!q-RFMatoM^~w1eTf~vI}XLKFNvc(
zk!0xBRbrG8o>tV3xuSOLwH@ixRwL|SU%uVZmmjAgP!=Bk3kX#-LrNHF-J@#~v#j~N
zWBiP4&P4(1LuU+7p+}Ch=WB>~rd@>AyNw-xh#%Vzg^if{vU@u}3eGl_l;A$D&iPgy
zk?SHP(vcc#lq?$*F}|wFern!hEc&@aTPp5G%@^$(pQl!lV@I+-vh4^z7y3h7&=LOQ
zq)(kam)rgn`orqb;OgKQ+s=U(z%QP%KdTM^l@mGy7lrqr*~}j}1MguyrE#_wojvnp
z8T31QmLq~vJCf}{O<|MOhXm<0H+&>}U+4g$d%!Vir|oEXFG{y#me#Sp#=d?gf{l?6
z_q`pf@o?Y81gq9bwg;-c3=VBCSEUtW*YMi!BH`*m(pzyo=b$e{*$%0)Ve=(&nH`9O
zHC}(o16N9T$G`-p>ssh@qi9Hv+MajzOpq<^I~^<8?kIX+fz5^r63+(rsO@QyY6?l#
zt2hO!6hI+Sj0zX;m#klS@nJt=s!Ob5(2s9y`F!j_E|%4>47fvI1&)+P#tgcfux%<C
z%esrV!IscrXc|oIpNZ_iOI(Z>t8S5sH<=HSG1On=hUl(3dsjX?u)Euo-zLSNE}D=u
z<QaPgzWu41X*4U5Uog@zDuR=hMel!{YrhUpwrA~*@S)C++Rr@9_ru0+yzfU^94x!-
zz@0rwGoEiBz(C2CJI~hsHvNALf9Q!7>cMlbco2vdoY)n5RCdi$8=(bqi33it3k^MC
zDGJb3EuB)6&XssiWBqb=25^TGiteE<PRr;j*6h$*ylR5Rr0Pk83h+<EW-&Ju!kuaw
zML9-<W{3H17_)!JtG6i|5j-DlLm^tHt62HCiyYl#%7Ext;WMPY2UiBl$QZhy;eJI`
zBEalk(_0qsZFmRJbgyM-zc?Px;&|K?KT2CvdgPvXjRQ<U&SjuGS8X$UtyIKZMRP~A
zjqVQ?k|3&!K1>o~hvxP%rU{KPI8)dl>(K7dVVo8|W*yIqy(pQ`yF~MA0nDPeXe)u0
zX&$XrYrtQt=EHh7FZ_zMVyzPAGt9!h8`vyd<zkIo4NhgKgYRtc1py0zw`o&gb8f>r
zi*(4E1mARRk@#)HZ&X%>HdAXxs8+<Aj#Y)^tP!yX5w;lA62wu1HDuMA3mo-B=;_c<
z`4$W54frh<QnKamRP8cxH%<KNG0@i9jI$+t`1L_w4`2i0YepUfp?L#fGg3os$m@pR
zGHv<@9HcLUWiNL4S&&{28gn2^n<iFHQf@i!=fFRjYUW}T&(<!5rIJ#aa|}@eUF(oj
zUg77Lxy3al^~h--eBD|*^rpm2<e0i=*eaB-N0uZtYC}4`kVT3Y;hEkB__G{XzAX2p
z23`PekBGGml3A{lStQEMFZ>&1Ud@8ErKlSo)Ff)&fK@frhqXcFy&Lh>3)#%`D#Tr{
zEkU@T!9xzFhhbJ3zGWy`rjc5bw*k6Tfo~D+voI?(U+VB#e0ol@h7XrD3pJq<^=u_{
z_i9%PsVpxQ%Ww*Ff$K!;5kk-Z+0c*L<cM%8%~1|rQ_57dGHp3z%tD^>`C$GvK$Zvh
zb8*ko)Sn_!nU{JUV$583T0DE^oLN<v6Jg^6$5$2s(M}7<F$tV)ln(8ZFHS+pA1C?a
zB!8UbkAq#DE^fSp!tw~56C`kPV<qGS2VC4Z9Xh0Zb?%Qt%6CZl4k>?><XbJF9vTh(
zDLONX^N4CL@nQ-WbBWlu`{n4GecJyyHxP^Ng8u?swYWqFtJdt>^Kk+Pcm5WQr~D3F
zNk{{xeq|g*iLO92j!p1(e+Io5^zISpY&#C%+6#IB7xoq8&syiGxHT>`stm_oeK&gS
zl}Ibs>0%fjGd<Kb6ZDqPpjUvtX#_gw^ZcOi1$`~<N7(0_Z(k96pELK&)}juKluu7G
zZqPX^VC=7GiRL2>Z3jLhJkN!4p>DBEjquB&;WI$51)cL227QH2cfqR+^i80%%niDI
zuFe22=AWO>44#WvX>fsb8|e9<^NB@SWmVm3Ul$j0*xh0`i7sO^cs7G)q;&2D{Rrr>
z^vr?SBcNxE(X^j14mCe+uaI@JbbLMUb|pHB$JgsOU}HVXK)D@2xJFYr*D50zce5ju
z&dW8^ZcN)eLtdn#OxC$t)VX$9=ZeuTFi$$b>q1*lWXQ$-by;pK3)ZI=(4UfY^I0@<
zZ+yOeHO`{3ZjLV)FP_Z<2%nF(C0~ZWm1o(ki^It^AqP}zO-#bMIL59X{oIjcq@x32
zu<SzQ(K>rO_Tgw+8qh4zdO@ot4FZbAIdWg>wBH(clYWStUWev`&xJHjK)qu=$I#nt
ze=oM)jAtXl=cCOu@-Q^&%Zy~5!~QcB5BYk*mxMO;Zrt<v#&hi^S7?-dz2f7ucL;pF
z;Cq#PLLa0Xr{D2RACZqd)8~=l*@&^TmWF!03GMW+jj+-4fQ&NuRm`+}2@;2$2gLfc
z0y0}L!Mc$$sds49ymgLS<J_nt#j=hRBL7$i?gnpClBQicQeMtZbjKywVkl5Dz5(G6
zBD@<D@n2(HvCAUgUL7Mi4n~5n^+2Q2@i;%Q#F8o(L|5Rs+lzR9#&}roLk=$=Vf!-u
z0Y(zE7VyxaICS@4U4t@oG4?-U_m-x89Vy`Y2Ibhk;IS9;=Iqv)MqcOPV$sQ@i)V4U
zX|p@?h0eMrC1(=W?4ZrzJUp5$A&c_UaZw%~ZQ-_=WYI(A?PT1O|9E^^;GsOmK}UIg
zDiClbk9E-;Z^uNGHv>rLl910Enk>Wl5y6wdm<}YzNJk0oMZU<0-Jgrb1(Ki<*2{b9
zNmmU%rcF7@;N_Q4`L70_*^!5?0~haAdON_^p$Z57D!r?4Z%#)}Hp&A5nGQ5fMmksr
zOxYzi3f&Gr<y5@pI7!PpAMGe2OTs;eg^ZW?jMFUd`zY{@CJ!YKY(t#c|5U7Tp&q@6
zmsw*oYOfyU@G}d|IYs@^c$r+B$g!x$@HH_uW6jIOVB;E?i=ymU12b0d)1@EtsoF#*
z{uNwVxK#KXabJt;7q}>|15k}MiGK&U8e0-)yQRjG#2*5##*V~y0?$W&DETh}SK~p_
z-v++PME`){fv*K5eGri4&G8TM@hGrOz&Vy7{yE?WO!PG1F0|cz?ns{oycRgeHpH)H
zc;E{pJ_|UDNy)DTo)3JHq;m|c#!d`>GjKIlBF^b(H8vv7b&+b!L;POgYFtBH7;Ye&
zj``mQx^l$#0as%i^8dj?f7gQl1GpONkUvR1ppZp*DZtfOhV(4pYMes+YT#;YLcGcn
zzSe>_0as%b@~^beziGjL09=hp$j=E*<*45l3%<vKb3MKqt1$e30#{=a;vWK6;|$`b
zq3)<L0`Uuht8oDF>A;m^{8veQFYYIxrTvnHejRW%4q*6Z3!UrnRsT)8T-b%3msRts
zi^`@>n`V6J<3v8N5_6rIaU#6>_{jf#f29fMu%FWJuMGXbl==G|(JzyjzRZG8?L_^J
zk8ni2jDynEiT%S#C;r`*p<i{-KlWh#Sj!20Ylt5Th$>>7!9VQ762_+|tg-x0eG*2U
zybtA~pN6q~&jJhPhkYr=bSOW_#)kx=X*9|KPo`$a0Fz_8aTttn{K55^=L2&8@H9#1
zIE?fHNxxRoeUcuKbTQ6B_^{;rf#kcNI3n97`5u+9SHj&Aa%{(V_^w9C_J@$m*r?ar
z622?pQ3*ehkhV4Qoe9WvoejwFw71Yd50L5NnWCg$FX^<WkiJUNzbolKl=S-~{ZUE(
zi=_We(#Iif4DXVV>xCH4H4>jI@x>BfCUGvWVYr`4{1J)wOZ-KNbH5ekv0W#>hW3>>
z_f-);SK=2-ob5U3g@8<F86flFT1odvdaI<bkn}Z@e!HaqSkmv2^!p`!horwQ>2FIq
zw$}=M#sM<^B#HA~pLm|c%Ovgtq<#TF>bFYLZ<F+UCH+^D&iP%Y_gP8*y`&FF`rjp;
z`!^ZiBtXi)1d#HJ02#gt7wJAg5kDa5oq(i&8yD$60VMqwfTTYRNcs~JJ|p2i3Ez_N
z&wva+7GoxccLFkeDj>sW0+N26q}NJ%NYXb*`oog`grq+!>2FB-$C5rM>1X1li1O0`
zDSrka<G&h^@wZ6&N=g5BiQg^pT@rsr;)ekl{sTaUKMf59<(~ye`PmY`QsPa3<ZlKf
z{~AfZO~QYZ@COp!E8$~+l(!2oE<@9vBR&Z>7C^@Ld*Yy<hF1gP69I`|0Lb_<02$w9
zfN^-CD<I57eUkKBB>lW`2safoKY$E32aw?c^q+!vOX>d`>HiM>voN+LL}NG_uOg01
zQGS37KMj!KXVV{i3kWaKv?hsvjS%5B5h7fVgpUHoVQ~F|#Q#8u`2R$I4C3SQQb_)@
z2(xj1g@hG=jJFby@ix&PjdMHU3{CqvA;P^*crk2MgfJ!?CA=JCa=aWe{B%HuF9D=}
zHxMG+ZG_<8NC^IC0Li}(ko=#=J>$8K5d8N6lKucL();L-eAp-9+k}w+2_g8u1RlbL
zgh<yaK!(2skm2va#qv87WlR6F0qH*t(2<XEDIs2BiUH#akgtRj5Dt*_VjJnWJ|=|z
zXM*M^#H<Y<=Svm<Qf?g}<#v-^3^{~TkZ+Rywxl~w*Zt2TL^>`dg#Kt|G+Ub7TlNM0
zdl|M1bUUo=BHg}eJ0JCgd>86_4s0&{{mTX;4x-d-=j!Kj*l@@&-#=}s`ump+#+wG>
zpO<!svoP;ZJO%kh2phv%LfA}hBSd_65T@&A_}R|XZJ6}GkN(McpCCL#KQr2fH0&mh
zG`aw}RyJS4S_vti{&!1Ae&Pou<hw8NED7Bbwn)hSlJsXJd{4pz_|ZR8!U_pnB<z-u
z??2?*FCqIq5sv*0?ztbBaIJ)QOL$Pi6o*dFk#K>8-<NQ=gzrh1fx1I^t0cTf!b1|e
z+0KF<Bt%=}<u^@FVxP*i8PiVqj70VkbUETT17otG`&2B;n|Su03u|D~<YG*>1ItCu
znh_toI@FsmFixy9nNjv(Fe`#n6x)x=Z7o>;RiUri=4uwkBo;G-b|+tdgIuPGH8xyu
zWAdlHa6VY8Ft5$|V=v}K+kjVK{@8;$>%v-rR{RBU>GS)`;P1y=Drx$xu?KV0oM+Z&
zzH2bM+6HM{^}tZ{Z$MbC2Vj^&&>HbaZkL#8z6tlFoBgX1HX!JnFZT=U-E8;-;a3TM
z%36s~#kgMvZK(NBUFSi*PsC0=nF4B3Z|E}z@ljd;y67_7aNiD2Jr_7r96-G7B6Tjz
z!7w$gz*`W`N-cqZR7=;88RzKivkS7DpnEf{E_$x0G?j?BxmtiD@@Pr8L<+f{BFe9{
zW&Sd+nR}Guf~H&{z*%#~z&42M4VW`b8MRjNaixMj<FCtQtbU|U<*W;GhjJ8Pm4vxG
z%aJ3qkh4Q`y&CH&s)zZi{O6hk=IPKdnl?}9!c<ak7gnY;W9>pSc$eeXrIjKK*AFxy
z1y)|x06#94t_!hyAcdvIw9r}k&Go{{ZRI_FofJ`sA3owXn4Hjr(>l_@egaKbhZ_)2
zV+VCd)6=mY5WF2f2OI<VI3Svzj#mINr0F;Yh@nXb&%?mbp@TN%1VFaO=<Yh|0MXrH
z^|P=wcYF&FU1P^D0nz+-(9VYLpyPEwbPpYW1WX3x94@+%4$jp=$BtY;nzm;Hq8sXH
z00gVX?*`ys+l(LRuN?qnYog9z$L%RwN5J+FU8Ha~@fY(?>o^A)io;?8`<!w3P)1@r
zCLkSsrQ_!S*@c<ZzC;cO4Erv16Yf;Z6;1W?%ZmS$Z%=h25hy>yF>g>W#C!tEU6cXS
z8f(5t<Q-^q%o{rEd{G%HRTlg)L=xpoS(KlSi{;L;rh8Ne#;?j>4B-U-@%R`A<*^RY
zQJ%6r5?Au_aBq&6gd=2-&Lv?kAf5}utw1^s0b@Gw{0MnWM+Gj*8!aO~0(mMfcncb#
zPu^2cx(~s`v?)g!yx89nDt8_pUb9oQb@1f9O0Nri4JJmV!!7VLr=u1RcM|-V4m{sR
zI#>r(9^+P93wi&>8|hTM<~T{(jZARClQNY&-ZM_Kyo2zlgP(Frp28J0`=5&WA|;pb
ze`0<}<t?8D+NaT`8IJQqml&9yM>8dU1d#UdY76~(3oZwUI6&rvzRJ8Xrh(h?t!DW}
zRen|zU(?jf$&QDeX&Hw`9<K{p94bgYAm4@N1G4dJAw)%C-QpTFmNy~Vc>&p`5>Jyb
zQ$n^W^cT+_V6nt2BxD|tzCgkT3H=fVC0r%pS_yBH@D2&TFX7!1-Y4M}2_Kbkw}j6~
zxL?B8B|Iph3y@=VrXSngH7`GAeKKS9>=QrJP&FDkh>I(Btmm2Y%OU37AXul(FO2Xb
z8Wr4F1T}&3TN-8hGHPJ)z=|W>7wH&u=KygFgx=!oB!Ky0u2-+64`{s4#{%Qb(C!>#
z^setY4ZXJji<_&lWuXbnsOMuZM+4SFSD4pB9~*lJOPbxzwND}i`X;WfinP3l9SZOp
zCP{cfNMPy!*>py~X9E2-twYx_lbd%|1R{34iE!IUJfcnDs|8Z1VGqTiI~N+(LUJy(
z#wzJ7;CX;Kh^YeW{IPWq(1BcGkU@8z;Om3LYVa|Q#ho9mI4!g)E!W0n1s%@fBjF=h
zO<jQ(AU9H2jnvH#?Owodw&?Fd$nD&S*eZv+T4pGuv#EmgaNhvFJ*w}iFz-KrFtG<4
z0`mqOSgGEC__;47L9Rn*35ooJe-=~N@tuuE-at=5!#efddR_|s%Od&WT`DX-EQ3u8
zKMU<n)z_(Sxe)qrQGGGwmGLuXI^oofn=&9jm65;&`4b&C6=9{4KRRsE*PNAsr32Tw
z%&DTp+Ok{YuoMcbv%ZWKQ@f*!&fFkV-X`#U4{(I_Kv`U<Hf&8<+4xzp)-$2G66-rC
z&cPqLlO3!56ISprA7YKi_~4-H7HMI6VvWZxXMLBB>8G=f$6iM}Rtta1BRggBVNA!x
zVp4rJ&pb0bm50{x*hqX?2uyiuTtq%4gK|lun}v(_<frQZU#xM_T+mb)^6{KGvs1Li
z@Z`NBb3XhP6Qk0h5q_%gCOHq8-~wd6&|l@tuyGMG=&PVBr{XooNm>?Owp{S!7#c%I
zA&+H3*(#55tMNM)xA8_gB~RfBn*C4xxQI0%>Q3bRWtDfVuN?P?#z%_a`O8;E#fh<D
zl?7*ccHm;$!0<lYZ^AvFf8uKZm1Dkz6#__HcE;j!XGN`EPtdDoiDw6bzQ&a^*;kMB
zf$-R)B+NO-_=t-167uHxf=&E3eSn|1=f~s=@V)hFzE_L0lv#JgS;~NMDEN)i|4!-u
zfb{1X4Wx7Zv>gvM-=P`q6+n)&cnks0wD}Z}Hfa~-pdMF9xI)5b2r+J2)b49A4NH#u
zot2#26aNNU5?^-Ua>Va&8{(hUN3TadOMqLk&@H*pXGs$vKTs0g8;8x#reQ?ry$W={
zwdge)^uBlCbg_rD&lXwxXDWgHRF_j^SZ)PG5BWAod|<IxlKm*Tz@c}pq1_ec{t=t3
zxTOx8PfHU4amYaFX@Hr4+yakX^rhng(*VZ-x&X%l;_Qx6ZfC=nOG`%sCIdPEld$t|
zNTfJ*Cua0tc%Z-Z;@voZc%FVfahe6c(1NF1@QW<C+IzyiIQkA1>m7Hys2wIc&FrHn
zBS8(;uPmfwChU}aHfeut71lXg<Gk=`!25s){dN=X_5DS(F0v<Ifr~aZb+4>|b+C{v
z0VN<p`yfqWjkxC=g>L;-_SJI1SqiDmu&~j-=GDq^-zfZ*PZex*Z6<&2l%i!e01c^6
z1%4Mn(|Yg~!j~3Ve5)6}wAAWWWoooca&d2!ZjI)yG4fI#^PmMO^WrVG-ng$9@3eD8
z$Rg;cLRO1B&~3d{2uI5`CFxe};r=>5(`M%8&Zz?UaX%O>zd<b<Wx`UiS}M)<XvR_n
zTPRD=jrU7hg}E1s*7hdoPkS+AqCQpNZAQw?G-Wj{7xsi`7(EW!-dX1Qt}t^rT5_46
zEXkp+PNJ+SbS*m2ZjtaC5{j`O?td!rEfV%h_!|lLOZcXQ?@DM#dr3zdCf&sn=1W*9
zVS|Kz34;=LNT~Ev;ct`vcS_hJ;cp~7DB)2F*>2ONqRplg?;(IWz>@$=09}A?z$`$n
z`O61f52)O!+B3!Y)R<j~C(d|D%fQ9)cF10o=&FOA6T6_?@Zyz^>kuyMcpOXZ`Mu#<
zyPM;2%cA?T@%FaiqjVA1-IN6<8fe~}?08(A^=MvaKeaXR&oG>JLH$_cbeK(qJ%nlG
z6>FTHA?pXo`d9|gI!@0;;nc#P@>p(^6^|<&7lW%YWD^jUm2xU?t>bj_x>)imzAW5R
zo~j$<yHg=1zC6jN;;n@M&Jif*k~g`4W0fc1My3Pum<|plR65FW&*19)VB@H$PVg2q
z!bW*dJ?Xv=zF6-EY{5<HX#L<bJ4FjgK9$5L!Kd08@~eDVjeB!Cj=@mif*;etah^(t
z_5ENK27`BiuAGXOP{m2wHVE%PW+Hnq-qq#to^h%?#;ul%apFHr0hK(`%+Bn8D&7xR
z*XUTr(XXxOezc>Wq2CJqZODy_fm458#IpfiCLBvWj5de#eBitkKW+^-{QU!iWRp9Q
zb^EMebj&)wPs|5oTx{=%HvlR}JFWShj(oQ(A|UY};>yRx_K@N415}RmhZF)x{83!d
zI&ySykA?oS1%KayBNGirdC3<13l?1L!;&G$Uu2=HzK<-Vdo6UHJEt7!w_5Ojv*16q
z;7?faeHQ#bEjZtClw*8c_oy84DHgoIg4bAZzXe}w!M|t0@3r7tEx2`^{6Py{f9a~%
zzSJC8-du_our{r#$?Nx*tCOqM>!?;Wvw2y0g9f8}AV`R1)dU58pQjBs<;}hz4gvSw
z<fRnNyfS*>Lf`b<=~EYZg9}^g7Y3W!o0m+jTcO2%d#wzbgHl#?02Y2<^CE3_yWcN_
zOT$0!D|~H1ZDymd)E~fS2IqQk5P6;7tEro+V4&4_qmH!{yCUFe@HUh$^(>0ARpWES
z<;_OIiQ=242409+&LyV9&Wn9*W|WJk_3wupAs7k04G(?cu}Ma$w;5-s*ORHdxiO$c
zg$Q)S^VBQ6i#+u!3j=|udczK5A9g@}m2YW_-#gnITpnm$V(27squ|RMV0rL0`n;_M
zi+hE)(9`BE3N%EM0>2`U-(TmckBX8xR@LJ7;rw$WxR|~{PFnr-{I>eK>kFFOd`958
z!R)Lo0~@*wALZ}%v<7(=y3BcCsEz?qqgg!^S<kOob*-Wv;rYZ;GR>Z>k8j3dg8vfW
z4ovWuO8;4a^uGZxE`{$<=-V&=xEaua&Lb>wv924!&Om#>xu#S=2Zh6Nof_Lv8~oWH
zaXlORUgB&cxXukK2pp^$*S~RWOS+5j+~`~s+kLK=%arsiLYHpWAb&3L^P_WA`NS`X
z&Q+BW|AL(F1;3kknp|%Od_M8?=p0rp@eAepJJ6emUnJMz0dFA=rGkXOR}fB;>+*ni
z5J#uFR?^oKV&HR|#JdTR7>+d<ek0)&xo!{mCgM}&`aR(H5Jw^1M+kf~Au?-=#J3S5
ze)e0W_Yxw$-4cJ2FiT%gPx@Zs=;ZfH`YVLfu<lXf2M90K*ZGnE5b+#Mdr#7j5MBmb
zm&A_|PS>=*OPu{5&)RnoB78g{21W@IPm(zMMbc9w&iX^#CGj+gbIi@~nTn2hXj6kq
z0#-}NeBxYalc)KlY-*QHyL1{3_J=$E`O)_zAQCvn9c!+yW*c*Ro@IGn9wwA(allaq
zOk5cZ2$)I6ehfJ=$@2^T4ov5q)x^k5PF5w!NkYyF&gX0sU^OSN0Nr6ugf+l~#iKVl
zjiw)8C5>u0e)wVdXJqfgG+gG6!*(9O_&n|xgeRyon~d{A^|>$eTp%oX4LA=e4_3U|
z{+U#a2Dv17<pOd#FJAcJpeZ>`CnvjB%!6*ZSa<lv?2q(muYqyhI5HQ<<K`~=0;dEq
z$)`^WIwA@8BQcp`PH;YgVdikfe!x5g=fRqpNTLwS1R7?*;DwrzzoGY5IeYF%>xM4K
z*e0CVoOTEAk<liLWaPfI@52{LH&N;J)oF9qSERXtH!%AL@=Wt{O)6<JS+W!w026dJ
z=D(itwa|+Nz!^@SRVAWC#&1S41+DWb=laR0qdN{E`@xv+TuYOJ%ut*&<xeZ4Z8Q?0
zUR}wL5kP)1%H1Ea;Vxb$Ayb+-B^pWIjy%C}ny5<t&W|9n*15I>PXx{m&ED4sbEr0O
zc4IfrmpisPI7vTb59eTtV<Y?2`J#^Yx3CJ#rXQ`Dy>H-^ZXSu*{(J|HB-Na2{|X(D
zfU=Oy7V5WMfg|pmo!9e>Fer;^$rBzAfn~=5dsv+cc3ave_#lZ88iqCq-h_{BKPtRs
zYDGGe*RW_K&Pcl!PQIUPp_!U3)N8u}nbUqCERR^t#<#Oqna=ZCyRW?(2YSXm#+SP7
zhydv=vG4d@{Ma3~KRJ7B$eN7v_k{kj+SwToO`SazX>)RCXE-}Q`BcZ;xw9t)7b4R#
zMCijG!XM9>j=V^u2SPdb+Jvkw?iVY?w8MV~g?>gt?+_`<?v-ic-W+^+K<e7@u`THD
z_}K333^CkoX>8KFN>WhY#Ichqb<Q49)lnSI&Q69uu$m=jJ6vjwPR~~v85F7QXWESj
zBX@`>BC}IwjANQ%3rD-)ocTOr%sQN?pX+8-Uc9#s(f{x_5igWD-2V@G-aC&kH9bF}
z_tH=yQ{<{*F^e936p&x?h*vzlpNEnu;7#R2f?OMP$HUiwjK>j%X*}Fid_%ov8(Vv{
zk2sjk6c5<)aR^)r9>El*6OVK<?o-J;a1q<Z4fIB>PmpJ}#fSBk$%Av#;LDGt^CUO@
zOi-gCq)zR-L+TuE(SEQOJK^}re2U{|yK}<vi$>~{rhi`cptW;Cn>k;#gDAaJw0}uZ
za?qWE$JC8dPK|ILB@MY*&F78nz};X#0l5G)o){UKrJ>0P^~Iy%Tgw;j$Y>l>EE+Dz
z5K>jgfilGN5E(akZ3SiHyv3bpMO|oQT;YD`Qr-DJP6b?rRV{w8q{GGbBYXt1BW08r
zkJTKUmJ<CW&n~2>Y8(JeY3(ne-{O&f8Pq*&6Du#$!fZKtmTUN!Xj^cue*eHh%9U$B
z5FiIpn?K2exvD98$1K{f#IBoh{(F3+Mvoj%EmcA6gO$~hF__4DLoM2{oPRhhzcUe0
znJK@MO!<wDA8AX0I>pRo*>@$&T*i5$DxVXW&s^jeDRFc)b9yTQi-6cqREQ%p#p%>C
zn^}ZO$mU(h)Z}nKgeOA<L=e0hKB>sC<ZdjY85inHh%`CSGXd~HVn*u<aSkw_X}#91
z=W|l~ZxAe1<Sq~U6uFxzb61pC|G?X)$_}23WTr9;;C{v**t|RKB|L8jrxY3I?YQlc
z;l^u*osVlXuKRFV?cwsgom%^*;bHw?=a`}vjnMTp?8S<=D6!iX_iC)ea!SYBe-y*W
zUNGM7kLfM!TO2d@I`nrD#<vc(eX+JV%RVzPp-3)m*57%u!0W<zc@<O}LAQMSlHuuM
zo^bwT(|<ASJ&YFv*OQGm5AkxoWfQ{kUBFZpI6ul%jswUa_+S-xLLc&=9}^pUipGog
zJkG~##=B@0f}6re>jBOQvX>4|GvlsB*ra&<J;fB(9CyC`)fjQl953EkH;F!9f3Icq
zCp`xegjHqg2$rD{zyCUwGbY}qg^jJArCx37qSiori-`S%euChlom;sa+#n0YyZCrO
zR5fwo^;%<*i1!h|d|U}*@gp5O1Ul<n$0iuSS0G>lXv`kUqx^JSl*h-0uEHdXIQi)C
znkx8@$Cm{@p`R=R%2P5Zhcr6cE_hFVIyd+jhjOIxnk%95|EfhlC2z6hlhKO3q}=DA
zoYJ8Y9%d0KXtUYwFkk4e@`Yug(u!Lx6AWhiwThR}6pi*uBI+(Y@Ot~1YmyG3ptdR@
z;5FR>i#oIashD$!N@n_41EOyDoB$qRljAqxRS354w9%)S=v<RT8<ldbi!&7hNW9E~
zvwhf%>ponR=e5vj)2c-#uw5s;%R;AZOF7D?Eaixc_ciH3{3%?$DC7lzl=q^f5s-ce
zmujm?|BwXfNN2mR+GElunhJ>Ybl|GZCB4u>U%>FPT_t@baMex{-w0f_eZ+MmiCBVF
zfekD{ZyAgxFd~o8I>okIW7Sn@YhZa{dt;-wm7jamMHv=L<E#vWq{mXYlJ?^&-=bzu
zu)Wo*4YMwLm-*_wJng~|rOx5tmmr52+97&Qi?_KF=3tWr*$4-+VPLizoFz>+pT;sl
z4`G-a@V77ZR(R^Xm?#)xuC`JTOq{LZ_bW9F19Ka536|~Vwjd11vB{O*k;&rO=ejf2
z39dVXnN6%m<Lfckooxdo{c%bE3;oBT4MO>I-C6}8UvWDD$rk~noChTRRYJ7s#{emB
z8mbDz%_2MlFGGM1v~78KZYXEJgr7&<cfe*`L<s-eCENqZczz8i*2w`<-a*38VXg>c
z5YjINB>g(TIM|Ta12X>qkn{&7{kNo}6N*P&Cw&T_2oEU21IEFYyk63OCh7kn>Dx(1
z{Jm&`7_JYH;r0U3|8r=F=zk6%{VxWjzl-^bwDb8U+$bS!o5B_;VT*+KNq9&??x7=J
zgM@bzA}vkJ&8z=h(e;0q;XW%X%k(>adJeD|)8Kbvw#t0j(Xh{tWvkS`RpG)*`;hO^
z@N9J5(8y0tWZ+etpRI|PTN9GgBBOEUKJ6zRc)>p-yw`e`dAHymO|kNvep&?b@Q#3!
z`olX{Jd4+nJiM&Xa;6(LQ^gy^{P50!`_12S;9>i)mxy<dYP{lOX*^yzX+7qvCkh9z
zo(}3NHcL=v7#+Y3gJB-m|08_}p9h~T5E(vq<nTFq_yln0!C;_=Kl%8R{+sdBkRjqn
z;!f53QyOHYGPmIF;E#Tm=0cvOiB}Ovf8VY`RCzHUQw+EX*Oj=ym%kE+(Bg3y_5J{$
z^v_cMLHM~)B3Ay};9nc{7yN9q?#4xj$6t3RyN>8zYz+Ma)>i45emd(IIty)&3;wLp
zXcmmIVmj^_Tt3F)Tkk*(r}A(ze9%lCmoE!El&9A18~~zZz+2D=XUTi=)A5~+aVSR_
zysTqrCzUrj^3Ykw&>Y8Z(MjT0>CgzwJcf27U#J7~<+H}nyCLsH#?UQjZ~4xQ=KM3q
z&>Tl~gGV`)4uvad_W$27hKAb0@fqhBkMDHKaSV+qI>RO5uEN0d@x&YpUJHB^E<W3o
z=L0-o!rO4~LMABs8sN1ioSj>}d69%zuTUP)R|1^$P;=M<0vv+Y;109~wRx?Wa~F5Q
ztKL@>Xm0c^lKuuNo-Z_XT(iZ#opp<SdjlcH5-vdY(Pa|WO1MHo)(O(@Aw*sBVflx-
z_cp#EK0@C;ZAQ)spZ`%IABr5r#lGA64RP8nP4;uHyvKYU=j~t$95z`eXSAZGdl9sA
z(7E;pkd7`Vm)1tEn?eVf!5GmyXUe&$YV3ux>G!g)&69@4j7aj=^{yKufp&<=i8Q5z
z<>#?rUaZ4JAml)!v;n8yvxoZPFdvw<thB56GDa59#!U<bjBl*8zlNSVN1t*KUunyO
zC|X*D(#B-qmJ6w82>R0Sn=u2uyYtp^%zO+ygT8-g=Hzl5!K5))O_Ld%Wfh+!1k?u-
z8z_`R0sWhMB6awP)(XzUW-6URyL0g!KwW|8cOS8*()x`VOl$CSSsBO$nV^nbtv%4E
z*>q8za-uXcC$~>27S4^7=7sIDti}bipc^Mu)VKBIw1;~>v~nWPQzO_P8WL(Ji5wC?
zB1`4GB=#>R$wZ6f%}4?cWuaXfG!vixlM-N8?+WqxP}z--v8jUjDEKtyT!i$-?g6}D
z@S8B@;<S-EoSv}=p(?P3Tt7$TRE=F|w^L)6bI`V!>~>L`AJ;R#OPi|2W>_{}JkuPr
zvz@8~WcZMshqGU+FPMf`8m<mp-QYP2$njBe$WgT}uIyI3{RjF8sX(^@^4X`8kLStT
z0M$C^f5JFs74(i}3uJ%DwvlP#70VWQ3)(&9*muxb$1xRn&*X$1<&mAT;&EBWG3>9+
zPUWR_95WIh+igT6;-DPzsX9VjiO<D7`Hb-n2r4e}kw#a8i}#dEcMyEB#ydBFroxcV
zsRm|5;1sP@-YY$lz{mG;<&+N1@Gy^e8qhbn;AbA6F#oJJ!zUq6Jn*2=sdx!hob<mN
z1A;7gpldVspR(*2r&;y=h-A4E0-EU-Sk#&QPyKiYgFTZQZZkyXGP&V4#;6UE?F7dw
z=bQNX&3o1d<(Ln%6#__{Etqn|mn#I2_)Ql477N~G!SA%-KLhT9Zgqgv&s--c{}BuS
zvljd%;Hr&c_=6VupDnn}RA7`(8>4c>`K&5Oe6j_<+=9C;c#{R!2Snx(pIpOP)!x#=
zaoR~47e`+IsqBo>WC<%|Td>vdZT2X`APzv*WN^dsrWwY_nI+}L-n#ZhYQ3yhSsi0F
zt>Q9`UtzkV`7XNZw}EKMa^oOf>?e)2ww5+aX}`qsOs?282^EVnqaq>D?e_#51FcIb
zyeimEb74JJpGH#x|59(zP+!APRI{T2NAsbLL*pTAf_UijfjgY~K8!dNFxw@Lb6GEW
z76@(BJlpU;>3@c%30q+@&eKG>QeFli<y{FFH&N5RObDA@Js{V6vd!T7P}-Ks&plS;
z-$MV-YuZjibP`V!BL0^M(NJ?eIpy*ET-xgRJ{Wf{Y;S<HA#$OV1Dz0UW)7FMK|(*C
zKNWXA&b=gr9t!}eM+5mTz&cezWWr5^NC$$7@p`R<YbCso5N#vZG@s1)Jv(Q{39l1;
z25F;H<9F+sAQ-rDDPMelzUU3YN&We3>NPd296EmGf&iBqh=q1z5AN~kr)vDgc0u*6
za%r!?v*7QNml{*K=IBEz^1E^6k3gr)7F=|yFZ@@ZOGWh;X<>R|jh|}auN>1)XB|KB
z+@>t}Qx>YQkQZzGv<Wn`Q+dcS3;9*wzRApld&S2%SUuIaXp@PCTR|h7CGW{kcQ-D^
zp&VuKnk%95e@@*<NFF+?9cVB7I!KUC>DLI{JTBUTd~v~#`9gp4F`d?N5&NgF!e2QR
zFCp_&xxXWWlHiG^>ND*?JU@Dc3IwR+nY_fU+5gm!i$t?vL^*t1WF0p}$3c8vIZi-R
zsk!7u{0q2Oj&`BT6#|%q%Wc6q?#;*L!o~0`N9D+`H>Bo%AM=1qw1WB@+kLHGaeq=h
ze`U}dw9@PMVgrT{QyDa47a(fUPXVfak8?tW(!Wgl&jaL~l#BkT2yBxHt0fE)qO6zt
z+UifHKbU^$iJ!%=5qi<7{=jO_8QPv_@SR`2vg?a3xzv)AGU5e3a=NffWM=P!*`^$<
zq1_qRhxdvFmg+1A@t&@KnLG3zKdb99<Z-!Hmgq%bC{g@mf}O?`3}%~=&wdEKmkN7_
zZg9|J!Rbii6k1pwQk0zl^F95+1W>plRJTj;)3-^mJS4;NfKNlG%5!G19yG<-0}IVi
z1vs6<^_{~Nv3z%(;lX>t!7;a#-3!I|iRm(=#Jm_4Dae6#_(Cxj!HG|w!~CRdDTBdm
zn4`{_@keLrUyvy1#*YDub>KpED8YrOsbRSYl{k`|iFmRgR2(bC`KkZD{!;s5sia7S
zQav)-l#iY7hj#=^utc%2e+;U5M`X0wpr-6~;hmlP!lSpbF$<Q*(pdk_^XJxlLK(qF
z@pbooD__R%Q^DugGr@8Nx4xx;Wtlp#t-F5=TI`NU;=oHo?PWFFG7yni2b*V76}dDY
z>wt}Y5}17Cu^^db9++XQ0~YHJ7a#)?@K7Y7a&v10X8~!<bKv3O{((Wa_+T{(K;I%^
z`hql8>i57u4JNci(zEydbvi=3VRl0uLh+bZpzCL-)og3f^))GrIt1OQ8rLgR=S(tT
zZDpF;(a}wvuu_$aQ9+L<FI5&Q>Sw-HBjczwo=Mc3G(+8?8w<8lF%;Y9ATSfs=12E(
z=;eZKB5F;#)P9J463+)d?JcS%pDFWkbn@}a3L6&IjO%y7pp2)&Tr{X!#i+n;RJSs$
z%&kW5=cAGXb%;C(_lfVX!`OJaYH5&S(LVsP?-ur6c2^98pg0Z=j}@ZVA3mlW^^SXG
z@)1!nA}NEl7st&6FT`B#0_aoW+=?^YXyrB)1EkG|GVVs?;#6pf{Q@|E24bbfwCfj)
z8`Ye-tgHIT+I?Yu;5#pP3G#Gu=SPoWNYD{|%EO1C$nYcOs7Eiqj-IFT3Z;?v{JY_P
zY+Lxm7EEpIc5Y2BX$&Wql7P((&%Yab*EVD4@<X;>sy-E@F*0{JGtIi7_Le}uRpOkz
zc#%b-M&x!5hW9`%bzIIz&dx8x!j0$Puz*lVw%;|`z4PXV-s7|2YFx9O$5_<-JUBMA
zJL!gnU)j~z-Lai-W1<8Iooo5B@9g>duLXF3uPfM8vE!YjvDj7d0N>ce&9n4>Ck6Lw
zKVh(*2e=Qx*>lU2f)KysK+;(3F1dwA2#cGi=zkz(Y+qLeHo4$*an#i`l#U}(5Fc5Q
z8fi(%?wxVW8G01bK#C82?2!9TaDaLE$x!dvDE5RM2OP|quHw<B%Vq<1^I)a3$352B
z(}EojE5`45TWEU}c>In(q>Mc}_T^wU7)HTkw29~#OO`QA#8J!<IF>tRyx7*>RsFfa
z8SgF&hIZIOy-84_{Z8auf@u9hJCiW05O0%N=IrDy5u7*}?`S`0<R>OE5}fNUM`45p
zwdL_^z%oW#cFr1@@f}*|Wi9)u86P`u`8?=4XA<tRdk_1;cLlU)T?b?#5E0|y8r%(S
zABT<yMAta<1<=}mm>vk(m3}6Fjd)nClSrw0yM;yWk!$kNuoq^3lsz~wf$eUMzP>+s
z#!dOlE{_xz+m2Y<4RkQCvZ>3*A%<C82ayv_;&vYWC_|Y%pdx0yfi=}%t15Zi(Xs&T
zK=u0SwDZ_rs#XOxL(PRCCsAzfFdKW$ht#nR$$r0cFw)`(P7&+&Cx(x7&5p<3qh!4u
z>5UKXoOCo&J>eJ*!v9lfk8Q>WT`lp;Uq(#xnNIeN`FIkI5et&_E*9CVP9eJ&o2Aav
zf*;6;^#;XgI`y_!uy99!j-sxs(~IW73d6IFXp4#b4}4pDCgiI3aeR$eoC(AC@jP4{
z*I$TB(OorB`T}@&;1a!=m?MdvDdU3wDqNd!U4skrBQAY@r1VyMlm0DM#<7VsJpb8*
zO2(3C9KG<)2R+M7U#!#9;CBF53+QV|$J&!?);VzCWYw*4*We?zmHO9r8BaWT@EQ_R
z4)v$qigxb@a8Eh-UNX+E6rbs~SIMI*OJFCWJ-8aYN5FeGd7<;LeFa5{Zu^GeQ%lUt
zZiL;0jzh!~D=faF8}nPrC9%)FWZJmaqSi4qZCR!~azNK^&?D3ry6G8&<b4U}a(+e6
zBjy3Wt>MBz?M%o6U+t{WC=b75%$$^2fK~1KT=#tN=EEK)dI*sY@hxL9zlNd)f6~yE
z_;J@@ze5s^RZl4BNAc}RbYOM9ZYR1MvbfIleBeesb4TmIZpJkNoq2i?^cK)NW%yy`
zfzMgnYhupz#rTS_KDVEXGNR$&4MV2od&?}RZ^e*VFus<)mQ#`n#$PksGYPU;7wAwt
zx;xpmP5+{EgKwCOHOvP(t8ME;*mY}BwzRnbh&)0u51Siw4V~sO@^UhG$uF~58;LIq
zJgoAJgN}U3`mOj?{(Sbyr)*$3;4{ii(iosd-cv4JF8HX6a+JY~HWEVR>MiL|G`9P^
zS9&ynZ?j4i{FM&PxHo01Rt-D*Cit0cR?H8p4J;XUh7kOfQ}LSPB<%<b3h~k`!DpB8
z(u;AL)X|Q>?oL~Ya!Q`U6*T*wdK;M4#%0bK>N_;EKWlDqCKRR(3)RtZoEywEFg+g%
zEjYs|$9$TP%Z-cuDdl+pJ8)%4+y|%}`P*=9#&r!Y@~;JCMPOe^JVIPL^520gAM`9h
z(!Vch1f>5Im+C7?e~1K>lj83sE*<%w#ija0^1lLH^?SsB4}22}o_!hdzX2-8@SozU
zMI}-4PlIl%A0q#Gz*T=k+&Xv2b?2&&A-x8;>L-ZT0auRk-AH~^@bhs``pp)47jV^2
zkk0ki$}#+}EcheDQEk`<ke_cj%8~y?3;u=$SLXvV4Ec3qA<lR-e}MF)telv(j4?52
z%u=e)epUw6or;RM*alJM4RWTlGAM6~0{Zt)d7O~E^LotsnLY_>963Y@LpO22C(yc*
zUyvO-(OA&jP=%w8I9)oFK(rWE+Mw5%lY|duMZGwmCQ$A1`R6q9xSlz!4cI0U>);~4
zuVGeUCC)0U_bv7KgMq@LVkBz_3a=nm4hja)hM>AS`aTYQ>0f)RhezR5i-VCcEo(ks
zN$0Nd$rF}pqUY^k8o7RHi^p_klIgRy(GRDJ!<kS8*eufi%yyXeXSOMvU!6pVdDluw
zXInwKSJK1M|C`ePhk%@i-6s7Xm;U?ckH+~RAsYH|sFRG3a~G7yaW3ae%ccJu>A#5n
zF#6vj{ntzXyXg;kdk8WA$~sTGIKRnCxm>?XxfcOCFn`N=R{C>%NPqRc(wj+#oIXN?
z=NWh8i$nWCK7N0c`LGz!fq}r!0ZC^+NBZ-mpNn&d(4LTfBOvL^0ZG4={+JiuDE;r0
z{*TiilWWfbGW;NM#GgG%5C26#hMxx*cLBcN4#@doA1=!KIwAPEmxTJi4@f!xAO!#U
z7z2}jItrBfqySQ02B0Gy?{Lz;O#08K|3#Q@mi`^mKMWX$O7H~f7vmdFXm==YJRs$z
z12TWI2{SeAJAnM|;C8~P7>5&Hg7y^U&b~Ka!deMCB)nU~-4Y&@FahPtaG4U$m+%e=
z4@npg9`dnYAmn^H;XM*QDd8ar^H`3!znc(w)xu-6O%o=^TmPD!ot>NGqC5UMJ8r%V
z!KwKY_5C|!DZ9-fV<Ymx78~1&Uku|Djr{pA6Xq&IT4Zi~cn^2ZSB%mo?Yv^PFyA{%
z-|ecNqEEL>>~a(uHolVhxMs(UJ>h0YD^0LtBNH3@iwi$R0rrk;Cm-F|?`VS2`Zc-k
z^}S5!Xa2?n^x_Ikt`FrZ%pB;K5y6oO($;6&(>2p}MM?bfbYYB;(+`L*6@gp`kOo7U
zSh^|f8f*4Eg<J?X$J^eApm?Os)+-D&qg6667c;v3!Tu6FG_V7fFe9~ryVP0Uy7_1a
zN>_tn!y(L4SKLmX;29E*&+gUloOks8**bs0`5-j`WSJMjJP*}{Vfaj_rPPtB8l3A8
zxj1x6h<kS^FNJAEz9pNiTal8K#(t_<lA~lrN_gCXBT_=U?BLuS;w34_D^5s>Nv7`4
zp0A>QVU@)tu5d|Oq$C$boj@%kbH$fO_J(hEL8MhtWBo5TN#TfbO0r~t%$LT{;JDxy
zsXmtYmZXGAQek_vUr~|_U0aO_reRTR;SiICTL+pBO=&r>b*R0Nh1PL7%yy1QVSM`p
z=T=7<Y@6Y09CCim+2e?p9-_X~WWO&aUow&Od~@zD&zDt1ueXtP94XG&)0V1Y{(s$_
z4S3Ymo$n{Zr~x7q-BhWvb=08^f;8dHP^ldxgwRHayh&SDh$Pdb4UmQjQp>GjCqbrT
zy4h;Gw)N@qv~C}_b(Ou>8*EE8ya>qk+DKd1?Rxt}w3ZlbS+$DRHuv*A|8r*knFJG_
z$7i>@=b1CV|L^60-u~zP{LVS#(KvHrFL|8gD|wWQ<Y`pN{~f{fj-N~X#OD0egL+Dx
zXnpiJFp#+BTI15@4}0$Ny(TG65efO0%9t~sYXooof6lEfQ&K0GSO0piM74y$q64ut
zflh;)SLE5PzifZS20n46O&%9&UJCCqCBnQnm$Lk#4O+|ev<d6A4=SpgBPM-Z*q9)6
z!JBLNxBfb5kCQQSDMRcFX;!|A*E93+CUtedNj+h#^`&s?>9PC5ZEc9!(?zPHS1?gN
zDfN^&H)CJ&`7jF@=Lb@6?VP~rSp+0sMV6eMiM5<)`Ng#fUV0VR*CmQmZ}pEg;o+<#
z4ncY=`P)2lnX(r`%wKXU)s$B|LN}U{lTo2(`c<6x;k=SS{IHJcbS!%(&KjL9lpqq@
z@Mfzo66tNxrkz#M%M=n$FuGw3e@pWCTN?E45Nbab-l^o|MxO|=n@H?f&Y_4D+3(LR
zzoMp*n?GuVhm2cdqMrJfv4>lpF>|SpoS@CY)1sCNVl=U(pntmOj^dj<k=Js5{P20x
z0*@fYJasVK^@K@*FwaK*S=fr*8gJftOCa_8AFW!sa^+Oc97>&d^X1fueWx#*vcDs=
zY|7&-T~51!Ox6E2=7V`pX|u?rjrX=mXXsbUr#GKX9t*tr%f6y)26&7xs6F~2O@4rM
zE2lmvp)#BGXbl9Cpp0b-FZ+5c=WWLl?`wT~e7NiAmh(Hl@Otap1@T9l0^x-}RTH5l
z4U>Q@^N05ork;*-qFZ>+6Ae#%v52LXz6&}EQvCKkAB;~q8s2k^Oj5)<V}OO>u2@hR
zSplNt`0h6#STT~_D?<b?tqYF`88g=2dYkr_Y(IG~(M~@c-3?&TZK5v&q)Zjt(H7NV
zvZ;z9p6=)AaD{2NJAM$8mlduq;k+HUbAVd)ig@z$<iu=S9v#O)RW84BNV;Ou_JazA
z`)>HN4fJqZv=u<24|ME}O5qTS7&580Xd91lNIQX%z@fJ2mwCtorX>Ts(?SJW@9q}V
zV?|V8P<Ur{RR3E%`S$WHAIEq3g$I(C2SPt)p1hOgvjLB4OU*e1P)(B~d&iGa?)0Vp
zb?TjWb<++HJRk3@{KLS&&3JqZHje!)whdY{@IGKS_C@SpgNNQ37^udsz^=xw!LGyB
zV(YPu*e2|Q$o@~P>ZKoHAI0v+9>N~QK84j7;~DI3<bMS`j(w8nmw~^<zKVSVtJS~P
zp$CcYxmb-wCSWhb>a2oGuphu)fvx2*v8#a7u`{r9u$m9J4tqUTr`B~Nvjlh=SjFns
zYV6J6oxppspXGTYwi$a6{5If8pvE*iuwTYbBXO&-ZP;&ue;fN9EWxA>yxV-^)L!$c
z(iH`5$HHwo#lNFEKeehLT^;g{k)oVr)>qSa8{yLKcqjE&dkOyOBc39R{*P$$NMA8@
z9JXF`REOlQS~CfIMawzZ|B!8ukavPOUH-VuN__`$%dA(8&b_`h#L<(Nl0zncWn$2G
ztpv8Xte%%;Tmge~q$;NMAJTf)DE(8~d;XR5e}(s2_j*Mro4(<;i9=F1KiuUNIa0Y`
z*o5i3OAe!kG^k|xQb~o(D_U{VO2w`39zL*7g3_!~oJR-OE0^K+El6}E%gD1XeN{FT
zewQy?<xmo^F=%}|@BQ7$-qS1xqa5H>CU_EVe^Ot@d|M9G4D=lls&p&1N!s@`6s4!b
z_j!1U!~fafcbhuNQ_;}-9!?#Y9;X_-ys{@1bhSiBbr1E;*e$<IZVctoJ@#@@Up)?G
z!)>XoBUeKw{Zt`ZBH>pJ2yd2n#M@SZP5{m&a;?)=iN5?1H1urx7N$MNw3zEc@++mL
z*WDTP-4r@~qRGA*v9IrKoh_J6!58s>{`fYU#YTUNvW=d`-snz!v_!NCEt*M;WVUjG
z=bez$jFpS!dg)x@!-_3=zdF6B2(Ti(D4LGxAhdatPf2ip^5}VFyK)|mOh_ILqXnhA
z^~$4FiDft(C0chQm)sj|1*m`*CnhPbU|v?u2NMrgXyB%72bgfD31M0RCWIUUd7u-~
zPDJSeP0B+)+P`aX|6KYvzQ}fHb=*6)P}c{lryy_KHa!;6wOvuY$^rIn3cz)jBB7qs
zIn=$Fbx%4;Okx=K3f!7G?#Y3)cZjRB=`w?-B)Ws1djv{Hyy^%7zkZN&&jkn(osv*8
ze86n9hlWoZQ{}WdgW=5KQ?e+0gVm8te9sUr>#nq?{PA_c9X^;t!{`4V!=>N5yO%uK
zNPZsF&rd|_O(vcd)vL<9UYk%J-9|1ZwADmtD{wWi2^a+?fL=ynAXrN_t4|(mM1RK{
zzZUU{{MjfoME255iZ)I)!VDJ*JRi^X4~4yQ>z)1KbpSK^o5h5;h_ETV%97@7WmUTw
z)qNR!F%`P&K<dM;A@~VzLPGUTPWtN8bx7lhqe^joqWS&|;+{T1=bb29Wmh`7MPNGP
zQ_#z=Szj2+E3eA^?I%?$kmTEZr7HD+sXnMOR2EYYM_UE<nj-C$g!bZ=$!5M`8{JxQ
zsc}@`c|{e^_JeX&XMdp3XG)+xTgSuEdjM1lUUDWuRMMyAk>1MARg1)CAeQ#(6dvuC
z+;l)4h`)oKu8yV|<?Be<f8YN6DZP+D#jLsrrKcn3L7&9K6BCk0!X$02di<o-q&Ll7
z25?u0%MqattD>fZ8Lr%ix+Z5jCoX_ng;k-cPf=MM%LJ5xr@S9e^`U_%9)?n=%JlTT
zrAF7(-`NUc7NYH|Jki?SOCMF7^r@D3aFX!8diW;&bM~KaKluRc4tpxCNuabUF=Z2|
zs%Ux4S0XG65l9de9t-#gM_?r%FbN!Ne<R#>7tIIF%#(61Ex)~UXF7gdEy@qJ@=vHr
z0CG`x)9RF(GHUdB$`@4Uaxom<@hKd_VPS>5QC!FaDL3sWG>n1ABK&cD@DI-c;zl&J
zzx(A-xa(NBtLUPgE22wiHI6e5H^@>>N?z^yZ{!OqeeReGU7Xt2-4{yzbo*}xjAQez
zOTG0N)Bb_W4=3L~FWfcnx}8<is-Q)n@p!{enBxtE%m1kNQ+>&OV~oddb!_d0y9B}M
z@LS*dba=txooz*}Aj$oC=&Tjrnqpu|*k^S-5EYqB+YLBW9$KPt*^)z^w9@S$bkd>-
zKU9|&;)PdMrO{+}=93qS(Qqr_Rz8#Nd8A{W_v&28%^^l$AK?&VB^}3%w%<=~*?v$T
z*o?x=_s1)-Y3~JO_!`B1-$Imt&P!Qk;EuNFx5XoSb|mEj-=2?=&$qF)OY%XFYKoTo
zvi;jjN@vWRHG9rAWpn4V)U&X{yX&r&bKr(PMFNow^&^?5$>y%N;*DIOF-7aL8`-0-
z`_n)$lezV#hX2*<e$d-j2c|RETm~%yXEN|Av#P8c)#_Ni-3(p#ttE`^Rs^^Sif*bC
zO*iJXz=_zs6q?mY7eo)F&r-uHtE-TA+p<93w*0(H3qqltdEUCRof7x%*+s9(>i+Bq
zEkdiOCac&~jPI4$U079I=>M>v{hZ~fLESM1+0SQ1&01yxkr;lIN){8r?!>l2y8+1i
zk;)xo%GnZsNAR;*eJ_2_9%PngWP;_%F}F_$9Xep#P#KO;+E!V<958$8H+ybGp`XI4
z<EnA4{8@YlZb*##f^{$vTlh^FC*n_l*`2A9!_32KeWL{0a`AHXmh8E%u`#nzRT^?I
zK*jiKUTNe#tznx98}ojSUJ!ay!Fz^zec||JLp6ZB{UqJESxu!fD-)(6ZZ-v<9>&e`
z@moaA(KV8qS|Ebe*s7B?mml*?I>lD)7?b3427}-5(o*R$4;h`AvlcloJ#zf6n6Uet
z;ErKESDw-Q$!;c@kMoQlt$AdcRowf$BlHO}*tc!2xqf^Ew$_MtO|ajdw9_4QCBem>
zq8EJ0Jc-Py5oDx;5Tnvme)aUl<j(bj+$rK4cOql**%|zjj#uvpGHZ}2p&2-nJ1SqT
z$h0DJv%<4rLK7K!`HmowBU6jNOa8$BxW|uF8vf@@o)^Dceq7+4m&N;(JM%s#*d96%
zf!_<i6aJ_5ekLwf5fhTWLx?<i3Yjk|4^?o!FyG;m?ZMU3-*d&hoQx5JU4m>AIy&n}
z$6>$ujT5@_#ymfKA>b9F5=h{Nj0J|aGlzE8`!h$>Wm~`XKjZGdZxBzCHe+V-l#eCr
znDu)_TQ*lt<;%&DrHzc_SdI?pGpWeQRAYNslXphxE5kDPpf$^hQP%r;N&b>0jC*o_
zGFI-1CKI{H`$is?{YI(>CGX@)kn<abO{N4Z_mn+kB&Rt+XPjIa1QQP{cpN#$ldO0$
zE3tmLm(C!k`do7IU*=`xT-_~PJlQW=2r%Y-+N|g^l9Blvte#ywCL$;O0B77|8p2pd
z1om7-nFA`F3$T(?x+xF1wBs?bn-8>057sz;{eFsd`U8|VUetG`sx<EDS$_K6tG@y_
zog?skk6>Bjrw`Se^SdbbX;^$_OeWWP#4!OXf1equ2j@>2xkn}9Go!hi&nM3N!Ax3z
z6UK#5{AEjb^A-DEP&!?ggD=d%)!*2KRlh~<tp+-y_dkP;k!Ynr@zr;6=E7ipK;OR=
zzT6RC`z2i;MYzHlArq~#{O<x=!IfXd|3@Ie<W=Dhfx141@c#|&`V7Lm!DSS-3-~?<
z4d(rc_7v9j2PFSo4*w-^*RG5Ins5?P?SpX5ySp}Bc%CoA$o;|`TxXxSHeB*LH`p1;
zUk&csZShS%#R`aj4Sd&Ti?6hfQFtoh310;6+G63-IqHSK)bdw>yEayQolD$`!)i~3
zYhJ$>T<xdu&5|d+Yb^dhz+KxXzUKO!QTYBQ2iJVRYyTww{T#kkQdu8ZYcJ3{D;+&l
z#H#8xqCMuR)2)@-ow+<dz(I3<&AP>#*`HivdBb@@Yqz%imd|h#T%fw5YUT3EK=ty4
zE9S3Qu`Ezsy>i8ZK=q=9`d_?a;SJp6*Vt0GVpC<^)`0A?<@F8m#L79d9K&j^l{ajG
zxOL`?fG)PrTp8#h>IHOpf-{ykXP7!}B!jG7?8#&_4DBl`0v=<2!af8H19X)q;r*NB
zSWv??eCPoMG7s5ABElXobC?RccgtG1VsAs8If6yWQQoqlNwHkKu?b9dbC3pBZR|Mm
z71eh@I$1Xfl27ip{0A-n|62YFf>g*_gVG&!^MOIyVdYo3qkO3|N3_PIGym!ZFC;Gm
z<=@wVlKUs1&JO9d^p`CCElV$^u8{n6pyVrn(zW|rOaD7d*SwABCk5Gve;sv--YW;{
zy*N-hcHM&TU$bx$4V36p1);CCa2HVTe-EhlyMQ`7rB8g?q&k`g@jnL?{~$0Fp{=Kn
zA-eh+qJM}cLOOBR0Ci?c94LMxQ2b8IzfXL^@u(o-&^gJ%e<n!0R`8*O-ziAj`CY+@
z_yd$aVK>l(!@?sLK51c(g*tmma?e`$oQ1s>zG&eI3r|{j%EH$zJZ<4S7OG*AyCDnn
zE!3R`q8D0NWZ^^$Cs`P=Flu43h0`o7v2d1!Wfsn}FlJ%7g_RcS-U9irdkF+rSh(84
zH5RV3u-3wQ3mYwLvM^!cRtvXT*lJ;$g*z?0)51;*@3!zB3-7gXmxcFPc)x`YSh(B5
zhb?@>!o3!DTX@jIBNjesVULABxA0jDpR=&n!WS((Vc|&&Pg(f7g{Lii$3jisnD1|)
z6itK|SU4XTV!&1}NWT55;N^^c1*4QLx<;Ze6Pz3f{6LV-ei5BWm7gbo%Kwj0m#F+a
z3Y7aNfzk>647AXdfxtfi#s2|T{3n3Y4Sfk1`XFZ@0mc6VR{Zy4#h(Kd|3;wrHvz@J
z-O|5i>EE*S9|HB>GnU_H`M<OLvDBgBe-J2lX9MN#wLrQ1Nz312`8zHDE0+H~(TUen
zg2d~j<-cnA1=P)|PbUJUyIKa6`_}>G{wmRVe;rVATZJR{HK63a1(e)=@kzs9S^gg^
zKaY3BzY;iRCg}^5dmDsPuiqueV6Kq5U*Y=*Q1NX6%Ka|__5N2Z{TZOX<8#8PM~_?l
zgoVYl9n!_U%fkDBl7CqE9P}wHzTfhxYK?Aem4#a^ywk$n7WP>9x`n#)(&*q?*ks{B
z3nx*RiXXF3eO2KPSlDCX>lRL=9TDH@>aMeRn}tSq7ydzuzi6R!%=F$Y3%3f=X51-w
z9%^yTbv6D=HAm9*oiTUz929*qBkTIUL%PcF`7p(_{o?~fKQp>v?>}?OT3@Turr>q{
z6(9EfGyT7Uwb)vwy;rBl{$wm2PG<0@vhGJaZYKB53#bPiN_;TQ5*wT9OAepAxw*DE
zp~L0tOJ89|yeaji{8UAOw?IGq{{PH{j7`i_mnp3FqDBH|SID@4E2YiIx=RoR(ycml
zzKLru?HX2UKQrNFiVVjEy#JN$zb5rt({saJ=Oue@*Ts!nlBYwgf#5W2Q07nqb}pL>
zww9Tl^f=e(JWq|={zttZZW~8xp}}_IvNl$GVl2^Y|07X{F^lKcFNFdvvsl$LsnB;h
zB)gW8`n^KQs@=5K+qng@v;CE=f16rW*!L%`4zZS!uE=)*?|+Q&AQcL?$8n(jmGI8>
zKvtBdrGC-DT0C?5tVC!r%p?p@iEkE=ER<Hda4HN!%Yp#Q5d$mp`A;1hSXmJ6S~Moy
zb(6WVvM29wCP~6=EAfbA;mlfmQ;7RsPyoH~w7krs(N66~(uzml=aE$!5f-gCyE`<4
ztVhU8n-Ri0f1`B@-L#qcH1^|Oz{hDy9Y%N-ZfH%|yK+wB$^fnmEURaEjn%<=<CgN{
zRDDnKQFh^d1v-!0%-JOQ=?jQ*y?NQLdKG?@?B1HVhzr@qf7E=Y_D>R;)Z=|~6)0~J
z&jqyYIxnF0_z^jTQg@1Pf|e0Wsan~Q&jhhhzL6J;Oe6;`?Eh}|)As#X8Xyl-<&&rO
zQe(2Jgs!|(ir2|BQj+i#(96<GJS78fNthD=)>E=7(;ExY=XK00ocp^iAHd7X)QKrQ
zsl01f6*SKin@cgNA@~AI^7D>rWe*p%BAHKsOhn9z>yQ(0I+5>xiti|OZQdfG=)952
ztYKD1C_G1D;GIsku7qfovRK9%s4haCs!O8Y*(_QcKa;LF_ueI>0?%Tj3PNJMFH^fR
z;a?p;+Z7v=%L&Q5t=C*nDP=BLd$4cP9Ij^5*}@!pob`?Q^ec*CS7NJ?I|xKpd)Ak?
z2k#h@JSSM6nRtgqm&MF^M5ve5)*#E;Ops~jZDtNyrR#3dF^G8PZ1*AmC!9^3Afz<)
z88eF~<p#Q0nf<AXPwsqc3|eC*qTW0Vq#^UId+FDy4VHT}b0%%%{$#8wCVe8A2YhY`
zcj#1}B|nl}2{Lle?JJgh&JD<hCwPN>mb}bvgye@aazl2Ng^vDje#d;g&)R3jP3Ae|
z?(-hazk4kXMhlrSjpV-wn9@ab$tj-t7A~$l23o1KG*|14!X_i={1iTomo=uQ3uo3(
z<(~4S-1fVtal!yJXPkQuchFBCIzQ_7S?;@7dT)<BU#gg9&1lZnb7`kCt$m~_kIv{U
zy_pUHD&C88@K5F7f0ctb<>1?L@b(=1>pA#CIrxDbya(LXGYbC;IsAU`2+63rMSR=w
zTOZIRTgw|ZG&R=gjs@MRb#}-34%xlR{#Uu;?b>uVVQDLA_ByZTI&O8~zAqiBD_Osk
ze>-OOXx#FarpAW#TxXVL58k4yz~@B6&F(E|+_bqahiA%x?t@~=!`vBhJy7#ZUj~k0
zT=6|Y#ubM|=Yv<0VKq;6yM-Sm2{qpN1W@x*HG(u6pAnt++bv)7MtV>Ec<t%jME;V$
zEkNB>p}wHzU9{dO`W&F>D}Z`$jfD}yp?<u+pP(Cu+#{Sa%obPQj=hoZo0>JdbjE1=
z@ha0Ys=J5l$D<Q=R%Z;}w2IbWDuV^|{0h-T*;AO98RyuZOZ&M)*PO+bJj7mz!en0_
z<iy4FSN<Zr=eqdZw-Yaf_v{bv8JKeV=CudR8Fg>M=zrOE8@zsy4bLEjI{JHf7^TNx
zdM@Ua#7^6Ndd(fq>&{FxB3@TXQKQ>OfTK>O%BtQ--D#lEIP~skHktR6N;-2cn0c={
z-@NDrJLgQOVdV?_@@JXeXZw9}!&6ST*Pm`9@jV^HGwq3FI9Kd?XmrS}!;In{PpH3}
zPnS<gWWIqJuMOE4NdmFCkX><!2}Wm$Jw2`HNVL59T4s+6g9aU$#*UeVsDsUD>rPBd
zaRA!svLh{%Q+@q~=DpOb?3^p>Y57p<?QqxpypG%Q!d=aIoFVv9>A?1v)QY7}PdTM?
z*1Ye;`#EH<`;E>V`D3E-6Gclhbl1v2VlG$QU(!F5elUB@*zhGH8JbN&myw?@4R>9a
zI$gFuaXj3$-_tZxp2n*!sCOgq8Up<<m~a~B3&MLYKzTgUa(-uWABDppiPzcFKnb}4
zQva2yLllmEFNF}B|Ndji<8LMRUo)i#QMhAINp5n-ZGYd<+{=!|bHWwRbTmH}PyXqg
zEr&ar(M$i+*e#EG@uX-CDo=`CzVm(pI;%tcpNR`ljUyNKPj<r+&)Hkw$EKK$P-{o|
z^)@gn>&I{AV|nRkw$v3e8i@D`9#sQ7`z{XeIk#hJkm{i03x8sJ(Z>=qZmnb|QMm0f
zJ`aSeNUw0)cZAICY57aUP1T_&+c#RCl6NoZI~+vS9aT41+<E=eEk~3tzveWw{7zg*
zEKMEu+`yB>KO^y1i6i`9-EthVL4PRD!^k%OG(PuVZavDKDVKQ31;c!=a9az*RqG5c
zw7k?;3!zitxU}?GXWxgw2oE@0ZV8nM6MNT`^Q|%}xv-FJXz}F70xiEOJ!bY7na#WX
zKb6k(FlVBM(r2pQa?9(x)MwQpQ_oOUou!5wO`kEj<0bW@TwkhK5>_`Ra*L-56ooVo
zTY_DV75|PP`b|5=1k1-w$mgEu&|wBsa-$a8i5<=znrL(ON;i<^(HOm>_OS<BDvI%Y
z$%M$d?73BsK-OC8Ret^_v;1eF$KHj18ouWCh6|JYmwwx>cj1@8>%m5l&4kZ)-uh~I
zr_R7v+HHkbNQBqv{fs^!Bhfp?+~$o$z5c4g(1aXII>waouN@to&>BP`ZQ7OY_U`py
z)i~cJ-HXOA@f`{_4RM7@9e=H74|#Wy|K0NO5kw*iBl4TAy!*zR>?fWGy&RcdWL8@l
z^s`nm_%&nbb?{>Jg+45Qvw4KG%#tC7%E3AgE?aPbgUb%_?G8@}RgMp)yz|YtZQRR6
zQmr!iNOP>ZGww{^O!{rR;Lot((7i&D8ZS>MpK0w+hTwSSzxg=)7-`{*;xD6o<i<?G
zchgr^ADOOeK*^)D$;VE{+N{D8>n!IQkoj|II2DTI`TWM5Nv;I0+;ih_$vHRlqIfd7
z<M4^d$q#2FC!0GCUyu_%=U(nOyd1fAY(9{iE(~#={poU=1iK%a(nWNaE_CfPapf@(
zgE^XU_(?KxEB=l&4sT=(GT#Lr_kEA@E@S-kKZkL+nQ$a@Dw`Uo5{-<}I9&P38Rf-m
z9Rd_yj#VB}TcY<hUh2d;_f%hXWA*98Zv^&W)jkMM0G*M0?bt#RN$rF9cLHNR{4Ve&
zaOeIv!JX0j-^K3o@xSkwK=J<<wg-L$DEEH^bVmFGSk<)=p!oj>=#2Qkz`FWh{Ns)(
zI`(%t_?zIa9gw_wxvmWmeja`)V=A45EAH#SRc{M_A9ydg>S*DYfXB$xs+WaFfv#>9
zJ_p>@rNYfXb$tL$mjxS|&TgiG^RT?P02}o-a|*gg2ee@@T6Jsl%BE&{Vi-d%+JS+H
z_*QH|(-$~<3S18YH3^IJAZe6^3||l6-g#Mi!8`#o6BL7|CEOguW_ytl(40gC+-M%Q
zCN?z$=Iif<x<t(lHHr20E?y!ucog3w>8^T2a|KknX0G5epyn>VVd;Nw=?{rM&f5zv
z`DZP?52(2d?eP{}eH6_(NT*D6?d29-^||OPE&U6Yt~n6VrL(2;rvA~=AF}kvM5jSN
zX6esb`fo&MZT(eCKW*vfku9`lFI{-~`vIWbpCkIE<S#*VVO9we*-wz)BzGfFa?-=o
zTK*S+qTdcQ;j{GbSo-~zuFXM;XM}XnTuRKsdJA`2c&~+fEqu<xcPw;kyz>+v+>uV4
z;5G|&E|>5}EPUO<C^XS4Ev&V0w}m|xo)RRi&56cAHyVw!Mq4_2&ZzGr&BqU!GtKST
z{fWMTnOl-^(;<w8u1Low0>-5;N@*Kfic^&<^7H)5FP&NGmVfPkp25!<=31C*NY?W%
z+xU|Tmp0lZE=<QJ0nRb5n*oa7y}tgF@7;JMf}fM*F-Cm@t;2Y_{<=}yyHGm<Ifh+_
zt-xmb?QsSyj8}B)w(8zm@i1gl&-^#<Cw|Yx6R7yhP<#jVhmMe+W6&tJ0cAa<O+I!q
zmf{hhX))%6g$}qhoC-nmBgvH@BllcCQSLc6cr-l0+<qciX;l5hi{-e_I5fAPsJhkP
zr*L7&?I-4+OZ|s?N|$%*C*FyBUmV6?`EQG|;g;c%+U}A1iIsehFAd|Kk7OR@zB7Lg
z{Y08IV^l`fuTa`KqkiIt9RgHdT$qDb=HTk@ti!52%e@AmGbS(FN_ai}0RJsU!|4Ry
zf==+Fs-@S@uUfmbq5^f`wJYXdU$t;;fTfYFqU^GohRt;=s;h9&fBBJ5pl)+wQ?n8A
z^1RwM^@r8Asg9C9)yD-P-U1ZA-txCuzWSrOqb~wfn^SI~<kYs*#T$rO!!2&{V8pg%
z<~5_%|7o-t(zPw)P07V$YnZUgr&|9D&F5;~|4>jHV|D7&@0pTEe*ivHj|Ip~kj&0;
zmi-27<X4&HgEtbFNeF>_JD<q@UnX{U1||L5yp~fp+v!Ymmj<)6I(<&ljYaLRB&LMB
z&gHDLQZ@*O%Z?<9`mf-wkFN5I@_0GiRd6vA#)Wf#(Q>l1+dmK7%|TQ*PdSpA8TRxQ
z%seUKC`gy4=ZB`wn0kF^?5XtU^QSiFrxzDY{dmFHQ#X%2ascJ!1q(hBDPDOC8q+Nw
zu4>p=)4VA%Yx<n&Gp{afF~r$ZJp9c2MwKUBJB6B?F`|`VBUr~%xzIO{VXwlft=gf(
z{SSHP<gbI&gk6F4=5exT#NXzh##uCe5mP`5?78r!yxq$yJy@fBV%%MC+<mt_Wl}*1
zOs}m;)C8vAvUzi0`ua^9Hq@bJK7He+MBVg7OIBXJIZ?CzbAjp2b&b>O>et4bYc|v=
zaHBJ7Z&X)Nof;G4Ut=C;ltwa_V<qR>kuo7Z<LYU}Egw6Q+%#n5gwkI|?y0SEMm*Ws
z7CQQR5q-v?i=pY+7NI~b$iqH47e3W%YA>8Aqf8frh^91<oWh?w-=My>#>mb%fBk-n
zr$ff{jaA>u9l578l>07CcnrJ_qg)TxIQJaxpr1ap9r1JJzKgy0_LxCFice&HX6U}D
zkZDgPqB3$JDavpq5W%W^2-nythE>@RJ_Xo>Re2CT2dMZf9|+G@m}&{!28+y5&Aua=
zIjos8hnwrXqn!N*6-RJOb+PJ2GY+t@*1}yDHYXS+x{8^_+7avKxwA*Trdw`5p2DCU
zldGHQtvOMd6^8fB4eyx|Zy!iZj?ZPa^>E_+{=d{3P<-yGmIzB{d*%l_ZevBNImiMC
zYiHbu^oEwrOdZWLXCZlLm%Ot5el00czlXG}!~%@gYvL*Vx`49{wNCQ8_+f+(q~6Hr
zw&`9v|9PQq9OBjz39C7Nq9at1vdf455lGG&Ez+zZ#*<n^^wym7;>mf}2U={~BK{-F
zen#Ztl5X3!u-0hhI?4k<EjW5>Sh^Q2#NiUXVa}WADEewgsM;-}J*H?Iez>bA+|}Jt
z@YRl@qsYYfy{y9lIVLLai77|+9S`O8ob|~9MRFXIyY8a;$h85coKru$Iro@bS6MiI
zv7IhAWx9%Y)?rP3Zr>N)iJgzlj)meH3Ym9WA@^dPU#c7K#;T~O9+DC5eryRe7hci!
zVykoHdZ5Xuo-yXX_?SukZ^cDcbq&!S)HZDu!5XEBOzxN|c3vP5fljy2)QECRb@61Z
zUU&8IBR;nvXVNft%ycHX66>BDGf6J<9V}1o=8l>6A~#%Hr@pyANSgog8;5?@%DLM9
z1dLvvpbJABn!l}EN4mtIDP2T&>5|*l9l_zzjF}QNCo%jUY0UI64QmSjoN@7RxPyNB
z(6-LS)|38^)NxaNpfL_pV43nRT=}jOJKyr7KxZ_jy4E2;<<%Q=@YUeGSg&pM?#@sK
zP(2{`KL>PmfbiSEUHKQzM3)*oHLT0MncmEttoOiV>{*SsaAnZUt#QT9-442FAm>g3
z!gUWeNJjWJa2(^S2Z6eCeV^d?Kp+BC+g)v8t%YqCn)l&9VDWAXe=bNq+p@veu#cu~
zzh?Apd%ewCv+!%Uw*3rqdPzxhA79IjcIvG#-K^8)LhQIu(HeNhql5BMjjF$oBnb%*
zPon8&&}EM7j+--xeG`hP3o$4wPyN=-_<4ugP3j+O+t$>d($_tL^F~2p?jLnxR*WWo
zfRl60atVh%hs#$)V;vPCg&@ToB&@lAY&qnPbbjyV2bH&7TW97?y!pXTu~xlCjba)6
zdDvELGu9hZW!Kfs`87)>#Dbq5dU}n@)K<NNQF0pdU%dUJsF=7YKEt(tuX?dG|BAm%
zZu{3neXDXdQv2uM^DcK>8metld+FNAGs%@8qnz#9Kgl^aARC@wZu?h;ocwS`Zph}g
ze`gx&<+gts>+N)o0bLk!+rMtoWg`5M+P{;yH=6cO=WeKe9;yA)9Pa(T@F}jt89)8c
zq5UJdj8VB&dvm$P1=PN&>^h^oxWpkq;cIg6wK=#c@0KR{_8h+E;##qiGwmIXfEqid
z{1$H1jW(;8i)*QA<cglAhK--ue0Gf;u2kI0<vfX+jqBZIKDm4HeUpoB_R&Ym&Npfp
zyKxKG{8Tk;wtM#}$TWjy?ooM8bB|XFLR7y%y3$H7%{A5t(g{=iH7A({YR=NkMIs*&
zoi-|F;Wk0?RC7Y}LfLk4r15Uq%u-rTnUVJ*y8P<e#Ias4y!CA6;@+hy9`&>qQ5}_0
z9jNl-@~ju`?5nO$P#%_Crf%ce@g(h@Kg6@Y4pd$j?u?V020`wXScc?=tJ{XmV_A6z
z<c3UcUwl2Zg@)t(IXOYwZ83~OkRF~CM!NYX9x7An=exM_80baLUk;sn;`xoAKC~|K
zbLGB2B*OhZ3MaGrjQZ}HACpl!UVwz!Iz2ml#vuIF0hb0IKWNI1LLqxW;MD=uHQD!H
z9dLzXy?+HETVQ>qcxb`S9LeE7u48arF|J`_L!zm%CUfo2h-J?$F^{6`ogywWuI%Nm
z1H5(s=6gIRp810BMWKBU=b|&=BFf6oGM8iZ-CZs#7tv>w4`g!7@R{Ut%dq4|Q-(Jg
zU$TD+lgwhQo?Y0Rc$Oc|xbP`Yt9&}6bNN($MN>T{IpMi=!oAQ&GZ%e70q8_lWliqL
zJ*8o8ouD%VuYm51i-*G<^wZz_I>FW4o^PrnXabE<I-0rUOrcxPDLD;^hMGq1;iD*5
zQxM~unl~U9!K$s?P?M<7wv4{HU{>QwOG-+7|8wSW8CU6?S<qxgZX4GqKp0m(bLWE1
z@)`px=0x+u|FHjOy>IM`B$(_h<+>=%ox0^WGoSlUJwJQd<M)&vvwZFJ(H4S-j=WhL
z4doqm3iz41UAJ$!iaFkCh*tWBhuXr-VqL8L4R(%{X{4CYy*l}9D>ey=#ykw|=Js}+
zq|U_wbD5Aw%?KJdnGzndVfnq%byr@TWKuE<MJvHZu#P91%47_CAyy`eU5#CbZN)Oz
zYVNnr+>^c3)8^K@h7Sy3jd_<kPOE4`IwyZ-`+yZE#YJ|wF=8)tXCy0=J4TF9+#=AG
zC6t}zmg<PfSe0{Ew?>5cj7vk+kCGort^^r5;l_w^&$$8F@C0+mh?+7Pt`5!}BQDJe
zpF?xUh?+O+lt<RMFvP+Ab#RPyDTbzW5#6OrZXMi<d!rd6>f8{;d89Go19Xx6;~^Ih
zf-uPV=|k&aTQS);{v+l{l?P;0Ry9Ub`Hc8*(PLQA#aEl`jPhowLx93HHd=>m#Y*1w
z`#{Z@bB!LXk-S&Y)62`84VOJ7?uM2|offBq;nuEg*|4d$wqd58Y8$rbDSK?(Sxu69
k`bj}N*L>_aGRF6T(kDG4=o_!8eekbWD(u4B1o__o9}7H|IsgCw

literal 0
HcmV?d00001

diff --git a/linux-x86/gnu-efi/lib/libgnuefi.a b/linux-x86/gnu-efi/lib/libgnuefi.a
new file mode 100644
index 0000000000000000000000000000000000000000..95e85389d9079399b316ec452e8bc8518904a4ba
GIT binary patch
literal 1880
zcmbVNK~ED=5PnNnSW2@NY$Aw<B{YapmM)YEh8VCS8VLy^YD}~&b(Jb@q1{cy5Fja4
zHX9NS9{d%?gLp6=8V%qPdol6gfs+w1@q)e8ncaP`kPy^K-hOXpzBluB-@MtnPB|4F
zz2I&Z_KMWncCI5B47P>@Az-?kPeBN_Q2wx+5aNQ7AcS4V5lJay$*8O<B(12A;^Sm2
znRtjuOh+Upx3-8$%;?M_1p<&_=NSqGQERu-3d8Q1p1#Wr!$2ZS7)ZLS5wd10LDStx
zDhNlZCJssYTQ`k9zt3Q@IrYZE04HrrTT*eOe&H<=GKFL6wM?N>D>GET*EPZFpEDmg
z<6;5WzD%J?`({i!Y}#ga`{;{Yc1!J_%c;lTLH5~u`dZ}f$Avcy7|)2Y8}FrjwmAJA
zvU>F&zrQXns10Oxn&q@oqm=o?aLgCxXSO)ADdp{@;Ft1qIc>>|xA6)C^@hXeg~p)~
zEum`7eX)d`N(w<SB(^q5nrUo1ZRv#gkPpH<y-t`Zj;Zyq>^$tO6Kp3<4<Sp4-8`2q
z3G<%ku5RA@j4g?{dCy9i=T^IUcKJ$0(!Iia!mB*jz09*c6@-ZC$+#+y0IDeqN9jye
zo~T5;FRL;UN788`Mw9Wlk^oyGsVZV`|4>s}m7|Y|2&XS9qmc(GIj-27`3tB84jyf(
z&Fum--@(?sHr4?m4@(iHV8PClwP&XQu`&+hodpiY3&23ZcxTL+^*|qvHXAJ~A@yi<
z2vx6w4d*4c&kxFN2aoQr2W;gIdjK4`U$o&jKpyIqFz7qLluSXqL7dn^^Ez{)YaSLY
z0^+sBI2aGVA;x#cs|H6k*r?EWRHx{)v*cHi+7b8OP}J$$TP)X}jOah&Tn;)tb;@T6
zZ!@q4s_=_Cno5-H_8tNJC6LbQLAy=ou%6Qv>abhe;XUW2y%*YZ%HV6lWoPvo9s0*4
zr^h^ZblIy9_@rEM-MHlE&}-Bf6Ra`G88MF`d&_eg(^Zsx|8mFdw1>j}yMy~|cdWv*
zN2!B>=Sa_g42=$<y#06QAm0AkL>}HJDzs)0ofYvK4C7$KQ^!g;s5S*yR0Do0G#=F{
eI_>{cn|Md4V6EYMov;mN?ODYo4(|Wcx&Ht=cK+7@

literal 0
HcmV?d00001

diff --git a/linux-x86_64/gnu-efi/include/efi/efi.h b/linux-x86_64/gnu-efi/include/efi/efi.h
new file mode 100644
index 0000000..e9de37b
--- /dev/null
+++ b/linux-x86_64/gnu-efi/include/efi/efi.h
@@ -0,0 +1,50 @@
+/*++
+
+Copyright (c) 1998  Intel Corporation
+
+Module Name:
+
+    efi.h
+
+Abstract:
+
+    Public EFI header files
+
+
+
+Revision History
+
+--*/
+
+//
+// Build flags on input
+//  EFI32
+//  EFI_DEBUG               - Enable debugging code
+//  EFI_NT_EMULATOR         - Building for running under NT
+//
+
+
+#ifndef _EFI_INCLUDE_
+#define _EFI_INCLUDE_
+
+#define EFI_FIRMWARE_VENDOR         L"INTEL"
+#define EFI_FIRMWARE_MAJOR_REVISION 12
+#define EFI_FIRMWARE_MINOR_REVISION 33
+#define EFI_FIRMWARE_REVISION ((EFI_FIRMWARE_MAJOR_REVISION <<16) | (EFI_FIRMWARE_MINOR_REVISION))
+
+#include "efibind.h"
+#include "efidef.h"
+#include "efidevp.h"
+#include "efipciio.h"
+#include "efiprot.h"
+#include "eficon.h"
+#include "efiser.h"
+#include "efi_nii.h"
+#include "efipxebc.h"
+#include "efinet.h"
+#include "efiapi.h"
+#include "efifs.h"
+#include "efierr.h"
+#include "efiui.h"
+
+#endif
diff --git a/linux-x86_64/gnu-efi/include/efi/efi_nii.h b/linux-x86_64/gnu-efi/include/efi/efi_nii.h
new file mode 100644
index 0000000..ba7a5b2
--- /dev/null
+++ b/linux-x86_64/gnu-efi/include/efi/efi_nii.h
@@ -0,0 +1,74 @@
+#ifndef _EFI_NII_H
+#define _EFI_NII_H
+
+/*++
+Copyright (c) 2000  Intel Corporation
+
+Module name:
+    efi_nii.h
+
+Abstract:
+
+Revision history:
+    2000-Feb-18 M(f)J   GUID updated.
+                Structure order changed for machine word alignment.
+                Added StringId[4] to structure.
+                
+    2000-Feb-14 M(f)J   Genesis.
+--*/
+
+#define EFI_NETWORK_INTERFACE_IDENTIFIER_PROTOCOL \
+    { 0xE18541CD, 0xF755, 0x4f73, {0x92, 0x8D, 0x64, 0x3C, 0x8A, 0x79, 0xB2, 0x29} }
+
+#define EFI_NETWORK_INTERFACE_IDENTIFIER_INTERFACE_REVISION 0x00010000
+
+typedef enum {
+    EfiNetworkInterfaceUndi = 1
+} EFI_NETWORK_INTERFACE_TYPE;
+
+typedef struct {
+
+    UINT64 Revision;
+    // Revision of the network interface identifier protocol interface.
+
+    UINT64 ID;
+    // Address of the first byte of the identifying structure for this
+    // network interface.  This is set to zero if there is no structure.
+    //
+    // For PXE/UNDI this is the first byte of the !PXE structure.
+
+    UINT64 ImageAddr;
+    // Address of the UNrelocated driver/ROM image.  This is set
+    // to zero if there is no driver/ROM image.
+    //
+    // For 16-bit UNDI, this is the first byte of the option ROM in
+    // upper memory.
+    //
+    // For 32/64-bit S/W UNDI, this is the first byte of the EFI ROM
+    // image.
+    //
+    // For H/W UNDI, this is set to zero.
+
+    UINT32 ImageSize;
+    // Size of the UNrelocated driver/ROM image of this network interface.
+    // This is set to zero if there is no driver/ROM image.
+
+    CHAR8 StringId[4];
+    // 4 char ASCII string to go in class identifier (option 60) in DHCP
+    // and Boot Server discover packets.
+    // For EfiNetworkInterfaceUndi this field is "UNDI".
+    // For EfiNetworkInterfaceSnp this field is "SNPN".
+
+    UINT8 Type;
+    UINT8 MajorVer;
+    UINT8 MinorVer;
+    // Information to be placed into the PXE DHCP and Discover packets.
+    // This is the network interface type and version number that will
+    // be placed into DHCP option 94 (client network interface identifier).
+    BOOLEAN Ipv6Supported;
+	UINT8   IfNum;	// interface number to be used with pxeid structure
+} EFI_NETWORK_INTERFACE_IDENTIFIER_INTERFACE;
+
+extern EFI_GUID NetworkInterfaceIdentifierProtocol;
+
+#endif // _EFI_NII_H
diff --git a/linux-x86_64/gnu-efi/include/efi/efi_pxe.h b/linux-x86_64/gnu-efi/include/efi/efi_pxe.h
new file mode 100644
index 0000000..d24251f
--- /dev/null
+++ b/linux-x86_64/gnu-efi/include/efi/efi_pxe.h
@@ -0,0 +1,1743 @@
+#ifndef _EFI_PXE_H
+#define _EFI_PXE_H
+
+
+/*++
+Copyright (c) Intel  1999
+
+Module name:
+    efi_pxe.h
+
+32/64-bit PXE specification:
+    alpha-4, 99-Dec-17
+
+Abstract:
+    This header file contains all of the PXE type definitions,
+    structure prototypes, global variables and constants that
+    are needed for porting PXE to EFI.
+--*/
+
+#pragma pack(1)
+
+#define PXE_INTEL_ORDER         1   // Intel order
+//#define PXE_NETWORK_ORDER         1   // network order
+
+#define PXE_UINT64_SUPPORT          1   // UINT64 supported
+//#define PXE_NO_UINT64_SUPPORT     1   // UINT64 not supported
+
+#define PXE_BUSTYPE(a,b,c,d)            \
+((((PXE_UINT32)(d) & 0xFF) << 24) | \
+(((PXE_UINT32)(c) & 0xFF) << 16) |  \
+(((PXE_UINT32)(b) & 0xFF) << 8) |       \
+((PXE_UINT32)(a) & 0xFF))
+
+//
+// UNDI ROM ID and devive ID signature
+//
+#define PXE_BUSTYPE_PXE         PXE_BUSTYPE('!', 'P', 'X', 'E')
+
+//
+// BUS ROM ID signatures
+//
+#define PXE_BUSTYPE_PCI         PXE_BUSTYPE('P', 'C', 'I', 'R')
+#define PXE_BUSTYPE_PC_CARD     PXE_BUSTYPE('P', 'C', 'C', 'R')
+#define PXE_BUSTYPE_USB         PXE_BUSTYPE('U', 'S', 'B', 'R')
+#define PXE_BUSTYPE_1394        PXE_BUSTYPE('1', '3', '9', '4')
+
+#define PXE_SWAP_UINT16(n)          \
+((((PXE_UINT16)(n) & 0x00FF) << 8) |    \
+(((PXE_UINT16)(n) & 0xFF00) >> 8))
+
+#define PXE_SWAP_UINT32(n)              \
+((((PXE_UINT32)(n) & 0x000000FF) << 24) |   \
+(((PXE_UINT32)(n) & 0x0000FF00) << 8) |     \
+(((PXE_UINT32)(n) & 0x00FF0000) >> 8) |     \
+(((PXE_UINT32)(n) & 0xFF000000) >> 24))
+
+#if PXE_UINT64_SUPPORT != 0
+#define PXE_SWAP_UINT64(n)                  \
+((((PXE_UINT64)(n) & 0x00000000000000FF) << 56) |   \
+(((PXE_UINT64)(n) & 0x000000000000FF00) << 40) |    \
+(((PXE_UINT64)(n) & 0x0000000000FF0000) << 24) |    \
+(((PXE_UINT64)(n) & 0x00000000FF000000) << 8) | \
+(((PXE_UINT64)(n) & 0x000000FF00000000) >> 8) | \
+(((PXE_UINT64)(n) & 0x0000FF0000000000) >> 24) |    \
+(((PXE_UINT64)(n) & 0x00FF000000000000) >> 40) |    \
+(((PXE_UINT64)(n) & 0xFF00000000000000) >> 56))
+#endif // PXE_UINT64_SUPPORT
+
+#if PXE_NO_UINT64_SUPPORT != 0
+#define PXE_SWAP_UINT64(n)                      \
+{                                       \
+PXE_UINT32 tmp = (PXE_UINT64)(n)[1];                \
+(PXE_UINT64)(n)[1] = PXE_SWAP_UINT32((PXE_UINT64)(n)[0]);   \
+(PXE_UINT64)(n)[0] = tmp;                       \
+}
+#endif // PXE_NO_UINT64_SUPPORT
+
+#define PXE_CPBSIZE_NOT_USED            0   // zero
+#define PXE_DBSIZE_NOT_USED         0   // zero
+#define PXE_CPBADDR_NOT_USED        (PXE_UINT64)0       // zero
+#define PXE_DBADDR_NOT_USED     (PXE_UINT64)0       // zero
+
+#define PXE_CONST const
+
+#define PXE_VOLATILE volatile
+
+typedef void PXE_VOID;
+
+typedef unsigned char PXE_UINT8;
+
+typedef unsigned short PXE_UINT16;
+
+typedef unsigned PXE_UINT32;
+
+#if PXE_UINT64_SUPPORT != 0
+// typedef unsigned long PXE_UINT64;
+typedef UINT64 PXE_UINT64;
+#endif // PXE_UINT64_SUPPORT
+
+#if PXE_NO_UINT64_SUPPORT != 0
+typedef PXE_UINT32 PXE_UINT64[2];
+#endif // PXE_NO_UINT64_SUPPORT
+
+typedef unsigned PXE_UINTN;
+
+typedef PXE_UINT8 PXE_BOOL;
+
+#define PXE_FALSE               0   // zero
+#define PXE_TRUE                    (!PXE_FALSE)
+
+typedef PXE_UINT16 PXE_OPCODE;
+
+//
+// Return UNDI operational state.
+//
+#define PXE_OPCODE_GET_STATE                    0x0000
+
+//
+// Change UNDI operational state from Stopped to Started.
+//
+#define PXE_OPCODE_START                    0x0001
+
+//
+// Change UNDI operational state from Started to Stopped.
+//
+#define PXE_OPCODE_STOP                     0x0002
+
+//
+// Get UNDI initialization information.
+//
+#define PXE_OPCODE_GET_INIT_INFO                0x0003
+
+//
+// Get NIC configuration information.
+//
+#define PXE_OPCODE_GET_CONFIG_INFO              0x0004
+
+//
+// Changed UNDI operational state from Started to Initialized.
+//
+#define PXE_OPCODE_INITIALIZE                   0x0005
+
+//
+// Re-initialize the NIC H/W.
+//
+#define PXE_OPCODE_RESET                    0x0006
+
+//
+// Change the UNDI operational state from Initialized to Started.
+//
+#define PXE_OPCODE_SHUTDOWN                 0x0007
+
+//
+// Read & change state of external interrupt enables.
+//
+#define PXE_OPCODE_INTERRUPT_ENABLES                0x0008
+
+//
+// Read & change state of packet receive filters.
+//
+#define PXE_OPCODE_RECEIVE_FILTERS              0x0009
+
+//
+// Read & change station MAC address.
+//
+#define PXE_OPCODE_STATION_ADDRESS              0x000A
+
+//
+// Read traffic statistics.
+//
+#define PXE_OPCODE_STATISTICS                   0x000B
+
+//
+// Convert multicast IP address to multicast MAC address.
+//
+#define PXE_OPCODE_MCAST_IP_TO_MAC              0x000C
+
+//
+// Read or change non-volatile storage on the NIC.
+//
+#define PXE_OPCODE_NVDATA                   0x000D
+
+//
+// Get & clear interrupt status.
+//
+#define PXE_OPCODE_GET_STATUS                   0x000E
+
+//
+// Fill media header in packet for transmit.
+//
+#define PXE_OPCODE_FILL_HEADER              0x000F
+
+//
+// Transmit packet(s).
+//
+#define PXE_OPCODE_TRANSMIT                 0x0010
+
+//
+// Receive packet.
+//
+#define PXE_OPCODE_RECEIVE                  0x0011
+
+// last valid opcode:
+#define PXE_OPCODE_VALID_MAX                    0x0011
+
+//
+// Last valid PXE UNDI OpCode number.
+//
+#define PXE_OPCODE_LAST_VALID                   0x0011
+
+typedef PXE_UINT16 PXE_OPFLAGS;
+
+#define PXE_OPFLAGS_NOT_USED                    0x0000
+
+////////////////////////////////////////
+// UNDI Get State
+//
+
+// No OpFlags
+
+////////////////////////////////////////
+// UNDI Start
+//
+
+// No OpFlags
+
+////////////////////////////////////////
+// UNDI Stop
+//
+
+// No OpFlags
+
+////////////////////////////////////////
+// UNDI Get Init Info
+//
+
+// No Opflags
+
+////////////////////////////////////////
+// UNDI Get Config Info
+//
+
+// No Opflags
+
+////////////////////////////////////////
+// UNDI Initialize
+//
+
+#define PXE_OPFLAGS_INITIALIZE_CABLE_DETECT_MASK    0x0001
+#define PXE_OPFLAGS_INITIALIZE_DETECT_CABLE         0x0000
+#define PXE_OPFLAGS_INITIALIZE_DO_NOT_DETECT_CABLE  0x0001
+
+////////////////////////////////////////
+// UNDI Reset
+//
+
+#define PXE_OPFLAGS_RESET_DISABLE_INTERRUPTS        0x0001
+#define PXE_OPFLAGS_RESET_DISABLE_FILTERS           0x0002
+
+////////////////////////////////////////
+// UNDI Shutdown
+//
+
+// No OpFlags
+
+////////////////////////////////////////
+// UNDI Interrupt Enables
+//
+
+//
+// Select whether to enable or disable external interrupt signals.
+// Setting both enable and disable will return PXE_STATCODE_INVALID_OPFLAGS.
+//
+#define PXE_OPFLAGS_INTERRUPT_OPMASK                0xC000
+#define PXE_OPFLAGS_INTERRUPT_ENABLE                0x8000
+#define PXE_OPFLAGS_INTERRUPT_DISABLE           0x4000
+#define PXE_OPFLAGS_INTERRUPT_READ              0x0000
+
+//
+// Enable receive interrupts.  An external interrupt will be generated
+// after a complete non-error packet has been received.
+//
+#define PXE_OPFLAGS_INTERRUPT_RECEIVE           0x0001
+
+//
+// Enable transmit interrupts.  An external interrupt will be generated
+// after a complete non-error packet has been transmitted.
+//
+#define PXE_OPFLAGS_INTERRUPT_TRANSMIT          0x0002
+
+//
+// Enable command interrupts.  An external interrupt will be generated
+// when command execution stops.
+//
+#define PXE_OPFLAGS_INTERRUPT_COMMAND           0x0004
+
+//
+// Generate software interrupt.  Setting this bit generates an external
+// interrupt, if it is supported by the hardware.
+//
+#define PXE_OPFLAGS_INTERRUPT_SOFTWARE          0x0008
+
+////////////////////////////////////////
+// UNDI Receive Filters
+//
+
+//
+// Select whether to enable or disable receive filters.
+// Setting both enable and disable will return PXE_STATCODE_INVALID_OPCODE.
+//
+#define PXE_OPFLAGS_RECEIVE_FILTER_OPMASK           0xC000
+#define PXE_OPFLAGS_RECEIVE_FILTER_ENABLE           0x8000
+#define PXE_OPFLAGS_RECEIVE_FILTER_DISABLE          0x4000
+#define PXE_OPFLAGS_RECEIVE_FILTER_READ         0x0000
+
+//
+// To reset the contents of the multicast MAC address filter list,
+// set this OpFlag:
+//
+#define PXE_OPFLAGS_RECEIVE_FILTER_RESET_MCAST_LIST 0x2000
+
+//
+// Enable unicast packet receiving.  Packets sent to the current station
+// MAC address will be received.
+//
+#define PXE_OPFLAGS_RECEIVE_FILTER_UNICAST          0x0001
+
+//
+// Enable broadcast packet receiving.  Packets sent to the broadcast 
+// MAC address will be received.
+//
+#define PXE_OPFLAGS_RECEIVE_FILTER_BROADCAST        0x0002
+
+//
+// Enable filtered multicast packet receiving.  Packets sent to any
+// of the multicast MAC addresses in the multicast MAC address filter
+// list will be received.  If the filter list is empty, no multicast
+//
+#define PXE_OPFLAGS_RECEIVE_FILTER_FILTERED_MULTICAST   0x0004
+
+//
+// Enable promiscuous packet receiving.  All packets will be received.
+//
+#define PXE_OPFLAGS_RECEIVE_FILTER_PROMISCUOUS      0x0008
+
+//
+// Enable promiscuous multicast packet receiving.  All multicast
+// packets will be received.
+//
+#define PXE_OPFLAGS_RECEIVE_FILTER_ALL_MULTICAST        0x0010
+
+////////////////////////////////////////
+// UNDI Station Address
+//
+
+#define PXE_OPFLAGS_STATION_ADDRESS_READ            0x0000
+#define PXE_OPFLAGS_STATION_ADDRESS_RESET           0x0001
+
+////////////////////////////////////////
+// UNDI Statistics
+//
+
+#define PXE_OPFLAGS_STATISTICS_READ             0x0000
+#define PXE_OPFLAGS_STATISTICS_RESET                0x0001
+
+////////////////////////////////////////
+// UNDI MCast IP to MAC
+//
+
+//
+// Identify the type of IP address in the CPB.
+//
+#define PXE_OPFLAGS_MCAST_IP_TO_MAC_OPMASK          0x0003
+#define PXE_OPFLAGS_MCAST_IPV4_TO_MAC           0x0000
+#define PXE_OPFLAGS_MCAST_IPV6_TO_MAC           0x0001
+
+////////////////////////////////////////
+// UNDI NvData
+//
+
+//
+// Select the type of non-volatile data operation.
+//
+#define PXE_OPFLAGS_NVDATA_OPMASK               0x0001
+#define PXE_OPFLAGS_NVDATA_READ             0x0000
+#define PXE_OPFLAGS_NVDATA_WRITE                0x0001
+
+////////////////////////////////////////
+// UNDI Get Status
+//
+
+//
+// Return current interrupt status.  This will also clear any interrupts
+// that are currently set.  This can be used in a polling routine.  The
+// interrupt flags are still set and cleared even when the interrupts
+// are disabled.
+//
+#define PXE_OPFLAGS_GET_INTERRUPT_STATUS            0x0001
+
+//
+// Return list of transmitted buffers for recycling.  Transmit buffers
+// must not be changed or unallocated until they have recycled.  After
+// issuing a transmit command, wait for a transmit complete interrupt.
+// When a transmit complete interrupt is received, read the transmitted
+// buffers.  Do not plan on getting one buffer per interrupt.  Some
+// NICs and UNDIs may transmit multiple buffers per interrupt.
+//
+#define PXE_OPFLAGS_GET_TRANSMITTED_BUFFERS         0x0002
+
+////////////////////////////////////////
+// UNDI Fill Header
+//
+
+#define PXE_OPFLAGS_FILL_HEADER_OPMASK          0x0001
+#define PXE_OPFLAGS_FILL_HEADER_FRAGMENTED          0x0001
+#define PXE_OPFLAGS_FILL_HEADER_WHOLE           0x0000
+
+////////////////////////////////////////
+// UNDI Transmit
+//
+
+//
+// S/W UNDI only.  Return after the packet has been transmitted.  A
+// transmit complete interrupt will still be generated and the transmit
+// buffer will have to be recycled.
+//
+#define PXE_OPFLAGS_SWUNDI_TRANSMIT_OPMASK          0x0001
+#define PXE_OPFLAGS_TRANSMIT_BLOCK              0x0001
+#define PXE_OPFLAGS_TRANSMIT_DONT_BLOCK         0x0000
+
+//
+//
+//
+#define PXE_OPFLAGS_TRANSMIT_OPMASK             0x0002
+#define PXE_OPFLAGS_TRANSMIT_FRAGMENTED         0x0002
+#define PXE_OPFLAGS_TRANSMIT_WHOLE              0x0000
+
+////////////////////////////////////////
+// UNDI Receive
+//
+
+// No OpFlags
+
+typedef PXE_UINT16 PXE_STATFLAGS;
+
+#define PXE_STATFLAGS_INITIALIZE                0x0000
+
+////////////////////////////////////////
+// Common StatFlags that can be returned by all commands.
+//
+
+//
+// The COMMAND_COMPLETE and COMMAND_FAILED status flags must be
+// implemented by all UNDIs.  COMMAND_QUEUED is only needed by UNDIs
+// that support command queuing.
+//
+#define PXE_STATFLAGS_STATUS_MASK               0xC000
+#define PXE_STATFLAGS_COMMAND_COMPLETE          0xC000
+#define PXE_STATFLAGS_COMMAND_FAILED                0x8000
+#define PXE_STATFLAGS_COMMAND_QUEUED                0x4000
+//#define PXE_STATFLAGS_INITIALIZE              0x0000
+
+#define PXE_STATFLAGS_DB_WRITE_TRUNCATED            0x2000
+
+////////////////////////////////////////
+// UNDI Get State
+//
+
+#define PXE_STATFLAGS_GET_STATE_MASK                0x0003
+#define PXE_STATFLAGS_GET_STATE_INITIALIZED         0x0002
+#define PXE_STATFLAGS_GET_STATE_STARTED         0x0001
+#define PXE_STATFLAGS_GET_STATE_STOPPED         0x0000
+
+////////////////////////////////////////
+// UNDI Start
+//
+
+// No additional StatFlags
+
+////////////////////////////////////////
+// UNDI Get Init Info
+//
+
+#define PXE_STATFLAGS_CABLE_DETECT_MASK          0x0001
+#define PXE_STATFLAGS_CABLE_DETECT_NOT_SUPPORTED 0x0000
+#define PXE_STATFLAGS_CABLE_DETECT_SUPPORTED     0x0001
+
+
+////////////////////////////////////////
+// UNDI Initialize
+//
+
+#define PXE_STATFLAGS_INITIALIZED_NO_MEDIA          0x0001
+
+////////////////////////////////////////
+// UNDI Reset
+//
+
+#define PXE_STATFLAGS_RESET_NO_MEDIA                0x0001
+
+////////////////////////////////////////
+// UNDI Shutdown
+//
+
+// No additional StatFlags
+
+////////////////////////////////////////
+// UNDI Interrupt Enables
+//
+
+//
+// If set, receive interrupts are enabled.
+//
+#define PXE_STATFLAGS_INTERRUPT_RECEIVE         0x0001
+
+//
+// If set, transmit interrupts are enabled.
+//
+#define PXE_STATFLAGS_INTERRUPT_TRANSMIT            0x0002
+
+//
+// If set, command interrupts are enabled.
+//
+#define PXE_STATFLAGS_INTERRUPT_COMMAND         0x0004
+
+
+////////////////////////////////////////
+// UNDI Receive Filters
+//
+
+//
+// If set, unicast packets will be received.
+//
+#define PXE_STATFLAGS_RECEIVE_FILTER_UNICAST        0x0001
+
+//
+// If set, broadcast packets will be received.
+//
+#define PXE_STATFLAGS_RECEIVE_FILTER_BROADCAST      0x0002
+
+//
+// If set, multicast packets that match up with the multicast address
+// filter list will be received.
+//
+#define PXE_STATFLAGS_RECEIVE_FILTER_FILTERED_MULTICAST 0x0004
+
+//
+// If set, all packets will be received.
+//
+#define PXE_STATFLAGS_RECEIVE_FILTER_PROMISCUOUS        0x0008
+
+//
+// If set, all multicast packets will be received.
+//
+#define PXE_STATFLAGS_RECEIVE_FILTER_ALL_MULTICAST  0x0010
+
+////////////////////////////////////////
+// UNDI Station Address
+//
+
+// No additional StatFlags
+
+////////////////////////////////////////
+// UNDI Statistics
+//
+
+// No additional StatFlags
+
+////////////////////////////////////////
+// UNDI MCast IP to MAC
+//
+
+// No additional StatFlags
+
+////////////////////////////////////////
+// UNDI NvData
+//
+
+// No additional StatFlags
+
+
+////////////////////////////////////////
+// UNDI Get Status
+//
+
+//
+// Use to determine if an interrupt has occurred.
+//
+#define PXE_STATFLAGS_GET_STATUS_INTERRUPT_MASK     0x000F
+#define PXE_STATFLAGS_GET_STATUS_NO_INTERRUPTS      0x0000
+
+//
+// If set, at least one receive interrupt occurred.
+//
+#define PXE_STATFLAGS_GET_STATUS_RECEIVE            0x0001
+
+//
+// If set, at least one transmit interrupt occurred.
+//
+#define PXE_STATFLAGS_GET_STATUS_TRANSMIT           0x0002
+
+//
+// If set, at least one command interrupt occurred.
+//
+#define PXE_STATFLAGS_GET_STATUS_COMMAND            0x0004
+
+//
+// If set, at least one software interrupt occurred.
+//
+#define PXE_STATFLAGS_GET_STATUS_SOFTWARE           0x0008
+
+//
+// This flag is set if the transmitted buffer queue is empty.  This flag
+// will be set if all transmitted buffer addresses get written into the DB.
+//
+#define PXE_STATFLAGS_GET_STATUS_TXBUF_QUEUE_EMPTY  0x0010
+
+//
+// This flag is set if no transmitted buffer addresses were written
+// into the DB.  (This could be because DBsize was too small.)
+//
+#define PXE_STATFLAGS_GET_STATUS_NO_TXBUFS_WRITTEN  0x0020
+
+////////////////////////////////////////
+// UNDI Fill Header
+//
+
+// No additional StatFlags
+
+////////////////////////////////////////
+// UNDI Transmit
+//
+
+// No additional StatFlags.
+
+////////////////////////////////////////
+// UNDI Receive
+//
+
+// No additional StatFlags.
+
+typedef PXE_UINT16 PXE_STATCODE;
+
+#define PXE_STATCODE_INITIALIZE             0x0000
+
+////////////////////////////////////////
+// Common StatCodes returned by all UNDI commands, UNDI protocol functions
+// and BC protocol functions.
+//
+
+#define PXE_STATCODE_SUCCESS                    0x0000
+
+#define PXE_STATCODE_INVALID_CDB                0x0001
+#define PXE_STATCODE_INVALID_CPB                0x0002
+#define PXE_STATCODE_BUSY                   	0x0003
+#define PXE_STATCODE_QUEUE_FULL             	0x0004
+#define PXE_STATCODE_ALREADY_STARTED            0x0005
+#define PXE_STATCODE_NOT_STARTED                0x0006
+#define PXE_STATCODE_NOT_SHUTDOWN               0x0007
+#define PXE_STATCODE_ALREADY_INITIALIZED        0x0008
+#define PXE_STATCODE_NOT_INITIALIZED            0x0009
+#define PXE_STATCODE_DEVICE_FAILURE             0x000A
+#define PXE_STATCODE_NVDATA_FAILURE             0x000B
+#define PXE_STATCODE_UNSUPPORTED                0x000C
+#define PXE_STATCODE_BUFFER_FULL                0x000D
+#define PXE_STATCODE_INVALID_PARAMETER		0x000E
+#define PXE_STATCODE_INVALID_UNDI		0x000F
+#define PXE_STATCODE_IPV4_NOT_SUPPORTED		0x0010
+#define PXE_STATCODE_IPV6_NOT_SUPPORTED		0x0011
+#define PXE_STATCODE_NOT_ENOUGH_MEMORY		0x0012
+#define PXE_STATCODE_NO_DATA			0x0013
+
+
+typedef PXE_UINT16 PXE_IFNUM;
+
+//
+// This interface number must be passed to the S/W UNDI Start command.
+//
+#define PXE_IFNUM_START                     0x0000
+
+//
+// This interface number is returned by the S/W UNDI Get State and
+// Start commands if information in the CDB, CPB or DB is invalid.
+//
+#define PXE_IFNUM_INVALID                   0x0000
+
+typedef PXE_UINT16 PXE_CONTROL;
+
+//
+// Setting this flag directs the UNDI to queue this command for later
+// execution if the UNDI is busy and it supports command queuing.
+// If queuing is not supported, a PXE_STATCODE_INVALID_CONTROL error
+// is returned.  If the queue is full, a PXE_STATCODE_CDB_QUEUE_FULL 
+// error is returned.
+//
+#define PXE_CONTROL_QUEUE_IF_BUSY               0x0002
+
+//
+// These two bit values are used to determine if there are more UNDI
+// CDB structures following this one.  If the link bit is set, there
+// must be a CDB structure following this one.  Execution will start
+// on the next CDB structure as soon as this one completes successfully.
+// If an error is generated by this command, execution will stop.
+//
+#define PXE_CONTROL_LINK                    0x0001
+#define PXE_CONTROL_LAST_CDB_IN_LIST                0x0000
+
+typedef PXE_UINT8 PXE_FRAME_TYPE;
+
+#define PXE_FRAME_TYPE_NONE                 0x00
+#define PXE_FRAME_TYPE_UNICAST              0x01
+#define PXE_FRAME_TYPE_BROADCAST                0x02
+#define PXE_FRAME_TYPE_MULTICAST            0x03
+#define PXE_FRAME_TYPE_PROMISCUOUS              0x04
+
+typedef PXE_UINT32 PXE_IPV4;
+
+typedef PXE_UINT32 PXE_IPV6[4];
+#define PXE_MAC_LENGTH 32
+
+typedef PXE_UINT8 PXE_MAC_ADDR[PXE_MAC_LENGTH];
+
+typedef PXE_UINT8 PXE_IFTYPE;
+typedef PXE_UINT16 PXE_MEDIA_PROTOCOL;
+
+//
+// This information is from the ARP section of RFC 1700.
+//
+//     1 Ethernet (10Mb)                                    [JBP]
+//     2 Experimental Ethernet (3Mb)                        [JBP]
+//     3 Amateur Radio AX.25                                [PXK]
+//     4 Proteon ProNET Token Ring                          [JBP]
+//     5 Chaos                                              [GXP]
+//     6 IEEE 802 Networks                                  [JBP]
+//     7 ARCNET                                             [JBP]
+//     8 Hyperchannel                                       [JBP]
+//     9 Lanstar                                             [TU]
+//    10 Autonet Short Address                             [MXB1]
+//    11 LocalTalk                                         [JKR1]
+//    12 LocalNet (IBM PCNet or SYTEK LocalNET)             [JXM]
+//    13 Ultra link                                        [RXD2]
+//    14 SMDS                                              [GXC1]
+//    15 Frame Relay                                        [AGM]
+//    16 Asynchronous Transmission Mode (ATM)              [JXB2]
+//    17 HDLC                                               [JBP]
+//    18 Fibre Channel                            [Yakov Rekhter]
+//    19 Asynchronous Transmission Mode (ATM)      [Mark Laubach]
+//    20 Serial Line                                        [JBP]
+//    21 Asynchronous Transmission Mode (ATM)              [MXB1]
+//
+
+#define PXE_IFTYPE_ETHERNET                 0x01
+#define PXE_IFTYPE_TOKENRING                    0x04
+#define PXE_IFTYPE_FIBRE_CHANNEL                0x12
+
+typedef struct s_pxe_hw_undi {
+PXE_UINT32 Signature;       // PXE_ROMID_SIGNATURE
+PXE_UINT8 Len;          // sizeof(PXE_HW_UNDI)
+PXE_UINT8 Fudge;            // makes 8-bit cksum equal zero
+PXE_UINT8 Rev;          // PXE_ROMID_REV
+PXE_UINT8 IFcnt;            // physical connector count
+PXE_UINT8 MajorVer;         // PXE_ROMID_MAJORVER
+PXE_UINT8 MinorVer;         // PXE_ROMID_MINORVER
+PXE_UINT16 reserved;        // zero, not used
+PXE_UINT32 Implementation;      // implementation flags
+// reserved             // vendor use
+// PXE_UINT32 Status;       // status port
+// PXE_UINT32 Command;      // command port
+// PXE_UINT64 CDBaddr;      // CDB address port
+} PXE_HW_UNDI;
+
+//
+// Status port bit definitions
+//
+
+//
+// UNDI operation state
+//
+#define PXE_HWSTAT_STATE_MASK                   0xC0000000
+#define PXE_HWSTAT_BUSY                     0xC0000000
+#define PXE_HWSTAT_INITIALIZED              0x80000000
+#define PXE_HWSTAT_STARTED                  0x40000000
+#define PXE_HWSTAT_STOPPED                  0x00000000
+
+//
+// If set, last command failed
+//
+#define PXE_HWSTAT_COMMAND_FAILED               0x20000000
+
+//
+// If set, identifies enabled receive filters
+//
+#define PXE_HWSTAT_PROMISCUOUS_MULTICAST_RX_ENABLED 0x00001000
+#define PXE_HWSTAT_PROMISCUOUS_RX_ENABLED           0x00000800
+#define PXE_HWSTAT_BROADCAST_RX_ENABLED         0x00000400
+#define PXE_HWSTAT_MULTICAST_RX_ENABLED         0x00000200
+#define PXE_HWSTAT_UNICAST_RX_ENABLED           0x00000100
+
+//
+// If set, identifies enabled external interrupts
+//
+#define PXE_HWSTAT_SOFTWARE_INT_ENABLED         0x00000080
+#define PXE_HWSTAT_TX_COMPLETE_INT_ENABLED          0x00000040
+#define PXE_HWSTAT_PACKET_RX_INT_ENABLED            0x00000020
+#define PXE_HWSTAT_CMD_COMPLETE_INT_ENABLED         0x00000010
+
+//
+// If set, identifies pending interrupts
+//
+#define PXE_HWSTAT_SOFTWARE_INT_PENDING         0x00000008
+#define PXE_HWSTAT_TX_COMPLETE_INT_PENDING          0x00000004
+#define PXE_HWSTAT_PACKET_RX_INT_PENDING            0x00000002
+#define PXE_HWSTAT_CMD_COMPLETE_INT_PENDING         0x00000001
+
+//
+// Command port definitions
+//
+
+//
+// If set, CDB identified in CDBaddr port is given to UNDI.
+// If not set, other bits in this word will be processed.
+//
+#define PXE_HWCMD_ISSUE_COMMAND             0x80000000
+#define PXE_HWCMD_INTS_AND_FILTS                0x00000000
+
+//
+// Use these to enable/disable receive filters.
+//
+#define PXE_HWCMD_PROMISCUOUS_MULTICAST_RX_ENABLE       0x00001000
+#define PXE_HWCMD_PROMISCUOUS_RX_ENABLE         0x00000800
+#define PXE_HWCMD_BROADCAST_RX_ENABLE           0x00000400
+#define PXE_HWCMD_MULTICAST_RX_ENABLE           0x00000200
+#define PXE_HWCMD_UNICAST_RX_ENABLE             0x00000100
+
+//
+// Use these to enable/disable external interrupts
+//
+#define PXE_HWCMD_SOFTWARE_INT_ENABLE           0x00000080
+#define PXE_HWCMD_TX_COMPLETE_INT_ENABLE            0x00000040
+#define PXE_HWCMD_PACKET_RX_INT_ENABLE          0x00000020
+#define PXE_HWCMD_CMD_COMPLETE_INT_ENABLE           0x00000010
+
+//
+// Use these to clear pending external interrupts
+//
+#define PXE_HWCMD_CLEAR_SOFTWARE_INT                0x00000008
+#define PXE_HWCMD_CLEAR_TX_COMPLETE_INT         0x00000004
+#define PXE_HWCMD_CLEAR_PACKET_RX_INT           0x00000002
+#define PXE_HWCMD_CLEAR_CMD_COMPLETE_INT            0x00000001
+
+typedef struct s_pxe_sw_undi {
+PXE_UINT32 Signature;       // PXE_ROMID_SIGNATURE
+PXE_UINT8 Len;          // sizeof(PXE_SW_UNDI)
+PXE_UINT8 Fudge;            // makes 8-bit cksum zero
+PXE_UINT8 Rev;          // PXE_ROMID_REV
+PXE_UINT8 IFcnt;            // physical connector count
+PXE_UINT8 MajorVer;         // PXE_ROMID_MAJORVER
+PXE_UINT8 MinorVer;         // PXE_ROMID_MINORVER
+PXE_UINT16 reserved1;       // zero, not used
+PXE_UINT32 Implementation;      // Implementation flags
+PXE_UINT64 EntryPoint;      // API entry point
+PXE_UINT8 reserved2[3];     // zero, not used
+PXE_UINT8 BusCnt;           // number of bustypes supported
+PXE_UINT32 BusType[1];      // list of supported bustypes
+} PXE_SW_UNDI;
+
+typedef union u_pxe_undi {
+PXE_HW_UNDI hw;
+PXE_SW_UNDI sw;
+} PXE_UNDI;
+
+//
+// Signature of !PXE structure
+//
+#define PXE_ROMID_SIGNATURE     PXE_BUSTYPE('!', 'P', 'X', 'E')
+
+//
+// !PXE structure format revision
+//
+#define PXE_ROMID_REV                       0x02
+
+//
+// UNDI command interface revision.  These are the values that get sent
+// in option 94 (Client Network Interface Identifier) in the DHCP Discover
+// and PXE Boot Server Request packets.
+//
+#define PXE_ROMID_MAJORVER                  0x03
+#define PXE_ROMID_MINORVER                  0x00
+
+//
+// Implementation flags
+//
+#define PXE_ROMID_IMP_HW_UNDI                   0x80000000
+#define PXE_ROMID_IMP_SW_VIRT_ADDR              0x40000000
+#define PXE_ROMID_IMP_64BIT_DEVICE              0x00010000
+#define PXE_ROMID_IMP_FRAG_SUPPORTED                0x00008000
+#define PXE_ROMID_IMP_CMD_LINK_SUPPORTED            0x00004000
+#define PXE_ROMID_IMP_CMD_QUEUE_SUPPORTED           0x00002000
+#define PXE_ROMID_IMP_MULTI_FRAME_SUPPORTED         0x00001000
+#define PXE_ROMID_IMP_NVDATA_SUPPORT_MASK           0x00000C00
+#define PXE_ROMID_IMP_NVDATA_BULK_WRITABLE          0x00000C00
+#define PXE_ROMID_IMP_NVDATA_SPARSE_WRITABLE        0x00000800
+#define PXE_ROMID_IMP_NVDATA_READ_ONLY          0x00000400
+#define PXE_ROMID_IMP_NVDATA_NOT_AVAILABLE          0x00000000
+#define PXE_ROMID_IMP_STATISTICS_SUPPORTED          0x00000200
+#define PXE_ROMID_IMP_STATION_ADDR_SETTABLE         0x00000100
+#define PXE_ROMID_IMP_PROMISCUOUS_MULTICAST_RX_SUPPORTED    0x00000080
+#define PXE_ROMID_IMP_PROMISCUOUS_RX_SUPPORTED      0x00000040
+#define PXE_ROMID_IMP_BROADCAST_RX_SUPPORTED        0x00000020
+#define PXE_ROMID_IMP_FILTERED_MULTICAST_RX_SUPPORTED   0x00000010
+#define PXE_ROMID_IMP_SOFTWARE_INT_SUPPORTED        0x00000008
+#define PXE_ROMID_IMP_TX_COMPLETE_INT_SUPPORTED     0x00000004
+#define PXE_ROMID_IMP_PACKET_RX_INT_SUPPORTED       0x00000002
+#define PXE_ROMID_IMP_CMD_COMPLETE_INT_SUPPORTED        0x00000001
+
+ 
+typedef struct s_pxe_cdb {
+PXE_OPCODE OpCode;
+PXE_OPFLAGS OpFlags;
+PXE_UINT16 CPBsize;
+PXE_UINT16 DBsize;
+UINT64 CPBaddr;
+UINT64 DBaddr;
+PXE_STATCODE StatCode;
+PXE_STATFLAGS StatFlags;
+PXE_UINT16 IFnum;
+PXE_CONTROL Control;
+} PXE_CDB;
+
+
+typedef union u_pxe_ip_addr {
+PXE_IPV6 IPv6;
+PXE_IPV4 IPv4;
+} PXE_IP_ADDR;
+
+typedef union pxe_device {
+//
+// PCI and PC Card NICs are both identified using bus, device
+// and function numbers.  For PC Card, this may require PC
+// Card services to be loaded in the BIOS or preboot
+// environment.
+//
+struct {
+//
+// See S/W UNDI ROMID structure definition for PCI and
+// PCC BusType definitions.
+//
+PXE_UINT32 BusType;
+
+//
+// Bus, device & function numbers that locate this device.
+//
+PXE_UINT16 Bus;
+PXE_UINT8 Device;
+PXE_UINT8 Function;
+} PCI, PCC;
+
+//
+// %%TBD - More information is needed about enumerating
+// USB and 1394 devices.
+//
+struct {
+PXE_UINT32 BusType;
+PXE_UINT32 tdb;
+} USB, _1394;
+} PXE_DEVICE;
+
+// cpb and db definitions
+
+#define MAX_PCI_CONFIG_LEN 64   // # of dwords
+#define MAX_EEPROM_LEN 128       // #of dwords
+#define MAX_XMIT_BUFFERS    32  // recycling Q length for xmit_done
+#define MAX_MCAST_ADDRESS_CNT 8
+
+typedef struct s_pxe_cpb_start {
+    //
+    // PXE_VOID Delay(PXE_UINT64 microseconds);
+    //
+    // UNDI will never request a delay smaller than 10 microseconds
+    // and will always request delays in increments of 10 microseconds.
+    // The Delay() CallBack routine must delay between n and n + 10 
+    // microseconds before returning control to the UNDI.
+    //
+    // This field cannot be set to zero.
+    //
+    PXE_UINT64 Delay;
+
+    //
+    // PXE_VOID Block(PXE_UINT32 enable);
+    //
+    // UNDI may need to block multi-threaded/multi-processor access to
+    // critical code sections when programming or accessing the network
+    // device.  To this end, a blocking service is needed by the UNDI.
+    // When UNDI needs a block, it will call Block() passing a non-zero
+    // value.  When UNDI no longer needs a block, it will call Block()
+    // with a zero value.  When called, if the Block() is already enabled,
+    // do not return control to the UNDI until the previous Block() is
+    // disabled.
+    //
+    // This field cannot be set to zero.
+    //
+    PXE_UINT64 Block;
+
+    //
+    // PXE_VOID Virt2Phys(PXE_UINT64 virtual, PXE_UINT64 physical_ptr);
+    //
+    // UNDI will pass the virtual address of a buffer and the virtual
+    // address of a 64-bit physical buffer.  Convert the virtual address
+    // to a physical address and write the result to the physical address
+    // buffer.  If virtual and physical addresses are the same, just
+    // copy the virtual address to the physical address buffer.
+    //
+    // This field can be set to zero if virtual and physical addresses 
+    // are equal.
+    //
+    PXE_UINT64 Virt2Phys;
+    //
+    // PXE_VOID Mem_IO(PXE_UINT8 read_write, PXE_UINT8 len, PXE_UINT64 port, 
+    //              PXE_UINT64 buf_addr);
+    //
+    // UNDI will read or write the device io space using this call back 
+    // function. It passes the number of bytes as the len parameter and it 
+    // will be either 1,2,4 or 8.
+    //
+    // This field can not be set to zero.
+    //
+    PXE_UINT64 Mem_IO;
+} PXE_CPB_START;
+
+#define PXE_DELAY_MILLISECOND                   1000
+#define PXE_DELAY_SECOND                    1000000
+#define PXE_IO_READ                     0
+#define PXE_IO_WRITE                        1
+#define PXE_MEM_READ                        2
+#define PXE_MEM_WRITE                       4
+
+
+typedef struct s_pxe_db_get_init_info {
+    //
+    // Minimum length of locked memory buffer that must be given to
+    // the Initialize command. Giving UNDI more memory will generally
+    // give better performance.
+    //
+    // If MemoryRequired is zero, the UNDI does not need and will not
+    // use system memory to receive and transmit packets.
+    //
+    PXE_UINT32 MemoryRequired;
+
+    //
+    // Maximum frame data length for Tx/Rx excluding the media header.
+    //
+    PXE_UINT32 FrameDataLen;
+
+    //
+    // Supported link speeds are in units of mega bits.  Common ethernet
+    // values are 10, 100 and 1000.  Unused LinkSpeeds[] entries are zero
+    // filled.
+    //
+    PXE_UINT32 LinkSpeeds[4];
+
+    //
+    // Number of non-volatile storage items.
+    //
+    PXE_UINT32 NvCount;
+
+    //
+    // Width of non-volatile storage item in bytes.  0, 1, 2 or 4
+    //
+    PXE_UINT16 NvWidth;
+
+    //
+    // Media header length.  This is the typical media header length for
+    // this UNDI.  This information is needed when allocating receive
+    // and transmit buffers.
+    //
+    PXE_UINT16 MediaHeaderLen;
+
+    //
+    // Number of bytes in the NIC hardware (MAC) address.
+    //
+    PXE_UINT16 HWaddrLen;
+
+    //
+    // Maximum number of multicast MAC addresses in the multicast
+    // MAC address filter list.
+    //
+    PXE_UINT16 MCastFilterCnt;
+
+    //
+    // Default number and size of transmit and receive buffers that will 
+    // be allocated by the UNDI.  If MemoryRequired is non-zero, this 
+    // allocation will come out of the memory buffer given to the Initialize 
+    // command.  If MemoryRequired is zero, this allocation will come out of 
+    // memory on the NIC.
+    //
+    PXE_UINT16 TxBufCnt;
+    PXE_UINT16 TxBufSize;
+    PXE_UINT16 RxBufCnt;
+    PXE_UINT16 RxBufSize;
+
+    //
+    // Hardware interface types defined in the Assigned Numbers RFC
+    // and used in DHCP and ARP packets.
+    // See the PXE_IFTYPE typedef and PXE_IFTYPE_xxx macros.
+    //
+    PXE_UINT8 IFtype;
+
+    //
+    // Supported duplex.  See PXE_DUPLEX_xxxxx #defines below.
+    //
+    PXE_UINT8 Duplex;
+
+    //
+    // Supported loopback options.  See PXE_LOOPBACK_xxxxx #defines below.
+    //
+    PXE_UINT8 LoopBack;
+} PXE_DB_GET_INIT_INFO;
+
+#define PXE_MAX_TXRX_UNIT_ETHER             1500
+
+#define PXE_HWADDR_LEN_ETHER                    0x0006
+#define PXE_MAC_HEADER_LEN_ETHER                0x000E
+
+#define PXE_DUPLEX_ENABLE_FULL_SUPPORTED            1
+#define PXE_DUPLEX_FORCE_FULL_SUPPORTED         2
+
+#define PXE_LOOPBACK_INTERNAL_SUPPORTED         1
+#define PXE_LOOPBACK_EXTERNAL_SUPPORTED         2
+
+
+typedef struct s_pxe_pci_config_info {
+    //
+    // This is the flag field for the PXE_DB_GET_CONFIG_INFO union.
+    // For PCI bus devices, this field is set to PXE_BUSTYPE_PCI.
+    //
+    PXE_UINT32 BusType;
+
+    //
+    // This identifies the PCI network device that this UNDI interface
+    // is bound to.
+    //
+    PXE_UINT16 Bus;
+    PXE_UINT8 Device;
+    PXE_UINT8 Function;
+
+    //
+    // This is a copy of the PCI configuration space for this 
+    // network device.
+    //
+    union {
+        PXE_UINT8 Byte[256];
+        PXE_UINT16 Word[128];
+        PXE_UINT32 Dword[64];
+    } Config;
+} PXE_PCI_CONFIG_INFO;
+
+
+typedef struct s_pxe_pcc_config_info {
+    //
+    // This is the flag field for the PXE_DB_GET_CONFIG_INFO union.
+    // For PCC bus devices, this field is set to PXE_BUSTYPE_PCC.
+    //
+    PXE_UINT32 BusType;
+    
+    //
+    // This identifies the PCC network device that this UNDI interface
+    // is bound to.
+    //
+    PXE_UINT16 Bus;
+    PXE_UINT8 Device;
+    PXE_UINT8 Function;
+
+    //
+    // This is a copy of the PCC configuration space for this 
+    // network device.
+    //
+    union {
+        PXE_UINT8 Byte[256];
+        PXE_UINT16 Word[128];
+        PXE_UINT32 Dword[64];
+    } Config;
+} PXE_PCC_CONFIG_INFO;
+
+
+typedef struct s_pxe_usb_config_info {
+    PXE_UINT32 BusType;
+    // %%TBD What should we return here...
+} PXE_USB_CONFIG_INFO;
+
+
+typedef struct s_pxe_1394_config_info {
+    PXE_UINT32 BusType;
+    // %%TBD What should we return here...
+} PXE_1394_CONFIG_INFO;
+
+
+typedef union u_pxe_db_get_config_info {
+    PXE_PCI_CONFIG_INFO pci;
+    PXE_PCC_CONFIG_INFO pcc;
+    PXE_USB_CONFIG_INFO usb;
+    PXE_1394_CONFIG_INFO _1394;
+} PXE_DB_GET_CONFIG_INFO;
+
+
+typedef struct s_pxe_cpb_initialize {
+    //
+    // Address of first (lowest) byte of the memory buffer.  This buffer must
+    // be in contiguous physical memory and cannot be swapped out.  The UNDI
+    // will be using this for transmit and receive buffering.
+    //
+    PXE_UINT64 MemoryAddr;
+
+    //
+    // MemoryLength must be greater than or equal to MemoryRequired
+    // returned by the Get Init Info command.
+    //
+    PXE_UINT32 MemoryLength;
+
+    //
+    // Desired link speed in Mbit/sec.  Common ethernet values are 10, 100
+    // and 1000.  Setting a value of zero will auto-detect and/or use the
+    // default link speed (operation depends on UNDI/NIC functionality).
+    //
+    PXE_UINT32 LinkSpeed;
+
+    //
+    // Suggested number and size of receive and transmit buffers to
+    // allocate.  If MemoryAddr and MemoryLength are non-zero, this
+    // allocation comes out of the supplied memory buffer.  If MemoryAddr 
+    // and MemoryLength are zero, this allocation comes out of memory
+    // on the NIC.
+    //
+    // If these fields are set to zero, the UNDI will allocate buffer
+    // counts and sizes as it sees fit.
+    //
+    PXE_UINT16 TxBufCnt;
+    PXE_UINT16 TxBufSize;
+    PXE_UINT16 RxBufCnt;
+    PXE_UINT16 RxBufSize;
+
+    //
+    // The following configuration parameters are optional and must be zero 
+    // to use the default values.
+    //
+    PXE_UINT8 Duplex; 
+
+    PXE_UINT8 LoopBack;
+} PXE_CPB_INITIALIZE;
+
+
+#define PXE_DUPLEX_DEFAULT                  0x00
+#define PXE_FORCE_FULL_DUPLEX                   0x01
+#define PXE_ENABLE_FULL_DUPLEX              0x02
+
+#define LOOPBACK_NORMAL 0
+#define LOOPBACK_INTERNAL 1
+#define LOOPBACK_EXTERNAL 2
+
+
+typedef struct s_pxe_db_initialize {
+    //
+    // Actual amount of memory used from the supplied memory buffer.  This
+    // may be less that the amount of memory suppllied and may be zero if
+    // the UNDI and network device do not use external memory buffers.
+    //
+    // Memory used by the UNDI and network device is allocated from the 
+    // lowest memory buffer address.
+    //
+    PXE_UINT32 MemoryUsed;
+
+    //
+    // Actual number and size of receive and transmit buffers that were
+    // allocated.
+    //
+    PXE_UINT16 TxBufCnt;
+    PXE_UINT16 TxBufSize;
+    PXE_UINT16 RxBufCnt;
+    PXE_UINT16 RxBufSize;
+} PXE_DB_INITIALIZE;
+
+
+typedef struct s_pxe_cpb_receive_filters {
+    //
+    // List of multicast MAC addresses.  This list, if present, will
+    // replace the existing multicast MAC address filter list.
+    //
+    PXE_MAC_ADDR MCastList[MAX_MCAST_ADDRESS_CNT];
+} PXE_CPB_RECEIVE_FILTERS;
+
+
+typedef struct s_pxe_db_receive_filters {
+    //
+    // Filtered multicast MAC address list.
+    //
+    PXE_MAC_ADDR MCastList[MAX_MCAST_ADDRESS_CNT];
+} PXE_DB_RECEIVE_FILTERS;
+
+
+typedef struct s_pxe_cpb_station_address {
+    //
+    // If supplied and supported, the current station MAC address
+    // will be changed.
+    //
+    PXE_MAC_ADDR StationAddr;
+} PXE_CPB_STATION_ADDRESS;
+
+
+typedef struct s_pxe_dpb_station_address {
+    //
+    // Current station MAC address.
+    //
+    PXE_MAC_ADDR StationAddr;
+
+    //
+    // Station broadcast MAC address.
+    //
+    PXE_MAC_ADDR BroadcastAddr;
+
+    //
+    // Permanent station MAC address.
+    //
+    PXE_MAC_ADDR PermanentAddr;
+} PXE_DB_STATION_ADDRESS;
+
+
+typedef struct s_pxe_db_statistics {
+    //
+    // Bit field identifying what statistic data is collected by the 
+    // UNDI/NIC.
+    // If bit 0x00 is set, Data[0x00] is collected.
+    // If bit 0x01 is set, Data[0x01] is collected.
+    // If bit 0x20 is set, Data[0x20] is collected.
+    // If bit 0x21 is set, Data[0x21] is collected.
+    // Etc.
+    //
+    PXE_UINT64 Supported;
+
+    //
+    // Statistic data.
+    //
+    PXE_UINT64 Data[64];
+} PXE_DB_STATISTICS;
+
+//
+// Total number of frames received.  Includes frames with errors and
+// dropped frames.
+//
+#define PXE_STATISTICS_RX_TOTAL_FRAMES          0x00
+
+//
+// Number of valid frames received and copied into receive buffers.
+//
+#define PXE_STATISTICS_RX_GOOD_FRAMES           0x01
+
+//
+// Number of frames below the minimum length for the media.
+// This would be <64 for ethernet.
+//
+#define PXE_STATISTICS_RX_UNDERSIZE_FRAMES          0x02
+
+//
+// Number of frames longer than the maxminum length for the
+// media.  This would be >1500 for ethernet.
+//
+#define PXE_STATISTICS_RX_OVERSIZE_FRAMES           0x03
+
+//
+// Valid frames that were dropped because receive buffers were full.
+//
+#define PXE_STATISTICS_RX_DROPPED_FRAMES            0x04
+
+//
+// Number of valid unicast frames received and not dropped.
+//
+#define PXE_STATISTICS_RX_UNICAST_FRAMES            0x05
+
+//
+// Number of valid broadcast frames received and not dropped.
+//
+#define PXE_STATISTICS_RX_BROADCAST_FRAMES          0x06
+
+//
+// Number of valid mutlicast frames received and not dropped.
+//
+#define PXE_STATISTICS_RX_MULTICAST_FRAMES          0x07
+
+//
+// Number of frames w/ CRC or alignment errors.
+//
+#define PXE_STATISTICS_RX_CRC_ERROR_FRAMES          0x08
+
+//
+// Total number of bytes received.  Includes frames with errors
+// and dropped frames.
+//
+#define PXE_STATISTICS_RX_TOTAL_BYTES           0x09
+
+//
+// Transmit statistics.
+//
+#define PXE_STATISTICS_TX_TOTAL_FRAMES          0x0A
+#define PXE_STATISTICS_TX_GOOD_FRAMES           0x0B
+#define PXE_STATISTICS_TX_UNDERSIZE_FRAMES          0x0C
+#define PXE_STATISTICS_TX_OVERSIZE_FRAMES           0x0D
+#define PXE_STATISTICS_TX_DROPPED_FRAMES            0x0E
+#define PXE_STATISTICS_TX_UNICAST_FRAMES            0x0F
+#define PXE_STATISTICS_TX_BROADCAST_FRAMES          0x10
+#define PXE_STATISTICS_TX_MULTICAST_FRAMES          0x11
+#define PXE_STATISTICS_TX_CRC_ERROR_FRAMES          0x12
+#define PXE_STATISTICS_TX_TOTAL_BYTES           0x13
+
+//
+// Number of collisions detection on this subnet.
+//
+#define PXE_STATISTICS_COLLISIONS               0x14
+
+//
+// Number of frames destined for unsupported protocol.
+//
+#define PXE_STATISTICS_UNSUPPORTED_PROTOCOL         0x15
+
+
+typedef struct s_pxe_cpb_mcast_ip_to_mac {
+    //
+    // Multicast IP address to be converted to multicast MAC address.
+    //
+    PXE_IP_ADDR IP;
+} PXE_CPB_MCAST_IP_TO_MAC;
+
+
+typedef struct s_pxe_db_mcast_ip_to_mac {
+    //
+    // Multicast MAC address.
+    //
+    PXE_MAC_ADDR MAC;
+} PXE_DB_MCAST_IP_TO_MAC;
+
+
+typedef struct s_pxe_cpb_nvdata_sparse {
+    //
+    // NvData item list.  Only items in this list will be updated.
+    //
+    struct {
+        //  Non-volatile storage address to be changed.
+        PXE_UINT32 Addr;
+
+        // Data item to write into above storage address.
+    
+        union {
+            PXE_UINT8 Byte;
+            PXE_UINT16 Word;
+            PXE_UINT32 Dword;
+        } Data;
+    } Item[MAX_EEPROM_LEN];
+} PXE_CPB_NVDATA_SPARSE;
+
+
+//
+// When using bulk update, the size of the CPB structure must be
+// the same size as the non-volatile NIC storage.
+//
+typedef union u_pxe_cpb_nvdata_bulk {
+    //
+    // Array of byte-wide data items.
+    //
+    PXE_UINT8 Byte[MAX_EEPROM_LEN << 2];
+
+    //
+    // Array of word-wide data items.
+    //
+    PXE_UINT16 Word[MAX_EEPROM_LEN << 1];
+
+    //
+    // Array of dword-wide data items.
+    //
+    PXE_UINT32 Dword[MAX_EEPROM_LEN];
+} PXE_CPB_NVDATA_BULK;
+
+typedef struct s_pxe_db_nvdata {
+
+    // Arrays of data items from non-volatile storage.
+
+    union {
+        //
+        // Array of byte-wide data items.
+        //
+        PXE_UINT8 Byte[MAX_EEPROM_LEN << 2];
+
+        //
+        // Array of word-wide data items.
+        //
+        PXE_UINT16 Word[MAX_EEPROM_LEN << 1];
+
+        // Array of dword-wide data items.
+
+        PXE_UINT32 Dword[MAX_EEPROM_LEN];
+    } Data;
+} PXE_DB_NVDATA;
+
+
+typedef struct s_pxe_db_get_status {
+    //
+    // Length of next receive frame (header + data).  If this is zero,
+    // there is no next receive frame available.
+    //
+    PXE_UINT32 RxFrameLen;
+
+    //
+    // Reserved, set to zero.
+    //
+    PXE_UINT32 reserved;
+
+    //
+    //  Addresses of transmitted buffers that need to be recycled.
+    //
+    PXE_UINT64 TxBuffer[MAX_XMIT_BUFFERS];
+} PXE_DB_GET_STATUS;
+
+
+
+typedef struct s_pxe_cpb_fill_header {
+    //
+    // Source and destination MAC addresses.  These will be copied into
+    // the media header without doing byte swapping.
+    //
+    PXE_MAC_ADDR SrcAddr;
+    PXE_MAC_ADDR DestAddr;
+
+    //
+    // Address of first byte of media header.  The first byte of packet data
+    // follows the last byte of the media header.
+    //
+    PXE_UINT64 MediaHeader;
+
+    //
+    // Length of packet data in bytes (not including the media header).
+    //
+    PXE_UINT32 PacketLen;
+
+    //
+    // Protocol type.  This will be copied into the media header without
+    // doing byte swapping.  Protocol type numbers can be obtained from
+    // the Assigned Numbers RFC 1700.
+    //
+    PXE_UINT16 Protocol;
+
+    //
+    // Length of the media header in bytes.
+    //
+    PXE_UINT16 MediaHeaderLen;
+} PXE_CPB_FILL_HEADER;
+
+
+#define PXE_PROTOCOL_ETHERNET_IP                0x0800
+#define PXE_PROTOCOL_ETHERNET_ARP               0x0806
+#define MAX_XMIT_FRAGMENTS 16
+
+typedef struct s_pxe_cpb_fill_header_fragmented {
+    //
+    // Source and destination MAC addresses.  These will be copied into
+    // the media header without doing byte swapping.
+    //
+    PXE_MAC_ADDR SrcAddr;
+    PXE_MAC_ADDR DestAddr;
+
+    //
+    // Length of packet data in bytes (not including the media header).
+    //
+    PXE_UINT32 PacketLen;
+
+    //
+    // Protocol type.  This will be copied into the media header without
+    // doing byte swapping.  Protocol type numbers can be obtained from
+    // the Assigned Numbers RFC 1700.
+    //
+    PXE_MEDIA_PROTOCOL Protocol;
+
+    //
+    // Length of the media header in bytes.
+    //
+    PXE_UINT16 MediaHeaderLen;
+
+    //
+    // Number of packet fragment descriptors.
+    //
+    PXE_UINT16 FragCnt;
+
+    //
+    // Reserved, must be set to zero.
+    //
+    PXE_UINT16 reserved;
+
+    //
+    // Array of packet fragment descriptors.  The first byte of the media
+    // header is the first byte of the first fragment.
+    //
+    struct {
+        //
+        // Address of this packet fragment.
+        //
+        PXE_UINT64 FragAddr;
+
+        //
+        // Length of this packet fragment.
+        //
+        PXE_UINT32 FragLen;
+
+        //
+        // Reserved, must be set to zero.
+        //
+        PXE_UINT32 reserved;
+    } FragDesc[MAX_XMIT_FRAGMENTS];
+} PXE_CPB_FILL_HEADER_FRAGMENTED;
+
+
+
+typedef struct s_pxe_cpb_transmit {
+    //
+    // Address of first byte of frame buffer.  This is also the first byte
+    // of the media header.
+    //
+    PXE_UINT64 FrameAddr;
+
+    //
+    // Length of the data portion of the frame buffer in bytes.  Do not
+    // include the length of the media header.
+    //
+    PXE_UINT32 DataLen;
+
+    //
+    // Length of the media header in bytes.
+    //
+    PXE_UINT16 MediaheaderLen;
+
+    //
+    // Reserved, must be zero.
+    //
+    PXE_UINT16 reserved;
+} PXE_CPB_TRANSMIT;
+
+
+
+typedef struct s_pxe_cpb_transmit_fragments {
+    //
+    // Length of packet data in bytes (not including the media header).
+    //
+    PXE_UINT32 FrameLen;
+
+    //
+    // Length of the media header in bytes.
+    //
+    PXE_UINT16 MediaheaderLen;
+
+    //
+    // Number of packet fragment descriptors.
+    //
+    PXE_UINT16 FragCnt;
+
+    //
+    // Array of frame fragment descriptors.  The first byte of the first
+    // fragment is also the first byte of the media header.
+    //
+    struct {
+        //
+        // Address of this frame fragment.
+        //
+        PXE_UINT64 FragAddr;
+
+        //
+        // Length of this frame fragment.
+        //
+        PXE_UINT32 FragLen;
+
+        //
+        // Reserved, must be set to zero.
+        //
+        PXE_UINT32 reserved;
+    } FragDesc[MAX_XMIT_FRAGMENTS];
+} PXE_CPB_TRANSMIT_FRAGMENTS;
+
+
+typedef struct s_pxe_cpb_receive {
+    //
+    // Address of first byte of receive buffer.  This is also the first byte
+    // of the frame header.
+    //
+    PXE_UINT64 BufferAddr;
+
+    //
+    // Length of receive buffer.  This must be large enough to hold the
+    // received frame (media header + data).  If the length of smaller than
+    // the received frame, data will be lost.
+    //
+    PXE_UINT32 BufferLen;
+
+    //
+    // Reserved, must be set to zero.
+    //
+    PXE_UINT32 reserved;
+} PXE_CPB_RECEIVE;
+
+
+typedef struct s_pxe_db_receive {
+    //
+    // Source and destination MAC addresses from media header.
+    //
+    PXE_MAC_ADDR SrcAddr;
+    PXE_MAC_ADDR DestAddr;
+
+    //
+    // Length of received frame.  May be larger than receive buffer size.
+    // The receive buffer will not be overwritten.  This is how to tell
+    // if data was lost because the receive buffer was too small.
+    //
+    PXE_UINT32 FrameLen;
+
+    //
+    // Protocol type from media header.
+    //
+    PXE_MEDIA_PROTOCOL Protocol;
+
+    //
+    // Length of media header in received frame.
+    //
+    PXE_UINT16 MediaHeaderLen;
+
+    //
+    // Type of receive frame.
+    //
+    PXE_FRAME_TYPE Type;
+
+    //
+    // Reserved, must be zero.
+    //
+    PXE_UINT8 reserved[7];
+
+} PXE_DB_RECEIVE;
+
+#pragma pack()
+
+/* EOF - efi_pxe.h */
+#endif /* _EFI_PXE_H */
+
diff --git a/linux-x86_64/gnu-efi/include/efi/efiapi.h b/linux-x86_64/gnu-efi/include/efi/efiapi.h
new file mode 100644
index 0000000..5e47324
--- /dev/null
+++ b/linux-x86_64/gnu-efi/include/efi/efiapi.h
@@ -0,0 +1,890 @@
+#ifndef _EFI_API_H
+#define _EFI_API_H
+
+/*++
+
+Copyright (c) 1998  Intel Corporation
+
+Module Name:
+
+    efiapi.h
+
+Abstract:
+
+    Global EFI runtime & boot service interfaces
+
+
+
+
+Revision History
+
+--*/
+
+//
+// EFI Specification Revision
+//
+
+#define EFI_SPECIFICATION_MAJOR_REVISION 1
+#define EFI_SPECIFICATION_MINOR_REVISION 02
+
+//
+// Declare forward referenced data structures
+//
+
+INTERFACE_DECL(_EFI_SYSTEM_TABLE);
+
+//
+// EFI Memory
+//
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_ALLOCATE_PAGES) (
+    IN EFI_ALLOCATE_TYPE            Type,
+    IN EFI_MEMORY_TYPE              MemoryType,
+    IN UINTN                        NoPages,
+    OUT EFI_PHYSICAL_ADDRESS        *Memory
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_FREE_PAGES) (
+    IN EFI_PHYSICAL_ADDRESS         Memory,
+    IN UINTN                        NoPages
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_GET_MEMORY_MAP) (
+    IN OUT UINTN                    *MemoryMapSize,
+    IN OUT EFI_MEMORY_DESCRIPTOR    *MemoryMap,
+    OUT UINTN                       *MapKey,
+    OUT UINTN                       *DescriptorSize,
+    OUT UINT32                      *DescriptorVersion
+    );
+
+#define NextMemoryDescriptor(Ptr,Size)  ((EFI_MEMORY_DESCRIPTOR *) (((UINT8 *) Ptr) + Size))
+
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_ALLOCATE_POOL) (
+    IN EFI_MEMORY_TYPE              PoolType,
+    IN UINTN                        Size,
+    OUT VOID                        **Buffer
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_FREE_POOL) (
+    IN VOID                         *Buffer
+    );
+
+typedef 
+EFI_STATUS
+(EFIAPI *EFI_SET_VIRTUAL_ADDRESS_MAP) (
+    IN UINTN                        MemoryMapSize,
+    IN UINTN                        DescriptorSize,
+    IN UINT32                       DescriptorVersion,
+    IN EFI_MEMORY_DESCRIPTOR        *VirtualMap
+    );
+
+
+#define EFI_OPTIONAL_PTR            0x00000001
+#define EFI_INTERNAL_FNC            0x00000002      // Pointer to internal runtime fnc
+#define EFI_INTERNAL_PTR            0x00000004      // Pointer to internal runtime data
+
+
+typedef 
+EFI_STATUS
+(EFIAPI *EFI_CONVERT_POINTER) (
+    IN UINTN                        DebugDisposition,
+    IN OUT VOID                     **Address
+    );
+
+
+//
+// EFI Events
+//
+
+
+
+#define EVT_TIMER                           0x80000000
+#define EVT_RUNTIME                         0x40000000
+#define EVT_RUNTIME_CONTEXT                 0x20000000
+
+#define EVT_NOTIFY_WAIT                     0x00000100
+#define EVT_NOTIFY_SIGNAL                   0x00000200
+
+#define EVT_SIGNAL_EXIT_BOOT_SERVICES       0x00000201
+#define EVT_SIGNAL_VIRTUAL_ADDRESS_CHANGE   0x60000202
+
+#define EVT_EFI_SIGNAL_MASK                 0x000000FF
+#define EVT_EFI_SIGNAL_MAX                  2
+
+typedef
+VOID
+(EFIAPI *EFI_EVENT_NOTIFY) (
+    IN EFI_EVENT                Event,
+    IN VOID                     *Context
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_CREATE_EVENT) (
+    IN UINT32                       Type,
+    IN EFI_TPL                      NotifyTpl,
+    IN EFI_EVENT_NOTIFY             NotifyFunction,
+    IN VOID                         *NotifyContext,
+    OUT EFI_EVENT                   *Event
+    );
+
+typedef enum {
+    TimerCancel,
+    TimerPeriodic,
+    TimerRelative,
+    TimerTypeMax
+} EFI_TIMER_DELAY;
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_SET_TIMER) (
+    IN EFI_EVENT                Event,
+    IN EFI_TIMER_DELAY          Type,
+    IN UINT64                   TriggerTime
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_SIGNAL_EVENT) (
+    IN EFI_EVENT                Event
+    );
+
+typedef 
+EFI_STATUS
+(EFIAPI *EFI_WAIT_FOR_EVENT) (
+    IN UINTN                    NumberOfEvents,
+    IN EFI_EVENT                *Event,
+    OUT UINTN                   *Index
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_CLOSE_EVENT) (
+    IN EFI_EVENT                Event
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_CHECK_EVENT) (
+    IN EFI_EVENT                Event
+    );
+
+//
+// Task priority level
+//
+
+#define TPL_APPLICATION    4
+#define TPL_CALLBACK       8
+#define TPL_NOTIFY        16 
+#define TPL_HIGH_LEVEL    31 
+
+typedef
+EFI_TPL
+(EFIAPI *EFI_RAISE_TPL) (
+    IN EFI_TPL      NewTpl
+    );
+
+typedef
+VOID
+(EFIAPI *EFI_RESTORE_TPL) (
+    IN EFI_TPL      OldTpl
+    );
+
+
+//
+// EFI platform varibles
+//
+
+#define EFI_GLOBAL_VARIABLE     \
+    { 0x8BE4DF61, 0x93CA, 0x11d2, {0xAA, 0x0D, 0x00, 0xE0, 0x98, 0x03, 0x2B, 0x8C} }
+
+// Variable attributes
+#define EFI_VARIABLE_NON_VOLATILE           0x00000001
+#define EFI_VARIABLE_BOOTSERVICE_ACCESS     0x00000002
+#define EFI_VARIABLE_RUNTIME_ACCESS         0x00000004
+
+// Variable size limitation
+#define EFI_MAXIMUM_VARIABLE_SIZE           1024
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_GET_VARIABLE) (
+    IN CHAR16                       *VariableName,
+    IN EFI_GUID                     *VendorGuid,
+    OUT UINT32                      *Attributes OPTIONAL,
+    IN OUT UINTN                    *DataSize,
+    OUT VOID                        *Data
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_GET_NEXT_VARIABLE_NAME) (
+    IN OUT UINTN                    *VariableNameSize,
+    IN OUT CHAR16                   *VariableName,
+    IN OUT EFI_GUID                 *VendorGuid
+    );
+
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_SET_VARIABLE) (
+    IN CHAR16                       *VariableName,
+    IN EFI_GUID                     *VendorGuid,
+    IN UINT32                       Attributes,
+    IN UINTN                        DataSize,
+    IN VOID                         *Data
+    );
+
+
+//
+// EFI Time
+//
+
+typedef struct {
+        UINT32                      Resolution;     // 1e-6 parts per million
+        UINT32                      Accuracy;       // hertz
+        BOOLEAN                     SetsToZero;     // Set clears sub-second time
+} EFI_TIME_CAPABILITIES;
+
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_GET_TIME) (
+    OUT EFI_TIME                    *Time,
+    OUT EFI_TIME_CAPABILITIES       *Capabilities OPTIONAL
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_SET_TIME) (
+    IN EFI_TIME                     *Time
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_GET_WAKEUP_TIME) (
+    OUT BOOLEAN                     *Enabled,
+    OUT BOOLEAN                     *Pending,
+    OUT EFI_TIME                    *Time
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_SET_WAKEUP_TIME) (
+    IN BOOLEAN                      Enable,
+    IN EFI_TIME                     *Time OPTIONAL
+    );
+
+
+//
+// Image functions
+//
+
+
+// PE32+ Subsystem type for EFI images
+
+#if !defined(IMAGE_SUBSYSTEM_EFI_APPLICATION)
+#define IMAGE_SUBSYSTEM_EFI_APPLICATION             10
+#define IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER     11
+#define IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER          12
+#endif
+
+// PE32+ Machine type for EFI images
+
+#if !defined(EFI_IMAGE_MACHINE_IA32)
+#define EFI_IMAGE_MACHINE_IA32      0x014c
+#endif
+
+#if !defined(EFI_IMAGE_MACHINE_IA64)
+#define EFI_IMAGE_MACHINE_IA64      0x0200
+#endif
+
+// Image Entry prototype
+
+typedef 
+EFI_STATUS
+(EFIAPI *EFI_IMAGE_ENTRY_POINT) (
+    IN EFI_HANDLE                   ImageHandle,
+    IN struct _EFI_SYSTEM_TABLE     *SystemTable
+    );
+
+typedef 
+EFI_STATUS
+(EFIAPI *EFI_IMAGE_LOAD) (
+    IN BOOLEAN                      BootPolicy,
+    IN EFI_HANDLE                   ParentImageHandle,
+    IN EFI_DEVICE_PATH              *FilePath,
+    IN VOID                         *SourceBuffer   OPTIONAL,
+    IN UINTN                        SourceSize,
+    OUT EFI_HANDLE                  *ImageHandle
+    );
+
+typedef 
+EFI_STATUS
+(EFIAPI *EFI_IMAGE_START) (
+    IN EFI_HANDLE                   ImageHandle,
+    OUT UINTN                       *ExitDataSize,
+    OUT CHAR16                      **ExitData  OPTIONAL
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_EXIT) (
+    IN EFI_HANDLE                   ImageHandle,
+    IN EFI_STATUS                   ExitStatus,
+    IN UINTN                        ExitDataSize,
+    IN CHAR16                       *ExitData OPTIONAL
+    );
+
+typedef 
+EFI_STATUS
+(EFIAPI *EFI_IMAGE_UNLOAD) (
+    IN EFI_HANDLE                   ImageHandle
+    );
+
+
+// Image handle
+#define LOADED_IMAGE_PROTOCOL      \
+    { 0x5B1B31A1, 0x9562, 0x11d2, {0x8E, 0x3F, 0x00, 0xA0, 0xC9, 0x69, 0x72, 0x3B} }
+
+#define EFI_IMAGE_INFORMATION_REVISION      0x1000
+typedef struct {
+    UINT32                          Revision;
+    EFI_HANDLE                      ParentHandle;
+    struct _EFI_SYSTEM_TABLE        *SystemTable;
+
+    // Source location of image
+    EFI_HANDLE                      DeviceHandle;
+    EFI_DEVICE_PATH                 *FilePath;
+    VOID                            *Reserved;
+
+    // Images load options
+    UINT32                          LoadOptionsSize;
+    VOID                            *LoadOptions;
+
+    // Location of where image was loaded
+    VOID                            *ImageBase;
+    UINT64                          ImageSize;
+    EFI_MEMORY_TYPE                 ImageCodeType;
+    EFI_MEMORY_TYPE                 ImageDataType;
+
+    // If the driver image supports a dynamic unload request
+    EFI_IMAGE_UNLOAD                Unload;
+
+} EFI_LOADED_IMAGE;
+
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_EXIT_BOOT_SERVICES) (
+    IN EFI_HANDLE                   ImageHandle,
+    IN UINTN                        MapKey
+    );
+
+//
+// Misc
+//
+
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_STALL) (
+    IN UINTN                    Microseconds
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_SET_WATCHDOG_TIMER) (
+    IN UINTN                    Timeout,
+    IN UINT64                   WatchdogCode,
+    IN UINTN                    DataSize,
+    IN CHAR16                   *WatchdogData OPTIONAL
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_CONNECT_CONTROLLER) (
+    IN EFI_HANDLE               ControllerHandle,
+    IN EFI_HANDLE               *DriverImageHandle OPTIONAL,
+    IN EFI_DEVICE_PATH          *RemainingDevicePath OPTIONAL,
+    IN BOOLEAN                  Recursive
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_DISCONNECT_CONTROLLER) (
+    IN EFI_HANDLE               ControllerHandle,
+    IN EFI_HANDLE               DriverImageHandle OPTIONAL,
+    IN EFI_HANDLE               ChildHandle OPTIONAL
+    );
+
+#define EFI_OPEN_PROTOCOL_BY_HANDLE_PROTOCOL  0x00000001
+#define EFI_OPEN_PROTOCOL_GET_PROTOCOL        0x00000002
+#define EFI_OPEN_PROTOCOL_TEST_PROTOCOL       0x00000004
+#define EFI_OPEN_PROTOCOL_BY_CHILD_CONTROLLER 0x00000008
+#define EFI_OPEN_PROTOCOL_BY_DRIVER           0x00000010
+#define EFI_OPEN_PROTOCOL_EXCLUSIVE           0x00000020
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_OPEN_PROTOCOL) (
+    IN EFI_HANDLE               Handle,
+    IN EFI_GUID                 *Protocol,
+    OUT VOID                    **Interface OPTIONAL,
+    IN EFI_HANDLE               AgentHandle,
+    IN EFI_HANDLE               ControllerHandle,
+    IN UINT32                   Attributes
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_CLOSE_PROTOCOL) (
+    IN EFI_HANDLE               Handle,
+    IN EFI_GUID                 *Protocol,
+    IN EFI_HANDLE               AgentHandle,
+    IN EFI_HANDLE               ControllerHandle
+    );
+
+typedef struct {
+    EFI_HANDLE                  AgentHandle;
+    EFI_HANDLE                  ControllerHandle;
+    UINT32                      Attributes;
+    UINT32                      OpenCount;
+} EFI_OPEN_PROTOCOL_INFORMATION_ENTRY;
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_OPEN_PROTOCOL_INFORMATION) (
+    IN EFI_HANDLE               Handle,
+    IN EFI_GUID                 *Protocol,
+    OUT EFI_OPEN_PROTOCOL_INFORMATION_ENTRY **EntryBuffer,
+    OUT UINTN                   *EntryCount
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PROTOCOLS_PER_HANDLE) (
+    IN EFI_HANDLE               Handle,
+    OUT EFI_GUID                ***ProtocolBuffer,
+    OUT UINTN                   *ProtocolBufferCount
+    );
+
+typedef enum {
+    AllHandles,
+    ByRegisterNotify,
+    ByProtocol
+} EFI_LOCATE_SEARCH_TYPE;
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_LOCATE_HANDLE_BUFFER) (
+    IN EFI_LOCATE_SEARCH_TYPE   SearchType,
+    IN EFI_GUID                 *Protocol OPTIONAL,
+    IN VOID                     *SearchKey OPTIONAL,
+    IN OUT UINTN                *NoHandles,
+    OUT EFI_HANDLE              **Buffer
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_LOCATE_PROTOCOL) (
+    IN EFI_GUID                 *Protocol,
+    IN VOID                     *Registration OPTIONAL,
+    OUT VOID                    **Interface
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_INSTALL_MULTIPLE_PROTOCOL_INTERFACES) (
+    IN OUT EFI_HANDLE           *Handle,
+    ...
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_UNINSTALL_MULTIPLE_PROTOCOL_INTERFACES) (
+    IN OUT EFI_HANDLE           Handle,
+    ...
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_CALCULATE_CRC32) (
+    IN VOID                     *Data,
+    IN UINTN                    DataSize,
+    OUT UINT32                  *Crc32
+    );
+
+typedef
+VOID
+(EFIAPI *EFI_COPY_MEM) (
+    IN VOID                     *Destination,
+    IN VOID                     *Source,
+    IN UINTN                    Length
+    );
+
+typedef
+VOID
+(EFIAPI *EFI_SET_MEM) (
+    IN VOID                     *Buffer,
+    IN UINTN                    Size,
+    IN UINT8                    Value
+    );
+
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_CREATE_EVENT_EX) (
+    IN UINT32                   Type,
+    IN EFI_TPL                  NotifyTpl,
+    IN EFI_EVENT_NOTIFY         NotifyFunction OPTIONAL,
+    IN const VOID               *NotifyContext OPTIONAL,
+    IN const EFI_GUID           EventGroup OPTIONAL,
+    OUT EFI_EVENT               *Event
+    );
+
+typedef enum {
+    EfiResetCold,
+    EfiResetWarm,
+    EfiResetShutdown
+} EFI_RESET_TYPE;
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_RESET_SYSTEM) (
+    IN EFI_RESET_TYPE           ResetType,
+    IN EFI_STATUS               ResetStatus,
+    IN UINTN                    DataSize,
+    IN CHAR16                   *ResetData OPTIONAL
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_GET_NEXT_MONOTONIC_COUNT) (
+    OUT UINT64                  *Count
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_GET_NEXT_HIGH_MONO_COUNT) (
+    OUT UINT32                  *HighCount
+    );
+
+//
+// Protocol handler functions
+//
+
+typedef enum {
+    EFI_NATIVE_INTERFACE,
+    EFI_PCODE_INTERFACE
+} EFI_INTERFACE_TYPE;
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_INSTALL_PROTOCOL_INTERFACE) (
+    IN OUT EFI_HANDLE           *Handle,
+    IN EFI_GUID                 *Protocol,
+    IN EFI_INTERFACE_TYPE       InterfaceType,
+    IN VOID                     *Interface
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_REINSTALL_PROTOCOL_INTERFACE) (
+    IN EFI_HANDLE               Handle,
+    IN EFI_GUID                 *Protocol,
+    IN VOID                     *OldInterface,
+    IN VOID                     *NewInterface
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_UNINSTALL_PROTOCOL_INTERFACE) (
+    IN EFI_HANDLE               Handle,
+    IN EFI_GUID                 *Protocol,
+    IN VOID                     *Interface
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_HANDLE_PROTOCOL) (
+    IN EFI_HANDLE               Handle,
+    IN EFI_GUID                 *Protocol,
+    OUT VOID                    **Interface
+    );
+
+typedef
+EFI_STATUS 
+(EFIAPI *EFI_REGISTER_PROTOCOL_NOTIFY) (
+    IN EFI_GUID                 *Protocol,
+    IN EFI_EVENT                Event,
+    OUT VOID                    **Registration
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_LOCATE_HANDLE) (
+    IN EFI_LOCATE_SEARCH_TYPE   SearchType,
+    IN EFI_GUID                 *Protocol OPTIONAL,
+    IN VOID                     *SearchKey OPTIONAL,
+    IN OUT UINTN                *BufferSize,
+    OUT EFI_HANDLE              *Buffer
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_LOCATE_DEVICE_PATH) (
+    IN EFI_GUID                 *Protocol,
+    IN OUT EFI_DEVICE_PATH      **DevicePath,
+    OUT EFI_HANDLE              *Device
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_INSTALL_CONFIGURATION_TABLE) (
+    IN EFI_GUID                 *Guid,
+    IN VOID                     *Table
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_RESERVED_SERVICE) (
+    );
+
+//
+// Standard EFI table header
+//
+
+typedef struct _EFI_TABLE_HEARDER {
+    UINT64                      Signature;
+    UINT32                      Revision;
+    UINT32                      HeaderSize;
+    UINT32                      CRC32;
+    UINT32                      Reserved;
+} EFI_TABLE_HEADER;
+
+
+//
+// EFI Runtime Serivces Table
+//
+
+#define EFI_RUNTIME_SERVICES_SIGNATURE  0x56524553544e5552
+#define EFI_RUNTIME_SERVICES_REVISION   (EFI_SPECIFICATION_MAJOR_REVISION<<16) | (EFI_SPECIFICATION_MINOR_REVISION)
+
+typedef struct  {
+    EFI_TABLE_HEADER                Hdr;
+
+    //
+    // Time services
+    //
+
+    EFI_GET_TIME                    GetTime;
+    EFI_SET_TIME                    SetTime;
+    EFI_GET_WAKEUP_TIME             GetWakeupTime;
+    EFI_SET_WAKEUP_TIME             SetWakeupTime;
+
+    //
+    // Virtual memory services
+    //
+
+    EFI_SET_VIRTUAL_ADDRESS_MAP     SetVirtualAddressMap;
+    EFI_CONVERT_POINTER             ConvertPointer;
+
+    //
+    // Variable serviers
+    //
+
+    EFI_GET_VARIABLE                GetVariable;
+    EFI_GET_NEXT_VARIABLE_NAME      GetNextVariableName;
+    EFI_SET_VARIABLE                SetVariable;
+
+    //
+    // Misc
+    //
+
+    EFI_GET_NEXT_HIGH_MONO_COUNT    GetNextHighMonotonicCount;
+    EFI_RESET_SYSTEM                ResetSystem;
+
+} EFI_RUNTIME_SERVICES;
+
+
+//
+// EFI Boot Services Table
+//
+
+#define EFI_BOOT_SERVICES_SIGNATURE     0x56524553544f4f42
+#define EFI_BOOT_SERVICES_REVISION      (EFI_SPECIFICATION_MAJOR_REVISION<<16) | (EFI_SPECIFICATION_MINOR_REVISION)
+
+typedef struct _EFI_BOOT_SERVICES {
+
+    EFI_TABLE_HEADER                Hdr;
+
+    //
+    // Task priority functions
+    //
+
+    EFI_RAISE_TPL                   RaiseTPL;
+    EFI_RESTORE_TPL                 RestoreTPL;
+
+    //
+    // Memory functions
+    //
+
+    EFI_ALLOCATE_PAGES              AllocatePages;
+    EFI_FREE_PAGES                  FreePages;
+    EFI_GET_MEMORY_MAP              GetMemoryMap;
+    EFI_ALLOCATE_POOL               AllocatePool;
+    EFI_FREE_POOL                   FreePool;
+
+    //
+    // Event & timer functions
+    //
+
+    EFI_CREATE_EVENT                CreateEvent;
+    EFI_SET_TIMER                   SetTimer;
+    EFI_WAIT_FOR_EVENT              WaitForEvent;
+    EFI_SIGNAL_EVENT                SignalEvent;
+    EFI_CLOSE_EVENT                 CloseEvent;
+    EFI_CHECK_EVENT                 CheckEvent;
+
+    //
+    // Protocol handler functions
+    //
+
+    EFI_INSTALL_PROTOCOL_INTERFACE  InstallProtocolInterface;
+    EFI_REINSTALL_PROTOCOL_INTERFACE ReinstallProtocolInterface;
+    EFI_UNINSTALL_PROTOCOL_INTERFACE UninstallProtocolInterface;
+    EFI_HANDLE_PROTOCOL             HandleProtocol;
+    EFI_HANDLE_PROTOCOL             PCHandleProtocol;
+    EFI_REGISTER_PROTOCOL_NOTIFY    RegisterProtocolNotify;
+    EFI_LOCATE_HANDLE               LocateHandle;
+    EFI_LOCATE_DEVICE_PATH          LocateDevicePath;
+    EFI_INSTALL_CONFIGURATION_TABLE InstallConfigurationTable;
+
+    //
+    // Image functions
+    //
+
+    EFI_IMAGE_LOAD                  LoadImage;
+    EFI_IMAGE_START                 StartImage;
+    EFI_EXIT                        Exit;
+    EFI_IMAGE_UNLOAD                UnloadImage;
+    EFI_EXIT_BOOT_SERVICES          ExitBootServices;
+
+    //
+    // Misc functions
+    //
+
+    EFI_GET_NEXT_MONOTONIC_COUNT    GetNextMonotonicCount;
+    EFI_STALL                       Stall;
+    EFI_SET_WATCHDOG_TIMER          SetWatchdogTimer;
+
+    //
+    // DriverSupport Services
+    //
+
+    EFI_CONNECT_CONTROLLER          ConnectController;
+    EFI_DISCONNECT_CONTROLLER       DisconnectController;
+
+    //
+    // Open and Close Protocol Services
+    //
+    EFI_OPEN_PROTOCOL               OpenProtocol;
+    EFI_CLOSE_PROTOCOL              CloseProtocol;
+    EFI_OPEN_PROTOCOL_INFORMATION   OpenProtocolInformation;
+
+    //
+    // Library Services
+    //
+    EFI_PROTOCOLS_PER_HANDLE        ProtocolsPerHandle;
+    EFI_LOCATE_HANDLE_BUFFER        LocateHandleBuffer;
+    EFI_LOCATE_PROTOCOL             LocateProtocol;
+    EFI_INSTALL_MULTIPLE_PROTOCOL_INTERFACES InstallMultipleProtocolInterfaces;
+    EFI_UNINSTALL_MULTIPLE_PROTOCOL_INTERFACES UninstallMultipleProtocolInterfaces;
+
+    //
+    // 32-bit CRC Services
+    //
+    EFI_CALCULATE_CRC32             CalculateCrc32;
+
+    //
+    // Misc Services
+    //
+    EFI_COPY_MEM                    CopyMem;
+    EFI_SET_MEM                     SetMem;
+    EFI_CREATE_EVENT_EX             CreateEventEx;
+} EFI_BOOT_SERVICES;
+
+
+//
+// EFI Configuration Table and GUID definitions
+//
+
+#define MPS_TABLE_GUID    \
+    { 0xeb9d2d2f, 0x2d88, 0x11d3, {0x9a, 0x16, 0x0, 0x90, 0x27, 0x3f, 0xc1, 0x4d} }
+
+#define ACPI_TABLE_GUID    \
+    { 0xeb9d2d30, 0x2d88, 0x11d3, {0x9a, 0x16, 0x0, 0x90, 0x27, 0x3f, 0xc1, 0x4d} }
+
+#define ACPI_20_TABLE_GUID  \
+    { 0x8868e871, 0xe4f1, 0x11d3, {0xbc, 0x22, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81} }
+
+#define SMBIOS_TABLE_GUID    \
+    { 0xeb9d2d31, 0x2d88, 0x11d3, {0x9a, 0x16, 0x0, 0x90, 0x27, 0x3f, 0xc1, 0x4d} }
+
+#define SAL_SYSTEM_TABLE_GUID    \
+    { 0xeb9d2d32, 0x2d88, 0x11d3, {0x9a, 0x16, 0x0, 0x90, 0x27, 0x3f, 0xc1, 0x4d} }
+
+
+typedef struct _EFI_CONFIGURATION_TABLE {
+    EFI_GUID                VendorGuid;
+    VOID                    *VendorTable;
+} EFI_CONFIGURATION_TABLE;
+
+
+//
+// EFI System Table
+//
+
+
+
+
+#define EFI_SYSTEM_TABLE_SIGNATURE      0x5453595320494249
+#define EFI_SYSTEM_TABLE_REVISION      (EFI_SPECIFICATION_MAJOR_REVISION<<16) | (EFI_SPECIFICATION_MINOR_REVISION)
+
+typedef struct _EFI_SYSTEM_TABLE {
+    EFI_TABLE_HEADER                Hdr;
+
+    CHAR16                          *FirmwareVendor;
+    UINT32                          FirmwareRevision;
+
+    EFI_HANDLE                      ConsoleInHandle;
+    SIMPLE_INPUT_INTERFACE          *ConIn;
+
+    EFI_HANDLE                      ConsoleOutHandle;
+    SIMPLE_TEXT_OUTPUT_INTERFACE    *ConOut;
+
+    EFI_HANDLE                      StandardErrorHandle;
+    SIMPLE_TEXT_OUTPUT_INTERFACE    *StdErr;
+
+    EFI_RUNTIME_SERVICES            *RuntimeServices;
+    EFI_BOOT_SERVICES               *BootServices;
+
+    UINTN                           NumberOfTableEntries;
+    EFI_CONFIGURATION_TABLE         *ConfigurationTable;
+
+} EFI_SYSTEM_TABLE;
+
+#endif
+
diff --git a/linux-x86_64/gnu-efi/include/efi/eficon.h b/linux-x86_64/gnu-efi/include/efi/eficon.h
new file mode 100644
index 0000000..089db98
--- /dev/null
+++ b/linux-x86_64/gnu-efi/include/efi/eficon.h
@@ -0,0 +1,302 @@
+#ifndef _EFI_CON_H
+#define _EFI_CON_H
+
+/*++
+
+Copyright (c) 1998  Intel Corporation
+
+Module Name:
+
+    eficon.h
+
+Abstract:
+
+    EFI console protocols
+
+
+
+Revision History
+
+--*/
+
+//
+// Text output protocol
+//
+
+#define SIMPLE_TEXT_OUTPUT_PROTOCOL \
+    { 0x387477c2, 0x69c7, 0x11d2, {0x8e, 0x39, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b} }
+
+INTERFACE_DECL(_SIMPLE_TEXT_OUTPUT_INTERFACE);
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_TEXT_RESET) (
+    IN struct _SIMPLE_TEXT_OUTPUT_INTERFACE     *This,
+    IN BOOLEAN                      ExtendedVerification
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_TEXT_OUTPUT_STRING) (
+    IN struct _SIMPLE_TEXT_OUTPUT_INTERFACE     *This,
+    IN CHAR16                       *String
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_TEXT_TEST_STRING) (
+    IN struct _SIMPLE_TEXT_OUTPUT_INTERFACE     *This,
+    IN CHAR16                       *String
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_TEXT_QUERY_MODE) (
+    IN struct _SIMPLE_TEXT_OUTPUT_INTERFACE     *This,
+    IN UINTN                        ModeNumber,
+    OUT UINTN                       *Columns,
+    OUT UINTN                       *Rows
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_TEXT_SET_MODE) (
+    IN struct _SIMPLE_TEXT_OUTPUT_INTERFACE     *This,
+    IN UINTN                        ModeNumber
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_TEXT_SET_ATTRIBUTE) (
+    IN struct _SIMPLE_TEXT_OUTPUT_INTERFACE     *This,
+    IN UINTN                        Attribute
+    );
+
+#define EFI_BLACK   0x00
+#define EFI_BLUE    0x01
+#define EFI_GREEN   0x02
+#define EFI_CYAN            (EFI_BLUE | EFI_GREEN)
+#define EFI_RED     0x04
+#define EFI_MAGENTA         (EFI_BLUE | EFI_RED)
+#define EFI_BROWN           (EFI_GREEN | EFI_RED)
+#define EFI_LIGHTGRAY       (EFI_BLUE | EFI_GREEN | EFI_RED)
+#define EFI_BRIGHT  0x08
+#define EFI_DARKGRAY        (EFI_BRIGHT)
+#define EFI_LIGHTBLUE       (EFI_BLUE | EFI_BRIGHT)
+#define EFI_LIGHTGREEN      (EFI_GREEN | EFI_BRIGHT)
+#define EFI_LIGHTCYAN       (EFI_CYAN | EFI_BRIGHT)
+#define EFI_LIGHTRED        (EFI_RED | EFI_BRIGHT)
+#define EFI_LIGHTMAGENTA    (EFI_MAGENTA | EFI_BRIGHT)
+#define EFI_YELLOW          (EFI_BROWN | EFI_BRIGHT)
+#define EFI_WHITE           (EFI_BLUE | EFI_GREEN | EFI_RED | EFI_BRIGHT)
+
+#define EFI_TEXT_ATTR(f,b)  ((f) | ((b) << 4))
+
+#define EFI_BACKGROUND_BLACK        0x00
+#define EFI_BACKGROUND_BLUE         0x10
+#define EFI_BACKGROUND_GREEN        0x20
+#define EFI_BACKGROUND_CYAN         (EFI_BACKGROUND_BLUE | EFI_BACKGROUND_GREEN)
+#define EFI_BACKGROUND_RED          0x40
+#define EFI_BACKGROUND_MAGENTA      (EFI_BACKGROUND_BLUE | EFI_BACKGROUND_RED)
+#define EFI_BACKGROUND_BROWN        (EFI_BACKGROUND_GREEN | EFI_BACKGROUND_RED)
+#define EFI_BACKGROUND_LIGHTGRAY    (EFI_BACKGROUND_BLUE | EFI_BACKGROUND_GREEN | EFI_BACKGROUND_RED)
+
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_TEXT_CLEAR_SCREEN) (
+    IN struct _SIMPLE_TEXT_OUTPUT_INTERFACE     *This
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_TEXT_SET_CURSOR_POSITION) (
+    IN struct _SIMPLE_TEXT_OUTPUT_INTERFACE     *This,
+    IN UINTN                        Column,
+    IN UINTN                        Row
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_TEXT_ENABLE_CURSOR) (
+    IN struct _SIMPLE_TEXT_OUTPUT_INTERFACE     *This,
+    IN BOOLEAN                      Enable
+    );
+
+typedef struct {
+    INT32                           MaxMode;
+    // current settings
+    INT32                           Mode;
+    INT32                           Attribute;
+    INT32                           CursorColumn;
+    INT32                           CursorRow;
+    BOOLEAN                         CursorVisible;
+} SIMPLE_TEXT_OUTPUT_MODE;
+
+typedef struct _SIMPLE_TEXT_OUTPUT_INTERFACE {
+    EFI_TEXT_RESET                  Reset;
+
+    EFI_TEXT_OUTPUT_STRING          OutputString;
+    EFI_TEXT_TEST_STRING            TestString;
+
+    EFI_TEXT_QUERY_MODE             QueryMode;
+    EFI_TEXT_SET_MODE               SetMode;
+    EFI_TEXT_SET_ATTRIBUTE          SetAttribute;
+
+    EFI_TEXT_CLEAR_SCREEN           ClearScreen;
+    EFI_TEXT_SET_CURSOR_POSITION    SetCursorPosition;
+    EFI_TEXT_ENABLE_CURSOR          EnableCursor;
+
+    // Current mode
+    SIMPLE_TEXT_OUTPUT_MODE         *Mode;
+} SIMPLE_TEXT_OUTPUT_INTERFACE;
+
+//
+// Define's for required EFI Unicode Box Draw character
+//
+
+#define BOXDRAW_HORIZONTAL                  0x2500
+#define BOXDRAW_VERTICAL                    0x2502
+#define BOXDRAW_DOWN_RIGHT                  0x250c
+#define BOXDRAW_DOWN_LEFT                   0x2510
+#define BOXDRAW_UP_RIGHT                    0x2514
+#define BOXDRAW_UP_LEFT                     0x2518
+#define BOXDRAW_VERTICAL_RIGHT              0x251c
+#define BOXDRAW_VERTICAL_LEFT               0x2524
+#define BOXDRAW_DOWN_HORIZONTAL             0x252c
+#define BOXDRAW_UP_HORIZONTAL               0x2534
+#define BOXDRAW_VERTICAL_HORIZONTAL         0x253c
+
+#define BOXDRAW_DOUBLE_HORIZONTAL           0x2550
+#define BOXDRAW_DOUBLE_VERTICAL             0x2551
+#define BOXDRAW_DOWN_RIGHT_DOUBLE           0x2552
+#define BOXDRAW_DOWN_DOUBLE_RIGHT           0x2553
+#define BOXDRAW_DOUBLE_DOWN_RIGHT           0x2554
+
+#define BOXDRAW_DOWN_LEFT_DOUBLE            0x2555
+#define BOXDRAW_DOWN_DOUBLE_LEFT            0x2556
+#define BOXDRAW_DOUBLE_DOWN_LEFT            0x2557
+
+#define BOXDRAW_UP_RIGHT_DOUBLE             0x2558
+#define BOXDRAW_UP_DOUBLE_RIGHT             0x2559
+#define BOXDRAW_DOUBLE_UP_RIGHT             0x255a
+
+#define BOXDRAW_UP_LEFT_DOUBLE              0x255b
+#define BOXDRAW_UP_DOUBLE_LEFT              0x255c
+#define BOXDRAW_DOUBLE_UP_LEFT              0x255d
+
+#define BOXDRAW_VERTICAL_RIGHT_DOUBLE       0x255e
+#define BOXDRAW_VERTICAL_DOUBLE_RIGHT       0x255f
+#define BOXDRAW_DOUBLE_VERTICAL_RIGHT       0x2560
+
+#define BOXDRAW_VERTICAL_LEFT_DOUBLE        0x2561
+#define BOXDRAW_VERTICAL_DOUBLE_LEFT        0x2562
+#define BOXDRAW_DOUBLE_VERTICAL_LEFT        0x2563
+
+#define BOXDRAW_DOWN_HORIZONTAL_DOUBLE      0x2564
+#define BOXDRAW_DOWN_DOUBLE_HORIZONTAL      0x2565
+#define BOXDRAW_DOUBLE_DOWN_HORIZONTAL      0x2566
+
+#define BOXDRAW_UP_HORIZONTAL_DOUBLE        0x2567
+#define BOXDRAW_UP_DOUBLE_HORIZONTAL        0x2568
+#define BOXDRAW_DOUBLE_UP_HORIZONTAL        0x2569
+
+#define BOXDRAW_VERTICAL_HORIZONTAL_DOUBLE  0x256a
+#define BOXDRAW_VERTICAL_DOUBLE_HORIZONTAL  0x256b
+#define BOXDRAW_DOUBLE_VERTICAL_HORIZONTAL  0x256c
+
+//
+// EFI Required Block Elements Code Chart
+//
+
+#define BLOCKELEMENT_FULL_BLOCK             0x2588
+#define BLOCKELEMENT_LIGHT_SHADE            0x2591
+//
+// EFI Required Geometric Shapes Code Chart
+//
+
+#define GEOMETRICSHAPE_UP_TRIANGLE           0x25b2
+#define GEOMETRICSHAPE_RIGHT_TRIANGLE        0x25ba
+#define GEOMETRICSHAPE_DOWN_TRIANGLE         0x25bc
+#define GEOMETRICSHAPE_LEFT_TRIANGLE         0x25c4
+
+//
+// EFI Required Arrow shapes
+//
+
+#define ARROW_UP                            0x2191
+#define ARROW_DOWN                          0x2193
+
+//
+// Text input protocol
+//
+
+#define SIMPLE_TEXT_INPUT_PROTOCOL  \
+    { 0x387477c1, 0x69c7, 0x11d2, {0x8e, 0x39, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b} }
+
+INTERFACE_DECL(_SIMPLE_INPUT_INTERFACE);
+
+typedef struct {
+    UINT16                              ScanCode;
+    CHAR16                              UnicodeChar;
+} EFI_INPUT_KEY;
+
+//
+// Baseline unicode control chars
+//
+
+#define CHAR_NULL                       0x0000
+#define CHAR_BACKSPACE                  0x0008
+#define CHAR_TAB                        0x0009
+#define CHAR_LINEFEED                   0x000A
+#define CHAR_CARRIAGE_RETURN            0x000D
+
+//
+// Scan codes for base line keys
+//
+
+#define SCAN_NULL                       0x0000
+#define SCAN_UP                         0x0001
+#define SCAN_DOWN                       0x0002
+#define SCAN_RIGHT                      0x0003
+#define SCAN_LEFT                       0x0004
+#define SCAN_HOME                       0x0005
+#define SCAN_END                        0x0006
+#define SCAN_INSERT                     0x0007
+#define SCAN_DELETE                     0x0008
+#define SCAN_PAGE_UP                    0x0009
+#define SCAN_PAGE_DOWN                  0x000A
+#define SCAN_F1                         0x000B
+#define SCAN_F2                         0x000C
+#define SCAN_F3                         0x000D
+#define SCAN_F4                         0x000E
+#define SCAN_F5                         0x000F
+#define SCAN_F6                         0x0010
+#define SCAN_F7                         0x0011
+#define SCAN_F8                         0x0012
+#define SCAN_F9                         0x0013
+#define SCAN_F10                        0x0014
+#define SCAN_ESC                        0x0017
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_INPUT_RESET) (
+    IN struct _SIMPLE_INPUT_INTERFACE   *This,
+    IN BOOLEAN                          ExtendedVerification
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_INPUT_READ_KEY) (
+    IN struct _SIMPLE_INPUT_INTERFACE   *This,
+    OUT EFI_INPUT_KEY                   *Key
+    );
+
+typedef struct _SIMPLE_INPUT_INTERFACE {
+    EFI_INPUT_RESET                     Reset;
+    EFI_INPUT_READ_KEY                  ReadKeyStroke;
+    EFI_EVENT                           WaitForKey;
+} SIMPLE_INPUT_INTERFACE;
+
+#endif
+
diff --git a/linux-x86_64/gnu-efi/include/efi/efidebug.h b/linux-x86_64/gnu-efi/include/efi/efidebug.h
new file mode 100644
index 0000000..f95d492
--- /dev/null
+++ b/linux-x86_64/gnu-efi/include/efi/efidebug.h
@@ -0,0 +1,110 @@
+#ifndef _EFI_DEBUG_H
+#define _EFI_DEBUG_H
+
+/*++
+
+Copyright (c) 1998  Intel Corporation
+
+Module Name:
+
+    efidebug.h
+
+Abstract:
+
+    EFI library debug functions
+
+
+
+Revision History
+
+--*/
+
+extern UINTN     EFIDebug;
+
+#if EFI_DEBUG
+
+    #define DBGASSERT(a)        DbgAssert(__FILE__, __LINE__, #a)
+    #define DEBUG(a)            DbgPrint a
+    
+#else
+
+    #define DBGASSERT(a)
+    #define DEBUG(a)
+    
+#endif
+
+#if EFI_DEBUG_CLEAR_MEMORY
+
+    #define DBGSETMEM(a,l)      SetMem(a,l,(CHAR8)BAD_POINTER)
+
+#else
+
+    #define DBGSETMEM(a,l)
+
+#endif
+
+#define D_INIT        0x00000001          // Initialization style messages
+#define D_WARN        0x00000002          // Warnings
+#define D_LOAD        0x00000004          // Load events
+#define D_FS          0x00000008          // EFI File system
+#define D_POOL        0x00000010          // Alloc & Free's
+#define D_PAGE        0x00000020          // Alloc & Free's
+#define D_INFO        0x00000040          // Verbose
+#define D_VAR         0x00000100          // Variable
+#define D_PARSE       0x00000200          // Command parsing
+#define D_BM          0x00000400          // Boot manager
+#define D_BLKIO       0x00001000          // BlkIo Driver
+#define D_BLKIO_ULTRA 0x00002000          // BlkIo Driver
+#define D_NET         0x00004000          // SNI Driver
+#define D_NET_ULTRA   0x00008000          // SNI Driver
+#define D_TXTIN       0x00010000          // Simple Input Driver
+#define D_TXTOUT      0x00020000          // Simple Text Output Driver
+#define D_ERROR_ATA	  0x00040000		  		// ATA error messages 
+#define D_ERROR       0x80000000          // Error
+
+#define D_RESERVED    0x7fffC880          // Bits not reserved above
+
+//
+// Current Debug level of the system, value of EFIDebug
+//
+//#define EFI_DBUG_MASK   (D_ERROR | D_WARN | D_LOAD | D_BLKIO | D_INIT)
+#define EFI_DBUG_MASK   (D_ERROR)
+
+//
+//
+//
+
+#if EFI_DEBUG
+
+    #define ASSERT(a)               if(!(a))       DBGASSERT(a)
+    #define ASSERT_LOCKED(l)        if(!(l)->Lock) DBGASSERT(l not locked)
+    #define ASSERT_STRUCT(p,t)      DBGASSERT(t not structure), p
+
+#else
+
+    #define ASSERT(a)               
+    #define ASSERT_LOCKED(l)        
+    #define ASSERT_STRUCT(p,t)      
+
+#endif
+
+//
+// Prototypes
+//
+
+INTN
+DbgAssert (
+    CHAR8   *file,
+    INTN    lineno,
+    CHAR8   *string
+    );
+
+INTN
+DbgPrint (
+    INTN    mask,
+    CHAR8   *format,
+    ...
+    );
+
+#endif
+
diff --git a/linux-x86_64/gnu-efi/include/efi/efidef.h b/linux-x86_64/gnu-efi/include/efi/efidef.h
new file mode 100644
index 0000000..07fdf0d
--- /dev/null
+++ b/linux-x86_64/gnu-efi/include/efi/efidef.h
@@ -0,0 +1,196 @@
+#ifndef _EFI_DEF_H
+#define _EFI_DEF_H
+
+/*++
+
+Copyright (c) 1998  Intel Corporation
+
+Module Name:
+
+    efidef.h
+
+Abstract:
+
+    EFI definitions
+
+
+
+
+Revision History
+
+--*/
+
+typedef UINT16          CHAR16;
+typedef UINT8           CHAR8;
+typedef UINT8           BOOLEAN;
+
+#ifndef TRUE
+    #define TRUE    ((BOOLEAN) 1)
+    #define FALSE   ((BOOLEAN) 0)
+#endif
+
+#ifndef NULL
+    #define NULL    ((VOID *) 0)
+#endif
+
+typedef UINTN           EFI_STATUS;
+typedef UINT64          EFI_LBA;
+typedef UINTN           EFI_TPL;
+typedef VOID            *EFI_HANDLE;
+typedef VOID            *EFI_EVENT;
+
+
+//
+// Prototype argument decoration for EFI parameters to indicate
+// their direction
+//
+// IN - argument is passed into the function
+// OUT - argument (pointer) is returned from the function
+// OPTIONAL - argument is optional
+//
+
+#ifndef IN
+    #define IN
+    #define OUT
+    #define OPTIONAL
+#endif
+
+
+//
+// A GUID
+//
+
+typedef struct {          
+    UINT32  Data1;
+    UINT16  Data2;
+    UINT16  Data3;
+    UINT8   Data4[8]; 
+} EFI_GUID;
+
+
+//
+// Time
+//
+
+typedef struct {          
+    UINT16      Year;       // 1998 - 20XX
+    UINT8       Month;      // 1 - 12
+    UINT8       Day;        // 1 - 31
+    UINT8       Hour;       // 0 - 23
+    UINT8       Minute;     // 0 - 59
+    UINT8       Second;     // 0 - 59
+    UINT8       Pad1;
+    UINT32      Nanosecond; // 0 - 999,999,999
+    INT16       TimeZone;   // -1440 to 1440 or 2047
+    UINT8       Daylight;
+    UINT8       Pad2;
+} EFI_TIME;
+
+// Bit definitions for EFI_TIME.Daylight
+#define EFI_TIME_ADJUST_DAYLIGHT    0x01
+#define EFI_TIME_IN_DAYLIGHT        0x02
+
+// Value definition for EFI_TIME.TimeZone
+#define EFI_UNSPECIFIED_TIMEZONE    0x07FF
+
+
+
+//
+// Networking
+//
+
+typedef struct {
+    UINT8                   Addr[4];
+} EFI_IPv4_ADDRESS;
+
+typedef struct {
+    UINT8                   Addr[16];
+} EFI_IPv6_ADDRESS;
+
+typedef struct {
+    UINT8                   Addr[32];
+} EFI_MAC_ADDRESS;
+
+//
+// Memory
+//
+
+typedef UINT64          EFI_PHYSICAL_ADDRESS;
+typedef UINT64          EFI_VIRTUAL_ADDRESS;
+
+typedef enum {
+    AllocateAnyPages,
+    AllocateMaxAddress,
+    AllocateAddress,
+    MaxAllocateType
+} EFI_ALLOCATE_TYPE;
+
+//Preseve the attr on any range supplied.
+//ConventialMemory must have WB,SR,SW when supplied.
+//When allocating from ConventialMemory always make it WB,SR,SW
+//When returning to ConventialMemory always make it WB,SR,SW
+//When getting the memory map, or on RT for runtime types
+
+
+typedef enum {
+    EfiReservedMemoryType,
+    EfiLoaderCode,
+    EfiLoaderData,
+    EfiBootServicesCode,
+    EfiBootServicesData,
+    EfiRuntimeServicesCode,
+    EfiRuntimeServicesData,
+    EfiConventionalMemory,
+    EfiUnusableMemory,
+    EfiACPIReclaimMemory,
+    EfiACPIMemoryNVS,
+    EfiMemoryMappedIO,
+    EfiMemoryMappedIOPortSpace,
+    EfiPalCode,
+    EfiMaxMemoryType
+} EFI_MEMORY_TYPE;
+
+// possible caching types for the memory range
+#define EFI_MEMORY_UC           0x0000000000000001
+#define EFI_MEMORY_WC           0x0000000000000002
+#define EFI_MEMORY_WT           0x0000000000000004
+#define EFI_MEMORY_WB           0x0000000000000008
+#define EFI_MEMORY_UCE          0x0000000000000010  
+
+// physical memory protection on range 
+#define EFI_MEMORY_WP           0x0000000000001000
+#define EFI_MEMORY_RP           0x0000000000002000
+#define EFI_MEMORY_XP           0x0000000000004000
+
+// range requires a runtime mapping
+#define EFI_MEMORY_RUNTIME      0x8000000000000000
+
+#define EFI_MEMORY_DESCRIPTOR_VERSION  1
+typedef struct {
+    UINT32                          Type;           // Field size is 32 bits followed by 32 bit pad
+    UINT32                          Pad;
+    EFI_PHYSICAL_ADDRESS            PhysicalStart;  // Field size is 64 bits
+    EFI_VIRTUAL_ADDRESS             VirtualStart;   // Field size is 64 bits
+    UINT64                          NumberOfPages;  // Field size is 64 bits
+    UINT64                          Attribute;      // Field size is 64 bits
+} EFI_MEMORY_DESCRIPTOR;
+
+//
+// International Language
+//
+
+typedef UINT8   ISO_639_2;
+#define ISO_639_2_ENTRY_SIZE    3
+
+//
+//
+//
+
+#define EFI_PAGE_SIZE   4096
+#define EFI_PAGE_MASK   0xFFF
+#define EFI_PAGE_SHIFT  12
+
+#define EFI_SIZE_TO_PAGES(a)  \
+    ( ((a) >> EFI_PAGE_SHIFT) + ((a) & EFI_PAGE_MASK ? 1 : 0) )
+
+#endif
diff --git a/linux-x86_64/gnu-efi/include/efi/efidevp.h b/linux-x86_64/gnu-efi/include/efi/efidevp.h
new file mode 100644
index 0000000..beb5785
--- /dev/null
+++ b/linux-x86_64/gnu-efi/include/efi/efidevp.h
@@ -0,0 +1,402 @@
+#ifndef _DEVPATH_H
+#define _DEVPATH_H
+
+/*++
+
+Copyright (c) 1998  Intel Corporation
+
+Module Name:
+
+    devpath.h
+
+Abstract:
+
+    Defines for parsing the EFI Device Path structures
+
+
+
+Revision History
+
+--*/
+
+//
+// Device Path structures - Section C
+//
+
+typedef struct _EFI_DEVICE_PATH {
+        UINT8                           Type;
+        UINT8                           SubType;
+        UINT8                           Length[2];
+} EFI_DEVICE_PATH;
+
+#define EFI_DP_TYPE_MASK                    0x7F
+#define EFI_DP_TYPE_UNPACKED                0x80
+
+//#define END_DEVICE_PATH_TYPE                0xff
+#define END_DEVICE_PATH_TYPE                0x7f
+//#define END_DEVICE_PATH_TYPE_UNPACKED       0x7f
+
+#define END_ENTIRE_DEVICE_PATH_SUBTYPE      0xff
+#define END_INSTANCE_DEVICE_PATH_SUBTYPE    0x01
+#define END_DEVICE_PATH_LENGTH              (sizeof(EFI_DEVICE_PATH))
+
+
+#define DP_IS_END_TYPE(a)
+#define DP_IS_END_SUBTYPE(a)        ( ((a)->SubType == END_ENTIRE_DEVICE_PATH_SUBTYPE )
+
+#define DevicePathType(a)           ( ((a)->Type) & EFI_DP_TYPE_MASK )
+#define DevicePathSubType(a)        ( (a)->SubType )
+#define DevicePathNodeLength(a)     ( ((a)->Length[0]) | ((a)->Length[1] << 8) )
+#define NextDevicePathNode(a)       ( (EFI_DEVICE_PATH *) ( ((UINT8 *) (a)) + DevicePathNodeLength(a)))
+//#define IsDevicePathEndType(a)      ( DevicePathType(a) == END_DEVICE_PATH_TYPE_UNPACKED )
+#define IsDevicePathEndType(a)      ( DevicePathType(a) == END_DEVICE_PATH_TYPE )
+#define IsDevicePathEndSubType(a)   ( (a)->SubType == END_ENTIRE_DEVICE_PATH_SUBTYPE )
+#define IsDevicePathEnd(a)          ( IsDevicePathEndType(a) && IsDevicePathEndSubType(a) )
+#define IsDevicePathUnpacked(a)     ( (a)->Type & EFI_DP_TYPE_UNPACKED )
+
+
+#define SetDevicePathNodeLength(a,l) {                  \
+            (a)->Length[0] = (UINT8) (l);               \
+            (a)->Length[1] = (UINT8) ((l) >> 8);        \
+            }
+
+#define SetDevicePathEndNode(a)  {                      \
+            (a)->Type = END_DEVICE_PATH_TYPE;           \
+            (a)->SubType = END_ENTIRE_DEVICE_PATH_SUBTYPE;     \
+            (a)->Length[0] = sizeof(EFI_DEVICE_PATH);   \
+            (a)->Length[1] = 0;                         \
+            }
+
+
+
+/*
+ *
+ */
+#define HARDWARE_DEVICE_PATH            0x01
+
+#define HW_PCI_DP                       0x01
+typedef struct _PCI_DEVICE_PATH {
+        EFI_DEVICE_PATH                 Header;
+        UINT8                           Function;
+        UINT8                           Device;
+} PCI_DEVICE_PATH;
+
+#define HW_PCCARD_DP                    0x02
+typedef struct _PCCARD_DEVICE_PATH {
+        EFI_DEVICE_PATH                 Header;
+        UINT8                           SocketNumber;
+} PCCARD_DEVICE_PATH;
+
+#define HW_MEMMAP_DP                    0x03
+typedef struct _MEMMAP_DEVICE_PATH {
+        EFI_DEVICE_PATH                 Header;
+        UINT32                          MemoryType;
+        EFI_PHYSICAL_ADDRESS            StartingAddress;
+        EFI_PHYSICAL_ADDRESS            EndingAddress;
+} MEMMAP_DEVICE_PATH;
+
+#define HW_VENDOR_DP                    0x04
+typedef struct _VENDOR_DEVICE_PATH {
+        EFI_DEVICE_PATH                 Header;
+        EFI_GUID                        Guid;
+} VENDOR_DEVICE_PATH;
+
+#define UNKNOWN_DEVICE_GUID \
+    { 0xcf31fac5, 0xc24e, 0x11d2,  {0x85, 0xf3, 0x0, 0xa0, 0xc9, 0x3e, 0xc9, 0x3b}  }
+
+typedef struct _UKNOWN_DEVICE_VENDOR_DP {
+    VENDOR_DEVICE_PATH      DevicePath;
+    UINT8                   LegacyDriveLetter;
+} UNKNOWN_DEVICE_VENDOR_DEVICE_PATH;
+
+#define HW_CONTROLLER_DP            0x05
+typedef struct _CONTROLLER_DEVICE_PATH {
+        EFI_DEVICE_PATH     Header;
+        UINT32              Controller;
+} CONTROLLER_DEVICE_PATH;
+
+/*
+ *
+ */
+#define ACPI_DEVICE_PATH                 0x02
+
+#define ACPI_DP                         0x01
+typedef struct _ACPI_HID_DEVICE_PATH {
+        EFI_DEVICE_PATH                 Header;
+        UINT32                          HID;
+        UINT32                          UID;
+} ACPI_HID_DEVICE_PATH;
+
+#define EXPANDED_ACPI_DP		0x02
+typedef struct _EXPANDED_ACPI_HID_DEVICE_PATH {
+	EFI_DEVICE_PATH			Header;
+	UINT32				HID;
+	UINT32				UID;
+	UINT32				CID;
+	UINT8				HidStr[1];
+} EXPANDED_ACPI_HID_DEVICE_PATH;
+
+//
+// EISA ID Macro
+// EISA ID Definition 32-bits
+//  bits[15:0] - three character compressed ASCII EISA ID.
+//  bits[31:16] - binary number
+//   Compressed ASCII is 5 bits per character 0b00001 = 'A' 0b11010 = 'Z'
+//
+#define PNP_EISA_ID_CONST       0x41d0    
+#define EISA_ID(_Name, _Num)    ((UINT32) ((_Name) | (_Num) << 16))   
+#define EISA_PNP_ID(_PNPId)     (EISA_ID(PNP_EISA_ID_CONST, (_PNPId)))
+
+#define PNP_EISA_ID_MASK        0xffff
+#define EISA_ID_TO_NUM(_Id)     ((_Id) >> 16)
+/*
+ *
+ */
+#define MESSAGING_DEVICE_PATH           0x03 
+
+#define MSG_ATAPI_DP                    0x01
+typedef struct _ATAPI_DEVICE_PATH {
+        EFI_DEVICE_PATH                 Header;
+        UINT8                           PrimarySecondary;
+        UINT8                           SlaveMaster;
+        UINT16                          Lun;
+} ATAPI_DEVICE_PATH;
+
+#define MSG_SCSI_DP                     0x02
+typedef struct _SCSI_DEVICE_PATH {
+        EFI_DEVICE_PATH                 Header;
+        UINT16                          Pun;
+        UINT16                          Lun; 
+} SCSI_DEVICE_PATH;
+
+#define MSG_FIBRECHANNEL_DP             0x03
+typedef struct _FIBRECHANNEL_DEVICE_PATH {
+        EFI_DEVICE_PATH                 Header;
+        UINT32                          Reserved;
+        UINT64                          WWN;
+        UINT64                          Lun;
+} FIBRECHANNEL_DEVICE_PATH;
+
+#define MSG_1394_DP                     0x04
+typedef struct _F1394_DEVICE_PATH {
+        EFI_DEVICE_PATH                 Header;
+        UINT32                          Reserved;
+        UINT64                          Guid;
+} F1394_DEVICE_PATH;
+
+#define MSG_USB_DP                      0x05
+typedef struct _USB_DEVICE_PATH {
+        EFI_DEVICE_PATH                 Header;
+        UINT8                           Port;
+        UINT8                           Endpoint;
+} USB_DEVICE_PATH;
+
+#define MSG_USB_CLASS_DP                0x0F
+typedef struct _USB_CLASS_DEVICE_PATH {
+        EFI_DEVICE_PATH                 Header;
+        UINT16                          VendorId;
+        UINT16                          ProductId;
+        UINT8                           DeviceClass;
+        UINT8                           DeviceSubclass;
+        UINT8                           DeviceProtocol;
+} USB_CLASS_DEVICE_PATH;
+
+#define MSG_I2O_DP                      0x06
+typedef struct _I2O_DEVICE_PATH {
+        EFI_DEVICE_PATH                 Header;
+        UINT32                          Tid;
+} I2O_DEVICE_PATH;
+
+#define MSG_MAC_ADDR_DP                 0x0b
+typedef struct _MAC_ADDR_DEVICE_PATH {
+        EFI_DEVICE_PATH                 Header;
+        EFI_MAC_ADDRESS                 MacAddress;
+        UINT8                           IfType;
+} MAC_ADDR_DEVICE_PATH;
+
+#define MSG_IPv4_DP                     0x0c
+typedef struct _IPv4_DEVICE_PATH {
+        EFI_DEVICE_PATH                 Header;
+        EFI_IPv4_ADDRESS                LocalIpAddress;
+        EFI_IPv4_ADDRESS                RemoteIpAddress;
+        UINT16                          LocalPort;
+        UINT16                          RemotePort;
+        UINT16                          Protocol;
+        BOOLEAN                         StaticIpAddress;
+} IPv4_DEVICE_PATH;
+
+#define MSG_IPv6_DP                     0x0d
+typedef struct _IPv6_DEVICE_PATH {
+        EFI_DEVICE_PATH                 Header;
+        EFI_IPv6_ADDRESS                LocalIpAddress;
+        EFI_IPv6_ADDRESS                RemoteIpAddress;
+        UINT16                          LocalPort;
+        UINT16                          RemotePort;
+        UINT16                          Protocol;
+        BOOLEAN                         StaticIpAddress;
+} IPv6_DEVICE_PATH;
+
+#define MSG_INFINIBAND_DP               0x09
+typedef struct _INFINIBAND_DEVICE_PATH {
+        EFI_DEVICE_PATH                 Header;
+        UINT32                          Reserved;
+        UINT64                          NodeGuid;
+        UINT64                          IocGuid;
+        UINT64                          DeviceId;
+} INFINIBAND_DEVICE_PATH;
+
+#define MSG_UART_DP                     0x0e
+typedef struct _UART_DEVICE_PATH {
+        EFI_DEVICE_PATH                 Header;
+        UINT32                          Reserved;
+        UINT64                          BaudRate;
+        UINT8                           DataBits;
+        UINT8                           Parity;
+        UINT8                           StopBits;
+} UART_DEVICE_PATH;
+
+#define MSG_VENDOR_DP                   0x0A
+/* Use VENDOR_DEVICE_PATH struct */
+
+#define DEVICE_PATH_MESSAGING_PC_ANSI \
+    { 0xe0c14753, 0xf9be, 0x11d2,  {0x9a, 0x0c, 0x00, 0x90, 0x27, 0x3f, 0xc1, 0x4d}  }
+
+#define DEVICE_PATH_MESSAGING_VT_100 \
+    { 0xdfa66065, 0xb419, 0x11d3,  {0x9a, 0x2d, 0x00, 0x90, 0x27, 0x3f, 0xc1, 0x4d}  }
+
+
+
+#define MEDIA_DEVICE_PATH               0x04
+
+#define MEDIA_HARDDRIVE_DP              0x01
+typedef struct _HARDDRIVE_DEVICE_PATH {
+        EFI_DEVICE_PATH                 Header;
+        UINT32                          PartitionNumber;
+        UINT64                          PartitionStart;
+        UINT64                          PartitionSize;
+        UINT8                           Signature[16];
+        UINT8                           MBRType;
+        UINT8                           SignatureType;
+} HARDDRIVE_DEVICE_PATH;
+
+#define MBR_TYPE_PCAT                       0x01
+#define MBR_TYPE_EFI_PARTITION_TABLE_HEADER 0x02
+
+#define SIGNATURE_TYPE_MBR                  0x01
+#define SIGNATURE_TYPE_GUID                 0x02
+
+#define MEDIA_CDROM_DP                  0x02
+typedef struct _CDROM_DEVICE_PATH {
+        EFI_DEVICE_PATH                 Header;
+        UINT32                          BootEntry;
+        UINT64                          PartitionStart;
+        UINT64                          PartitionSize;
+} CDROM_DEVICE_PATH;
+
+#define MEDIA_VENDOR_DP                 0x03
+/* Use VENDOR_DEVICE_PATH struct */
+
+#define MEDIA_FILEPATH_DP               0x04
+typedef struct _FILEPATH_DEVICE_PATH {
+        EFI_DEVICE_PATH                 Header;
+        CHAR16                          PathName[1];
+} FILEPATH_DEVICE_PATH;
+
+#define SIZE_OF_FILEPATH_DEVICE_PATH EFI_FIELD_OFFSET(FILEPATH_DEVICE_PATH,PathName)
+
+#define MEDIA_PROTOCOL_DP               0x05
+typedef struct _MEDIA_PROTOCOL_DEVICE_PATH {
+        EFI_DEVICE_PATH                 Header;
+        EFI_GUID                        Protocol;
+} MEDIA_PROTOCOL_DEVICE_PATH;
+
+
+#define BBS_DEVICE_PATH                 0x05
+#define BBS_BBS_DP                      0x01
+typedef struct _BBS_BBS_DEVICE_PATH {
+        EFI_DEVICE_PATH                 Header;
+        UINT16                          DeviceType;
+        UINT16                          StatusFlag;
+        CHAR8                           String[1];
+} BBS_BBS_DEVICE_PATH;
+
+/* DeviceType definitions - from BBS specification */
+#define BBS_TYPE_FLOPPY                 0x01
+#define BBS_TYPE_HARDDRIVE              0x02
+#define BBS_TYPE_CDROM                  0x03
+#define BBS_TYPE_PCMCIA                 0x04
+#define BBS_TYPE_USB                    0x05
+#define BBS_TYPE_EMBEDDED_NETWORK       0x06
+#define BBS_TYPE_DEV                    0x80
+#define BBS_TYPE_UNKNOWN                0xFF
+
+typedef union {
+    EFI_DEVICE_PATH                      DevPath;
+    PCI_DEVICE_PATH                      Pci;
+    PCCARD_DEVICE_PATH                   PcCard;
+    MEMMAP_DEVICE_PATH                   MemMap;
+    VENDOR_DEVICE_PATH                   Vendor;
+    UNKNOWN_DEVICE_VENDOR_DEVICE_PATH    UnknownVendor;   
+    CONTROLLER_DEVICE_PATH               Controller;
+    ACPI_HID_DEVICE_PATH                 Acpi;
+
+    ATAPI_DEVICE_PATH                    Atapi;
+    SCSI_DEVICE_PATH                     Scsi;
+    FIBRECHANNEL_DEVICE_PATH             FibreChannel;
+
+    F1394_DEVICE_PATH                    F1394;
+    USB_DEVICE_PATH                      Usb;
+    USB_CLASS_DEVICE_PATH                UsbClass;
+    I2O_DEVICE_PATH                      I2O;
+    MAC_ADDR_DEVICE_PATH                 MacAddr;
+    IPv4_DEVICE_PATH                     Ipv4;
+    IPv6_DEVICE_PATH                     Ipv6;
+    INFINIBAND_DEVICE_PATH               InfiniBand;
+    UART_DEVICE_PATH                     Uart;
+
+    HARDDRIVE_DEVICE_PATH                HardDrive;
+    CDROM_DEVICE_PATH                    CD;
+
+    FILEPATH_DEVICE_PATH                 FilePath;
+    MEDIA_PROTOCOL_DEVICE_PATH           MediaProtocol;
+
+    BBS_BBS_DEVICE_PATH                  Bbs;
+
+} EFI_DEV_PATH;
+
+typedef union {
+    EFI_DEVICE_PATH                      *DevPath;
+    PCI_DEVICE_PATH                      *Pci;
+    PCCARD_DEVICE_PATH                   *PcCard;
+    MEMMAP_DEVICE_PATH                   *MemMap;
+    VENDOR_DEVICE_PATH                   *Vendor;
+    UNKNOWN_DEVICE_VENDOR_DEVICE_PATH    *UnknownVendor;   
+    CONTROLLER_DEVICE_PATH               *Controller;
+    ACPI_HID_DEVICE_PATH                 *Acpi;
+
+    ATAPI_DEVICE_PATH                    *Atapi;
+    SCSI_DEVICE_PATH                     *Scsi;
+    FIBRECHANNEL_DEVICE_PATH             *FibreChannel;
+
+    F1394_DEVICE_PATH                    *F1394;
+    USB_DEVICE_PATH                      *Usb;
+    USB_CLASS_DEVICE_PATH                *UsbClass;
+    I2O_DEVICE_PATH                      *I2O;
+    MAC_ADDR_DEVICE_PATH                 *MacAddr;
+    IPv4_DEVICE_PATH                     *Ipv4;
+    IPv6_DEVICE_PATH                     *Ipv6;
+    INFINIBAND_DEVICE_PATH               *InfiniBand;
+    UART_DEVICE_PATH                     *Uart;
+
+    HARDDRIVE_DEVICE_PATH                *HardDrive;
+
+    FILEPATH_DEVICE_PATH                 *FilePath;
+    MEDIA_PROTOCOL_DEVICE_PATH           *MediaProtocol;
+
+    CDROM_DEVICE_PATH                    *CD;
+    BBS_BBS_DEVICE_PATH                  *Bbs;
+
+} EFI_DEV_PATH_PTR;
+
+
+#endif
diff --git a/linux-x86_64/gnu-efi/include/efi/efierr.h b/linux-x86_64/gnu-efi/include/efi/efierr.h
new file mode 100644
index 0000000..669d7ba
--- /dev/null
+++ b/linux-x86_64/gnu-efi/include/efi/efierr.h
@@ -0,0 +1,60 @@
+#ifndef _EFI_ERR_H
+#define _EFI_ERR_H
+
+/*++
+
+Copyright (c) 1998  Intel Corporation
+
+Module Name:
+
+    efierr.h
+
+Abstract:
+
+    EFI error codes
+
+
+
+
+Revision History
+
+--*/
+
+
+#define EFIWARN(a)                            (a)
+#define EFI_ERROR(a)              (((INTN) a) < 0)
+
+
+#define EFI_SUCCESS                             0
+#define EFI_LOAD_ERROR                  EFIERR(1)
+#define EFI_INVALID_PARAMETER           EFIERR(2)
+#define EFI_UNSUPPORTED                 EFIERR(3)
+#define EFI_BAD_BUFFER_SIZE             EFIERR(4)
+#define EFI_BUFFER_TOO_SMALL            EFIERR(5)
+#define EFI_NOT_READY                   EFIERR(6)
+#define EFI_DEVICE_ERROR                EFIERR(7)
+#define EFI_WRITE_PROTECTED             EFIERR(8)
+#define EFI_OUT_OF_RESOURCES            EFIERR(9)
+#define EFI_VOLUME_CORRUPTED            EFIERR(10)
+#define EFI_VOLUME_FULL                 EFIERR(11)
+#define EFI_NO_MEDIA                    EFIERR(12)
+#define EFI_MEDIA_CHANGED               EFIERR(13)
+#define EFI_NOT_FOUND                   EFIERR(14)
+#define EFI_ACCESS_DENIED               EFIERR(15)
+#define EFI_NO_RESPONSE                 EFIERR(16)
+#define EFI_NO_MAPPING                  EFIERR(17)
+#define EFI_TIMEOUT                     EFIERR(18)
+#define EFI_NOT_STARTED                 EFIERR(19)
+#define EFI_ALREADY_STARTED             EFIERR(20)
+#define EFI_ABORTED                     EFIERR(21)
+#define EFI_ICMP_ERROR                  EFIERR(22)
+#define EFI_TFTP_ERROR                  EFIERR(23)
+#define EFI_PROTOCOL_ERROR              EFIERR(24)
+
+#define EFI_WARN_UNKOWN_GLYPH           EFIWARN(1)
+#define EFI_WARN_DELETE_FAILURE         EFIWARN(2)
+#define EFI_WARN_WRITE_FAILURE          EFIWARN(3)
+#define EFI_WARN_BUFFER_TOO_SMALL       EFIWARN(4)
+
+#endif
+
diff --git a/linux-x86_64/gnu-efi/include/efi/efifs.h b/linux-x86_64/gnu-efi/include/efi/efifs.h
new file mode 100644
index 0000000..fc595d1
--- /dev/null
+++ b/linux-x86_64/gnu-efi/include/efi/efifs.h
@@ -0,0 +1,116 @@
+#ifndef _EFI_FS_H
+#define _EFI_FS_H
+
+/*++
+
+Copyright (c) 1998  Intel Corporation
+
+Module Name:
+
+    efifs.h
+
+Abstract:
+
+    EFI File System structures
+
+
+
+Revision History
+
+--*/
+
+
+//
+// EFI Partition header (normaly starts in LBA 1)
+//
+
+#define EFI_PARTITION_SIGNATURE         0x5053595320494249
+#define EFI_PARTITION_REVISION          0x00010001
+#define MIN_EFI_PARTITION_BLOCK_SIZE    512
+#define EFI_PARTITION_LBA               1
+
+typedef struct _EFI_PARTITION_HEADER {
+    EFI_TABLE_HEADER    Hdr;
+    UINT32              DirectoryAllocationNumber;
+    UINT32              BlockSize;
+    EFI_LBA             FirstUsableLba;
+    EFI_LBA             LastUsableLba;
+    EFI_LBA             UnusableSpace;
+    EFI_LBA             FreeSpace;
+    EFI_LBA             RootFile;
+    EFI_LBA             SecutiryFile;
+} EFI_PARTITION_HEADER;
+
+
+//
+// File header
+//
+
+#define EFI_FILE_HEADER_SIGNATURE   0x454c494620494249
+#define EFI_FILE_HEADER_REVISION    0x00010000
+#define EFI_FILE_STRING_SIZE        260
+
+typedef struct _EFI_FILE_HEADER {
+    EFI_TABLE_HEADER    Hdr;
+    UINT32              Class;
+    UINT32              LBALOffset;
+    EFI_LBA             Parent;
+    UINT64              FileSize;
+    UINT64              FileAttributes;
+    EFI_TIME            FileCreateTime;
+    EFI_TIME            FileModificationTime;
+    EFI_GUID            VendorGuid;
+    CHAR16              FileString[EFI_FILE_STRING_SIZE];
+} EFI_FILE_HEADER;
+
+
+//
+// Return the file's first LBAL which is in the same
+// logical block as the file header
+//
+
+#define EFI_FILE_LBAL(a)    ((EFI_LBAL *) (((CHAR8 *) (a)) + (a)->LBALOffset))
+
+#define EFI_FILE_CLASS_FREE_SPACE   1
+#define EFI_FILE_CLASS_EMPTY        2
+#define EFI_FILE_CLASS_NORMAL       3
+
+
+//
+// Logical Block Address List - the fundemental block
+// description structure
+//
+
+#define EFI_LBAL_SIGNATURE      0x4c41424c20494249
+#define EFI_LBAL_REVISION       0x00010000
+
+typedef struct _EFI_LBAL {
+    EFI_TABLE_HEADER    Hdr;
+    UINT32              Class;
+    EFI_LBA             Parent;
+    EFI_LBA             Next;
+    UINT32              ArraySize;
+    UINT32              ArrayCount;
+} EFI_LBAL;
+
+// Array size 
+#define EFI_LBAL_ARRAY_SIZE(lbal,offs,blks)  \
+        (((blks) - (offs) - (lbal)->Hdr.HeaderSize) / sizeof(EFI_RL))
+
+//
+// Logical Block run-length
+//
+
+typedef struct {
+    EFI_LBA     Start;
+    UINT64      Length;
+} EFI_RL;
+
+//
+// Return the run-length structure from an LBAL header
+//
+
+#define EFI_LBAL_RL(a)      ((EFI_RL*) (((CHAR8 *) (a)) + (a)->Hdr.HeaderSize))
+
+#endif
+
diff --git a/linux-x86_64/gnu-efi/include/efi/efigpt.h b/linux-x86_64/gnu-efi/include/efi/efigpt.h
new file mode 100644
index 0000000..d1694ae
--- /dev/null
+++ b/linux-x86_64/gnu-efi/include/efi/efigpt.h
@@ -0,0 +1,68 @@
+#ifndef _EFI_GPT_H
+#define _EFI_GPT_H
+/*++
+
+Copyright (c) 1998  Intel Corporation
+
+Module Name:
+
+    EfiGpt.h
+    
+Abstract:
+    Include file for EFI partitioning scheme
+
+
+
+Revision History
+
+--*/
+
+#define PRIMARY_PART_HEADER_LBA         1
+
+typedef struct {
+    EFI_TABLE_HEADER    Header;
+    EFI_LBA             MyLBA;
+    EFI_LBA             AlternateLBA;
+    EFI_LBA             FirstUsableLBA;
+    EFI_LBA             LastUsableLBA;
+    EFI_GUID            DiskGUID;
+    EFI_LBA             PartitionEntryLBA;
+    UINT32              NumberOfPartitionEntries;
+    UINT32              SizeOfPartitionEntry;
+    UINT32              PartitionEntryArrayCRC32;
+} EFI_PARTITION_TABLE_HEADER;
+
+#define EFI_PTAB_HEADER_ID  "EFI PART"
+
+typedef struct {
+    EFI_GUID    PartitionTypeGUID;
+    EFI_GUID    UniquePartitionGUID;
+    EFI_LBA     StartingLBA;
+    EFI_LBA     EndingLBA;
+    UINT64      Attributes;
+    CHAR16      PartitionName[36];
+} EFI_PARTITION_ENTRY;
+
+//
+// EFI Partition Attributes
+//
+#define EFI_PART_USED_BY_EFI            0x0000000000000001
+#define EFI_PART_REQUIRED_TO_FUNCTION   0x0000000000000002
+#define EFI_PART_USED_BY_OS             0x0000000000000004
+#define EFI_PART_REQUIRED_BY_OS         0x0000000000000008
+#define EFI_PART_BACKUP_REQUIRED        0x0000000000000010
+#define EFI_PART_USER_DATA              0x0000000000000020
+#define EFI_PART_CRITICAL_USER_DATA     0x0000000000000040
+#define EFI_PART_REDUNDANT_PARTITION    0x0000000000000080
+
+#define EFI_PART_TYPE_UNUSED_GUID   \
+    { 0x00000000, 0x0000, 0x0000, {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00} }
+    
+#define EFI_PART_TYPE_EFI_SYSTEM_PART_GUID  \
+    { 0xc12a7328, 0xf81f, 0x11d2, {0xba, 0x4b, 0x00, 0xa0, 0xc9, 0x3e, 0xc9, 0x3b} }
+
+#define EFI_PART_TYPE_LEGACY_MBR_GUID   \
+    { 0x024dee41, 0x33e7, 0x11d3, {0x9d, 0x69, 0x00, 0x08, 0xc7, 0x81, 0xf3, 0x9f} }
+
+#endif
+
diff --git a/linux-x86_64/gnu-efi/include/efi/efilib.h b/linux-x86_64/gnu-efi/include/efi/efilib.h
new file mode 100644
index 0000000..740c2ff
--- /dev/null
+++ b/linux-x86_64/gnu-efi/include/efi/efilib.h
@@ -0,0 +1,880 @@
+#ifndef _EFILIB_INCLUDE_
+#define _EFILIB_INCLUDE_
+
+/*++
+
+Copyright (c) 2000  Intel Corporation
+
+Module Name:
+
+    efilib.h
+
+Abstract:
+
+    EFI library functions
+
+
+
+Revision History
+
+--*/
+
+#include "efidebug.h"
+#include "efipart.h"
+#include "efilibplat.h"
+#include "efilink.h"
+#include "efirtlib.h"
+#include "pci22.h"
+#include "libsmbios.h"
+
+//
+// Public read-only data in the EFI library
+//
+
+extern EFI_SYSTEM_TABLE         *ST;
+extern EFI_BOOT_SERVICES        *BS;
+extern EFI_RUNTIME_SERVICES     *RT;
+
+extern EFI_GUID DevicePathProtocol;
+extern EFI_GUID LoadedImageProtocol;
+extern EFI_GUID TextInProtocol;
+extern EFI_GUID TextOutProtocol;
+extern EFI_GUID BlockIoProtocol;
+extern EFI_GUID DiskIoProtocol;
+extern EFI_GUID FileSystemProtocol;
+extern EFI_GUID LoadFileProtocol;
+extern EFI_GUID DeviceIoProtocol;
+extern EFI_GUID VariableStoreProtocol;
+extern EFI_GUID LegacyBootProtocol;
+extern EFI_GUID UnicodeCollationProtocol;
+extern EFI_GUID SerialIoProtocol;
+extern EFI_GUID VgaClassProtocol;
+extern EFI_GUID TextOutSpliterProtocol;
+extern EFI_GUID ErrorOutSpliterProtocol;
+extern EFI_GUID TextInSpliterProtocol;
+extern EFI_GUID SimpleNetworkProtocol;
+extern EFI_GUID PxeBaseCodeProtocol;
+extern EFI_GUID PxeCallbackProtocol;
+extern EFI_GUID NetworkInterfaceIdentifierProtocol;
+extern EFI_GUID UiProtocol;
+extern EFI_GUID InternalShellProtocol;
+extern EFI_GUID PciIoProtocol;
+
+extern EFI_GUID EfiGlobalVariable;
+extern EFI_GUID GenericFileInfo;
+extern EFI_GUID FileSystemInfo;
+extern EFI_GUID FileSystemVolumeLabelInfo;
+extern EFI_GUID PcAnsiProtocol;
+extern EFI_GUID Vt100Protocol;
+extern EFI_GUID NullGuid;
+extern EFI_GUID UnknownDevice;
+
+extern EFI_GUID EfiPartTypeSystemPartitionGuid;
+extern EFI_GUID EfiPartTypeLegacyMbrGuid;
+
+extern EFI_GUID MpsTableGuid;
+extern EFI_GUID AcpiTableGuid;
+extern EFI_GUID SMBIOSTableGuid;
+extern EFI_GUID SalSystemTableGuid;
+
+//
+// EFI Variable strings
+//
+#define LOAD_OPTION_ACTIVE      0x00000001
+
+#define VarLanguageCodes       L"LangCodes"
+#define VarLanguage            L"Lang"
+#define VarTimeout             L"Timeout"
+#define VarConsoleInp          L"ConIn"
+#define VarConsoleOut          L"ConOut"
+#define VarErrorOut            L"ErrOut"
+#define VarBootOption          L"Boot%04x"
+#define VarBootOrder           L"BootOrder"
+#define VarBootNext            L"BootNext"
+#define VarBootCurrent         L"BootCurrent"
+#define VarDriverOption        L"Driver%04x"
+#define VarDriverOrder         L"DriverOrder"
+#define VarConsoleInpDev       L"ConInDev"
+#define VarConsoleOutDev       L"ConOutDev"
+#define VarErrorOutDev         L"ErrOutDev"
+
+#define LanguageCodeEnglish    "eng"
+
+extern EFI_DEVICE_PATH RootDevicePath[];
+extern EFI_DEVICE_PATH EndDevicePath[];
+extern EFI_DEVICE_PATH EndInstanceDevicePath[];
+
+//
+// Other public data in the EFI library
+//
+
+extern EFI_MEMORY_TYPE PoolAllocationType;
+
+//
+// STATIC - Name is internal to the module
+// INTERNAL - Name is internal to the component (i.e., directory)
+// BOOTSERVCE - Name of a boot service function
+//
+
+#define STATIC
+#define INTERNAL
+#define BOOTSERVICE
+
+//
+// Prototypes
+//
+
+VOID
+InitializeLib (
+    IN EFI_HANDLE           ImageHandle,
+    IN EFI_SYSTEM_TABLE     *SystemTable
+    );
+
+VOID
+InitializeUnicodeSupport (
+    CHAR8 *LangCode
+    );
+
+VOID
+EFIDebugVariable (
+    VOID
+    );
+
+VOID
+SetCrc (
+    IN OUT EFI_TABLE_HEADER *Hdr
+    );
+
+VOID
+SetCrcAltSize (
+    IN UINTN                 Size,
+    IN OUT EFI_TABLE_HEADER *Hdr
+    );
+
+BOOLEAN
+CheckCrc (
+    IN UINTN                 MaxSize,
+    IN OUT EFI_TABLE_HEADER *Hdr
+    );
+
+BOOLEAN
+CheckCrcAltSize (
+    IN UINTN                 MaxSize,
+    IN UINTN                 Size,
+    IN OUT EFI_TABLE_HEADER *Hdr
+    );
+
+UINT32
+CalculateCrc (
+    UINT8 *pt,
+    UINTN Size
+    );
+
+VOID
+ZeroMem (
+    IN VOID     *Buffer,
+    IN UINTN     Size
+    );
+
+VOID
+SetMem (
+    IN VOID     *Buffer,
+    IN UINTN    Size,
+    IN UINT8    Value    
+    );
+
+VOID
+CopyMem (
+    IN VOID     *Dest,
+    IN VOID     *Src,
+    IN UINTN    len
+    );
+
+INTN
+CompareMem (
+    IN VOID     *Dest,
+    IN VOID     *Src,
+    IN UINTN    len
+    );
+
+INTN
+StrCmp (
+    IN CHAR16   *s1,
+    IN CHAR16   *s2
+    );
+
+INTN
+StrnCmp (
+    IN CHAR16   *s1,
+    IN CHAR16   *s2,
+    IN UINTN    len
+    );
+
+INTN
+StriCmp (
+    IN CHAR16   *s1,
+    IN CHAR16   *s2
+    );
+
+VOID
+StrLwr (
+    IN CHAR16   *Str
+    );
+
+VOID
+StrUpr (
+    IN CHAR16   *Str
+    );
+
+VOID
+StrCpy (
+    IN CHAR16   *Dest,
+    IN CHAR16    *Src
+    );
+
+VOID
+StrCat (
+    IN CHAR16   *Dest,
+    IN CHAR16   *Src
+    );
+
+UINTN
+StrLen (
+    IN CHAR16   *s1
+    );
+
+UINTN
+StrSize (
+    IN CHAR16   *s1
+    );
+
+CHAR16 *
+StrDuplicate (
+    IN CHAR16   *Src
+    );
+
+UINTN
+strlena (
+    IN CHAR8    *s1
+    );
+    
+UINTN
+strcmpa (
+    IN CHAR8    *s1,
+    IN CHAR8    *s2
+    );
+
+UINTN
+strncmpa (
+    IN CHAR8    *s1,
+    IN CHAR8    *s2,
+    IN UINTN    len
+    );
+
+UINTN
+xtoi (
+    CHAR16      *str
+    );
+
+UINTN
+Atoi (
+    CHAR16  *str
+    );
+
+BOOLEAN 
+MetaMatch (
+    IN CHAR16   *String,
+    IN CHAR16   *Pattern
+    );
+
+BOOLEAN 
+MetaiMatch (
+    IN CHAR16   *String,
+    IN CHAR16   *Pattern
+    );
+
+UINT64
+LShiftU64 (
+    IN UINT64   Operand,
+    IN UINTN    Count
+    );
+
+UINT64
+RShiftU64 (
+    IN UINT64   Operand,
+    IN UINTN    Count
+    );
+
+UINT64
+MultU64x32 (
+    IN UINT64   Multiplicand,
+    IN UINTN    Multiplier
+    );
+
+UINT64
+DivU64x32 (
+    IN UINT64   Dividend,
+    IN UINTN    Divisor,
+    OUT UINTN   *Remainder OPTIONAL
+    );
+
+VOID
+InitializeLock (
+    IN OUT FLOCK    *Lock,
+    IN EFI_TPL  Priority
+    );
+
+VOID
+AcquireLock (
+    IN FLOCK    *Lock
+    );
+
+VOID
+ReleaseLock (
+    IN FLOCK    *Lock
+    );
+
+
+INTN
+CompareGuid(
+    IN EFI_GUID     *Guid1,
+    IN EFI_GUID     *Guid2
+    );
+
+VOID *
+AllocatePool (
+    IN UINTN     Size
+    );
+
+VOID *
+AllocateZeroPool (
+    IN UINTN     Size
+    );
+
+VOID *
+ReallocatePool (
+    IN VOID                 *OldPool,
+    IN UINTN                OldSize,
+    IN UINTN                NewSize
+    );
+
+VOID
+FreePool (
+    IN VOID     *p
+    );
+
+
+VOID
+Output (
+    IN CHAR16   *Str
+    );
+
+VOID
+Input (
+    IN CHAR16   *Prompt OPTIONAL,
+    OUT CHAR16  *InStr,
+    IN UINTN    StrLen
+    );
+
+VOID
+IInput (
+    IN SIMPLE_TEXT_OUTPUT_INTERFACE     *ConOut,
+    IN SIMPLE_INPUT_INTERFACE           *ConIn,
+    IN CHAR16                           *Prompt OPTIONAL,
+    OUT CHAR16                          *InStr,
+    IN UINTN                            StrLen
+    );
+
+UINTN
+Print (
+    IN CHAR16   *fmt,
+    ...
+    );
+
+UINTN
+SPrint (
+    OUT CHAR16  *Str,
+    IN UINTN    StrSize,
+    IN CHAR16   *fmt,
+    ...
+    );
+
+CHAR16 *
+PoolPrint (
+    IN CHAR16           *fmt,
+    ...
+    );
+
+typedef struct {
+    CHAR16      *str;
+    UINTN       len;
+    UINTN       maxlen;
+} POOL_PRINT;
+
+CHAR16 *
+CatPrint (
+    IN OUT POOL_PRINT   *Str,
+    IN CHAR16           *fmt,
+    ...
+    );
+
+UINTN
+PrintAt (
+    IN UINTN    Column,
+    IN UINTN    Row,
+    IN CHAR16   *fmt,
+    ...
+    );
+
+UINTN
+IPrint (
+    IN SIMPLE_TEXT_OUTPUT_INTERFACE    *Out,
+    IN CHAR16                          *fmt,
+    ...
+    );
+
+UINTN
+IPrintAt (
+    IN SIMPLE_TEXT_OUTPUT_INTERFACE     *Out,
+    IN UINTN                            Column,
+    IN UINTN                            Row,
+    IN CHAR16                           *fmt,
+    ...
+    );
+
+UINTN
+APrint (
+    IN CHAR8    *fmt,
+    ...
+    );
+
+VOID
+ValueToHex (
+    IN CHAR16   *Buffer,
+    IN UINT64   v
+    );
+
+VOID
+ValueToString (
+    IN CHAR16   *Buffer,
+    IN BOOLEAN  Comma,
+    IN INT64    v
+    );
+
+VOID
+TimeToString (
+    OUT CHAR16      *Buffer,
+    IN EFI_TIME     *Time
+    );
+
+VOID
+GuidToString (
+    OUT CHAR16      *Buffer,
+    IN EFI_GUID     *Guid
+    );
+
+VOID
+StatusToString (
+    OUT CHAR16      *Buffer,
+    EFI_STATUS      Status
+    );
+
+VOID
+DumpHex (
+    IN UINTN        Indent,
+    IN UINTN        Offset,
+    IN UINTN        DataSize,
+    IN VOID         *UserData
+    );
+
+BOOLEAN
+GrowBuffer(
+    IN OUT EFI_STATUS   *Status,
+    IN OUT VOID         **Buffer,
+    IN UINTN            BufferSize
+    );
+
+EFI_MEMORY_DESCRIPTOR *
+LibMemoryMap (
+    OUT UINTN               *NoEntries,
+    OUT UINTN               *MapKey,
+    OUT UINTN               *DescriptorSize,
+    OUT UINT32              *DescriptorVersion
+    );
+
+VOID *
+LibGetVariable (
+    IN CHAR16               *Name,
+    IN EFI_GUID             *VendorGuid
+    );
+
+VOID *
+LibGetVariableAndSize (
+    IN CHAR16               *Name,
+    IN EFI_GUID             *VendorGuid,
+    OUT UINTN               *VarSize
+    );
+
+EFI_STATUS
+LibDeleteVariable (
+    IN CHAR16   *VarName,
+    IN EFI_GUID *VarGuid
+    );
+
+EFI_STATUS
+LibInsertToTailOfBootOrder (
+    IN  UINT16  BootOption,
+    IN  BOOLEAN OnlyInsertIfEmpty
+    );
+
+EFI_STATUS
+LibLocateProtocol (
+    IN  EFI_GUID    *ProtocolGuid,
+    OUT VOID        **Interface
+    );
+
+EFI_STATUS
+LibLocateHandle (
+    IN EFI_LOCATE_SEARCH_TYPE   SearchType,
+    IN EFI_GUID                 *Protocol OPTIONAL,
+    IN VOID                     *SearchKey OPTIONAL,
+    IN OUT UINTN                *NoHandles,
+    OUT EFI_HANDLE              **Buffer
+    );
+
+EFI_STATUS
+LibLocateHandleByDiskSignature (
+    IN UINT8                        MBRType,
+    IN UINT8                        SignatureType,
+    IN VOID                         *Signature,
+    IN OUT UINTN                    *NoHandles,
+    OUT EFI_HANDLE                  **Buffer
+    );
+
+EFI_STATUS
+LibInstallProtocolInterfaces (
+    IN OUT EFI_HANDLE       *Handle,
+    ...
+    );
+
+VOID
+LibUninstallProtocolInterfaces (
+    IN EFI_HANDLE           Handle,
+    ...
+    );
+
+EFI_STATUS
+LibReinstallProtocolInterfaces (
+    IN OUT EFI_HANDLE           *Handle,
+    ...
+    );
+
+EFI_EVENT
+LibCreateProtocolNotifyEvent (
+    IN EFI_GUID             *ProtocolGuid,
+    IN EFI_TPL              NotifyTpl,
+    IN EFI_EVENT_NOTIFY     NotifyFunction,
+    IN VOID                 *NotifyContext,
+    OUT VOID                *Registration
+    );
+
+EFI_STATUS
+WaitForSingleEvent (
+    IN EFI_EVENT        Event,
+    IN UINT64           Timeout OPTIONAL
+    );
+
+VOID
+WaitForEventWithTimeout (
+    IN  EFI_EVENT       Event,
+    IN  UINTN           Timeout,
+    IN  UINTN           Row,
+    IN  UINTN           Column,
+    IN  CHAR16          *String,
+    IN  EFI_INPUT_KEY   TimeoutKey,
+    OUT EFI_INPUT_KEY   *Key
+    );
+
+EFI_FILE_HANDLE
+LibOpenRoot (
+    IN EFI_HANDLE           DeviceHandle
+    );
+
+EFI_FILE_INFO *
+LibFileInfo (
+    IN EFI_FILE_HANDLE      FHand
+    );
+
+EFI_FILE_SYSTEM_INFO *
+LibFileSystemInfo (
+    IN EFI_FILE_HANDLE      FHand
+    );
+
+EFI_FILE_SYSTEM_VOLUME_LABEL_INFO *
+LibFileSystemVolumeLabelInfo (
+    IN EFI_FILE_HANDLE      FHand
+    );
+
+BOOLEAN
+ValidMBR(
+    IN  MASTER_BOOT_RECORD  *Mbr,
+    IN  EFI_BLOCK_IO        *BlkIo
+    );
+
+BOOLEAN
+LibMatchDevicePaths (
+    IN  EFI_DEVICE_PATH *Multi,
+    IN  EFI_DEVICE_PATH *Single
+    );
+
+EFI_DEVICE_PATH *
+LibDuplicateDevicePathInstance (
+    IN EFI_DEVICE_PATH  *DevPath
+    );
+
+EFI_DEVICE_PATH *
+DevicePathFromHandle (
+    IN EFI_HANDLE           Handle
+    );
+
+EFI_DEVICE_PATH *
+DevicePathInstance (
+    IN OUT EFI_DEVICE_PATH  **DevicePath,
+    OUT UINTN               *Size
+    );
+
+UINTN
+DevicePathInstanceCount (
+    IN EFI_DEVICE_PATH      *DevicePath
+    );
+
+EFI_DEVICE_PATH *
+AppendDevicePath (
+    IN EFI_DEVICE_PATH      *Src1,
+    IN EFI_DEVICE_PATH      *Src2
+    );
+
+EFI_DEVICE_PATH *
+AppendDevicePathNode (
+    IN EFI_DEVICE_PATH      *Src1,
+    IN EFI_DEVICE_PATH      *Src2
+    );
+
+EFI_DEVICE_PATH*
+AppendDevicePathInstance (
+    IN EFI_DEVICE_PATH  *Src,
+    IN EFI_DEVICE_PATH  *Instance
+    );
+
+EFI_DEVICE_PATH *
+FileDevicePath (
+    IN EFI_HANDLE           Device  OPTIONAL,
+    IN CHAR16               *FileName
+    );
+
+UINTN
+DevicePathSize (
+    IN EFI_DEVICE_PATH      *DevPath
+    );
+
+EFI_DEVICE_PATH *
+DuplicateDevicePath (
+    IN EFI_DEVICE_PATH      *DevPath
+    );
+
+EFI_DEVICE_PATH *
+UnpackDevicePath (
+    IN EFI_DEVICE_PATH      *DevPath
+    );
+
+EFI_STATUS
+LibDevicePathToInterface (
+    IN EFI_GUID             *Protocol,
+    IN EFI_DEVICE_PATH      *FilePath,
+    OUT VOID                **Interface
+    );
+
+CHAR16 *
+DevicePathToStr (
+    EFI_DEVICE_PATH         *DevPath
+    );
+
+//
+// BugBug: I need my own include files
+//
+typedef struct {
+    UINT8   Register;
+    UINT8   Function;
+    UINT8   Device;
+    UINT8   Bus;
+    UINT32  Reserved;
+} EFI_ADDRESS;
+
+typedef union {
+    UINT64          Address;
+    EFI_ADDRESS     EfiAddress;
+} EFI_PCI_ADDRESS_UNION;
+
+
+EFI_STATUS
+PciFindDeviceClass (
+    IN  OUT EFI_PCI_ADDRESS_UNION   *Address,
+    IN      UINT8                   BaseClass,
+    IN      UINT8                   SubClass
+    );
+
+EFI_STATUS
+PciFindDevice (
+    IN  OUT EFI_PCI_ADDRESS_UNION   *DeviceAddress,
+    IN      UINT16                  VendorId,
+    IN      UINT16                  DeviceId,
+    IN OUT  PCI_TYPE00              *Pci
+    );
+
+//
+// SIMPLE_READ_FILE object used to access files
+//
+
+typedef VOID        *SIMPLE_READ_FILE;
+
+EFI_STATUS
+OpenSimpleReadFile (
+    IN BOOLEAN                  BootPolicy,
+    IN VOID                     *SourceBuffer   OPTIONAL,
+    IN UINTN                    SourceSize,
+    IN OUT EFI_DEVICE_PATH      **FilePath,
+    OUT EFI_HANDLE              *DeviceHandle,    
+    OUT SIMPLE_READ_FILE        *SimpleReadHandle
+    );
+
+EFI_STATUS
+ReadSimpleReadFile (
+    IN SIMPLE_READ_FILE     SimpleReadHandle,
+    IN UINTN                Offset,
+    IN OUT UINTN            *ReadSize,
+    OUT VOID                *Buffer
+    );
+
+
+VOID
+CloseSimpleReadFile (
+    IN SIMPLE_READ_FILE     SimpleReadHandle
+    );
+
+VOID
+InitializeGuid (
+    VOID
+    );
+
+UINT8
+DecimaltoBCD(
+    IN  UINT8 DecValue
+    );
+
+UINT8
+BCDtoDecimal(
+    IN  UINT8 BcdValue
+    );
+
+EFI_STATUS
+LibGetSystemConfigurationTable(
+    IN EFI_GUID *TableGuid,
+    IN OUT VOID **Table
+    );
+
+BOOLEAN
+LibIsValidTextGraphics (
+    IN  CHAR16  Graphic,   
+    OUT CHAR8   *PcAnsi,    OPTIONAL
+    OUT CHAR8   *Ascii      OPTIONAL
+    );
+
+BOOLEAN
+IsValidAscii (
+    IN  CHAR16  Ascii
+    );
+
+BOOLEAN
+IsValidEfiCntlChar (
+    IN  CHAR16  c
+    );
+
+CHAR16 *
+LibGetUiString (
+    IN  EFI_HANDLE      Handle,
+    IN  UI_STRING_TYPE  StringType,
+    IN  ISO_639_2       *LangCode,
+    IN  BOOLEAN         ReturnDevicePathStrOnMismatch
+    );
+
+CHAR8*
+LibGetSmbiosString (
+    IN  SMBIOS_STRUCTURE_POINTER    *Smbios,
+    IN  UINT16                      StringNumber
+    );
+
+EFI_STATUS
+LibGetSmbiosSystemGuidAndSerialNumber (
+    IN  EFI_GUID    *SystemGuid,
+    OUT CHAR8       **SystemSerialNumber
+    );
+
+
+EFI_STATUS
+InitializeGlobalIoDevice (
+        IN  EFI_DEVICE_PATH             *DevicePath,
+        IN  EFI_GUID                    *Protocol,
+        IN  CHAR8                       *ErrorStr,
+        OUT EFI_DEVICE_IO_INTERFACE     **GlobalIoFncs 
+        );
+
+UINT32 
+ReadPort (
+        IN  EFI_DEVICE_IO_INTERFACE     *GlobalIoFncs, 
+        IN  EFI_IO_WIDTH                Width,
+        IN  UINTN                       Port
+        );
+
+UINT32 
+WritePort (
+        IN  EFI_DEVICE_IO_INTERFACE     *GlobalIoFncs, 
+        IN  EFI_IO_WIDTH                Width,
+        IN  UINTN                       Port,
+        IN  UINTN                       Data
+        );
+
+UINT32 
+ReadPciConfig (
+        IN  EFI_DEVICE_IO_INTERFACE     *GlobalIoFncs, 
+        IN  EFI_IO_WIDTH                Width,
+        IN  UINTN                       Port
+        );
+
+UINT32 
+WritePciConfig (
+        IN  EFI_DEVICE_IO_INTERFACE     *GlobalIoFncs, 
+        IN  EFI_IO_WIDTH                Width,
+        IN  UINTN                       Port,
+        IN  UINTN                       Data
+        );
+
+extern EFI_DEVICE_IO_INTERFACE  *GlobalIoFncs;
+
+#define outp(_Port, _DataByte)  (UINT8)WritePort(GlobalIoFncs,  IO_UINT8,  (UINTN)_Port, (UINTN)_DataByte)
+#define inp(_Port)              (UINT8)ReadPort(GlobalIoFncs,   IO_UINT8,  (UINTN)_Port)
+#define outpw(_Port, _DataByte) (UINT16)WritePort(GlobalIoFncs, IO_UINT16, (UINTN)_Port, (UINTN)_DataByte)
+#define inpw(_Port)             (UINT16)ReadPort(GlobalIoFncs,  IO_UINT16, (UINTN)_Port)
+#define outpd(_Port, _DataByte) (UINT32)WritePort(GlobalIoFncs, IO_UINT32, (UINTN)_Port, (UINTN)_DataByte)
+#define inpd(_Port)             (UINT32)ReadPort(GlobalIoFncs,  IO_UINT32, (UINTN)_Port)
+
+#define writepci8(_Addr, _DataByte)  (UINT8)WritePciConfig(GlobalIoFncs,  IO_UINT8,  (UINTN)_Addr, (UINTN)_DataByte)
+#define readpci8(_Addr)              (UINT8)ReadPciConfig(GlobalIoFncs,   IO_UINT8,  (UINTN)_Addr)
+#define writepci16(_Addr, _DataByte) (UINT16)WritePciConfig(GlobalIoFncs, IO_UINT16, (UINTN)_Addr, (UINTN)_DataByte)
+#define readpci16(_Addr)             (UINT16)ReadPciConfig(GlobalIoFncs,  IO_UINT16, (UINTN)_Addr)
+#define writepci32(_Addr, _DataByte) (UINT32)WritePciConfig(GlobalIoFncs, IO_UINT32, (UINTN)_Addr, (UINTN)_DataByte)
+#define readpci32(_Addr)             (UINT32)ReadPciConfig(GlobalIoFncs,  IO_UINT32, (UINTN)_Addr)
+
+#define Pause()             WaitForSingleEvent (ST->ConIn->WaitForKey, 0)
+#define Port80(_PostCode)   GlobalIoFncs->Io.Write (GlobalIoFncs, IO_UINT16, (UINT64)0x80, 1, &(_PostCode))
+
+#endif
diff --git a/linux-x86_64/gnu-efi/include/efi/efilink.h b/linux-x86_64/gnu-efi/include/efi/efilink.h
new file mode 100644
index 0000000..b2ff4fa
--- /dev/null
+++ b/linux-x86_64/gnu-efi/include/efi/efilink.h
@@ -0,0 +1,177 @@
+#ifndef _EFI_LINK_H
+#define _EFI_LINK_H
+
+/*++
+
+Copyright (c) 1998  Intel Corporation
+
+Module Name:
+
+    link.h (renamed efilink.h to avoid conflicts)
+
+Abstract:
+
+    EFI link list macro's
+
+
+
+Revision History
+
+--*/
+
+#ifndef EFI_NT_EMUL
+
+//
+// List entry - doubly linked list
+//
+
+typedef struct _LIST_ENTRY {
+    struct _LIST_ENTRY  *Flink;
+    struct _LIST_ENTRY  *Blink;
+} LIST_ENTRY;
+
+#endif 
+
+
+//
+//  VOID
+//  InitializeListHead(
+//      LIST_ENTRY *ListHead
+//      );
+//
+
+#define InitializeListHead(ListHead) \
+    (ListHead)->Flink = ListHead;    \
+    (ListHead)->Blink = ListHead;
+
+//
+//  BOOLEAN
+//  IsListEmpty(
+//      PLIST_ENTRY ListHead
+//      );
+//
+
+#define IsListEmpty(ListHead) \
+    ((ListHead)->Flink == (ListHead))
+
+//
+//  VOID
+//  RemoveEntryList(
+//      PLIST_ENTRY Entry
+//      );
+//
+
+#define _RemoveEntryList(Entry) {       \
+        LIST_ENTRY *_Blink, *_Flink;    \
+        _Flink = (Entry)->Flink;        \
+        _Blink = (Entry)->Blink;        \
+        _Blink->Flink = _Flink;         \
+        _Flink->Blink = _Blink;         \
+        }
+
+#if EFI_DEBUG
+    #define RemoveEntryList(Entry)                      \
+        _RemoveEntryList(Entry);                        \
+        (Entry)->Flink = (LIST_ENTRY *) BAD_POINTER;    \
+        (Entry)->Blink = (LIST_ENTRY *) BAD_POINTER; 
+#else
+    #define RemoveEntryList(Entry)      \
+        _RemoveEntryList(Entry);
+#endif
+
+//
+//  VOID
+//  InsertTailList(
+//      PLIST_ENTRY ListHead,
+//      PLIST_ENTRY Entry
+//      );
+//
+
+#define InsertTailList(ListHead,Entry) {\
+    LIST_ENTRY *_ListHead, *_Blink;     \
+    _ListHead = (ListHead);             \
+    _Blink = _ListHead->Blink;          \
+    (Entry)->Flink = _ListHead;         \
+    (Entry)->Blink = _Blink;            \
+    _Blink->Flink = (Entry);            \
+    _ListHead->Blink = (Entry);         \
+    }
+
+//
+//  VOID
+//  InsertHeadList(
+//      PLIST_ENTRY ListHead,
+//      PLIST_ENTRY Entry
+//      );
+//
+
+#define InsertHeadList(ListHead,Entry) {\
+    LIST_ENTRY *_ListHead, *_Flink;     \
+    _ListHead = (ListHead);             \
+    _Flink = _ListHead->Flink;          \
+    (Entry)->Flink = _Flink;            \
+    (Entry)->Blink = _ListHead;         \
+    _Flink->Blink = (Entry);            \
+    _ListHead->Flink = (Entry);         \
+    }
+
+//  VOID
+//  SwapListEntries(
+//      PLIST_ENTRY Entry1,
+//      PLIST_ENTRY Entry2
+//      );
+//
+// Put Entry2 before Entry1
+//
+#define SwapListEntries(Entry1,Entry2) {\
+    LIST_ENTRY *Entry1Flink, *Entry1Blink;     \
+    LIST_ENTRY *Entry2Flink, *Entry2Blink;     \
+    Entry2Flink = (Entry2)->Flink;             \
+    Entry2Blink = (Entry2)->Blink;             \
+    Entry1Flink = (Entry1)->Flink;             \
+    Entry1Blink = (Entry1)->Blink;             \
+    Entry2Blink->Flink = Entry2Flink;       \
+    Entry2Flink->Blink = Entry2Blink;        \
+    (Entry2)->Flink = Entry1;               \
+    (Entry2)->Blink = Entry1Blink;          \
+    Entry1Blink->Flink = (Entry2);            \
+    (Entry1)->Blink = (Entry2);             \
+    }
+
+//
+//  EFI_FIELD_OFFSET - returns the byte offset to a field within a structure
+//
+
+#define EFI_FIELD_OFFSET(TYPE,Field) ((UINTN)(&(((TYPE *) 0)->Field)))
+
+//
+//  CONTAINING_RECORD - returns a pointer to the structure
+//      from one of it's elements.
+//
+
+#define _CR(Record, TYPE, Field)  \
+    ((TYPE *) ( (CHAR8 *)(Record) - (CHAR8 *) &(((TYPE *) 0)->Field)))
+
+#if EFI_DEBUG
+    #define CR(Record, TYPE, Field, Sig)     \
+        _CR(Record, TYPE, Field)->Signature != Sig ?        \
+            (TYPE *) ASSERT_STRUCT(_CR(Record, TYPE, Field), Record) : \
+            _CR(Record, TYPE, Field)
+#else
+    #define CR(Record, TYPE, Field, Signature)   \
+        _CR(Record, TYPE, Field)                           
+#endif
+
+
+//
+// A lock structure
+//
+
+typedef struct _FLOCK {
+    EFI_TPL     Tpl;
+    EFI_TPL     OwnerTpl;
+    UINTN       Lock;
+} FLOCK;
+
+#endif
+
diff --git a/linux-x86_64/gnu-efi/include/efi/efinet.h b/linux-x86_64/gnu-efi/include/efi/efinet.h
new file mode 100644
index 0000000..b2e5aa8
--- /dev/null
+++ b/linux-x86_64/gnu-efi/include/efi/efinet.h
@@ -0,0 +1,340 @@
+#ifndef _EFINET_H
+#define _EFINET_H
+
+
+/*++
+Copyright (c) 1999  Intel Corporation
+
+Module Name:
+    efinet.h
+
+Abstract:
+    EFI Simple Network protocol
+
+Revision History
+--*/
+
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//      Simple Network Protocol
+//
+
+#define EFI_SIMPLE_NETWORK_PROTOCOL \
+    { 0xA19832B9, 0xAC25, 0x11D3, {0x9A, 0x2D, 0x00, 0x90, 0x27, 0x3F, 0xC1, 0x4D} }
+
+
+INTERFACE_DECL(_EFI_SIMPLE_NETWORK);
+
+///////////////////////////////////////////////////////////////////////////////
+//
+
+typedef struct {
+    //
+    // Total number of frames received.  Includes frames with errors and
+    // dropped frames.
+    //
+    UINT64  RxTotalFrames;
+
+    //
+    // Number of valid frames received and copied into receive buffers.
+    //
+    UINT64  RxGoodFrames;
+
+    //
+    // Number of frames below the minimum length for the media.
+    // This would be <64 for ethernet.
+    //
+    UINT64  RxUndersizeFrames;
+
+    //
+    // Number of frames longer than the maxminum length for the
+    // media.  This would be >1500 for ethernet.
+    //
+    UINT64  RxOversizeFrames;
+
+    //
+    // Valid frames that were dropped because receive buffers were full.
+    //
+    UINT64  RxDroppedFrames;
+
+    //
+    // Number of valid unicast frames received and not dropped.
+    //
+    UINT64  RxUnicastFrames;
+
+    //
+    // Number of valid broadcast frames received and not dropped.
+    //
+    UINT64  RxBroadcastFrames;
+
+    //
+    // Number of valid mutlicast frames received and not dropped.
+    //
+    UINT64  RxMulticastFrames;
+
+    //
+    // Number of frames w/ CRC or alignment errors.
+    //
+    UINT64  RxCrcErrorFrames;
+
+    //
+    // Total number of bytes received.  Includes frames with errors
+    // and dropped frames.
+    //
+    UINT64  RxTotalBytes;
+
+    //
+    // Transmit statistics.
+    //
+    UINT64  TxTotalFrames;
+    UINT64  TxGoodFrames;
+    UINT64  TxUndersizeFrames;
+    UINT64  TxOversizeFrames;
+    UINT64  TxDroppedFrames;
+    UINT64  TxUnicastFrames;
+    UINT64  TxBroadcastFrames;
+    UINT64  TxMulticastFrames;
+    UINT64  TxCrcErrorFrames;
+    UINT64  TxTotalBytes;
+
+    //
+    // Number of collisions detection on this subnet.
+    //
+    UINT64  Collisions;
+
+    //
+    // Number of frames destined for unsupported protocol.
+    //
+    UINT64  UnsupportedProtocol;
+
+} EFI_NETWORK_STATISTICS;
+
+///////////////////////////////////////////////////////////////////////////////
+//
+
+typedef enum {
+    EfiSimpleNetworkStopped,
+    EfiSimpleNetworkStarted,
+    EfiSimpleNetworkInitialized,
+    EfiSimpleNetworkMaxState
+} EFI_SIMPLE_NETWORK_STATE;
+
+///////////////////////////////////////////////////////////////////////////////
+//
+
+#define EFI_SIMPLE_NETWORK_RECEIVE_UNICAST               0x01
+#define EFI_SIMPLE_NETWORK_RECEIVE_MULTICAST             0x02
+#define EFI_SIMPLE_NETWORK_RECEIVE_BROADCAST             0x04
+#define EFI_SIMPLE_NETWORK_RECEIVE_PROMISCUOUS           0x08
+#define EFI_SIMPLE_NETWORK_RECEIVE_PROMISCUOUS_MULTICAST 0x10
+
+///////////////////////////////////////////////////////////////////////////////
+//
+
+#define EFI_SIMPLE_NETWORK_RECEIVE_INTERRUPT        0x01
+#define EFI_SIMPLE_NETWORK_TRANSMIT_INTERRUPT       0x02
+#define EFI_SIMPLE_NETWORK_COMMAND_INTERRUPT        0x04
+#define EFI_SIMPLE_NETWORK_SOFTWARE_INTERRUPT       0x08
+
+///////////////////////////////////////////////////////////////////////////////
+//
+#define MAX_MCAST_FILTER_CNT    16
+typedef struct {
+    UINT32                      State;
+    UINT32                      HwAddressSize;
+    UINT32                      MediaHeaderSize;
+    UINT32                      MaxPacketSize;
+    UINT32                      NvRamSize;
+    UINT32                      NvRamAccessSize;
+    UINT32                      ReceiveFilterMask;
+    UINT32                      ReceiveFilterSetting;
+    UINT32                      MaxMCastFilterCount;
+    UINT32                      MCastFilterCount;
+    EFI_MAC_ADDRESS             MCastFilter[MAX_MCAST_FILTER_CNT];
+    EFI_MAC_ADDRESS             CurrentAddress;
+    EFI_MAC_ADDRESS             BroadcastAddress;
+    EFI_MAC_ADDRESS             PermanentAddress;
+    UINT8                       IfType;
+    BOOLEAN                     MacAddressChangeable;
+    BOOLEAN                     MultipleTxSupported;
+    BOOLEAN                     MediaPresentSupported;
+    BOOLEAN                     MediaPresent;
+} EFI_SIMPLE_NETWORK_MODE;
+
+///////////////////////////////////////////////////////////////////////////////
+//
+
+typedef 
+EFI_STATUS 
+(EFIAPI *EFI_SIMPLE_NETWORK_START) (
+    IN struct _EFI_SIMPLE_NETWORK  *This
+);
+
+///////////////////////////////////////////////////////////////////////////////
+//
+
+typedef 
+EFI_STATUS 
+(EFIAPI *EFI_SIMPLE_NETWORK_STOP) (
+    IN struct _EFI_SIMPLE_NETWORK  *This
+);
+
+///////////////////////////////////////////////////////////////////////////////
+//
+
+typedef 
+EFI_STATUS 
+(EFIAPI *EFI_SIMPLE_NETWORK_INITIALIZE) (
+    IN struct _EFI_SIMPLE_NETWORK  *This,
+    IN UINTN                       ExtraRxBufferSize  OPTIONAL,
+    IN UINTN                       ExtraTxBufferSize  OPTIONAL
+);
+
+///////////////////////////////////////////////////////////////////////////////
+//
+
+typedef 
+EFI_STATUS 
+(EFIAPI *EFI_SIMPLE_NETWORK_RESET) (
+    IN struct _EFI_SIMPLE_NETWORK   *This,
+    IN BOOLEAN                      ExtendedVerification
+);
+
+///////////////////////////////////////////////////////////////////////////////
+//
+
+typedef 
+EFI_STATUS 
+(EFIAPI *EFI_SIMPLE_NETWORK_SHUTDOWN) (
+    IN struct _EFI_SIMPLE_NETWORK  *This
+);
+
+///////////////////////////////////////////////////////////////////////////////
+//
+
+typedef 
+EFI_STATUS 
+(EFIAPI *EFI_SIMPLE_NETWORK_RECEIVE_FILTERS) (
+    IN struct _EFI_SIMPLE_NETWORK   *This,
+    IN UINT32                       Enable,
+    IN UINT32                       Disable,
+    IN BOOLEAN                      ResetMCastFilter,
+    IN UINTN                        MCastFilterCnt     OPTIONAL,
+    IN EFI_MAC_ADDRESS              *MCastFilter       OPTIONAL
+);
+
+///////////////////////////////////////////////////////////////////////////////
+//
+
+typedef 
+EFI_STATUS 
+(EFIAPI *EFI_SIMPLE_NETWORK_STATION_ADDRESS) (
+    IN struct _EFI_SIMPLE_NETWORK   *This,
+    IN BOOLEAN                      Reset,
+    IN EFI_MAC_ADDRESS              *New      OPTIONAL
+);
+
+///////////////////////////////////////////////////////////////////////////////
+//
+
+typedef 
+EFI_STATUS 
+(EFIAPI *EFI_SIMPLE_NETWORK_STATISTICS) (
+    IN struct _EFI_SIMPLE_NETWORK   *This,
+    IN BOOLEAN                      Reset,
+    IN OUT UINTN                    *StatisticsSize   OPTIONAL,
+    OUT EFI_NETWORK_STATISTICS      *StatisticsTable  OPTIONAL
+);
+
+///////////////////////////////////////////////////////////////////////////////
+//
+
+typedef 
+EFI_STATUS 
+(EFIAPI *EFI_SIMPLE_NETWORK_MCAST_IP_TO_MAC) (
+    IN struct _EFI_SIMPLE_NETWORK   *This,
+    IN BOOLEAN                      IPv6,
+    IN EFI_IP_ADDRESS               *IP,
+    OUT EFI_MAC_ADDRESS             *MAC
+);
+
+///////////////////////////////////////////////////////////////////////////////
+//
+
+typedef 
+EFI_STATUS 
+(EFIAPI *EFI_SIMPLE_NETWORK_NVDATA) (
+    IN struct _EFI_SIMPLE_NETWORK  *This,
+    IN BOOLEAN                     ReadWrite,
+    IN UINTN                       Offset,
+    IN UINTN                       BufferSize,
+    IN OUT VOID                    *Buffer
+);
+
+///////////////////////////////////////////////////////////////////////////////
+//
+
+typedef 
+EFI_STATUS 
+(EFIAPI *EFI_SIMPLE_NETWORK_GET_STATUS) (
+    IN struct _EFI_SIMPLE_NETWORK  *This,
+    OUT UINT32                     *InterruptStatus  OPTIONAL,
+    OUT VOID                       **TxBuf           OPTIONAL
+);
+
+///////////////////////////////////////////////////////////////////////////////
+//
+
+typedef 
+EFI_STATUS 
+(EFIAPI *EFI_SIMPLE_NETWORK_TRANSMIT) (
+    IN struct _EFI_SIMPLE_NETWORK   *This,
+    IN UINTN                        HeaderSize,
+    IN UINTN                        BufferSize,
+    IN VOID                         *Buffer,
+    IN EFI_MAC_ADDRESS              *SrcAddr     OPTIONAL,
+    IN EFI_MAC_ADDRESS              *DestAddr    OPTIONAL,
+    IN UINT16                       *Protocol    OPTIONAL
+);
+
+///////////////////////////////////////////////////////////////////////////////
+//
+
+typedef 
+EFI_STATUS 
+(EFIAPI *EFI_SIMPLE_NETWORK_RECEIVE) (
+    IN struct _EFI_SIMPLE_NETWORK   *This,
+    OUT UINTN                       *HeaderSize  OPTIONAL,
+    IN OUT UINTN                    *BufferSize,
+    OUT VOID                        *Buffer,
+    OUT EFI_MAC_ADDRESS             *SrcAddr     OPTIONAL,
+    OUT EFI_MAC_ADDRESS             *DestAddr    OPTIONAL,
+    OUT UINT16                      *Protocol    OPTIONAL
+);
+
+///////////////////////////////////////////////////////////////////////////////
+//
+
+#define EFI_SIMPLE_NETWORK_INTERFACE_REVISION   0x00010000
+
+typedef struct _EFI_SIMPLE_NETWORK {
+    UINT64                              Revision;
+    EFI_SIMPLE_NETWORK_START            Start;
+    EFI_SIMPLE_NETWORK_STOP             Stop;
+    EFI_SIMPLE_NETWORK_INITIALIZE       Initialize;
+    EFI_SIMPLE_NETWORK_RESET            Reset;
+    EFI_SIMPLE_NETWORK_SHUTDOWN         Shutdown;
+    EFI_SIMPLE_NETWORK_RECEIVE_FILTERS  ReceiveFilters;
+    EFI_SIMPLE_NETWORK_STATION_ADDRESS  StationAddress;
+    EFI_SIMPLE_NETWORK_STATISTICS       Statistics;
+    EFI_SIMPLE_NETWORK_MCAST_IP_TO_MAC  MCastIpToMac;
+    EFI_SIMPLE_NETWORK_NVDATA           NvData;
+    EFI_SIMPLE_NETWORK_GET_STATUS       GetStatus;
+    EFI_SIMPLE_NETWORK_TRANSMIT         Transmit;
+    EFI_SIMPLE_NETWORK_RECEIVE          Receive;
+    EFI_EVENT                           WaitForPacket;
+    EFI_SIMPLE_NETWORK_MODE             *Mode;
+} EFI_SIMPLE_NETWORK;
+
+#endif /* _EFINET_H */
diff --git a/linux-x86_64/gnu-efi/include/efi/efipart.h b/linux-x86_64/gnu-efi/include/efi/efipart.h
new file mode 100644
index 0000000..d4c5573
--- /dev/null
+++ b/linux-x86_64/gnu-efi/include/efi/efipart.h
@@ -0,0 +1,61 @@
+#ifndef _EFI_PART_H
+#define _EFI_PART_H
+
+/*++
+
+Copyright (c) 1998  Intel Corporation
+
+Module Name:
+
+    efipart.h
+    
+Abstract:   
+    Info about disk partitions and Master Boot Records
+
+
+
+
+Revision History
+
+--*/
+
+//
+//
+//
+
+#define EFI_PARTITION   0xef
+#define MBR_SIZE        512
+
+#pragma pack(1)
+
+typedef struct {
+    UINT8       BootIndicator;
+    UINT8       StartHead;
+    UINT8       StartSector;
+    UINT8       StartTrack;
+    UINT8       OSIndicator;
+    UINT8       EndHead;
+    UINT8       EndSector;
+    UINT8       EndTrack;
+    UINT8       StartingLBA[4];
+    UINT8       SizeInLBA[4];
+} MBR_PARTITION_RECORD;
+
+#define EXTRACT_UINT32(D) (UINT32)(D[0] | (D[1] << 8) | (D[2] << 16) | (D[3] << 24))
+
+#define MBR_SIGNATURE           0xaa55
+#define MIN_MBR_DEVICE_SIZE     0x80000
+#define MBR_ERRATA_PAD          0x40000 // 128 MB
+
+#define MAX_MBR_PARTITIONS  4   
+typedef struct {
+    UINT8                   BootStrapCode[440];
+    UINT8                   UniqueMbrSignature[4];
+    UINT8                   Unknown[2];
+    MBR_PARTITION_RECORD    Partition[MAX_MBR_PARTITIONS];
+    UINT16                  Signature;
+} MASTER_BOOT_RECORD;
+#pragma pack()
+
+
+#endif
diff --git a/linux-x86_64/gnu-efi/include/efi/efipciio.h b/linux-x86_64/gnu-efi/include/efi/efipciio.h
new file mode 100644
index 0000000..0724f95
--- /dev/null
+++ b/linux-x86_64/gnu-efi/include/efi/efipciio.h
@@ -0,0 +1,219 @@
+#ifndef _EFI_PCI_IO_H
+#define _EFI_PCI_IO_H
+
+#define EFI_PCI_IO_PROTOCOL \
+    { 0x4cf5b200, 0x68b8, 0x4ca5, {0x9e, 0xec, 0xb2, 0x3e, 0x3f, 0x50, 0x02, 0x9a} }
+
+INTERFACE_DECL(_EFI_PCI_IO);
+
+typedef enum {
+    EfiPciIoWidthUint8,
+    EfiPciIoWidthUint16,
+    EfiPciIoWidthUint32,
+    EfiPciIoWidthUint64,
+    EfiPciIoWidthFifoUint8,
+    EfiPciIoWidthFifoUint16,
+    EfiPciIoWidthFifoUint32,
+    EfiPciIoWidthFifoUint64,
+    EfiPciIoWidthFillUint8,
+    EfiPciIoWidthFillUint16,
+    EfiPciIoWidthFillUint32,
+    EfiPciIoWidthFillUint64,
+    EfiPciIoWidthMaximum
+} EFI_PCI_IO_PROTOCOL_WIDTH;
+
+#define EFI_PCI_IO_PASS_THROUGH_BAR 0xff
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PCI_IO_PROTOCOL_POLL_IO_MEM) (
+  IN struct _EFI_PCI_IO *This,
+  IN EFI_PCI_IO_PROTOCOL_WIDTH  Width,
+  IN UINT8                      BarIndex,
+  IN UINT64                     Offset,
+  IN UINT64                     Mask,
+  IN UINT64                     Value,
+  IN UINT64                     Delay,
+  OUT UINT64                    *Result
+  );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PCI_IO_PROTOCOL_IO_MEM) (
+  IN struct _EFI_PCI_IO *This,
+  IN EFI_PCI_IO_PROTOCOL_WIDTH  Width,
+  IN UINT8                      BarIndex,
+  IN UINT64                     Offset,
+  IN UINTN                      Count,
+  IN OUT VOID                   *Buffer
+);
+
+typedef struct {
+  EFI_PCI_IO_PROTOCOL_IO_MEM    Read;
+  EFI_PCI_IO_PROTOCOL_IO_MEM    Write;
+} EFI_PCI_IO_PROTOCOL_ACCESS;
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PCI_IO_PROTOCOL_CONFIG) (
+  IN struct _EFI_PCI_IO *This,
+  IN EFI_PCI_IO_PROTOCOL_WIDTH  Width,
+  IN UINT32                     Offset,
+  IN UINTN                      Count,
+  IN OUT VOID                   *Buffer
+);
+
+typedef struct {
+  EFI_PCI_IO_PROTOCOL_CONFIG Read;
+  EFI_PCI_IO_PROTOCOL_CONFIG Write;
+} EFI_PCI_IO_PROTOCOL_CONFIG_ACCESS;
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PCI_IO_PROTOCOL_COPY_MEM) (
+  IN struct _EFI_PCI_IO *This,
+  IN EFI_PCI_IO_PROTOCOL_WIDTH  Width,
+  IN UINT8                      DestBarIndex,
+  IN UINT64                     DestOffset,
+  IN UINT8                      SrcBarIndex,
+  IN UINT64                     SrcOffset,
+  IN UINTN                      Count
+  );
+
+typedef enum {
+    EfiPciIoOperationBusMasterRead,
+    EfiPciIoOperationBusMasterWrite,
+    EfiPciIoOperationBusMasterCommonBuffer,
+    EfiPciIoOperationMaximum
+} EFI_PCI_IO_PROTOCOL_OPERATION;
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PCI_IO_PROTOCOL_MAP) (
+  IN struct _EFI_PCI_IO    *This,
+  IN EFI_PCI_IO_PROTOCOL_OPERATION Operation,
+  IN VOID                          *HostAddress,
+  IN OUT UINTN                     *NumberOfBytes,
+  OUT EFI_PHYSICAL_ADDRESS         *DeviceAddress,
+  OUT VOID                         **Mapping
+  );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PCI_IO_PROTOCOL_UNMAP) (
+  IN struct _EFI_PCI_IO *This,
+  IN VOID                       *Mapping
+);
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PCI_IO_PROTOCOL_ALLOCATE_BUFFER) (
+  IN struct _EFI_PCI_IO *This,
+  IN EFI_ALLOCATE_TYPE          Type,
+  IN EFI_MEMORY_TYPE            MemoryType,
+  IN UINTN                      Pages,
+  OUT VOID                      **HostAddress,
+  IN UINT64                     Attributes
+  );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PCI_IO_PROTOCOL_FREE_BUFFER) (
+  IN struct _EFI_PCI_IO *This,
+  IN UINTN                      Pages,
+  IN VOID                       *HostAddress
+  );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PCI_IO_PROTOCOL_FLUSH) (
+  IN struct _EFI_PCI_IO *This
+  );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PCI_IO_PROTOCOL_GET_LOCATION) (
+  IN struct _EFI_PCI_IO *This,
+  OUT UINTN                     *SegmentNumber,
+  OUT UINTN                     *BusNumber,
+  OUT UINTN                     *DeviceNumber,
+  OUT UINTN                     *FunctionNumber
+  );
+
+#define EFI_PCI_IO_ATTRIBUTE_ISA_IO               0x0002
+#define EFI_PCI_IO_ATTRIBUTE_VGA_PALETTE_IO       0x0004
+#define EFI_PCI_IO_ATTRIBUTE_VGA_MEMORY           0x0008
+#define EFI_PCI_IO_ATTRIBUTE_VGA_IO               0x0010
+#define EFI_PCI_IO_ATTRIBUTE_IDE_PRIMARY_IO       0x0020
+#define EFI_PCI_IO_ATTRIBUTE_IDE_SECONDARY_IO     0x0040
+#define EFI_PCI_IO_ATTRIBUTE_MEMORY_WRITE_COMBINE 0x0080
+#define EFI_PCI_IO_ATTRIBUTE_IO                   0x0100
+#define EFI_PCI_IO_ATTRIBUTE_MEMORY               0x0200
+#define EFI_PCI_IO_ATTRIBUTE_BUS_MASTER           0x0400
+#define EFI_PCI_IO_ATTRIBUTE_MEMORY_CACHED        0x0800
+#define EFI_PCI_IO_ATTRIBUTE_MEMORY_DISABLE       0x1000
+#define EFI_PCI_IO_ATTRIBUTE_EMBEDDED_DEVICE      0x2000
+#define EFI_PCI_IO_ATTRIBUTE_EMBEDDED_ROM         0x4000
+#define EFI_PCI_IO_ATTRIBUTE_DUAL_ADDRESS_CYCLE   0x8000
+#define EFI_PCI_IO_ATTRIBUTE_ISA_IO_16            0x10000
+#define EFI_PCI_IO_ATTRIBUTE_VGA_PALETTE_IO_16    0x20000
+#define EFI_PCI_IO_ATTRIBUTE_VGA_IO_16            0x40000
+
+typedef enum {
+    EfiPciIoAttributeOperationGet,
+    EfiPciIoAttributeOperationSet,
+    EfiPciIoAttributeOperationEnable,
+    EfiPciIoAttributeOperationDisable,
+    EfiPciIoAttributeOperationSupported,
+    EfiPciIoAttributeOperationMaximum
+} EFI_PCI_IO_PROTOCOL_ATTRIBUTE_OPERATION;
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PCI_IO_PROTOCOL_ATTRIBUTES) (
+  IN struct _EFI_PCI_IO             *This,
+  IN EFI_PCI_IO_PROTOCOL_ATTRIBUTE_OPERATION Operation,
+  IN UINT64                                  Attributes,
+  OUT UINT64                                 *Result OPTIONAL
+  );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PCI_IO_PROTOCOL_GET_BAR_ATTRIBUTES) (
+  IN struct _EFI_PCI_IO *This,
+  IN UINT8                      BarIndex,
+  OUT UINT64                    *Supports OPTIONAL,
+  OUT VOID                      **Resources OPTIONAL
+  );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PCI_IO_PROTOCOL_SET_BAR_ATTRIBUTES) (
+  IN struct _EFI_PCI_IO *This,
+  IN UINT64                     Attributes,
+  IN UINT8                      BarIndex,
+  IN OUT UINT64                 *Offset,
+  IN OUT UINT64                 *Length
+  );
+
+typedef struct _EFI_PCI_IO {
+  EFI_PCI_IO_PROTOCOL_POLL_IO_MEM        PollMem;
+  EFI_PCI_IO_PROTOCOL_POLL_IO_MEM        PollIo;
+  EFI_PCI_IO_PROTOCOL_ACCESS             Mem;
+  EFI_PCI_IO_PROTOCOL_ACCESS             Io;
+  EFI_PCI_IO_PROTOCOL_CONFIG_ACCESS      Pci;
+  EFI_PCI_IO_PROTOCOL_COPY_MEM           CopyMem;
+  EFI_PCI_IO_PROTOCOL_MAP                Map;
+  EFI_PCI_IO_PROTOCOL_UNMAP              Unmap;
+  EFI_PCI_IO_PROTOCOL_ALLOCATE_BUFFER    AllocateBuffer;
+  EFI_PCI_IO_PROTOCOL_FREE_BUFFER        FreeBuffer;
+  EFI_PCI_IO_PROTOCOL_FLUSH              Flush;
+  EFI_PCI_IO_PROTOCOL_GET_LOCATION       GetLocation;
+  EFI_PCI_IO_PROTOCOL_ATTRIBUTES         Attributes;
+  EFI_PCI_IO_PROTOCOL_GET_BAR_ATTRIBUTES GetBarAttributes;
+  EFI_PCI_IO_PROTOCOL_SET_BAR_ATTRIBUTES SetBarAttributes;
+  UINT64                                 RomSize;
+  VOID                                   *RomImage;
+} EFI_PCI_IO;
+
+#endif /* _EFI_PCI_IO_H */
diff --git a/linux-x86_64/gnu-efi/include/efi/efiprot.h b/linux-x86_64/gnu-efi/include/efi/efiprot.h
new file mode 100644
index 0000000..a6df337
--- /dev/null
+++ b/linux-x86_64/gnu-efi/include/efi/efiprot.h
@@ -0,0 +1,736 @@
+#ifndef _EFI_PROT_H
+#define _EFI_PROT_H
+
+/*++
+
+Copyright (c) 1998  Intel Corporation
+
+Module Name:
+
+    efiprot.h
+
+Abstract:
+
+    EFI Protocols
+
+
+
+Revision History
+
+--*/
+
+//
+//  FPSWA library protocol
+//
+#define FPSWA_PROTOCOL          \
+    { 0xc41b6531, 0x97b9, 0x11d3, {0x9a, 0x29, 0x0, 0x90, 0x27, 0x3f, 0xc1, 0x4d} }
+
+//
+// Device Path protocol
+//
+
+#define DEVICE_PATH_PROTOCOL    \
+    { 0x9576e91, 0x6d3f, 0x11d2, {0x8e, 0x39, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b} }
+
+
+//
+// Block IO protocol
+//
+
+#define BLOCK_IO_PROTOCOL \
+    { 0x964e5b21, 0x6459, 0x11d2, {0x8e, 0x39, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b} }
+#define EFI_BLOCK_IO_INTERFACE_REVISION   0x00010000
+#define EFI_BLOCK_IO_INTERFACE_REVISION2  0x00020001
+#define EFI_BLOCK_IO_INTERFACE_REVISION3  ((2<<16) | 31)
+
+INTERFACE_DECL(_EFI_BLOCK_IO);
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_BLOCK_RESET) (
+    IN struct _EFI_BLOCK_IO     *This,
+    IN BOOLEAN                  ExtendedVerification
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_BLOCK_READ) (
+    IN struct _EFI_BLOCK_IO     *This,
+    IN UINT32                   MediaId,
+    IN EFI_LBA                  LBA,
+    IN UINTN                    BufferSize,
+    OUT VOID                    *Buffer
+    );
+
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_BLOCK_WRITE) (
+    IN struct _EFI_BLOCK_IO     *This,
+    IN UINT32                   MediaId,
+    IN EFI_LBA                  LBA,
+    IN UINTN                    BufferSize,
+    IN VOID                     *Buffer
+    );
+
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_BLOCK_FLUSH) (
+    IN struct _EFI_BLOCK_IO     *This
+    );
+
+
+
+typedef struct {
+    UINT32              MediaId;
+    BOOLEAN             RemovableMedia;
+    BOOLEAN             MediaPresent;
+
+    BOOLEAN             LogicalPartition;
+    BOOLEAN             ReadOnly;
+    BOOLEAN             WriteCaching;
+
+    UINT32              BlockSize;
+    UINT32              IoAlign;
+
+    EFI_LBA             LastBlock;
+
+    /* revision 2 */
+    EFI_LBA             LowestAlignedLba;
+    UINT32              LogicalBlocksPerPhysicalBlock;
+    /* revision 3 */
+    UINT32              OptimalTransferLengthGranularity;
+} EFI_BLOCK_IO_MEDIA;
+
+typedef struct _EFI_BLOCK_IO {
+    UINT64                  Revision;
+
+    EFI_BLOCK_IO_MEDIA      *Media;
+
+    EFI_BLOCK_RESET         Reset;
+    EFI_BLOCK_READ          ReadBlocks;
+    EFI_BLOCK_WRITE         WriteBlocks;
+    EFI_BLOCK_FLUSH         FlushBlocks;
+
+} EFI_BLOCK_IO;
+
+
+
+//
+// Disk Block IO protocol
+//
+
+#define DISK_IO_PROTOCOL \
+    { 0xce345171, 0xba0b, 0x11d2,  {0x8e, 0x4f, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b} }
+#define EFI_DISK_IO_INTERFACE_REVISION   0x00010000
+
+INTERFACE_DECL(_EFI_DISK_IO);
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_DISK_READ) (
+    IN struct _EFI_DISK_IO      *This,
+    IN UINT32                   MediaId,
+    IN UINT64                   Offset,
+    IN UINTN                    BufferSize,
+    OUT VOID                    *Buffer
+    );
+
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_DISK_WRITE) (
+    IN struct _EFI_DISK_IO      *This,
+    IN UINT32                   MediaId,
+    IN UINT64                   Offset,
+    IN UINTN                    BufferSize,
+    IN VOID                     *Buffer
+    );
+
+
+typedef struct _EFI_DISK_IO {
+    UINT64              Revision;
+    EFI_DISK_READ       ReadDisk;
+    EFI_DISK_WRITE      WriteDisk;
+} EFI_DISK_IO;
+
+
+//
+// Simple file system protocol
+//
+
+#define SIMPLE_FILE_SYSTEM_PROTOCOL \
+    { 0x964e5b22, 0x6459, 0x11d2, {0x8e, 0x39, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b} }
+
+INTERFACE_DECL(_EFI_FILE_IO_INTERFACE);
+INTERFACE_DECL(_EFI_FILE_HANDLE);
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_VOLUME_OPEN) (
+    IN struct _EFI_FILE_IO_INTERFACE    *This,
+    OUT struct _EFI_FILE_HANDLE         **Root
+    );
+
+#define EFI_FILE_IO_INTERFACE_REVISION   0x00010000
+
+typedef struct _EFI_FILE_IO_INTERFACE {
+    UINT64                  Revision;
+    EFI_VOLUME_OPEN         OpenVolume;
+} EFI_FILE_IO_INTERFACE;
+
+//
+//
+//
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_FILE_OPEN) (
+    IN struct _EFI_FILE_HANDLE  *File,
+    OUT struct _EFI_FILE_HANDLE **NewHandle,
+    IN CHAR16                   *FileName,
+    IN UINT64                   OpenMode,
+    IN UINT64                   Attributes
+    );
+
+// Open modes
+#define EFI_FILE_MODE_READ      0x0000000000000001
+#define EFI_FILE_MODE_WRITE     0x0000000000000002
+#define EFI_FILE_MODE_CREATE    0x8000000000000000
+
+// File attributes
+#define EFI_FILE_READ_ONLY      0x0000000000000001
+#define EFI_FILE_HIDDEN         0x0000000000000002
+#define EFI_FILE_SYSTEM         0x0000000000000004
+#define EFI_FILE_RESERVIED      0x0000000000000008
+#define EFI_FILE_DIRECTORY      0x0000000000000010
+#define EFI_FILE_ARCHIVE        0x0000000000000020
+#define EFI_FILE_VALID_ATTR     0x0000000000000037
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_FILE_CLOSE) (
+    IN struct _EFI_FILE_HANDLE  *File
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_FILE_DELETE) (
+    IN struct _EFI_FILE_HANDLE  *File
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_FILE_READ) (
+    IN struct _EFI_FILE_HANDLE  *File,
+    IN OUT UINTN                *BufferSize,
+    OUT VOID                    *Buffer
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_FILE_WRITE) (
+    IN struct _EFI_FILE_HANDLE  *File,
+    IN OUT UINTN                *BufferSize,
+    IN VOID                     *Buffer
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_FILE_SET_POSITION) (
+    IN struct _EFI_FILE_HANDLE  *File,
+    IN UINT64                   Position
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_FILE_GET_POSITION) (
+    IN struct _EFI_FILE_HANDLE  *File,
+    OUT UINT64                  *Position
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_FILE_GET_INFO) (
+    IN struct _EFI_FILE_HANDLE  *File,
+    IN EFI_GUID                 *InformationType,
+    IN OUT UINTN                *BufferSize,
+    OUT VOID                    *Buffer
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_FILE_SET_INFO) (
+    IN struct _EFI_FILE_HANDLE  *File,
+    IN EFI_GUID                 *InformationType,
+    IN UINTN                    BufferSize,
+    IN VOID                     *Buffer
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_FILE_FLUSH) (
+    IN struct _EFI_FILE_HANDLE  *File
+    );
+
+
+
+#define EFI_FILE_HANDLE_REVISION         0x00010000
+typedef struct _EFI_FILE_HANDLE {
+    UINT64                  Revision;
+    EFI_FILE_OPEN           Open;
+    EFI_FILE_CLOSE          Close;
+    EFI_FILE_DELETE         Delete;
+    EFI_FILE_READ           Read;
+    EFI_FILE_WRITE          Write;
+    EFI_FILE_GET_POSITION   GetPosition;
+    EFI_FILE_SET_POSITION   SetPosition;
+    EFI_FILE_GET_INFO       GetInfo;
+    EFI_FILE_SET_INFO       SetInfo;
+    EFI_FILE_FLUSH          Flush;
+} EFI_FILE, *EFI_FILE_HANDLE;
+
+
+//
+// File information types
+//
+
+#define EFI_FILE_INFO_ID   \
+    { 0x9576e92, 0x6d3f, 0x11d2, {0x8e, 0x39, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b} }
+
+typedef struct {
+    UINT64                  Size;
+    UINT64                  FileSize;
+    UINT64                  PhysicalSize;
+    EFI_TIME                CreateTime;
+    EFI_TIME                LastAccessTime;
+    EFI_TIME                ModificationTime;
+    UINT64                  Attribute;
+    CHAR16                  FileName[1];
+} EFI_FILE_INFO;
+
+//
+// The FileName field of the EFI_FILE_INFO data structure is variable length.
+// Whenever code needs to know the size of the EFI_FILE_INFO data structure, it needs to
+// be the size of the data structure without the FileName field.  The following macro 
+// computes this size correctly no matter how big the FileName array is declared.
+// This is required to make the EFI_FILE_INFO data structure ANSI compilant. 
+//
+
+#define SIZE_OF_EFI_FILE_INFO EFI_FIELD_OFFSET(EFI_FILE_INFO,FileName)
+
+#define EFI_FILE_SYSTEM_INFO_ID    \
+    { 0x9576e93, 0x6d3f, 0x11d2, {0x8e, 0x39, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b} }
+
+typedef struct {
+    UINT64                  Size;
+    BOOLEAN                 ReadOnly;
+    UINT64                  VolumeSize;
+    UINT64                  FreeSpace;
+    UINT32                  BlockSize;
+    CHAR16                  VolumeLabel[1];
+} EFI_FILE_SYSTEM_INFO;
+
+//
+// The VolumeLabel field of the EFI_FILE_SYSTEM_INFO data structure is variable length.
+// Whenever code needs to know the size of the EFI_FILE_SYSTEM_INFO data structure, it needs
+// to be the size of the data structure without the VolumeLable field.  The following macro 
+// computes this size correctly no matter how big the VolumeLable array is declared.
+// This is required to make the EFI_FILE_SYSTEM_INFO data structure ANSI compilant. 
+//
+
+#define SIZE_OF_EFI_FILE_SYSTEM_INFO EFI_FIELD_OFFSET(EFI_FILE_SYSTEM_INFO,VolumeLabel)
+
+#define EFI_FILE_SYSTEM_VOLUME_LABEL_INFO_ID    \
+    { 0xDB47D7D3,0xFE81, 0x11d3, {0x9A, 0x35, 0x00, 0x90, 0x27, 0x3F, 0xC1, 0x4D} }
+
+typedef struct {
+    CHAR16                  VolumeLabel[1];
+} EFI_FILE_SYSTEM_VOLUME_LABEL_INFO;
+
+#define SIZE_OF_EFI_FILE_SYSTEM_VOLUME_LABEL_INFO EFI_FIELD_OFFSET(EFI_FILE_SYSTEM_VOLUME_LABEL_INFO,VolumeLabel)
+
+//
+// Load file protocol
+//
+
+
+#define LOAD_FILE_PROTOCOL \
+    { 0x56EC3091, 0x954C, 0x11d2, {0x8E, 0x3F, 0x00, 0xA0, 0xC9, 0x69, 0x72, 0x3B} }
+
+INTERFACE_DECL(_EFI_LOAD_FILE_INTERFACE);
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_LOAD_FILE) (
+    IN struct _EFI_LOAD_FILE_INTERFACE  *This,
+    IN EFI_DEVICE_PATH                  *FilePath,
+    IN BOOLEAN                          BootPolicy,
+    IN OUT UINTN                        *BufferSize,
+    IN VOID                             *Buffer OPTIONAL
+    );
+
+typedef struct _EFI_LOAD_FILE_INTERFACE {
+    EFI_LOAD_FILE                       LoadFile;
+} EFI_LOAD_FILE_INTERFACE;
+
+
+//
+// Device IO protocol
+//
+
+#define DEVICE_IO_PROTOCOL \
+    { 0xaf6ac311, 0x84c3, 0x11d2, {0x8e, 0x3c, 0x00, 0xa0, 0xc9, 0x69, 0x72, 0x3b} }
+
+INTERFACE_DECL(_EFI_DEVICE_IO_INTERFACE);
+
+typedef enum {
+    IO_UINT8,
+    IO_UINT16,
+    IO_UINT32,
+    IO_UINT64,
+//
+// Specification Change: Copy from MMIO to MMIO vs. MMIO to buffer, buffer to MMIO
+//
+    MMIO_COPY_UINT8,
+    MMIO_COPY_UINT16,
+    MMIO_COPY_UINT32,
+    MMIO_COPY_UINT64
+} EFI_IO_WIDTH;
+
+#define EFI_PCI_ADDRESS(_bus,_dev,_func) \
+    ( (UINT64) ( (((UINTN)_bus) << 24) + (((UINTN)_dev) << 16) + (((UINTN)_func) << 8) ) )
+
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_DEVICE_IO) (
+    IN struct _EFI_DEVICE_IO_INTERFACE *This,
+    IN EFI_IO_WIDTH                 Width,
+    IN UINT64                       Address,
+    IN UINTN                        Count,
+    IN OUT VOID                     *Buffer
+    );
+
+typedef struct {
+    EFI_DEVICE_IO                   Read;
+    EFI_DEVICE_IO                   Write;
+} EFI_IO_ACCESS;
+
+typedef 
+EFI_STATUS
+(EFIAPI *EFI_PCI_DEVICE_PATH) (
+    IN struct _EFI_DEVICE_IO_INTERFACE  *This,
+    IN UINT64                           Address,
+    IN OUT EFI_DEVICE_PATH              **PciDevicePath
+    );
+
+typedef enum {
+    EfiBusMasterRead,
+    EfiBusMasterWrite,
+    EfiBusMasterCommonBuffer
+} EFI_IO_OPERATION_TYPE;
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_IO_MAP) (
+    IN struct _EFI_DEVICE_IO_INTERFACE  *This,
+    IN EFI_IO_OPERATION_TYPE            Operation,
+    IN EFI_PHYSICAL_ADDRESS             *HostAddress,
+    IN OUT UINTN                        *NumberOfBytes,
+    OUT EFI_PHYSICAL_ADDRESS            *DeviceAddress,
+    OUT VOID                            **Mapping
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_IO_UNMAP) (
+    IN struct _EFI_DEVICE_IO_INTERFACE  *This,
+    IN VOID                             *Mapping
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_IO_ALLOCATE_BUFFER) (
+    IN struct _EFI_DEVICE_IO_INTERFACE  *This,
+    IN EFI_ALLOCATE_TYPE                Type,
+    IN EFI_MEMORY_TYPE                  MemoryType,
+    IN UINTN                            Pages,
+    IN OUT EFI_PHYSICAL_ADDRESS         *HostAddress
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_IO_FLUSH) (
+    IN struct _EFI_DEVICE_IO_INTERFACE  *This
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_IO_FREE_BUFFER) (
+    IN struct _EFI_DEVICE_IO_INTERFACE  *This,
+    IN UINTN                            Pages,
+    IN EFI_PHYSICAL_ADDRESS             HostAddress
+    );
+
+typedef struct _EFI_DEVICE_IO_INTERFACE {
+    EFI_IO_ACCESS                       Mem;
+    EFI_IO_ACCESS                       Io;
+    EFI_IO_ACCESS                       Pci;
+    EFI_IO_MAP                          Map;
+    EFI_PCI_DEVICE_PATH                 PciDevicePath;
+    EFI_IO_UNMAP                        Unmap;
+    EFI_IO_ALLOCATE_BUFFER              AllocateBuffer;
+    EFI_IO_FLUSH                        Flush;
+    EFI_IO_FREE_BUFFER                  FreeBuffer;
+} EFI_DEVICE_IO_INTERFACE;
+
+
+//
+// Unicode Collation protocol
+//
+
+#define UNICODE_COLLATION_PROTOCOL \
+    { 0x1d85cd7f, 0xf43d, 0x11d2, {0x9a, 0xc,  0x0, 0x90, 0x27, 0x3f, 0xc1, 0x4d} }
+
+#define UNICODE_BYTE_ORDER_MARK       (CHAR16)(0xfeff)
+
+INTERFACE_DECL(_EFI_UNICODE_COLLATION_INTERFACE);
+
+typedef
+INTN
+(EFIAPI *EFI_UNICODE_STRICOLL) (
+    IN struct _EFI_UNICODE_COLLATION_INTERFACE  *This,
+    IN CHAR16                         *s1,
+    IN CHAR16                         *s2
+    );
+
+typedef
+BOOLEAN
+(EFIAPI *EFI_UNICODE_METAIMATCH) (
+    IN struct _EFI_UNICODE_COLLATION_INTERFACE  *This,
+    IN CHAR16                         *String,
+    IN CHAR16                         *Pattern
+    );
+
+typedef
+VOID
+(EFIAPI *EFI_UNICODE_STRLWR) (
+    IN struct _EFI_UNICODE_COLLATION_INTERFACE  *This,
+    IN OUT CHAR16                       *Str
+    );
+
+typedef
+VOID
+(EFIAPI *EFI_UNICODE_STRUPR) (
+    IN struct _EFI_UNICODE_COLLATION_INTERFACE  *This,
+    IN OUT CHAR16                       *Str
+    );
+
+typedef
+VOID
+(EFIAPI *EFI_UNICODE_FATTOSTR) (
+    IN struct _EFI_UNICODE_COLLATION_INTERFACE  *This,
+    IN UINTN                            FatSize,
+    IN CHAR8                            *Fat,
+    OUT CHAR16                          *String
+    );
+
+typedef
+BOOLEAN
+(EFIAPI *EFI_UNICODE_STRTOFAT) (
+    IN struct _EFI_UNICODE_COLLATION_INTERFACE  *This,
+    IN CHAR16                           *String,
+    IN UINTN                            FatSize,
+    OUT CHAR8                           *Fat
+    );
+
+
+typedef struct _EFI_UNICODE_COLLATION_INTERFACE {
+
+    // general
+    EFI_UNICODE_STRICOLL                StriColl;
+    EFI_UNICODE_METAIMATCH              MetaiMatch;
+    EFI_UNICODE_STRLWR                  StrLwr;
+    EFI_UNICODE_STRUPR                  StrUpr;
+
+    // for supporting fat volumes
+    EFI_UNICODE_FATTOSTR                FatToStr;
+    EFI_UNICODE_STRTOFAT                StrToFat;
+
+    CHAR8                               *SupportedLanguages;
+} EFI_UNICODE_COLLATION_INTERFACE;
+
+/* Graphics output protocol */
+#define EFI_GRAPHICS_OUTPUT_PROTOCOL_GUID \
+  { \
+    0x9042a9de, 0x23dc, 0x4a38, {0x96, 0xfb, 0x7a, 0xde, 0xd0, 0x80, 0x51, 0x6a } \
+  }
+
+typedef struct _EFI_GRAPHICS_OUTPUT_PROTOCOL EFI_GRAPHICS_OUTPUT_PROTOCOL;
+
+typedef struct {
+  UINT32            RedMask;
+  UINT32            GreenMask;
+  UINT32            BlueMask;
+  UINT32            ReservedMask;
+} EFI_PIXEL_BITMASK;
+
+typedef enum {
+  PixelRedGreenBlueReserved8BitPerColor,
+  PixelBlueGreenRedReserved8BitPerColor,
+  PixelBitMask,
+  PixelBltOnly,
+  PixelFormatMax
+} EFI_GRAPHICS_PIXEL_FORMAT;
+
+typedef struct {
+  UINT32                     Version;
+  UINT32                     HorizontalResolution;
+  UINT32                     VerticalResolution;
+  EFI_GRAPHICS_PIXEL_FORMAT  PixelFormat;
+  EFI_PIXEL_BITMASK          PixelInformation;
+  UINT32                     PixelsPerScanLine;
+} EFI_GRAPHICS_OUTPUT_MODE_INFORMATION;
+
+/**
+  Return the current video mode information.
+
+  @param  This       Protocol instance pointer.
+  @param  ModeNumber The mode number to return information on.
+  @param  SizeOfInfo A pointer to the size, in bytes, of the Info buffer.
+  @param  Info       A pointer to callee allocated buffer that returns information about ModeNumber.
+
+  @retval EFI_SUCCESS           Mode information returned.
+  @retval EFI_BUFFER_TOO_SMALL  The Info buffer was too small.
+  @retval EFI_DEVICE_ERROR      A hardware error occurred trying to retrieve the video mode.
+  @retval EFI_NOT_STARTED       Video display is not initialized. Call SetMode ()
+  @retval EFI_INVALID_PARAMETER One of the input args was NULL.
+
+**/
+typedef
+EFI_STATUS
+(EFIAPI *EFI_GRAPHICS_OUTPUT_PROTOCOL_QUERY_MODE) (
+  IN  EFI_GRAPHICS_OUTPUT_PROTOCOL          *This,
+  IN  UINT32                                ModeNumber,
+  OUT UINTN                                 *SizeOfInfo,
+  OUT EFI_GRAPHICS_OUTPUT_MODE_INFORMATION  **Info
+  )
+;
+
+/**
+  Return the current video mode information.
+
+  @param  This              Protocol instance pointer.
+  @param  ModeNumber        The mode number to be set.
+
+  @retval EFI_SUCCESS       Graphics mode was changed.
+  @retval EFI_DEVICE_ERROR  The device had an error and could not complete the request.
+  @retval EFI_UNSUPPORTED   ModeNumber is not supported by this device.
+
+**/
+typedef
+EFI_STATUS
+(EFIAPI *EFI_GRAPHICS_OUTPUT_PROTOCOL_SET_MODE) (
+  IN  EFI_GRAPHICS_OUTPUT_PROTOCOL *This,
+  IN  UINT32                       ModeNumber
+  )
+;
+
+typedef struct {
+  UINT8 Blue;
+  UINT8 Green;
+  UINT8 Red;
+  UINT8 Reserved;
+} EFI_GRAPHICS_OUTPUT_BLT_PIXEL;
+
+typedef union {
+  EFI_GRAPHICS_OUTPUT_BLT_PIXEL Pixel;
+  UINT32                        Raw;
+} EFI_GRAPHICS_OUTPUT_BLT_PIXEL_UNION;
+
+typedef enum {
+  EfiBltVideoFill,
+  EfiBltVideoToBltBuffer,
+  EfiBltBufferToVideo, 
+  EfiBltVideoToVideo,
+  EfiGraphicsOutputBltOperationMax
+} EFI_GRAPHICS_OUTPUT_BLT_OPERATION;
+
+/**
+  The following table defines actions for BltOperations:
+
+  <B>EfiBltVideoFill</B> - Write data from the  BltBuffer pixel (SourceX, SourceY) 
+  directly to every pixel of the video display rectangle 
+  (DestinationX, DestinationY) (DestinationX + Width, DestinationY + Height). 
+  Only one pixel will be used from the BltBuffer. Delta is NOT used.
+
+  <B>EfiBltVideoToBltBuffer</B> - Read data from the video display rectangle 
+  (SourceX, SourceY) (SourceX + Width, SourceY + Height) and place it in 
+  the BltBuffer rectangle (DestinationX, DestinationY ) 
+  (DestinationX + Width, DestinationY + Height). If DestinationX or 
+  DestinationY is not zero then Delta must be set to the length in bytes 
+  of a row in the BltBuffer.
+
+  <B>EfiBltBufferToVideo</B> - Write data from the  BltBuffer rectangle 
+  (SourceX, SourceY) (SourceX + Width, SourceY + Height) directly to the 
+  video display rectangle (DestinationX, DestinationY) 
+  (DestinationX + Width, DestinationY + Height). If SourceX or SourceY is 
+  not zero then Delta must be set to the length in bytes of a row in the 
+  BltBuffer.
+
+  <B>EfiBltVideoToVideo</B> - Copy from the video display rectangle (SourceX, SourceY)
+  (SourceX + Width, SourceY + Height) .to the video display rectangle 
+  (DestinationX, DestinationY) (DestinationX + Width, DestinationY + Height). 
+  The BltBuffer and Delta  are not used in this mode.
+
+  @param  This         Protocol instance pointer.
+  @param  BltBuffer    Buffer containing data to blit into video buffer. This
+                       buffer has a size of Width*Height*sizeof(EFI_GRAPHICS_OUTPUT_BLT_PIXEL)
+  @param  BltOperation Operation to perform on BlitBuffer and video memory
+  @param  SourceX      X coordinate of source for the BltBuffer.
+  @param  SourceY      Y coordinate of source for the BltBuffer.
+  @param  DestinationX X coordinate of destination for the BltBuffer.
+  @param  DestinationY Y coordinate of destination for the BltBuffer.
+  @param  Width        Width of rectangle in BltBuffer in pixels.
+  @param  Height       Hight of rectangle in BltBuffer in pixels.
+  @param  Delta        OPTIONAL
+
+  @retval EFI_SUCCESS           The Blt operation completed.
+  @retval EFI_INVALID_PARAMETER BltOperation is not valid.
+  @retval EFI_DEVICE_ERROR      A hardware error occured writting to the video buffer.
+
+**/
+typedef
+EFI_STATUS
+(EFIAPI *EFI_GRAPHICS_OUTPUT_PROTOCOL_BLT) (
+  IN  EFI_GRAPHICS_OUTPUT_PROTOCOL            *This,
+  IN  EFI_GRAPHICS_OUTPUT_BLT_PIXEL           *BltBuffer,   OPTIONAL
+  IN  EFI_GRAPHICS_OUTPUT_BLT_OPERATION       BltOperation,
+  IN  UINTN                                   SourceX,
+  IN  UINTN                                   SourceY,
+  IN  UINTN                                   DestinationX,
+  IN  UINTN                                   DestinationY,
+  IN  UINTN                                   Width,
+  IN  UINTN                                   Height,
+  IN  UINTN                                   Delta         OPTIONAL
+  );
+
+typedef struct {
+  UINT32                                 MaxMode;
+  UINT32                                 Mode;
+  EFI_GRAPHICS_OUTPUT_MODE_INFORMATION   *Info;
+  UINTN                                  SizeOfInfo;
+  EFI_PHYSICAL_ADDRESS                   FrameBufferBase;
+  UINTN                                  FrameBufferSize;
+} EFI_GRAPHICS_OUTPUT_PROTOCOL_MODE;
+
+struct _EFI_GRAPHICS_OUTPUT_PROTOCOL {
+  EFI_GRAPHICS_OUTPUT_PROTOCOL_QUERY_MODE  QueryMode;
+  EFI_GRAPHICS_OUTPUT_PROTOCOL_SET_MODE    SetMode;
+  EFI_GRAPHICS_OUTPUT_PROTOCOL_BLT         Blt;
+  EFI_GRAPHICS_OUTPUT_PROTOCOL_MODE        *Mode;
+};
+#endif
+
diff --git a/linux-x86_64/gnu-efi/include/efi/efipxebc.h b/linux-x86_64/gnu-efi/include/efi/efipxebc.h
new file mode 100644
index 0000000..792d323
--- /dev/null
+++ b/linux-x86_64/gnu-efi/include/efi/efipxebc.h
@@ -0,0 +1,463 @@
+#ifndef _EFIPXEBC_H
+#define _EFIPXEBC_H
+
+/*++
+
+Copyright (c) 1998  Intel Corporation
+
+Module Name:
+
+    efipxebc.h
+
+Abstract:
+
+    EFI PXE Base Code Protocol
+
+
+
+Revision History
+
+--*/
+
+//
+// PXE Base Code protocol
+//
+
+#define EFI_PXE_BASE_CODE_PROTOCOL \
+    { 0x03c4e603, 0xac28, 0x11d3, {0x9a, 0x2d, 0x00, 0x90, 0x27, 0x3f, 0xc1, 0x4d} }
+
+INTERFACE_DECL(_EFI_PXE_BASE_CODE);
+
+#define DEFAULT_TTL 4
+#define DEFAULT_ToS 0
+//
+// Address definitions
+//
+
+typedef union {
+    UINT32      Addr[4];
+    EFI_IPv4_ADDRESS    v4;
+    EFI_IPv6_ADDRESS    v6;
+} EFI_IP_ADDRESS;
+
+typedef UINT16 EFI_PXE_BASE_CODE_UDP_PORT;
+
+//
+// Packet definitions
+//
+
+typedef struct {
+    UINT8                           BootpOpcode;
+    UINT8                           BootpHwType;
+    UINT8                           BootpHwAddrLen;
+    UINT8                           BootpGateHops;
+    UINT32                          BootpIdent;
+    UINT16                          BootpSeconds;
+    UINT16                          BootpFlags;
+    UINT8                           BootpCiAddr[4];
+    UINT8                           BootpYiAddr[4];
+    UINT8                           BootpSiAddr[4];
+    UINT8                           BootpGiAddr[4];
+    UINT8                           BootpHwAddr[16];
+    UINT8                           BootpSrvName[64];
+    UINT8                           BootpBootFile[128];
+    UINT32                          DhcpMagik;
+    UINT8                           DhcpOptions[56];
+} EFI_PXE_BASE_CODE_DHCPV4_PACKET;
+
+// TBD in EFI v1.1
+//typedef struct {
+//    UINT8                           reserved;
+//} EFI_PXE_BASE_CODE_DHCPV6_PACKET;
+
+typedef union {
+    UINT8                               Raw[1472];
+    EFI_PXE_BASE_CODE_DHCPV4_PACKET     Dhcpv4;
+//    EFI_PXE_BASE_CODE_DHCPV6_PACKET     Dhcpv6;
+} EFI_PXE_BASE_CODE_PACKET;
+
+typedef struct {
+    UINT8                   Type;
+    UINT8                   Code;
+    UINT16                  Checksum;
+    union {
+        UINT32              reserved;
+        UINT32              Mtu;
+        UINT32              Pointer;
+        struct {
+            UINT16          Identifier;
+            UINT16          Sequence;
+        } Echo;
+    } u;
+    UINT8                   Data[494];
+} EFI_PXE_BASE_CODE_ICMP_ERROR;
+
+typedef struct {
+    UINT8                   ErrorCode;
+    CHAR8                   ErrorString[127];
+} EFI_PXE_BASE_CODE_TFTP_ERROR;
+
+//
+// IP Receive Filter definitions
+//
+#define EFI_PXE_BASE_CODE_MAX_IPCNT             8
+typedef struct {
+    UINT8                       Filters;
+    UINT8                       IpCnt;
+    UINT16                      reserved;
+    EFI_IP_ADDRESS              IpList[EFI_PXE_BASE_CODE_MAX_IPCNT];
+} EFI_PXE_BASE_CODE_IP_FILTER;
+
+#define EFI_PXE_BASE_CODE_IP_FILTER_STATION_IP             0x0001
+#define EFI_PXE_BASE_CODE_IP_FILTER_BROADCAST              0x0002
+#define EFI_PXE_BASE_CODE_IP_FILTER_PROMISCUOUS            0x0004
+#define EFI_PXE_BASE_CODE_IP_FILTER_PROMISCUOUS_MULTICAST  0x0008
+
+//
+// ARP Cache definitions
+//
+
+typedef struct {
+    EFI_IP_ADDRESS       IpAddr;
+    EFI_MAC_ADDRESS      MacAddr;
+} EFI_PXE_BASE_CODE_ARP_ENTRY;
+
+typedef struct {
+    EFI_IP_ADDRESS       IpAddr;
+    EFI_IP_ADDRESS       SubnetMask;
+    EFI_IP_ADDRESS       GwAddr;
+} EFI_PXE_BASE_CODE_ROUTE_ENTRY;
+
+//
+// UDP definitions
+//
+
+#define EFI_PXE_BASE_CODE_UDP_OPFLAGS_ANY_SRC_IP    0x0001
+#define EFI_PXE_BASE_CODE_UDP_OPFLAGS_ANY_SRC_PORT  0x0002
+#define EFI_PXE_BASE_CODE_UDP_OPFLAGS_ANY_DEST_IP   0x0004
+#define EFI_PXE_BASE_CODE_UDP_OPFLAGS_ANY_DEST_PORT 0x0008
+#define EFI_PXE_BASE_CODE_UDP_OPFLAGS_USE_FILTER    0x0010
+#define EFI_PXE_BASE_CODE_UDP_OPFLAGS_MAY_FRAGMENT  0x0020
+
+//
+// Discover() definitions
+//
+
+#define EFI_PXE_BASE_CODE_BOOT_TYPE_BOOTSTRAP           0   
+#define EFI_PXE_BASE_CODE_BOOT_TYPE_MS_WINNT_RIS        1
+#define EFI_PXE_BASE_CODE_BOOT_TYPE_INTEL_LCM           2
+#define EFI_PXE_BASE_CODE_BOOT_TYPE_DOSUNDI             3
+#define EFI_PXE_BASE_CODE_BOOT_TYPE_NEC_ESMPRO          4
+#define EFI_PXE_BASE_CODE_BOOT_TYPE_IBM_WSoD            5
+#define EFI_PXE_BASE_CODE_BOOT_TYPE_IBM_LCCM            6
+#define EFI_PXE_BASE_CODE_BOOT_TYPE_CA_UNICENTER_TNG    7
+#define EFI_PXE_BASE_CODE_BOOT_TYPE_HP_OPENVIEW         8
+#define EFI_PXE_BASE_CODE_BOOT_TYPE_ALTIRIS_9           9
+#define EFI_PXE_BASE_CODE_BOOT_TYPE_ALTIRIS_10          10
+#define EFI_PXE_BASE_CODE_BOOT_TYPE_ALTIRIS_11          11
+#define EFI_PXE_BASE_CODE_BOOT_TYPE_NOT_USED_12         12
+#define EFI_PXE_BASE_CODE_BOOT_TYPE_REDHAT_INSTALL      13
+#define EFI_PXE_BASE_CODE_BOOT_TYPE_REDHAT_BOOT         14
+#define EFI_PXE_BASE_CODE_BOOT_TYPE_REMBO               15
+#define EFI_PXE_BASE_CODE_BOOT_TYPE_BEOBOOT             16
+//
+// 17 through 32767 are reserved
+// 32768 through 65279 are for vendor use
+// 65280 through 65534 are reserved
+//
+#define EFI_PXE_BASE_CODE_BOOT_TYPE_PXETEST             65535
+
+#define EFI_PXE_BASE_CODE_BOOT_LAYER_MASK               0x7FFF
+#define EFI_PXE_BASE_CODE_BOOT_LAYER_INITIAL            0x0000
+
+
+typedef struct {
+    UINT16                      Type;
+    BOOLEAN                     AcceptAnyResponse;
+    UINT8                       Reserved;
+    EFI_IP_ADDRESS              IpAddr;
+} EFI_PXE_BASE_CODE_SRVLIST;
+
+typedef struct {
+    BOOLEAN                     UseMCast;
+    BOOLEAN                     UseBCast;
+    BOOLEAN                     UseUCast;
+    BOOLEAN                     MustUseList;
+    EFI_IP_ADDRESS              ServerMCastIp;
+    UINT16                      IpCnt;
+    EFI_PXE_BASE_CODE_SRVLIST   SrvList[1];
+} EFI_PXE_BASE_CODE_DISCOVER_INFO;
+
+//
+// Mtftp() definitions
+//
+
+typedef enum {
+    EFI_PXE_BASE_CODE_TFTP_FIRST,
+    EFI_PXE_BASE_CODE_TFTP_GET_FILE_SIZE,
+    EFI_PXE_BASE_CODE_TFTP_READ_FILE,
+    EFI_PXE_BASE_CODE_TFTP_WRITE_FILE,
+    EFI_PXE_BASE_CODE_TFTP_READ_DIRECTORY,
+    EFI_PXE_BASE_CODE_MTFTP_GET_FILE_SIZE,
+    EFI_PXE_BASE_CODE_MTFTP_READ_FILE,
+    EFI_PXE_BASE_CODE_MTFTP_READ_DIRECTORY,
+    EFI_PXE_BASE_CODE_MTFTP_LAST
+} EFI_PXE_BASE_CODE_TFTP_OPCODE;
+
+typedef struct {
+    EFI_IP_ADDRESS   MCastIp;
+    EFI_PXE_BASE_CODE_UDP_PORT  CPort;
+    EFI_PXE_BASE_CODE_UDP_PORT  SPort;
+    UINT16                      ListenTimeout;
+    UINT16                      TransmitTimeout;
+} EFI_PXE_BASE_CODE_MTFTP_INFO;
+
+//
+// PXE Base Code Mode structure
+//
+
+#define EFI_PXE_BASE_CODE_MAX_ARP_ENTRIES       8
+#define EFI_PXE_BASE_CODE_MAX_ROUTE_ENTRIES     8
+
+typedef struct {
+    BOOLEAN                         Started;
+    BOOLEAN                         Ipv6Available;
+    BOOLEAN                         Ipv6Supported;
+    BOOLEAN                         UsingIpv6;
+    BOOLEAN                         BisSupported;
+    BOOLEAN                         BisDetected;
+    BOOLEAN                         AutoArp;
+    BOOLEAN                         SendGUID;
+    BOOLEAN                         DhcpDiscoverValid;
+    BOOLEAN                         DhcpAckReceived;
+    BOOLEAN                         ProxyOfferReceived;
+    BOOLEAN                         PxeDiscoverValid;
+    BOOLEAN                         PxeReplyReceived;
+    BOOLEAN                         PxeBisReplyReceived;
+    BOOLEAN                         IcmpErrorReceived;
+    BOOLEAN                         TftpErrorReceived;
+    BOOLEAN                         MakeCallbacks;
+    UINT8                           TTL;
+    UINT8                           ToS;
+    EFI_IP_ADDRESS                  StationIp;
+    EFI_IP_ADDRESS                  SubnetMask;
+    EFI_PXE_BASE_CODE_PACKET        DhcpDiscover;
+    EFI_PXE_BASE_CODE_PACKET        DhcpAck;
+    EFI_PXE_BASE_CODE_PACKET        ProxyOffer;
+    EFI_PXE_BASE_CODE_PACKET        PxeDiscover;
+    EFI_PXE_BASE_CODE_PACKET        PxeReply;
+    EFI_PXE_BASE_CODE_PACKET        PxeBisReply;
+    EFI_PXE_BASE_CODE_IP_FILTER     IpFilter;
+    UINT32                          ArpCacheEntries;
+    EFI_PXE_BASE_CODE_ARP_ENTRY     ArpCache[EFI_PXE_BASE_CODE_MAX_ARP_ENTRIES];
+    UINT32                          RouteTableEntries;
+    EFI_PXE_BASE_CODE_ROUTE_ENTRY   RouteTable[EFI_PXE_BASE_CODE_MAX_ROUTE_ENTRIES];
+    EFI_PXE_BASE_CODE_ICMP_ERROR    IcmpError;
+    EFI_PXE_BASE_CODE_TFTP_ERROR    TftpError;
+} EFI_PXE_BASE_CODE_MODE;
+
+//
+// PXE Base Code Interface Function definitions
+//
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PXE_BASE_CODE_START) (
+    IN struct _EFI_PXE_BASE_CODE    *This,
+    IN BOOLEAN                      UseIpv6
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PXE_BASE_CODE_STOP) (
+    IN struct _EFI_PXE_BASE_CODE    *This
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PXE_BASE_CODE_DHCP) (
+    IN struct _EFI_PXE_BASE_CODE    *This,
+    IN BOOLEAN                      SortOffers
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PXE_BASE_CODE_DISCOVER) (
+    IN struct _EFI_PXE_BASE_CODE            *This,
+    IN UINT16                               Type,
+    IN UINT16                               *Layer,
+    IN BOOLEAN                              UseBis,
+    IN OUT EFI_PXE_BASE_CODE_DISCOVER_INFO  *Info   OPTIONAL
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PXE_BASE_CODE_MTFTP) (
+    IN struct _EFI_PXE_BASE_CODE        *This,
+    IN EFI_PXE_BASE_CODE_TFTP_OPCODE    Operation,
+    IN OUT VOID                         *BufferPtr  OPTIONAL,
+    IN BOOLEAN                          Overwrite,
+    IN OUT UINTN                        *BufferSize,
+    IN UINTN                            *BlockSize  OPTIONAL,
+    IN EFI_IP_ADDRESS                   *ServerIp,
+    IN UINT8                            *Filename,
+    IN EFI_PXE_BASE_CODE_MTFTP_INFO     *Info       OPTIONAL,
+    IN BOOLEAN                          DontUseBuffer
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PXE_BASE_CODE_UDP_WRITE) (
+    IN struct _EFI_PXE_BASE_CODE        *This,
+    IN UINT16                           OpFlags,
+    IN EFI_IP_ADDRESS                   *DestIp,
+    IN EFI_PXE_BASE_CODE_UDP_PORT       *DestPort,
+    IN EFI_IP_ADDRESS                   *GatewayIp,  OPTIONAL
+    IN EFI_IP_ADDRESS                   *SrcIp,      OPTIONAL
+    IN OUT EFI_PXE_BASE_CODE_UDP_PORT   *SrcPort,    OPTIONAL
+    IN UINTN                            *HeaderSize, OPTIONAL
+    IN VOID                             *HeaderPtr,  OPTIONAL
+    IN UINTN                            *BufferSize,
+    IN VOID                             *BufferPtr
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PXE_BASE_CODE_UDP_READ) (
+    IN struct _EFI_PXE_BASE_CODE        *This,
+    IN UINT16                           OpFlags,
+    IN OUT EFI_IP_ADDRESS               *DestIp,      OPTIONAL
+    IN OUT EFI_PXE_BASE_CODE_UDP_PORT   *DestPort,    OPTIONAL
+    IN OUT EFI_IP_ADDRESS               *SrcIp,       OPTIONAL
+    IN OUT EFI_PXE_BASE_CODE_UDP_PORT   *SrcPort,     OPTIONAL
+    IN UINTN                            *HeaderSize,  OPTIONAL
+    IN VOID                             *HeaderPtr,   OPTIONAL
+    IN OUT UINTN                        *BufferSize,
+    IN VOID                             *BufferPtr
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PXE_BASE_CODE_SET_IP_FILTER) (
+    IN struct _EFI_PXE_BASE_CODE    *This,
+    IN EFI_PXE_BASE_CODE_IP_FILTER  *NewFilter
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PXE_BASE_CODE_ARP) (
+    IN struct _EFI_PXE_BASE_CODE    *This,
+    IN EFI_IP_ADDRESS               *IpAddr,      
+    IN EFI_MAC_ADDRESS              *MacAddr      OPTIONAL
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PXE_BASE_CODE_SET_PARAMETERS) (
+    IN struct _EFI_PXE_BASE_CODE    *This,
+    IN BOOLEAN                      *NewAutoArp,    OPTIONAL
+    IN BOOLEAN                      *NewSendGUID,   OPTIONAL
+    IN UINT8                        *NewTTL,        OPTIONAL
+    IN UINT8                        *NewToS,        OPTIONAL
+    IN BOOLEAN                      *NewMakeCallback    OPTIONAL
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PXE_BASE_CODE_SET_STATION_IP) (
+    IN struct _EFI_PXE_BASE_CODE    *This,
+    IN EFI_IP_ADDRESS               *NewStationIp,  OPTIONAL
+    IN EFI_IP_ADDRESS               *NewSubnetMask  OPTIONAL
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PXE_BASE_CODE_SET_PACKETS) (
+    IN struct _EFI_PXE_BASE_CODE    *This,
+    BOOLEAN                         *NewDhcpDiscoverValid,  OPTIONAL
+    BOOLEAN                         *NewDhcpAckReceived,    OPTIONAL
+    BOOLEAN                         *NewProxyOfferReceived, OPTIONAL
+    BOOLEAN                         *NewPxeDiscoverValid,   OPTIONAL
+    BOOLEAN                         *NewPxeReplyReceived,   OPTIONAL
+    BOOLEAN                         *NewPxeBisReplyReceived,OPTIONAL
+    IN EFI_PXE_BASE_CODE_PACKET     *NewDhcpDiscover, OPTIONAL
+    IN EFI_PXE_BASE_CODE_PACKET     *NewDhcpAck,      OPTIONAL
+    IN EFI_PXE_BASE_CODE_PACKET     *NewProxyOffer,   OPTIONAL
+    IN EFI_PXE_BASE_CODE_PACKET     *NewPxeDiscover,  OPTIONAL
+    IN EFI_PXE_BASE_CODE_PACKET     *NewPxeReply,     OPTIONAL
+    IN EFI_PXE_BASE_CODE_PACKET     *NewPxeBisReply   OPTIONAL
+    );
+
+//
+// PXE Base Code Protocol structure
+//
+
+#define EFI_PXE_BASE_CODE_INTERFACE_REVISION    0x00010000
+
+typedef struct _EFI_PXE_BASE_CODE {
+    UINT64                              Revision;
+    EFI_PXE_BASE_CODE_START             Start;
+    EFI_PXE_BASE_CODE_STOP              Stop;
+    EFI_PXE_BASE_CODE_DHCP              Dhcp;
+    EFI_PXE_BASE_CODE_DISCOVER          Discover;
+    EFI_PXE_BASE_CODE_MTFTP             Mtftp;
+    EFI_PXE_BASE_CODE_UDP_WRITE         UdpWrite;
+    EFI_PXE_BASE_CODE_UDP_READ          UdpRead;
+    EFI_PXE_BASE_CODE_SET_IP_FILTER     SetIpFilter;
+    EFI_PXE_BASE_CODE_ARP               Arp;
+    EFI_PXE_BASE_CODE_SET_PARAMETERS    SetParameters;
+    EFI_PXE_BASE_CODE_SET_STATION_IP    SetStationIp;
+    EFI_PXE_BASE_CODE_SET_PACKETS       SetPackets;
+    EFI_PXE_BASE_CODE_MODE              *Mode;
+} EFI_PXE_BASE_CODE;
+
+//
+// Call Back Definitions
+//
+
+#define EFI_PXE_BASE_CODE_CALLBACK_PROTOCOL \
+    { 0x245dca21, 0xfb7b, 0x11d3, {0x8f, 0x01, 0x00, 0xa0, 0xc9, 0x69, 0x72, 0x3b} }
+
+//
+// Revision Number
+//
+
+#define EFI_PXE_BASE_CODE_CALLBACK_INTERFACE_REVISION   0x00010000
+
+INTERFACE_DECL(_EFI_PXE_BASE_CODE_CALLBACK);
+
+typedef enum {
+    EFI_PXE_BASE_CODE_FUNCTION_FIRST,
+    EFI_PXE_BASE_CODE_FUNCTION_DHCP,
+    EFI_PXE_BASE_CODE_FUNCTION_DISCOVER,
+    EFI_PXE_BASE_CODE_FUNCTION_MTFTP,
+    EFI_PXE_BASE_CODE_FUNCTION_UDP_WRITE,
+    EFI_PXE_BASE_CODE_FUNCTION_UDP_READ,
+    EFI_PXE_BASE_CODE_FUNCTION_ARP,
+    EFI_PXE_BASE_CODE_FUNCTION_IGMP,
+    EFI_PXE_BASE_CODE_PXE_FUNCTION_LAST
+} EFI_PXE_BASE_CODE_FUNCTION;
+
+typedef enum {
+    EFI_PXE_BASE_CODE_CALLBACK_STATUS_FIRST,
+    EFI_PXE_BASE_CODE_CALLBACK_STATUS_CONTINUE,
+    EFI_PXE_BASE_CODE_CALLBACK_STATUS_ABORT,
+    EFI_PXE_BASE_CODE_CALLBACK_STATUS_LAST
+} EFI_PXE_BASE_CODE_CALLBACK_STATUS;
+
+typedef
+EFI_PXE_BASE_CODE_CALLBACK_STATUS 
+(EFIAPI *EFI_PXE_CALLBACK) (
+    IN struct _EFI_PXE_BASE_CODE_CALLBACK   *This,
+    IN EFI_PXE_BASE_CODE_FUNCTION           Function,
+    IN BOOLEAN                              Received,
+    IN UINT32                               PacketLen,
+    IN EFI_PXE_BASE_CODE_PACKET             *Packet     OPTIONAL
+    );
+
+typedef struct _EFI_PXE_BASE_CODE_CALLBACK {
+    UINT64                      Revision;
+    EFI_PXE_CALLBACK            Callback;
+} EFI_PXE_BASE_CODE_CALLBACK;
+
+#endif /* _EFIPXEBC_H */
diff --git a/linux-x86_64/gnu-efi/include/efi/efirtlib.h b/linux-x86_64/gnu-efi/include/efi/efirtlib.h
new file mode 100644
index 0000000..0100180
--- /dev/null
+++ b/linux-x86_64/gnu-efi/include/efi/efirtlib.h
@@ -0,0 +1,141 @@
+#ifndef _EFI_RT_LIB_INCLUDE_
+#define _EFI_RT_LIB_INCLUDE_
+/*++
+
+Copyright (c) 1998  Intel Corporation
+
+Module Name:
+
+    efilib.h
+
+Abstract:
+
+    EFI Runtime library functions
+
+
+
+Revision History
+
+--*/
+
+#include "efidebug.h"
+#include "efipart.h"
+#include "efilibplat.h"
+
+
+VOID
+RUNTIMEFUNCTION
+RtZeroMem (
+    IN VOID     *Buffer,
+    IN UINTN     Size
+    );
+
+VOID
+RUNTIMEFUNCTION
+RtSetMem (
+    IN VOID     *Buffer,
+    IN UINTN    Size,
+    IN UINT8    Value    
+    );
+
+VOID
+RUNTIMEFUNCTION
+RtCopyMem (
+    IN VOID     *Dest,
+    IN VOID     *Src,
+    IN UINTN    len
+    );
+
+INTN
+RUNTIMEFUNCTION
+RtCompareMem (
+    IN VOID     *Dest,
+    IN VOID     *Src,
+    IN UINTN    len
+    );
+
+INTN
+RUNTIMEFUNCTION
+RtStrCmp (
+    IN CHAR16   *s1,
+    IN CHAR16   *s2
+    );
+
+
+VOID
+RUNTIMEFUNCTION
+RtStrCpy (
+    IN CHAR16   *Dest,
+    IN CHAR16    *Src
+    );
+
+VOID
+RUNTIMEFUNCTION
+RtStrCat (
+    IN CHAR16   *Dest,
+    IN CHAR16   *Src
+    );
+
+UINTN
+RUNTIMEFUNCTION
+RtStrLen (
+    IN CHAR16   *s1
+    );
+
+UINTN
+RUNTIMEFUNCTION
+RtStrSize (
+    IN CHAR16   *s1
+    );
+
+INTN
+RUNTIMEFUNCTION
+RtCompareGuid (
+    IN EFI_GUID     *Guid1,
+    IN EFI_GUID     *Guid2
+    );
+
+UINT8
+RUNTIMEFUNCTION
+RtDecimaltoBCD(
+    IN  UINT8 BcdValue
+    );
+
+UINT8
+RUNTIMEFUNCTION
+RtBCDtoDecimal(
+    IN  UINT8 BcdValue
+    );
+
+//
+// Virtual mapping transition support.  (Only used during
+// the virtual address change transisition)
+//
+
+VOID
+RUNTIMEFUNCTION
+RtLibEnableVirtualMappings (
+    VOID
+    );
+
+VOID
+RUNTIMEFUNCTION
+RtConvertList (
+    IN UINTN            DebugDisposition,
+    IN OUT LIST_ENTRY   *ListHead
+    );
+
+VOID
+RUNTIMEFUNCTION
+RtAcquireLock (
+    IN FLOCK    *Lock
+    );
+
+VOID
+RUNTIMEFUNCTION
+RtReleaseLock (
+    IN FLOCK    *Lock
+    );
+
+
+#endif
diff --git a/linux-x86_64/gnu-efi/include/efi/efiser.h b/linux-x86_64/gnu-efi/include/efi/efiser.h
new file mode 100644
index 0000000..fcc97a1
--- /dev/null
+++ b/linux-x86_64/gnu-efi/include/efi/efiser.h
@@ -0,0 +1,132 @@
+#ifndef _EFI_SER_H
+#define _EFI_SER_H
+
+/*++
+
+Copyright (c) 1998  Intel Corporation
+
+Module Name:
+
+    efiser.h
+
+Abstract:
+
+    EFI serial protocol
+
+Revision History
+
+--*/
+
+//
+// Serial protocol
+//
+
+#define SERIAL_IO_PROTOCOL \
+    { 0xBB25CF6F, 0xF1D4, 0x11D2, {0x9A, 0x0C, 0x00, 0x90, 0x27, 0x3F, 0xC1, 0xFD} }
+
+INTERFACE_DECL(_SERIAL_IO_INTERFACE);
+
+typedef enum {
+    DefaultParity,      
+    NoParity,           
+    EvenParity,
+    OddParity,
+    MarkParity,
+    SpaceParity
+} EFI_PARITY_TYPE;
+
+typedef enum {
+    DefaultStopBits,        
+    OneStopBit,         // 1 stop bit
+    OneFiveStopBits,    // 1.5 stop bits
+    TwoStopBits         // 2 stop bits
+} EFI_STOP_BITS_TYPE;
+
+#define EFI_SERIAL_CLEAR_TO_SEND                   0x0010  // RO
+#define EFI_SERIAL_DATA_SET_READY                  0x0020  // RO
+#define EFI_SERIAL_RING_INDICATE                   0x0040  // RO
+#define EFI_SERIAL_CARRIER_DETECT                  0x0080  // RO
+#define EFI_SERIAL_REQUEST_TO_SEND                 0x0002  // WO
+#define EFI_SERIAL_DATA_TERMINAL_READY             0x0001  // WO
+#define EFI_SERIAL_INPUT_BUFFER_EMPTY              0x0100  // RO
+#define EFI_SERIAL_OUTPUT_BUFFER_EMPTY             0x0200  // RO
+#define EFI_SERIAL_HARDWARE_LOOPBACK_ENABLE        0x1000  // RW
+#define EFI_SERIAL_SOFTWARE_LOOPBACK_ENABLE        0x2000  // RW
+#define EFI_SERIAL_HARDWARE_FLOW_CONTROL_ENABLE    0x4000  // RW
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_SERIAL_RESET) (
+    IN struct _SERIAL_IO_INTERFACE  *This
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_SERIAL_SET_ATTRIBUTES) (
+    IN struct _SERIAL_IO_INTERFACE  *This,
+    IN UINT64                       BaudRate,
+    IN UINT32                       ReceiveFifoDepth,
+    IN UINT32                       Timeout,
+    IN EFI_PARITY_TYPE              Parity,
+    IN UINT8                        DataBits,
+    IN EFI_STOP_BITS_TYPE           StopBits
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_SERIAL_SET_CONTROL_BITS) (
+    IN struct _SERIAL_IO_INTERFACE  *This,
+    IN UINT32                       Control
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_SERIAL_GET_CONTROL_BITS) (
+    IN struct _SERIAL_IO_INTERFACE  *This,
+    OUT UINT32                      *Control
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_SERIAL_WRITE) (
+    IN struct _SERIAL_IO_INTERFACE  *This,
+    IN OUT UINTN                    *BufferSize,
+    IN VOID                         *Buffer
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_SERIAL_READ) (
+    IN struct _SERIAL_IO_INTERFACE  *This,
+    IN OUT UINTN                    *BufferSize,
+    OUT VOID                        *Buffer
+    );
+
+typedef struct {
+    UINT32                  ControlMask;
+
+    // current Attributes
+    UINT32                  Timeout;
+    UINT64                  BaudRate;
+    UINT32                  ReceiveFifoDepth;
+    UINT32                  DataBits;
+    UINT32                  Parity;
+    UINT32                  StopBits;
+} SERIAL_IO_MODE;
+
+#define SERIAL_IO_INTERFACE_REVISION    0x00010000
+
+typedef struct _SERIAL_IO_INTERFACE {
+    UINT32                       Revision;
+    EFI_SERIAL_RESET             Reset;
+    EFI_SERIAL_SET_ATTRIBUTES    SetAttributes;
+    EFI_SERIAL_SET_CONTROL_BITS  SetControl;
+    EFI_SERIAL_GET_CONTROL_BITS  GetControl;
+    EFI_SERIAL_WRITE             Write;
+    EFI_SERIAL_READ              Read;
+
+    SERIAL_IO_MODE               *Mode;
+} SERIAL_IO_INTERFACE;
+
+#endif
+
diff --git a/linux-x86_64/gnu-efi/include/efi/efistdarg.h b/linux-x86_64/gnu-efi/include/efi/efistdarg.h
new file mode 100644
index 0000000..8a96b94
--- /dev/null
+++ b/linux-x86_64/gnu-efi/include/efi/efistdarg.h
@@ -0,0 +1,33 @@
+#ifndef _EFISTDARG_H_
+#define _EFISTDARG_H_
+
+/*++
+
+Copyright (c) 1998  Intel Corporation
+
+Module Name:
+
+    devpath.h
+
+Abstract:
+
+    Defines for parsing the EFI Device Path structures
+
+
+
+Revision History
+
+--*/
+#ifdef __GNUC__
+#include "stdarg.h"
+#else
+#define _INTSIZEOF(n)   ( (sizeof(n) + sizeof(UINTN) - 1) & ~(sizeof(UINTN) - 1) )
+
+typedef CHAR8 * va_list;
+
+#define va_start(ap,v)  ( ap = (va_list)&v + _INTSIZEOF(v) )
+#define va_arg(ap,t)    ( *(t *)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)) )
+#define va_end(ap)  ( ap = (va_list)0 )
+#endif
+
+#endif  /* _INC_STDARG */
diff --git a/linux-x86_64/gnu-efi/include/efi/efiui.h b/linux-x86_64/gnu-efi/include/efi/efiui.h
new file mode 100644
index 0000000..7341943
--- /dev/null
+++ b/linux-x86_64/gnu-efi/include/efi/efiui.h
@@ -0,0 +1,54 @@
+#ifndef _EFI_UI_H
+#define _EFI_UI_H
+
+/*++
+
+Copyright (c) 200  Intel Corporation
+
+Module Name:
+
+    EfiUi.h
+    
+Abstract:   
+    Protocol used to build User Interface (UI) stuff.
+
+    This protocol is just data. It is a multi dimentional array.
+    For each string there is an array of UI_STRING_ENTRY. Each string
+    is for a different language translation of the same string. The list 
+    is terminated by a NULL UiString. There can be any number of 
+    UI_STRING_ENTRY arrays. A NULL array terminates the list. A NULL array
+    entry contains all zeros.  
+
+    Thus the shortest possible EFI_UI_PROTOCOL has three UI_STRING_ENTRY.
+    The String, it's NULL terminator, and the NULL terminator for the entire 
+    thing.
+
+
+Revision History
+
+--*/
+
+#define EFI_UI_PROTOCOL \
+    { 0x32dd7981, 0x2d27, 0x11d4, {0xbc, 0x8b, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81} }
+
+
+typedef enum {
+    UiDeviceString,
+    UiVendorString,
+    UiMaxString
+} UI_STRING_TYPE;
+
+typedef struct {
+    ISO_639_2   *LangCode;
+    CHAR16      *UiString;
+} UI_STRING_ENTRY;
+
+#define EFI_UI_VERSION      0x00010000
+
+typedef struct _UI_INTERFACE {
+    UINT32          Version;
+    UI_STRING_ENTRY *Entry;
+} UI_INTERFACE;
+
+
+#endif
diff --git a/linux-x86_64/gnu-efi/include/efi/libsmbios.h b/linux-x86_64/gnu-efi/include/efi/libsmbios.h
new file mode 100644
index 0000000..8f1a28e
--- /dev/null
+++ b/linux-x86_64/gnu-efi/include/efi/libsmbios.h
@@ -0,0 +1,132 @@
+#ifndef _LIB_SMBIOS_H
+#define _LIB_SMBIOS_H
+/*++
+
+Copyright (c) 2000  Intel Corporation
+
+Module Name:
+
+    LibSmbios.h
+    
+Abstract:
+
+    Lib include  for SMBIOS services. Used to get system serial number and GUID
+
+Revision History
+
+--*/
+
+//
+// Define SMBIOS tables.
+//
+#pragma pack(1)
+typedef struct {
+    UINT8   AnchorString[4];
+    UINT8   EntryPointStructureChecksum;
+    UINT8   EntryPointLength;
+    UINT8   MajorVersion;
+    UINT8   MinorVersion;
+    UINT16  MaxStructureSize;
+    UINT8   EntryPointRevision;
+    UINT8   FormattedArea[5];
+    UINT8   IntermediateAnchorString[5];
+    UINT8   IntermediateChecksum;
+    UINT16  TableLength;
+    UINT32  TableAddress;
+    UINT16  NumberOfSmbiosStructures;
+    UINT8   SmbiosBcdRevision;
+} SMBIOS_STRUCTURE_TABLE;
+
+//
+// Please note that SMBIOS structures can be odd byte aligned since the
+//  unformated section of each record is a set of arbitrary size strings.
+//
+
+typedef struct {
+    UINT8   Type;
+    UINT8   Length;
+    UINT8   Handle[2];
+} SMBIOS_HEADER;
+
+typedef UINT8   SMBIOS_STRING;
+
+typedef struct {
+    SMBIOS_HEADER   Hdr;
+    SMBIOS_STRING   Vendor;
+    SMBIOS_STRING   BiosVersion;
+    UINT8           BiosSegment[2];
+    SMBIOS_STRING   BiosReleaseDate;
+    UINT8           BiosSize;
+    UINT8           BiosCharacteristics[8];
+} SMBIOS_TYPE0;
+
+typedef struct {
+    SMBIOS_HEADER   Hdr;
+    SMBIOS_STRING   Manufacturer;
+    SMBIOS_STRING   ProductName;
+    SMBIOS_STRING   Version;
+    SMBIOS_STRING   SerialNumber;
+
+    //
+    // always byte copy this data to prevent alignment faults!
+    //
+    EFI_GUID        Uuid;
+    
+    UINT8           WakeUpType;
+} SMBIOS_TYPE1;
+
+typedef struct {
+    SMBIOS_HEADER   Hdr;
+    SMBIOS_STRING   Manufacturer;
+    SMBIOS_STRING   ProductName;
+    SMBIOS_STRING   Version;
+    SMBIOS_STRING   SerialNumber;
+} SMBIOS_TYPE2;
+
+typedef struct {
+    SMBIOS_HEADER   Hdr;
+    SMBIOS_STRING   Manufacturer;
+    UINT8           Type;
+    SMBIOS_STRING   Version;
+    SMBIOS_STRING   SerialNumber;
+    SMBIOS_STRING   AssetTag;
+    UINT8           BootupState;
+    UINT8           PowerSupplyState;
+    UINT8           ThermalState;
+    UINT8           SecurityStatus;
+    UINT8           OemDefined[4];
+} SMBIOS_TYPE3;
+
+typedef struct {
+    SMBIOS_HEADER   Hdr;
+    UINT8           Socket;
+    UINT8           ProcessorType;
+    UINT8           ProcessorFamily;
+    SMBIOS_STRING   ProcessorManufacture;
+    UINT8           ProcessorId[8];
+    SMBIOS_STRING   ProcessorVersion;
+    UINT8           Voltage;
+    UINT8           ExternalClock[2];
+    UINT8           MaxSpeed[2];
+    UINT8           CurrentSpeed[2];
+    UINT8           Status;
+    UINT8           ProcessorUpgrade;
+    UINT8           L1CacheHandle[2];
+    UINT8           L2CacheHandle[2];
+    UINT8           L3CacheHandle[2];
+} SMBIOS_TYPE4;
+
+typedef union {
+    SMBIOS_HEADER   *Hdr;
+    SMBIOS_TYPE0    *Type0;
+    SMBIOS_TYPE1    *Type1;
+    SMBIOS_TYPE2    *Type2;
+    SMBIOS_TYPE3    *Type3;
+    SMBIOS_TYPE4    *Type4;
+    UINT8           *Raw;
+} SMBIOS_STRUCTURE_POINTER;
+#pragma pack()
+
+
+#endif
+
diff --git a/linux-x86_64/gnu-efi/include/efi/pci22.h b/linux-x86_64/gnu-efi/include/efi/pci22.h
new file mode 100644
index 0000000..b94f519
--- /dev/null
+++ b/linux-x86_64/gnu-efi/include/efi/pci22.h
@@ -0,0 +1,193 @@
+#ifndef _PCI22_H
+#define _PCI22_H
+
+/*++
+
+Copyright (c) 1999  Intel Corporation
+
+Module Name:
+
+    pci22.h
+    
+Abstract:      
+    Support for PCI 2.2 standard.
+
+
+
+
+Revision History
+
+--*/
+
+#ifdef SOFT_SDV
+#define PCI_MAX_BUS     1
+#else
+#define PCI_MAX_BUS     255
+#endif
+
+#define PCI_MAX_DEVICE  31
+#define PCI_MAX_FUNC    7
+
+//
+// Command
+//
+#define PCI_VGA_PALETTE_SNOOP_DISABLED   0x20
+
+#pragma pack(1)
+typedef struct {
+    UINT16      VendorId;
+    UINT16      DeviceId;
+    UINT16      Command;
+    UINT16      Status;
+    UINT8       RevisionID;
+    UINT8       ClassCode[3];
+    UINT8       CacheLineSize;
+    UINT8       LaytencyTimer;
+    UINT8       HeaderType;
+    UINT8       BIST;
+} PCI_DEVICE_INDEPENDENT_REGION;
+
+typedef struct {
+    UINT32      Bar[6];
+    UINT32      CISPtr;
+    UINT16      SubsystemVendorID;
+    UINT16      SubsystemID;
+    UINT32      ExpansionRomBar;
+    UINT32      Reserved[2];
+    UINT8       InterruptLine;
+    UINT8       InterruptPin;
+    UINT8       MinGnt;
+    UINT8       MaxLat;     
+} PCI_DEVICE_HEADER_TYPE_REGION;
+
+typedef struct {
+    PCI_DEVICE_INDEPENDENT_REGION   Hdr;
+    PCI_DEVICE_HEADER_TYPE_REGION   Device;
+} PCI_TYPE00;
+
+typedef struct {              
+    UINT32      Bar[2];
+    UINT8       PrimaryBus;
+    UINT8       SecondaryBus;
+    UINT8       SubordinateBus;
+    UINT8       SecondaryLatencyTimer;
+    UINT8       IoBase;
+    UINT8       IoLimit;
+    UINT16      SecondaryStatus;
+    UINT16      MemoryBase;
+    UINT16      MemoryLimit;
+    UINT16      PrefetchableMemoryBase;
+    UINT16      PrefetchableMemoryLimit;
+    UINT32      PrefetchableBaseUpper32;
+    UINT32      PrefetchableLimitUpper32;
+    UINT16      IoBaseUpper16;
+    UINT16      IoLimitUpper16;
+    UINT32      Reserved;
+    UINT32      ExpansionRomBAR;
+    UINT8       InterruptLine;
+    UINT8       InterruptPin;
+    UINT16      BridgeControl;
+} PCI_BRIDGE_CONTROL_REGISTER;
+
+#define PCI_CLASS_DISPLAY_CTRL          0x03
+#define PCI_CLASS_VGA                   0x00
+
+#define PCI_CLASS_BRIDGE                0x06
+#define PCI_CLASS_ISA                   0x01
+#define PCI_CLASS_ISA_POSITIVE_DECODE   0x80
+
+#define PCI_CLASS_NETWORK               0x02 
+#define PCI_CLASS_ETHERNET              0x00
+        
+#define HEADER_TYPE_DEVICE              0x00
+#define HEADER_TYPE_PCI_TO_PCI_BRIDGE   0x01
+#define HEADER_TYPE_MULTI_FUNCTION      0x80
+#define HEADER_LAYOUT_CODE              0x7f
+
+#define IS_PCI_BRIDGE(_p) ((((_p)->Hdr.HeaderType) & HEADER_LAYOUT_CODE) == HEADER_TYPE_PCI_TO_PCI_BRIDGE)        
+#define IS_PCI_MULTI_FUNC(_p)   (((_p)->Hdr.HeaderType) & HEADER_TYPE_MULTI_FUNCTION)         
+
+typedef struct {
+    PCI_DEVICE_INDEPENDENT_REGION   Hdr;
+    PCI_BRIDGE_CONTROL_REGISTER     Bridge;
+} PCI_TYPE01;
+
+typedef struct {
+    UINT8   Register;
+    UINT8   Function;
+    UINT8   Device;
+    UINT8   Bus;
+    UINT8   Reserved[4];
+} DEFIO_PCI_ADDR;
+
+typedef struct {
+    UINT32  Reg     : 8;
+    UINT32  Func    : 3;
+    UINT32  Dev     : 5;
+    UINT32  Bus     : 8;
+    UINT32  Reserved: 7;
+    UINT32  Enable  : 1;
+} PCI_CONFIG_ACCESS_CF8;
+
+#pragma pack()
+
+#define EFI_ROOT_BRIDGE_LIST    'eprb'
+typedef struct {
+    UINTN           Signature;
+
+    UINT16          BridgeNumber;
+    UINT16          PrimaryBus;
+    UINT16          SubordinateBus;
+
+    EFI_DEVICE_PATH *DevicePath;
+
+    LIST_ENTRY      Link;
+} PCI_ROOT_BRIDGE_ENTRY;
+
+
+#define PCI_EXPANSION_ROM_HEADER_SIGNATURE        0xaa55
+#define EFI_PCI_EXPANSION_ROM_HEADER_EFISIGNATURE 0x0EF1
+#define PCI_DATA_STRUCTURE_SIGNATURE              EFI_SIGNATURE_32('P','C','I','R')
+
+#pragma pack(1)
+typedef struct {
+    UINT16          Signature;              // 0xaa55
+    UINT8           Reserved[0x16];
+    UINT16          PcirOffset;
+} PCI_EXPANSION_ROM_HEADER;
+
+
+typedef struct {
+    UINT16          Signature;              // 0xaa55
+    UINT16          InitializationSize;
+    UINT16          EfiSignature;           // 0x0EF1
+    UINT16          EfiSubsystem;
+    UINT16          EfiMachineType;
+    UINT8           Reserved[0x0A];
+    UINT16          EfiImageHeaderOffset;
+    UINT16          PcirOffset;
+} EFI_PCI_EXPANSION_ROM_HEADER;
+
+typedef struct {
+    UINT32          Signature;              // "PCIR" 
+    UINT16          VendorId;
+    UINT16          DeviceId;
+    UINT16          Reserved0;
+    UINT16          Length;
+    UINT8           Revision;
+    UINT8           ClassCode[3];
+    UINT16          ImageLength;
+    UINT16          CodeRevision;
+    UINT8           CodeType;
+    UINT8           Indicator;
+    UINT16          Reserved1;
+} PCI_DATA_STRUCTURE;
+#pragma pack()
+
+#endif
+    
+
+
+
+
+    
diff --git a/linux-x86_64/gnu-efi/include/efi/protocol/adapterdebug.h b/linux-x86_64/gnu-efi/include/efi/protocol/adapterdebug.h
new file mode 100644
index 0000000..d70af5d
--- /dev/null
+++ b/linux-x86_64/gnu-efi/include/efi/protocol/adapterdebug.h
@@ -0,0 +1,32 @@
+#ifndef _ADAPTER_DEBUG_H
+#define _ADAPTER_DEBUG_H
+
+/*++
+
+Copyright (c) 1999  Intel Corporation
+
+Module Name:
+
+    AdapterDebug.h
+    
+Abstract:
+
+    Protocol to debug the EDD 3.0 enablement of BIOS option ROMs
+
+
+
+Revision History
+
+--*/
+
+// {82F86881-282B-11d4-BC7D-0080C73C8881}
+#define ADAPTER_DEBUG_PROTOCOL \
+{ 0x82f86881, 0x282b, 0x11d4, {0xbc, 0x7d, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81} }
+
+//
+// This protocol points to the BIOS_LEGACY_DRIVE data structure
+//  see edd.h for more details
+//
+
+#endif
+
diff --git a/linux-x86_64/gnu-efi/include/efi/protocol/eficonsplit.h b/linux-x86_64/gnu-efi/include/efi/protocol/eficonsplit.h
new file mode 100644
index 0000000..15adb92
--- /dev/null
+++ b/linux-x86_64/gnu-efi/include/efi/protocol/eficonsplit.h
@@ -0,0 +1,32 @@
+#ifndef _EFI_CONFORK_H
+#define _EFI_CONFORK_H
+/*++
+
+Copyright (c) 1999  Intel Corporation
+
+Module Name:
+
+Abstract:
+
+
+
+Revision History
+
+--*/
+
+
+
+//
+// ConOut Forker Protocol
+//
+
+#define TEXT_OUT_SPLITER_PROTOCOL    \
+    { 0x56d830a0, 0x7e7a, 0x11d3, {0xbb, 0xa0, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b} }
+
+#define ERROR_OUT_SPLITER_PROTOCOL    \
+    { 0xf0ba9039, 0x68f1, 0x425e, {0xaa, 0x7f, 0xd9, 0xaa, 0xf9, 0x1b, 0x82, 0xa1}}
+
+#define TEXT_IN_SPLITER_PROTOCOL    \
+    { 0xf9a3c550, 0x7fb5, 0x11d3, {0xbb, 0xa0, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b} }
+
+#endif
diff --git a/linux-x86_64/gnu-efi/include/efi/protocol/efidbg.h b/linux-x86_64/gnu-efi/include/efi/protocol/efidbg.h
new file mode 100644
index 0000000..1f95a70
--- /dev/null
+++ b/linux-x86_64/gnu-efi/include/efi/protocol/efidbg.h
@@ -0,0 +1,210 @@
+/*
+ * Copyright (c) 1999, 2000
+ * Intel Corporation.
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ * 
+ *    This product includes software developed by Intel Corporation and
+ *    its contributors.
+ * 
+ * 4. Neither the name of Intel Corporation or its contributors may be
+ *    used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY INTEL CORPORATION AND CONTRIBUTORS ``AS IS''
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL INTEL CORPORATION OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * 
+ */
+
+
+#ifndef _EFIDBG_H_
+#define _EFIDBG_H_
+
+#include "eficontext.h"
+#include "efiser.h"
+
+typedef struct _DEBUGPORT_16550_CONFIG_DATA {
+        UINT32							PortAddress;
+        UINT64                          BaudRate;
+    	UINT32               			ReceiveFifoDepth;
+    	UINT32               			Timeout;
+        UINT8                           Parity;
+        UINT8                           DataBits;
+        UINT8                           StopBits;
+	    UINT32                       	ControlMask;
+        BOOLEAN							RtsCtsEnable;		// RTS, CTS control
+} DEBUGPORT_16550_CONFIG_DATA;
+
+typedef struct _DEBUGPORT_16550_DEVICE_PATH {
+        EFI_DEVICE_PATH                 Header;
+        DEBUGPORT_16550_CONFIG_DATA		ConfigData;
+} DEBUGPORT_16550_DEVICE_PATH;
+
+typedef union {
+    EFI_DEVICE_PATH                     DevPath;
+    DEBUGPORT_16550_DEVICE_PATH         Uart;
+    // add new types of debugport device paths to this union...
+} DEBUGPORT_DEV_PATH;
+
+
+//
+// Debug Support protocol {2755590C-6F3C-42FA-9EA4-A3BA543CDA25}
+//
+
+#define DEBUG_SUPPORT_PROTOCOL \
+{ 0x2755590C, 0x6F3C, 0x42fa, 0x9E, 0xA4, 0xA3, 0xBA, 0x54, 0x3C, 0xDA, 0x25 }
+
+
+typedef UINTN EXCEPTION_TYPE;
+
+typedef
+VOID
+(*EXCEPTION_HANDLER) (
+	IN EXCEPTION_TYPE ExceptionType,
+    IN SYSTEM_CONTEXT *SystemContext
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_REGISTER_TIMER_TICK_CALLBACK) (
+    IN struct _EFI_DEBUG_SUPPORT_INTERFACE  *This,
+    IN EXCEPTION_HANDLER	                TimerTickCallback
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_REGISTER_EXCEPTION_HANDLER) (
+    IN     struct _EFI_DEBUG_SUPPORT_INTERFACE  *This,
+    IN     EXCEPTION_HANDLER                    ExceptionHandler,
+    IN     EXCEPTION_TYPE                       ExceptionType
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_IP_CALL_TRACE) (
+    IN     struct _EFI_DEBUG_SUPPORT_INTERFACE  *This
+    );
+
+
+#define EFI_DEBUG_SUPPORT_INTERFACE_REVISION     0x00010000
+
+typedef struct _EFI_DEBUG_SUPPORT_INTERFACE {
+    UINT32                          	Revision;
+    EFI_REGISTER_TIMER_TICK_CALLBACK	RegisterTimerTickCallback;
+    EFI_REGISTER_EXCEPTION_HANDLER  	RegisterExceptionHandler;
+    EFI_IP_CALL_TRACE               	IpCallTrace;
+} EFI_DEBUG_SUPPORT_INTERFACE;
+
+
+//
+// Debugport io protocol {EBA4E8D2-3858-41EC-A281-2647BA9660D0}
+//
+
+#define DEBUGPORT_IO_PROTOCOL \
+{ 0XEBA4E8D2, 0X3858, 0X41EC, 0XA2, 0X81, 0X26, 0X47, 0XBA, 0X96, 0X60, 0XD0 }
+ 
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_DEBUGPORT_IO_RESET) (
+    IN struct _EFI_DEBUGPORT_IO_INTERFACE  	*This
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_DEBUGPORT_IO_READ) (
+    IN     struct _EFI_DEBUGPORT_IO_INTERFACE	*This,
+    IN OUT UINTN                    		*BufferSize,
+    OUT VOID                         		*Buffer
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_DEBUGPORT_IO_WRITE) (
+    IN     struct _EFI_DEBUGPORT_IO_INTERFACE *This,
+    IN OUT UINTN                    		*BufferSize,
+    IN VOID                         		*Buffer
+    );
+
+#define EFI_DEBUGPORT_IO_INTERFACE_REVISION   0x00010000
+
+typedef struct _EFI_DEBUGPORT_IO_INTERFACE {
+    UINT32                          		Revision;
+    EFI_DEBUGPORT_IO_READ					Read;
+    EFI_DEBUGPORT_IO_WRITE					Write;
+    EFI_DEBUGPORT_IO_RESET					Reset;
+} EFI_DEBUGPORT_IO_INTERFACE;
+
+
+//
+// Debugport UART16550 control protocol {628EA978-4C26-4605-BC02-A42A496917DD}
+//
+
+#define DEBUGPORT_UART16550_CONTROL_PROTOCOL \
+{ 0X628EA978, 0X4C26, 0X4605, 0XBC, 0X2, 0XA4, 0X2A, 0X49, 0X69, 0X17, 0XDD }
+ 
+// Note: The definitions for EFI_PARITY_TYPE, EFI_STOP_BITS_TYPE, and 
+// SERIAL_IO_MODE are included from efiser.h
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_UART16550_SET_ATTRIBUTES) (
+    IN struct _EFI_DEBUGPORT_UART16550_CONTROL_INTERFACE  	*This,
+    IN UINT64                       	BaudRate,
+    IN UINT32                       	ReceiveFifoDepth,
+    IN UINT32                       	Timeout,
+    IN EFI_PARITY_TYPE       			Parity,
+    IN UINT8                        	DataBits,
+    IN EFI_STOP_BITS_TYPE    			StopBits
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_UART16550_SET_CONTROL_BITS) (
+    IN struct _EFI_DEBUGPORT_UART16550_CONTROL_INTERFACE  	*This,
+    IN UINT32                       	Control
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_UART16550_GET_CONTROL_BITS) (
+    IN struct _EFI_DEBUGPORT_UART16550_CONTROL_INTERFACE	*This,
+    OUT UINT32                      	*Control
+    );
+
+#define EFI_DEBUGPORT_UART16550_CONTROL_INTERFACE_REVISION   0x00010000
+
+typedef struct _EFI_DEBUGPORT_UART16550_CONTROL_INTERFACE {
+    UINT32                          	Revision;
+	EFI_UART16550_SET_ATTRIBUTES		SetAttributes;
+	EFI_UART16550_SET_CONTROL_BITS		SetControl;
+	EFI_UART16550_GET_CONTROL_BITS 		GetControl;
+	DEBUGPORT_16550_CONFIG_DATA			*Mode;
+} EFI_DEBUGPORT_UART16550_CONTROL_INTERFACE;
+        
+
+#define DEVICE_PATH_DEBUGPORT DEBUGPORT_IO_PROTOCOL
+        
+#endif /* _EFIDBG_H_ */
diff --git a/linux-x86_64/gnu-efi/include/efi/protocol/efivar.h b/linux-x86_64/gnu-efi/include/efi/protocol/efivar.h
new file mode 100644
index 0000000..92dc506
--- /dev/null
+++ b/linux-x86_64/gnu-efi/include/efi/protocol/efivar.h
@@ -0,0 +1,133 @@
+/*++
+
+Copyright (c) 1998  Intel Corporation
+
+Module Name:
+
+Abstract:
+
+
+
+Revision History
+
+--*/
+
+
+
+//
+// The variable store protocol interface is specific to the reference
+// implementation.  The initialization code adds variable store devices
+// to the system, and the FW connects to the devices to provide the
+// variable store interfaces through these devices.
+//
+
+//
+// Variable Store Device protocol
+//
+
+#define VARIABLE_STORE_PROTOCOL    \
+    { 0xf088cd91, 0xa046, 0x11d2, {0x8e, 0x42, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b} }
+
+INTERFACE_DECL(_EFI_VARIABLE_STORE);
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_STORE_CLEAR) (
+    IN struct _EFI_VARIABLE_STORE   *This,
+    IN UINTN                        BankNo,
+    IN OUT VOID                     *Scratch
+    );
+
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_STORE_READ) (
+    IN struct _EFI_VARIABLE_STORE   *This,
+    IN UINTN                        BankNo,
+    IN UINTN                        Offset,
+    IN UINTN                        BufferSize,
+    OUT VOID                        *Buffer
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_STORE_UPDATE) (
+    IN struct _EFI_VARIABLE_STORE   *This,
+    IN UINTN                        BankNo,
+    IN UINTN                        Offset,
+    IN UINTN                        BufferSize,
+    IN VOID                         *Buffer
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_STORE_SIZE) (
+    IN struct _EFI_VARIABLE_STORE   *This,
+    IN UINTN                        NoBanks
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_TRANSACTION_UPDATE) (
+    IN struct _EFI_VARIABLE_STORE   *This,
+    IN UINTN                        BankNo,
+    IN VOID                         *NewContents
+    );
+
+typedef struct _EFI_VARIABLE_STORE {
+
+    //
+    // Number of banks and bank size
+    //
+
+    UINT32                      Attributes;
+    UINT32                      BankSize;
+    UINT32                      NoBanks;
+
+    //
+    // Functions to access the storage banks
+    //
+
+    EFI_STORE_CLEAR             ClearStore;
+    EFI_STORE_READ              ReadStore;
+    EFI_STORE_UPDATE            UpdateStore;
+    EFI_STORE_SIZE              SizeStore OPTIONAL;
+    EFI_TRANSACTION_UPDATE      TransactionUpdate OPTIONAL;
+
+} EFI_VARIABLE_STORE;
+
+
+//
+//
+// ClearStore()     - A function to clear the requested storage bank.  A cleared
+//      bank contains all "on" bits.
+//
+// ReadStore()      - Read data from the requested store.
+//
+// UpdateStore()    - Updates data on the requested store. The FW will only
+//      ever issue updates to clear bits in the store. Updates must be
+//      performed in LSb to MSb order of the update buffer.
+//
+// SizeStore()      - An optional function for non-runtime stores that can be
+//      dynamically sized.  The FW will only ever increase or decrease the store
+//      by 1 banksize at a time, and it is always adding or removing a bank from 
+//      the end of the store.
+//
+// By default the FW will update variables and storage banks in an
+// "atomic" manner by keeping 1 old copy of the data during an update,
+// and recovering appropiately if the power is lost during the middle
+// of an operation.  To do this the FW needs to have multiple banks
+// of storage dedicated to its use. If that's not possible, the driver 
+// can implement an atomic bank update function and the FW will allow 
+// 1 bank in this case.  (It will allow any number of banks,
+// but it won't require an "extra" bank to provide its bank transaction 
+// function).
+//
+// TransactionUpdate()  - An optional function that can clear & update an 
+//      entire bank in an "atomic" fashion.  If the operation fails in the 
+//      middle the driver is responsible for having either the previous copy 
+//      of the bank's data or the new copy.  A copy that's partially written
+//      is not valid as internal data settings may get lost.  Supply this
+//      function only when needed.
+//
+
diff --git a/linux-x86_64/gnu-efi/include/efi/protocol/intload.h b/linux-x86_64/gnu-efi/include/efi/protocol/intload.h
new file mode 100644
index 0000000..fb24e3f
--- /dev/null
+++ b/linux-x86_64/gnu-efi/include/efi/protocol/intload.h
@@ -0,0 +1,27 @@
+/*++
+
+Copyright (c) 1999 Intel Corporation
+
+Module Name:
+
+    intload
+
+Abstract:
+
+    EFI support for loading internally linked in apps
+
+
+
+Revision History
+
+--*/
+
+#ifndef _INTERNAL_LOAD_INCLUDE_
+#define _INTERNAL_LOAD_INCLUDE_
+
+// {D65A6B8C-71E5-4df0-A909-F0D2992B5AA9}
+#define INTERNAL_SHELL_GUID \
+    { 0xd65a6b8c, 0x71e5, 0x4df0, {0xa9, 0x09, 0xf0, 0xd2, 0x99, 0x2b, 0x5a, 0xa9} }
+
+
+#endif
diff --git a/linux-x86_64/gnu-efi/include/efi/protocol/legacyboot.h b/linux-x86_64/gnu-efi/include/efi/protocol/legacyboot.h
new file mode 100644
index 0000000..16e94e7
--- /dev/null
+++ b/linux-x86_64/gnu-efi/include/efi/protocol/legacyboot.h
@@ -0,0 +1,119 @@
+/*++
+
+Copyright (c) 1999 Intel Corporation
+
+Module Name:
+
+    legacyboot
+
+Abstract:
+
+    EFI support for legacy boot
+
+
+
+Revision History
+
+--*/
+
+#ifndef _LEGACY_BOOT_INCLUDE_
+#define _LEGACY_BOOT_INCLUDE_
+
+#define LEGACY_BOOT_PROTOCOL \
+    { 0x376e5eb2, 0x30e4, 0x11d3, { 0xba, 0xe5, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81 } }
+
+#pragma pack(1)
+
+//
+// BBS 1.01 (See Appendix A) IPL and BCV Table Entry Data structure.
+//  Seg:Off pointers have been converted to EFI pointers in this data structure
+//  This is the structure that also maps to the EFI device path for the boot selection
+//
+typedef struct {
+    UINT16  DeviceType;
+    UINT16  StatusFlag;
+    UINT32  Reserved;
+    VOID    *BootHandler;   // Not an EFI entry point
+    CHAR8   *DescString;
+} BBS_TABLE_ENTRY;
+#pragma pack()
+
+typedef
+EFI_STATUS
+(EFIAPI *LEGACY_BOOT_CALL) (
+    IN EFI_DEVICE_PATH      *DevicePath
+    );
+
+
+//
+// BBS support functions
+//  PnP Call numbers and BiosSelector hidden in implementation
+//
+
+typedef enum {
+    IplRelative,
+    BcvRelative
+} BBS_TYPE;
+
+INTERFACE_DECL(_LEGACY_BOOT_INTERFACE);
+
+//
+// == PnP Function 0x60 then BbsVersion == 0x0101 if this call fails then BbsVersion == 0x0000
+//
+
+//
+// == PnP Function 0x61
+//
+typedef
+EFI_STATUS
+(EFIAPI *GET_DEVICE_COUNT) (
+    IN  struct _LEGACY_BOOT_INTERFACE   *This,
+    IN  BBS_TYPE        *TableType,
+    OUT UINTN           *DeviceCount,
+    OUT UINTN           *MaxCount
+    );
+
+//
+// == PnP Function 0x62
+//
+typedef
+EFI_STATUS
+(EFIAPI *GET_PRIORITY_AND_TABLE) (
+    IN  struct _LEGACY_BOOT_INTERFACE   *This,
+    IN  BBS_TYPE        *TableType,
+    IN OUT  UINTN       *PrioritySize, // MaxCount * sizeof(UINT8)
+    OUT     UINTN       *Priority,
+    IN OUT  UINTN       *TableSize,    // MaxCount * sizeof(BBS_TABLE_ENTRY)
+    OUT BBS_TABLE_ENTRY *TableEntrySize
+    );
+
+//
+// == PnP Function 0x63
+//
+typedef
+EFI_STATUS
+(EFIAPI *SET_PRIORITY) (
+    IN  struct _LEGACY_BOOT_INTERFACE   *This,
+    IN  BBS_TYPE        *TableType,
+    IN OUT  UINTN       *PrioritySize,
+    OUT     UINTN       *Priority
+    );
+
+typedef struct _LEGACY_BOOT_INTERFACE {
+    LEGACY_BOOT_CALL    BootIt;
+
+    //
+    // New functions to allow BBS booting to be configured from EFI
+    //
+    UINTN                   BbsVersion;     // Currently 0x0101
+    GET_DEVICE_COUNT        GetDeviceCount;
+    GET_PRIORITY_AND_TABLE  GetPriorityAndTable;
+    SET_PRIORITY            SetPriority;   
+} LEGACY_BOOT_INTERFACE;
+
+EFI_STATUS
+PlInitializeLegacyBoot (
+    VOID
+    );
+
+#endif
diff --git a/linux-x86_64/gnu-efi/include/efi/protocol/piflash64.h b/linux-x86_64/gnu-efi/include/efi/protocol/piflash64.h
new file mode 100644
index 0000000..d521dfc
--- /dev/null
+++ b/linux-x86_64/gnu-efi/include/efi/protocol/piflash64.h
@@ -0,0 +1,121 @@
+#ifndef _PIFLASH64_H
+#define _PIFLASH64_H
+
+/*++
+
+Copyright (c) 1999  Intel Corporation
+
+Module Name:
+
+    PIflash64.h
+    
+Abstract:
+
+    Iflash64.efi protocol to abstract iflash from
+    the system.
+
+Revision History
+
+--*/
+
+//
+// Guid that identifies the IFLASH protocol
+//
+#define IFLASH64_PROTOCOL_PROTOCOL \
+    { 0x65cba110, 0x74ab, 0x11d3, 0xbb, 0x89, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81 };
+
+//
+// Unlock FLASH from StartAddress to EndAddress and return a LockKey
+//
+typedef
+EFI_STATUS
+(EFIAPI *UNLOCK_FLASH_API)(
+    IN struct _IFLASH64_PROTOCOL_INTERFACE  *This
+    );
+
+//
+// Lock the flash represented by the LockKey
+//
+typedef
+EFI_STATUS
+(EFIAPI *LOCK_FLASH_API)(
+    IN struct _IFLASH64_PROTOCOL_INTERFACE  *This
+    );
+
+//
+// Status callback for a utility like IFLASH64
+//
+//  Token would map to a list like Ted proposed. The utility has no idea what 
+//      happens on the other side.
+//  ErrorStatus - Level of Error or success. Independent of Token. If you 
+//      don't know the token you will at least know pass or fail.
+//  String - Optional extra information about the error. Could be used for 
+//      debug or future expansion
+//
+//  Attributes - Options screen attributes for String. Could allow the string to be different colors.
+//
+typedef
+EFI_STATUS
+(EFIAPI *UTILITY_PROGRESS_API)(
+    IN struct _IFLASH64_PROTOCOL_INTERFACE  *This,
+    IN  UINTN                               Token,
+    IN  EFI_STATUS                          ErrorStatus, 
+    IN  CHAR16                              *String,    OPTIONAL
+    IN  UINTN                               *Attributes OPTIONAL
+    );
+
+//
+// Token Values
+//
+// IFlash64 Token Codes
+#define IFLASH_TOKEN_IFLASHSTART    0xB0                // IFlash64 has started
+#define IFLASH_TOKEN_READINGFILE    0xB1                // Reading File
+#define IFLASH_TOKEN_INITVPP        0xB2                // Initializing Vpp
+#define IFLASH_TOKEN_DISABLEVPP     0x10                // Disable Vpp
+#define IFLASH_TOKEN_FLASHUNLOCK    0xB3                // Unlocking FLASH Devices
+#define IFLASH_TOKEN_FLASHERASE     0xB4                // Erasing FLASH Devices
+#define IFLASH_TOKEN_FLASHPROGRAM   0xB5                // Programming FLASH
+#define IFLASH_TOKEN_FLASHVERIFY    0xB6                // Verifying FLASH
+#define IFLASH_TOKEN_UPDATESUCCES   0xB7                // FLASH Updage Success!
+
+#define IFLASH_TOKEN_PROGRESS_READINGFILE   0x11        // % Reading File
+#define IFLASH_TOKEN_PROGRESS_FLASHUNLOCK   0x13        // % Unlocking FLASH Devices
+#define IFLASH_TOKEN_PROGRESS_FLASHERASE    0x14        // % Erasing FLASH Devices
+#define IFLASH_TOKEN_PROGRESS_FLASHPROGRAM  0x15        // % Programming FLASH
+#define IFLASH_TOKEN_PROGRESS_FLASHVERIFY   0x16        // % Verifying FLASH
+
+#define IFLASH_TOKEN_READINGFILE_ER 0xB8                // File Read Error
+#define IFLASH_TOKEN_INITVPP_ER     0xB9                // Initialization of IFB Error
+#define IFLASH_TOKEN_FLASHUNLOCK_ER 0xBA                // FLASH Unlock Error
+#define IFLASH_TOKEN_FLASHERASE_ER  0xBB                // FLASH Erase Error
+#define IFLASH_TOKEN_FLASHVERIFY_ER 0xBC                // FLASH Verify Error
+#define IFLASH_TOKEN_FLASHPROG_ER   0xBD                // FLASH Program Error
+
+#define IFLASH_TABLE_END            0x00
+
+//
+// If this number changes one of the existing API's has changes
+//
+#define IFLASH_PI_MAJOR_VERSION 0x01
+
+//
+// This number changes when new APIs or data variables get added to the end
+//  of the data structure
+//
+#define IFLASH_PI_MINOR_VERSION 0x01
+
+typedef struct _IFLASH64_PROTOCOL_INTERFACE {
+    UINT32                  MajorVersion;       
+    UINT32                  MinorVersion;   
+    UNLOCK_FLASH_API        UnlockFlash;
+    LOCK_FLASH_API          LockFlash;
+    UTILITY_PROGRESS_API    Progress;
+    
+    //
+    // Future expansion goes here
+    //
+
+} IFLASH64_PROTOCOL_INTERFACE;
+
+
+#endif
diff --git a/linux-x86_64/gnu-efi/include/efi/protocol/vgaclass.h b/linux-x86_64/gnu-efi/include/efi/protocol/vgaclass.h
new file mode 100644
index 0000000..d0deb5c
--- /dev/null
+++ b/linux-x86_64/gnu-efi/include/efi/protocol/vgaclass.h
@@ -0,0 +1,95 @@
+#ifndef _VGA_CLASS_H
+#define _VGA_CLASS_H
+
+/*++
+
+Copyright (c) 1999  Intel Corporation
+
+Module Name:
+
+    VgaClass.h
+    
+Abstract:
+
+    Vga Mini port binding to Vga Class protocol
+
+
+
+Revision History
+
+--*/
+
+//
+// VGA Device Structure
+//
+
+// {0E3D6310-6FE4-11d3-BB81-0080C73C8881}
+#define VGA_CLASS_DRIVER_PROTOCOL \
+    { 0xe3d6310, 0x6fe4, 0x11d3, {0xbb, 0x81, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81} }
+
+typedef 
+EFI_STATUS 
+(* INIT_VGA_CARD) (
+    IN  UINTN   VgaMode,
+    IN  VOID    *Context
+    );
+
+typedef struct {
+    UINTN   MaxColumns;
+    UINTN   MaxRows;
+} MAX_CONSOLE_GEOMETRY;
+
+#define VGA_CON_OUT_DEV_SIGNATURE   EFI_SIGNATURE_32('c','v','g','a')
+typedef struct {
+    UINTN                           Signature;
+
+    EFI_HANDLE                      Handle;
+    SIMPLE_TEXT_OUTPUT_INTERFACE    ConOut;
+    SIMPLE_TEXT_OUTPUT_MODE         ConOutMode;
+    EFI_DEVICE_PATH                 *DevicePath;
+
+    UINT8                           *Buffer;
+    EFI_DEVICE_IO_INTERFACE         *DeviceIo;
+
+    //
+    // Video Card Context
+    //
+    INIT_VGA_CARD                   InitVgaCard;
+    VOID                            *VgaCardContext;
+    MAX_CONSOLE_GEOMETRY            *Geometry;
+    //
+    // Video buffer normally 0xb8000
+    //
+    UINT64                          VideoBuffer;
+
+    //
+    // Clear Screen & Default Attribute
+    //
+    UINT32                          Attribute;
+
+    //
+    // -1 means search for active VGA device
+    //
+    EFI_PCI_ADDRESS_UNION           Pci;
+} VGA_CON_OUT_DEV;
+
+#define VGA_CON_OUT_DEV_FROM_THIS(a) CR(a, VGA_CON_OUT_DEV, ConOut, VGA_CON_OUT_DEV_SIGNATURE)
+
+//
+// Vga Class Driver Protocol. 
+// GUID defined in EFI Lib
+//
+
+typedef 
+EFI_STATUS
+(EFIAPI *INSTALL_VGA_DRIVER) (
+    IN  VGA_CON_OUT_DEV    *ConOutDev 
+    );
+
+typedef struct {
+    UINT32               Version;
+    INSTALL_VGA_DRIVER   InstallGenericVgaDriver;
+} INSTALL_VGA_DRIVER_INTERFACE;
+
+#endif
+
diff --git a/linux-x86_64/gnu-efi/include/efi/romload.h b/linux-x86_64/gnu-efi/include/efi/romload.h
new file mode 100644
index 0000000..0506011
--- /dev/null
+++ b/linux-x86_64/gnu-efi/include/efi/romload.h
@@ -0,0 +1,41 @@
+#ifndef _EFI_ROMLOAD_H
+#define _EFI_ROMLOAD_H
+
+#define ROM_SIGNATURE 0xaa55
+#define PCIDS_SIGNATURE "PCIR"
+#pragma pack(push)
+#pragma pack(1)
+typedef struct 
+{
+    UINT8    Pcids_Sig[4];
+    UINT16  VendId;
+    UINT16  DevId;
+    UINT16  Vpd_Off;
+    UINT16  Size;
+    UINT8 Rev;
+    UINT8 Class_Code[3];
+    UINT16  Image_Len;
+    UINT16  Rev_Lvl;
+    UINT8 Code_Type;
+    UINT8 Indi;
+    UINT16  Rsvd;
+}PciDataStructure;
+typedef struct
+{
+    UINT16 Size;
+    UINT32 Header_Sig;
+    UINT16 SubSystem;
+    UINT16 MachineType;
+    UINT8  Resvd[10];
+    UINT16 EfiOffset;
+}ArchData;
+typedef struct 
+{
+    UINT16 Rom_Sig;
+    ArchData Arch_Data;
+    UINT16 Pcids_Off;
+    UINT8 resvd[38];
+}RomHeader;
+#pragma pack(pop)
+
+#endif
diff --git a/linux-x86_64/gnu-efi/include/efi/x86_64/efibind.h b/linux-x86_64/gnu-efi/include/efi/x86_64/efibind.h
new file mode 100644
index 0000000..b940943
--- /dev/null
+++ b/linux-x86_64/gnu-efi/include/efi/x86_64/efibind.h
@@ -0,0 +1,285 @@
+/*++
+
+Copyright (c) 1998  Intel Corporation
+
+Module Name:
+
+    efefind.h
+
+Abstract:
+
+    EFI to compile bindings
+
+
+
+
+Revision History
+
+--*/
+#ifndef X86_64_EFI_BIND
+#define X86_64_EFI_BIND
+#ifndef __GNUC__
+#pragma pack()
+#endif
+
+//
+// Basic int types of various widths
+//
+
+#if !defined(__STDC_VERSION__) || (__STDC_VERSION__ < 199901L )
+
+    // No ANSI C 1999/2000 stdint.h integer width declarations 
+
+    #if defined(_MSC_EXTENSIONS)
+
+        // Use Microsoft C compiler integer width declarations 
+
+        typedef unsigned __int64    uint64_t;
+        typedef __int64             int64_t;
+        typedef unsigned __int32    uint32_t;
+        typedef __int32             int32_t;
+        typedef unsigned short      uint16_t;
+        typedef short               int16_t;
+        typedef unsigned char       uint8_t;
+        typedef char                int8_t;
+    #elif defined(__GNUC__)
+        typedef unsigned long long  uint64_t __attribute__((aligned (8)));
+        typedef long long           int64_t __attribute__((aligned (8)));
+        typedef unsigned int        uint32_t;
+        typedef int                 int32_t;
+        typedef unsigned short      uint16_t;
+        typedef short               int16_t;
+        typedef unsigned char       uint8_t;
+        typedef char                int8_t;
+    #elif defined(UNIX_LP64)
+
+        /*  Use LP64 programming model from C_FLAGS for integer width declarations */
+
+       typedef unsigned long       uint64_t;
+       typedef long                int64_t;
+       typedef unsigned int        uint32_t;
+       typedef int                 int32_t;
+       typedef unsigned short      uint16_t;
+       typedef short               int16_t;
+       typedef unsigned char       uint8_t;
+       typedef char                int8_t;
+    #else
+
+       /*  Assume P64 programming model from C_FLAGS for integer width declarations */
+
+       typedef unsigned long long  uint64_t __attribute__((aligned (8)));
+       typedef long long           int64_t __attribute__((aligned (8)));
+       typedef unsigned int        uint32_t;
+       typedef int                 int32_t;
+       typedef unsigned short      uint16_t;
+       typedef short               int16_t;
+       typedef unsigned char       uint8_t;
+       typedef char                int8_t;
+    #endif
+#endif
+
+//
+// Basic EFI types of various widths
+//
+
+#ifndef __WCHAR_TYPE__
+# define __WCHAR_TYPE__ short
+#endif
+
+typedef uint64_t   UINT64;
+typedef int64_t    INT64;
+
+#ifndef _BASETSD_H_
+    typedef uint32_t   UINT32;
+    typedef int32_t    INT32;
+#endif
+
+typedef uint16_t   UINT16;
+typedef int16_t    INT16;
+typedef uint8_t    UINT8;
+typedef int8_t     INT8;
+typedef __WCHAR_TYPE__ WCHAR;
+
+#undef VOID
+#define VOID    void
+
+
+typedef int64_t    INTN;
+typedef uint64_t   UINTN;
+
+#ifdef EFI_NT_EMULATOR
+    #define POST_CODE(_Data)
+#else    
+    #ifdef EFI_DEBUG
+#define POST_CODE(_Data)    __asm mov eax,(_Data) __asm out 0x80,al
+    #else
+        #define POST_CODE(_Data)
+    #endif  
+#endif
+
+#define EFIERR(a)           (0x8000000000000000 | a)
+#define EFI_ERROR_MASK      0x8000000000000000
+#define EFIERR_OEM(a)       (0xc000000000000000 | a)      
+
+
+#define BAD_POINTER         0xFBFBFBFBFBFBFBFB
+#define MAX_ADDRESS         0xFFFFFFFFFFFFFFFF
+
+#ifdef EFI_NT_EMULATOR
+    #define BREAKPOINT()        __asm { int 3 }
+#else
+    #define BREAKPOINT()        while (TRUE);    // Make it hang on Bios[Dbg]32
+#endif
+
+//
+// Pointers must be aligned to these address to function
+//
+
+#define MIN_ALIGNMENT_SIZE  4
+
+#define ALIGN_VARIABLE(Value ,Adjustment) \
+            (UINTN)Adjustment = 0; \
+            if((UINTN)Value % MIN_ALIGNMENT_SIZE) \
+                (UINTN)Adjustment = MIN_ALIGNMENT_SIZE - ((UINTN)Value % MIN_ALIGNMENT_SIZE); \
+            Value = (UINTN)Value + (UINTN)Adjustment
+
+
+//
+// Define macros to build data structure signatures from characters.
+//
+
+#define EFI_SIGNATURE_16(A,B)             ((A) | (B<<8))
+#define EFI_SIGNATURE_32(A,B,C,D)         (EFI_SIGNATURE_16(A,B)     | (EFI_SIGNATURE_16(C,D)     << 16))
+#define EFI_SIGNATURE_64(A,B,C,D,E,F,G,H) (EFI_SIGNATURE_32(A,B,C,D) | ((UINT64)(EFI_SIGNATURE_32(E,F,G,H)) << 32))
+//
+// To export & import functions in the EFI emulator environment
+//
+
+#ifdef EFI_NT_EMULATOR
+    #define EXPORTAPI           __declspec( dllexport )
+#else
+    #define EXPORTAPI
+#endif
+
+
+//
+// EFIAPI - prototype calling convention for EFI function pointers
+// BOOTSERVICE - prototype for implementation of a boot service interface
+// RUNTIMESERVICE - prototype for implementation of a runtime service interface
+// RUNTIMEFUNCTION - prototype for implementation of a runtime function that is not a service
+// RUNTIME_CODE - pragma macro for declaring runtime code    
+//
+
+#ifndef EFIAPI                  // Forces EFI calling conventions reguardless of compiler options 
+    #ifdef _MSC_EXTENSIONS
+        #define EFIAPI __cdecl  // Force C calling convention for Microsoft C compiler 
+    #else
+        #define EFIAPI          // Substitute expresion to force C calling convention 
+    #endif
+#endif
+
+#define BOOTSERVICE
+//#define RUNTIMESERVICE(proto,a)    alloc_text("rtcode",a); proto a
+//#define RUNTIMEFUNCTION(proto,a)   alloc_text("rtcode",a); proto a
+#define RUNTIMESERVICE
+#define RUNTIMEFUNCTION
+
+
+#define RUNTIME_CODE(a)         alloc_text("rtcode", a)
+#define BEGIN_RUNTIME_DATA()    data_seg("rtdata")
+#define END_RUNTIME_DATA()      data_seg("")
+
+#define VOLATILE    volatile
+
+#define MEMORY_FENCE()    
+
+#ifdef EFI_NT_EMULATOR
+
+//
+// To help ensure proper coding of integrated drivers, they are
+// compiled as DLLs.  In NT they require a dll init entry pointer.
+// The macro puts a stub entry point into the DLL so it will load.
+//
+
+#define EFI_DRIVER_ENTRY_POINT(InitFunction)    \
+    UINTN                                       \
+    __stdcall                                   \
+    _DllMainCRTStartup (                        \
+        UINTN    Inst,                          \
+        UINTN    reason_for_call,               \
+        VOID    *rserved                        \
+        )                                       \
+    {                                           \
+        return 1;                               \
+    }                                           \
+                                                \
+    int                                         \
+    EXPORTAPI                                   \
+    __cdecl                                     \
+    InitializeDriver (                          \
+        void *ImageHandle,                      \
+        void *SystemTable                       \
+        )                                       \
+    {                                           \
+        return InitFunction(ImageHandle, SystemTable);       \
+    }
+
+
+    #define LOAD_INTERNAL_DRIVER(_if, type, name, entry)      \
+        (_if)->LoadInternal(type, name, NULL)             
+
+#else // EFI_NT_EMULATOR 
+
+//
+// When build similiar to FW, then link everything together as
+// one big module.
+//
+
+    #define EFI_DRIVER_ENTRY_POINT(InitFunction)    \
+        UINTN                                       \
+        InitializeDriver (                          \
+            VOID    *ImageHandle,                   \
+            VOID    *SystemTable                    \
+            )                                       \
+        {                                           \
+            return InitFunction(ImageHandle,        \
+                    SystemTable);                   \
+        }                                           \
+                                                    \
+        EFI_STATUS efi_main(                        \
+            EFI_HANDLE image,                       \
+            EFI_SYSTEM_TABLE *systab                \
+            ) __attribute__((weak,                  \
+                    alias ("InitializeDriver")));
+
+    #define LOAD_INTERNAL_DRIVER(_if, type, name, entry)    \
+            (_if)->LoadInternal(type, name, entry)
+
+#endif // EFI_FW_NT 
+
+//
+// Some compilers don't support the forward reference construct:
+//  typedef struct XXXXX
+//
+// The following macro provide a workaround for such cases.
+//
+#ifdef NO_INTERFACE_DECL
+#define INTERFACE_DECL(x)
+#else
+#ifdef __GNUC__
+#define INTERFACE_DECL(x) struct x
+#else
+#define INTERFACE_DECL(x) typedef struct x
+#endif
+#endif
+
+/* for x86_64, EFI_FUNCTION_WRAPPER must be defined */
+UINTN uefi_call_wrapper(void *func, unsigned long va_num, ...);
+#define EFI_FUNCTION __attribute__((ms_abi))
+
+#ifdef _MSC_EXTENSIONS
+#pragma warning ( disable : 4731 )  // Suppress warnings about modification of EBP
+#endif
+
+#endif
+
diff --git a/linux-x86_64/gnu-efi/include/efi/x86_64/efilibplat.h b/linux-x86_64/gnu-efi/include/efi/x86_64/efilibplat.h
new file mode 100644
index 0000000..3844578
--- /dev/null
+++ b/linux-x86_64/gnu-efi/include/efi/x86_64/efilibplat.h
@@ -0,0 +1,26 @@
+/*++
+
+Copyright (c) 1998  Intel Corporation
+
+Module Name:
+
+    efilibplat.h
+
+Abstract:
+
+    EFI to compile bindings
+
+
+
+
+Revision History
+
+--*/
+
+VOID
+InitializeLibPlatform (
+    IN EFI_HANDLE           ImageHandle,
+    IN EFI_SYSTEM_TABLE     *SystemTable
+    );
+
+   
diff --git a/linux-x86_64/gnu-efi/include/efi/x86_64/pe.h b/linux-x86_64/gnu-efi/include/efi/x86_64/pe.h
new file mode 100644
index 0000000..16e40ef
--- /dev/null
+++ b/linux-x86_64/gnu-efi/include/efi/x86_64/pe.h
@@ -0,0 +1,591 @@
+/* 
+    PE32+ header file
+ */
+#ifndef _PE_H
+#define _PE_H
+
+#define IMAGE_DOS_SIGNATURE                 0x5A4D      // MZ
+#define IMAGE_OS2_SIGNATURE                 0x454E      // NE
+#define IMAGE_OS2_SIGNATURE_LE              0x454C      // LE
+#define IMAGE_NT_SIGNATURE                  0x00004550  // PE00  
+#define IMAGE_EDOS_SIGNATURE                0x44454550  // PEED
+
+
+typedef struct _IMAGE_DOS_HEADER {      // DOS .EXE header
+    UINT16   e_magic;                     // Magic number
+    UINT16   e_cblp;                      // Bytes on last page of file
+    UINT16   e_cp;                        // Pages in file
+    UINT16   e_crlc;                      // Relocations
+    UINT16   e_cparhdr;                   // Size of header in paragraphs
+    UINT16   e_minalloc;                  // Minimum extra paragraphs needed
+    UINT16   e_maxalloc;                  // Maximum extra paragraphs needed
+    UINT16   e_ss;                        // Initial (relative) SS value
+    UINT16   e_sp;                        // Initial SP value
+    UINT16   e_csum;                      // Checksum
+    UINT16   e_ip;                        // Initial IP value
+    UINT16   e_cs;                        // Initial (relative) CS value
+    UINT16   e_lfarlc;                    // File address of relocation table
+    UINT16   e_ovno;                      // Overlay number
+    UINT16   e_res[4];                    // Reserved words
+    UINT16   e_oemid;                     // OEM identifier (for e_oeminfo)
+    UINT16   e_oeminfo;                   // OEM information; e_oemid specific
+    UINT16   e_res2[10];                  // Reserved words
+    UINT32   e_lfanew;                    // File address of new exe header
+  } IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;
+
+typedef struct _IMAGE_OS2_HEADER {      // OS/2 .EXE header
+    UINT16   ne_magic;                    // Magic number
+    UINT8    ne_ver;                      // Version number
+    UINT8    ne_rev;                      // Revision number
+    UINT16   ne_enttab;                   // Offset of Entry Table
+    UINT16   ne_cbenttab;                 // Number of bytes in Entry Table
+    UINT32   ne_crc;                      // Checksum of whole file
+    UINT16   ne_flags;                    // Flag UINT16
+    UINT16   ne_autodata;                 // Automatic data segment number
+    UINT16   ne_heap;                     // Initial heap allocation
+    UINT16   ne_stack;                    // Initial stack allocation
+    UINT32   ne_csip;                     // Initial CS:IP setting
+    UINT32   ne_sssp;                     // Initial SS:SP setting
+    UINT16   ne_cseg;                     // Count of file segments
+    UINT16   ne_cmod;                     // Entries in Module Reference Table
+    UINT16   ne_cbnrestab;                // Size of non-resident name table
+    UINT16   ne_segtab;                   // Offset of Segment Table
+    UINT16   ne_rsrctab;                  // Offset of Resource Table
+    UINT16   ne_restab;                   // Offset of resident name table
+    UINT16   ne_modtab;                   // Offset of Module Reference Table
+    UINT16   ne_imptab;                   // Offset of Imported Names Table
+    UINT32   ne_nrestab;                  // Offset of Non-resident Names Table
+    UINT16   ne_cmovent;                  // Count of movable entries
+    UINT16   ne_align;                    // Segment alignment shift count
+    UINT16   ne_cres;                     // Count of resource segments
+    UINT8    ne_exetyp;                   // Target Operating system
+    UINT8    ne_flagsothers;              // Other .EXE flags
+    UINT16   ne_pretthunks;               // offset to return thunks
+    UINT16   ne_psegrefbytes;             // offset to segment ref. bytes
+    UINT16   ne_swaparea;                 // Minimum code swap area size
+    UINT16   ne_expver;                   // Expected Windows version number
+  } IMAGE_OS2_HEADER, *PIMAGE_OS2_HEADER;
+
+//
+// File header format.
+//
+
+typedef struct _IMAGE_FILE_HEADER {
+    UINT16   Machine;
+    UINT16   NumberOfSections;
+    UINT32   TimeDateStamp;
+    UINT32   PointerToSymbolTable;
+    UINT32   NumberOfSymbols;
+    UINT16   SizeOfOptionalHeader;
+    UINT16   Characteristics;
+} IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;
+
+#define IMAGE_SIZEOF_FILE_HEADER             20
+
+#define IMAGE_FILE_RELOCS_STRIPPED           0x0001  // Relocation info stripped from file.
+#define IMAGE_FILE_EXECUTABLE_IMAGE          0x0002  // File is executable  (i.e. no unresolved externel references).
+#define IMAGE_FILE_LINE_NUMS_STRIPPED        0x0004  // Line nunbers stripped from file.
+#define IMAGE_FILE_LOCAL_SYMS_STRIPPED       0x0008  // Local symbols stripped from file.
+#define IMAGE_FILE_BYTES_REVERSED_LO         0x0080  // Bytes of machine word are reversed.
+#define IMAGE_FILE_32BIT_MACHINE             0x0100  // 32 bit word machine.
+#define IMAGE_FILE_DEBUG_STRIPPED            0x0200  // Debugging info stripped from file in .DBG file
+#define IMAGE_FILE_SYSTEM                    0x1000  // System File.
+#define IMAGE_FILE_DLL                       0x2000  // File is a DLL.
+#define IMAGE_FILE_BYTES_REVERSED_HI         0x8000  // Bytes of machine word are reversed.
+
+#define IMAGE_FILE_MACHINE_UNKNOWN           0
+#define IMAGE_FILE_MACHINE_I386              0x14c   // Intel 386.
+#define IMAGE_FILE_MACHINE_R3000             0x162   // MIPS little-endian, 0540 big-endian
+#define IMAGE_FILE_MACHINE_R4000             0x166   // MIPS little-endian
+#define IMAGE_FILE_MACHINE_ALPHA             0x184   // Alpha_AXP
+#define IMAGE_FILE_MACHINE_POWERPC           0x1F0   // IBM PowerPC Little-Endian
+#define IMAGE_FILE_MACHINE_TAHOE             0x7cc   // Intel EM machine
+//
+// Directory format.
+//
+
+typedef struct _IMAGE_DATA_DIRECTORY {
+    UINT32   VirtualAddress;
+    UINT32   Size;
+} IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;
+
+#define IMAGE_NUMBEROF_DIRECTORY_ENTRIES    16
+
+//
+// Optional header format.
+//
+
+typedef struct _IMAGE_OPTIONAL_HEADER {
+    //
+    // Standard fields.
+    //
+
+    UINT16    Magic;
+    UINT8     MajorLinkerVersion;
+    UINT8     MinorLinkerVersion;
+    UINT32    SizeOfCode;
+    UINT32    SizeOfInitializedData;
+    UINT32    SizeOfUninitializedData;
+    UINT32    AddressOfEntryPoint;
+    UINT32    BaseOfCode;
+    UINT32    BaseOfData;
+                
+    //
+    // NT additional fields.
+    //
+
+    UINT32   ImageBase;
+    UINT32   SectionAlignment;
+    UINT32   FileAlignment;
+    UINT16   MajorOperatingSystemVersion;
+    UINT16   MinorOperatingSystemVersion;
+    UINT16   MajorImageVersion;
+    UINT16   MinorImageVersion;
+    UINT16   MajorSubsystemVersion;
+    UINT16   MinorSubsystemVersion;
+    UINT32   Reserved1;
+    UINT32   SizeOfImage;
+    UINT32   SizeOfHeaders;
+    UINT32   CheckSum;
+    UINT16   Subsystem;
+    UINT16   DllCharacteristics;
+    UINT32   SizeOfStackReserve;
+    UINT32   SizeOfStackCommit;
+    UINT32   SizeOfHeapReserve;
+    UINT32   SizeOfHeapCommit;
+    UINT32   LoaderFlags;
+    UINT32   NumberOfRvaAndSizes;
+    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
+} IMAGE_OPTIONAL_HEADER, *PIMAGE_OPTIONAL_HEADER;
+
+typedef struct _IMAGE_ROM_OPTIONAL_HEADER {
+    UINT16  Magic;
+    UINT8   MajorLinkerVersion;
+    UINT8   MinorLinkerVersion;
+    UINT32  SizeOfCode;
+    UINT32  SizeOfInitializedData;
+    UINT32  SizeOfUninitializedData;
+    UINT32  AddressOfEntryPoint;
+    UINT32  BaseOfCode;
+    UINT32  BaseOfData;
+    UINT32  BaseOfBss;
+    UINT32  GprMask;
+    UINT32  CprMask[4];
+    UINT32  GpValue;
+} IMAGE_ROM_OPTIONAL_HEADER, *PIMAGE_ROM_OPTIONAL_HEADER;
+
+#define IMAGE_SIZEOF_ROM_OPTIONAL_HEADER      56
+#define IMAGE_SIZEOF_STD_OPTIONAL_HEADER      28
+#define IMAGE_SIZEOF_NT_OPTIONAL_HEADER      224
+
+#define IMAGE_NT_OPTIONAL_HDR_MAGIC        0x10b
+#define IMAGE_ROM_OPTIONAL_HDR_MAGIC       0x107
+
+typedef struct _IMAGE_NT_HEADERS {
+    UINT32 Signature;
+    IMAGE_FILE_HEADER FileHeader;
+    IMAGE_OPTIONAL_HEADER OptionalHeader;
+} IMAGE_NT_HEADERS, *PIMAGE_NT_HEADERS;
+
+typedef struct _IMAGE_ROM_HEADERS {
+    IMAGE_FILE_HEADER FileHeader;
+    IMAGE_ROM_OPTIONAL_HEADER OptionalHeader;
+} IMAGE_ROM_HEADERS, *PIMAGE_ROM_HEADERS;
+
+#define IMAGE_FIRST_SECTION( ntheader ) ((PIMAGE_SECTION_HEADER)        \
+    ((UINT32)ntheader +                                                  \
+     FIELD_OFFSET( IMAGE_NT_HEADERS, OptionalHeader ) +                 \
+     ((PIMAGE_NT_HEADERS)(ntheader))->FileHeader.SizeOfOptionalHeader   \
+    ))
+
+
+// Subsystem Values
+
+#define IMAGE_SUBSYSTEM_UNKNOWN              0   // Unknown subsystem.
+#define IMAGE_SUBSYSTEM_NATIVE               1   // Image doesn't require a subsystem.
+#define IMAGE_SUBSYSTEM_WINDOWS_GUI          2   // Image runs in the Windows GUI subsystem.
+#define IMAGE_SUBSYSTEM_WINDOWS_CUI          3   // Image runs in the Windows character subsystem.
+#define IMAGE_SUBSYSTEM_OS2_CUI              5   // image runs in the OS/2 character subsystem.
+#define IMAGE_SUBSYSTEM_POSIX_CUI            7   // image run  in the Posix character subsystem.
+
+
+// Directory Entries
+
+#define IMAGE_DIRECTORY_ENTRY_EXPORT         0   // Export Directory
+#define IMAGE_DIRECTORY_ENTRY_IMPORT         1   // Import Directory
+#define IMAGE_DIRECTORY_ENTRY_RESOURCE       2   // Resource Directory
+#define IMAGE_DIRECTORY_ENTRY_EXCEPTION      3   // Exception Directory
+#define IMAGE_DIRECTORY_ENTRY_SECURITY       4   // Security Directory
+#define IMAGE_DIRECTORY_ENTRY_BASERELOC      5   // Base Relocation Table
+#define IMAGE_DIRECTORY_ENTRY_DEBUG          6   // Debug Directory
+#define IMAGE_DIRECTORY_ENTRY_COPYRIGHT      7   // Description String
+#define IMAGE_DIRECTORY_ENTRY_GLOBALPTR      8   // Machine Value (MIPS GP)
+#define IMAGE_DIRECTORY_ENTRY_TLS            9   // TLS Directory
+#define IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG   10   // Load Configuration Directory
+
+//
+// Section header format.
+//
+
+#define IMAGE_SIZEOF_SHORT_NAME              8
+
+typedef struct _IMAGE_SECTION_HEADER {
+    UINT8   Name[IMAGE_SIZEOF_SHORT_NAME];
+    union {
+            UINT32   PhysicalAddress;
+            UINT32   VirtualSize;
+    } Misc;
+    UINT32   VirtualAddress;
+    UINT32   SizeOfRawData;
+    UINT32   PointerToRawData;
+    UINT32   PointerToRelocations;
+    UINT32   PointerToLinenumbers;
+    UINT16   NumberOfRelocations;
+    UINT16   NumberOfLinenumbers;
+    UINT32   Characteristics;
+} IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;
+
+#define IMAGE_SIZEOF_SECTION_HEADER          40
+
+#define IMAGE_SCN_TYPE_NO_PAD                0x00000008  // Reserved.
+
+#define IMAGE_SCN_CNT_CODE                   0x00000020  // Section contains code.
+#define IMAGE_SCN_CNT_INITIALIZED_DATA       0x00000040  // Section contains initialized data.
+#define IMAGE_SCN_CNT_UNINITIALIZED_DATA     0x00000080  // Section contains uninitialized data.
+
+#define IMAGE_SCN_LNK_OTHER                  0x00000100  // Reserved.
+#define IMAGE_SCN_LNK_INFO                   0x00000200  // Section contains comments or some other type of information.
+#define IMAGE_SCN_LNK_REMOVE                 0x00000800  // Section contents will not become part of image.
+#define IMAGE_SCN_LNK_COMDAT                 0x00001000  // Section contents comdat.
+
+#define IMAGE_SCN_ALIGN_1BYTES               0x00100000  //
+#define IMAGE_SCN_ALIGN_2BYTES               0x00200000  //
+#define IMAGE_SCN_ALIGN_4BYTES               0x00300000  //
+#define IMAGE_SCN_ALIGN_8BYTES               0x00400000  //
+#define IMAGE_SCN_ALIGN_16BYTES              0x00500000  // Default alignment if no others are specified.
+#define IMAGE_SCN_ALIGN_32BYTES              0x00600000  //
+#define IMAGE_SCN_ALIGN_64BYTES              0x00700000  //
+
+#define IMAGE_SCN_MEM_DISCARDABLE            0x02000000  // Section can be discarded.
+#define IMAGE_SCN_MEM_NOT_CACHED             0x04000000  // Section is not cachable.
+#define IMAGE_SCN_MEM_NOT_PAGED              0x08000000  // Section is not pageable.
+#define IMAGE_SCN_MEM_SHARED                 0x10000000  // Section is shareable.
+#define IMAGE_SCN_MEM_EXECUTE                0x20000000  // Section is executable.
+#define IMAGE_SCN_MEM_READ                   0x40000000  // Section is readable.
+#define IMAGE_SCN_MEM_WRITE                  0x80000000  // Section is writeable.
+
+//
+// Symbol format.
+//
+
+
+#define IMAGE_SIZEOF_SYMBOL                  18
+
+//
+// Section values.
+//
+// Symbols have a section number of the section in which they are
+// defined. Otherwise, section numbers have the following meanings:
+//
+
+#define IMAGE_SYM_UNDEFINED           (UINT16)0           // Symbol is undefined or is common.
+#define IMAGE_SYM_ABSOLUTE            (UINT16)-1          // Symbol is an absolute value.
+#define IMAGE_SYM_DEBUG               (UINT16)-2          // Symbol is a special debug item.
+
+//
+// Type (fundamental) values.
+//
+
+#define IMAGE_SYM_TYPE_NULL                  0           // no type.
+#define IMAGE_SYM_TYPE_VOID                  1           //
+#define IMAGE_SYM_TYPE_CHAR                  2           // type character.
+#define IMAGE_SYM_TYPE_SHORT                 3           // type short integer.
+#define IMAGE_SYM_TYPE_INT                   4           //
+#define IMAGE_SYM_TYPE_LONG                  5           //
+#define IMAGE_SYM_TYPE_FLOAT                 6           //
+#define IMAGE_SYM_TYPE_DOUBLE                7           //
+#define IMAGE_SYM_TYPE_STRUCT                8           //
+#define IMAGE_SYM_TYPE_UNION                 9           //
+#define IMAGE_SYM_TYPE_ENUM                  10          // enumeration.
+#define IMAGE_SYM_TYPE_MOE                   11          // member of enumeration.
+#define IMAGE_SYM_TYPE_BYTE                  12          //
+#define IMAGE_SYM_TYPE_WORD                  13          //
+#define IMAGE_SYM_TYPE_UINT                  14          //
+#define IMAGE_SYM_TYPE_DWORD                 15          //
+
+//
+// Type (derived) values.
+//
+
+#define IMAGE_SYM_DTYPE_NULL                 0           // no derived type.
+#define IMAGE_SYM_DTYPE_POINTER              1           // pointer.
+#define IMAGE_SYM_DTYPE_FUNCTION             2           // function.
+#define IMAGE_SYM_DTYPE_ARRAY                3           // array.
+
+//
+// Storage classes.
+//
+
+#define IMAGE_SYM_CLASS_END_OF_FUNCTION      (BYTE )-1
+#define IMAGE_SYM_CLASS_NULL                 0
+#define IMAGE_SYM_CLASS_AUTOMATIC            1
+#define IMAGE_SYM_CLASS_EXTERNAL             2
+#define IMAGE_SYM_CLASS_STATIC               3
+#define IMAGE_SYM_CLASS_REGISTER             4
+#define IMAGE_SYM_CLASS_EXTERNAL_DEF         5
+#define IMAGE_SYM_CLASS_LABEL                6
+#define IMAGE_SYM_CLASS_UNDEFINED_LABEL      7
+#define IMAGE_SYM_CLASS_MEMBER_OF_STRUCT     8
+#define IMAGE_SYM_CLASS_ARGUMENT             9
+#define IMAGE_SYM_CLASS_STRUCT_TAG           10
+#define IMAGE_SYM_CLASS_MEMBER_OF_UNION      11
+#define IMAGE_SYM_CLASS_UNION_TAG            12
+#define IMAGE_SYM_CLASS_TYPE_DEFINITION      13
+#define IMAGE_SYM_CLASS_UNDEFINED_STATIC     14
+#define IMAGE_SYM_CLASS_ENUM_TAG             15
+#define IMAGE_SYM_CLASS_MEMBER_OF_ENUM       16
+#define IMAGE_SYM_CLASS_REGISTER_PARAM       17
+#define IMAGE_SYM_CLASS_BIT_FIELD            18
+#define IMAGE_SYM_CLASS_BLOCK                100
+#define IMAGE_SYM_CLASS_FUNCTION             101
+#define IMAGE_SYM_CLASS_END_OF_STRUCT        102
+#define IMAGE_SYM_CLASS_FILE                 103
+// new
+#define IMAGE_SYM_CLASS_SECTION              104
+#define IMAGE_SYM_CLASS_WEAK_EXTERNAL        105
+
+// type packing constants
+
+#define N_BTMASK                            017
+#define N_TMASK                             060
+#define N_TMASK1                            0300
+#define N_TMASK2                            0360
+#define N_BTSHFT                            4
+#define N_TSHIFT                            2
+
+// MACROS
+
+//
+// Communal selection types.
+//
+
+#define IMAGE_COMDAT_SELECT_NODUPLICATES   1
+#define IMAGE_COMDAT_SELECT_ANY            2
+#define IMAGE_COMDAT_SELECT_SAME_SIZE      3
+#define IMAGE_COMDAT_SELECT_EXACT_MATCH    4
+#define IMAGE_COMDAT_SELECT_ASSOCIATIVE    5
+
+#define IMAGE_WEAK_EXTERN_SEARCH_NOLIBRARY 1
+#define IMAGE_WEAK_EXTERN_SEARCH_LIBRARY   2
+#define IMAGE_WEAK_EXTERN_SEARCH_ALIAS     3
+
+
+//
+// Relocation format.
+//
+
+typedef struct _IMAGE_RELOCATION {
+    UINT32   VirtualAddress;
+    UINT32   SymbolTableIndex;
+    UINT16    Type;
+} IMAGE_RELOCATION;
+
+#define IMAGE_SIZEOF_RELOCATION              10
+
+//
+// I386 relocation types.
+//
+
+#define IMAGE_REL_I386_ABSOLUTE              0           // Reference is absolute, no relocation is necessary
+#define IMAGE_REL_I386_DIR16                 01          // Direct 16-bit reference to the symbols virtual address
+#define IMAGE_REL_I386_REL16                 02          // PC-relative 16-bit reference to the symbols virtual address
+#define IMAGE_REL_I386_DIR32                 06          // Direct 32-bit reference to the symbols virtual address
+#define IMAGE_REL_I386_DIR32NB               07          // Direct 32-bit reference to the symbols virtual address, base not included
+#define IMAGE_REL_I386_SEG12                 011         // Direct 16-bit reference to the segment-selector bits of a 32-bit virtual address
+#define IMAGE_REL_I386_SECTION               012
+#define IMAGE_REL_I386_SECREL                013
+#define IMAGE_REL_I386_REL32                 024         // PC-relative 32-bit reference to the symbols virtual address
+
+//
+// MIPS relocation types.
+//
+
+#define IMAGE_REL_MIPS_ABSOLUTE              0           // Reference is absolute, no relocation is necessary
+#define IMAGE_REL_MIPS_REFHALF               01
+#define IMAGE_REL_MIPS_REFWORD               02
+#define IMAGE_REL_MIPS_JMPADDR               03
+#define IMAGE_REL_MIPS_REFHI                 04
+#define IMAGE_REL_MIPS_REFLO                 05
+#define IMAGE_REL_MIPS_GPREL                 06
+#define IMAGE_REL_MIPS_LITERAL               07
+#define IMAGE_REL_MIPS_SECTION               012
+#define IMAGE_REL_MIPS_SECREL                013
+#define IMAGE_REL_MIPS_REFWORDNB             042
+#define IMAGE_REL_MIPS_PAIR                  045
+
+//
+// Alpha Relocation types.
+//
+
+#define IMAGE_REL_ALPHA_ABSOLUTE             0x0
+#define IMAGE_REL_ALPHA_REFLONG              0x1
+#define IMAGE_REL_ALPHA_REFQUAD              0x2
+#define IMAGE_REL_ALPHA_GPREL32              0x3
+#define IMAGE_REL_ALPHA_LITERAL              0x4
+#define IMAGE_REL_ALPHA_LITUSE               0x5
+#define IMAGE_REL_ALPHA_GPDISP               0x6
+#define IMAGE_REL_ALPHA_BRADDR               0x7
+#define IMAGE_REL_ALPHA_HINT                 0x8
+#define IMAGE_REL_ALPHA_INLINE_REFLONG       0x9
+#define IMAGE_REL_ALPHA_REFHI                0xA
+#define IMAGE_REL_ALPHA_REFLO                0xB
+#define IMAGE_REL_ALPHA_PAIR                 0xC
+#define IMAGE_REL_ALPHA_MATCH                0xD
+#define IMAGE_REL_ALPHA_SECTION              0xE
+#define IMAGE_REL_ALPHA_SECREL               0xF
+#define IMAGE_REL_ALPHA_REFLONGNB            0x10
+
+//
+// IBM PowerPC relocation types.
+//
+
+#define IMAGE_REL_PPC_ABSOLUTE 0x0000  // NOP
+#define IMAGE_REL_PPC_ADDR64   0x0001  // 64-bit address
+#define IMAGE_REL_PPC_ADDR32   0x0002  // 32-bit address
+#define IMAGE_REL_PPC_ADDR24   0x0003  // 26-bit address, shifted left 2 (branch absolute)
+#define IMAGE_REL_PPC_ADDR16   0x0004  // 16-bit address
+#define IMAGE_REL_PPC_ADDR14   0x0005  // 16-bit address, shifted left 2 (load doubleword)
+#define IMAGE_REL_PPC_REL24    0x0006  // 26-bit PC-relative offset, shifted left 2 (branch relative)
+#define IMAGE_REL_PPC_REL14    0x0007  // 16-bit PC-relative offset, shifted left 2 (br cond relative)
+#define IMAGE_REL_PPC_TOCREL16 0x0008  // 16-bit offset from TOC base
+#define IMAGE_REL_PPC_TOCREL14 0x0009  // 16-bit offset from TOC base, shifted left 2 (load doubleword)
+
+#define IMAGE_REL_PPC_ADDR32NB 0x000A  // 32-bit addr w/o image base
+#define IMAGE_REL_PPC_SECREL   0x000B  // va of containing section (as in an image sectionhdr)
+#define IMAGE_REL_PPC_SECTION  0x000C  // sectionheader number
+#define IMAGE_REL_PPC_IFGLUE   0x000D  // substitute TOC restore instruction iff symbol is glue code
+#define IMAGE_REL_PPC_IMGLUE   0x000E  // symbol is glue code; virtual address is TOC restore instruction
+
+#define IMAGE_REL_PPC_TYPEMASK 0x00FF  // mask to isolate above values in IMAGE_RELOCATION.Type
+
+// Flag bits in IMAGE_RELOCATION.TYPE
+
+#define IMAGE_REL_PPC_NEG      0x0100  // subtract reloc value rather than adding it
+#define IMAGE_REL_PPC_BRTAKEN  0x0200  // fix branch prediction bit to predict branch taken
+#define IMAGE_REL_PPC_BRNTAKEN 0x0400  // fix branch prediction bit to predict branch not taken
+#define IMAGE_REL_PPC_TOCDEFN  0x0800  // toc slot defined in file (or, data in toc)
+
+//
+// Based relocation format.
+//
+
+typedef struct _IMAGE_BASE_RELOCATION {
+    UINT32   VirtualAddress;
+    UINT32   SizeOfBlock;
+//  UINT16    TypeOffset[1];
+} IMAGE_BASE_RELOCATION, *PIMAGE_BASE_RELOCATION;
+
+#define IMAGE_SIZEOF_BASE_RELOCATION         8
+
+//
+// Based relocation types.
+//
+
+#define IMAGE_REL_BASED_ABSOLUTE              0
+#define IMAGE_REL_BASED_HIGH                  1
+#define IMAGE_REL_BASED_LOW                   2
+#define IMAGE_REL_BASED_HIGHLOW               3
+#define IMAGE_REL_BASED_HIGHADJ               4
+#define IMAGE_REL_BASED_MIPS_JMPADDR          5
+#define IMAGE_REL_BASED_IA64_IMM64            9
+#define IMAGE_REL_BASED_DIR64                 10
+
+//
+// Line number format.
+//
+
+typedef struct _IMAGE_LINENUMBER {
+    union {
+        UINT32   SymbolTableIndex;               // Symbol table index of function name if Linenumber is 0.
+        UINT32   VirtualAddress;                 // Virtual address of line number.
+    } Type;
+    UINT16    Linenumber;                         // Line number.
+} IMAGE_LINENUMBER;
+
+#define IMAGE_SIZEOF_LINENUMBER              6
+
+//
+// Archive format.
+//
+
+#define IMAGE_ARCHIVE_START_SIZE             8
+#define IMAGE_ARCHIVE_START                  "!<arch>\n"
+#define IMAGE_ARCHIVE_END                    "`\n"
+#define IMAGE_ARCHIVE_PAD                    "\n"
+#define IMAGE_ARCHIVE_LINKER_MEMBER          "/               "
+#define IMAGE_ARCHIVE_LONGNAMES_MEMBER       "//              "
+
+typedef struct _IMAGE_ARCHIVE_MEMBER_HEADER {
+    UINT8     Name[16];                          // File member name - `/' terminated.
+    UINT8     Date[12];                          // File member date - decimal.
+    UINT8     UserID[6];                         // File member user id - decimal.
+    UINT8     GroupID[6];                        // File member group id - decimal.
+    UINT8     Mode[8];                           // File member mode - octal.
+    UINT8     Size[10];                          // File member size - decimal.
+    UINT8     EndHeader[2];                      // String to end header.
+} IMAGE_ARCHIVE_MEMBER_HEADER, *PIMAGE_ARCHIVE_MEMBER_HEADER;
+
+#define IMAGE_SIZEOF_ARCHIVE_MEMBER_HDR      60
+
+//
+// DLL support.
+//
+
+//
+// Export Format
+//
+
+typedef struct _IMAGE_EXPORT_DIRECTORY {
+    UINT32   Characteristics;
+    UINT32   TimeDateStamp;
+    UINT16   MajorVersion;
+    UINT16   MinorVersion;
+    UINT32   Name;
+    UINT32   Base;
+    UINT32   NumberOfFunctions;
+    UINT32   NumberOfNames;
+    UINT32   *AddressOfFunctions;
+    UINT32   *AddressOfNames;
+    UINT32   *AddressOfNameOrdinals;
+} IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;
+
+//
+// Import Format
+//
+
+typedef struct _IMAGE_IMPORT_BY_NAME {
+    UINT16    Hint;
+    UINT8     Name[1];
+} IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;
+
+typedef struct _IMAGE_THUNK_DATA {
+    union {
+        UINT32 Function;
+        UINT32 Ordinal;
+        PIMAGE_IMPORT_BY_NAME AddressOfData;
+    } u1;
+} IMAGE_THUNK_DATA, *PIMAGE_THUNK_DATA;
+
+#define IMAGE_ORDINAL_FLAG 0x80000000
+#define IMAGE_SNAP_BY_ORDINAL(Ordinal) ((Ordinal & IMAGE_ORDINAL_FLAG) != 0)
+#define IMAGE_ORDINAL(Ordinal) (Ordinal & 0xffff)
+
+typedef struct _IMAGE_IMPORT_DESCRIPTOR {
+    UINT32   Characteristics;
+    UINT32   TimeDateStamp;
+    UINT32   ForwarderChain;
+    UINT32   Name;
+    PIMAGE_THUNK_DATA FirstThunk;
+} IMAGE_IMPORT_DESCRIPTOR, *PIMAGE_IMPORT_DESCRIPTOR;
+
+#endif
diff --git a/linux-x86_64/gnu-efi/lib/crt0-efi-x86_64.o b/linux-x86_64/gnu-efi/lib/crt0-efi-x86_64.o
new file mode 100644
index 0000000000000000000000000000000000000000..9a10d08d64e94ab109743407b7d0f74070909c96
GIT binary patch
literal 1328
zcmbW0Jxc>Y5QZmyB}Rn^7K%+8ML`ZyC~1_$FCwUrbg}T<=&6C6hTIB?jfHjoPkQ|^
z7XAc5=iS>i$Cxy}us1W$?#%4o?Y$hG9#5oF<dmX48b*#14Tdh2j9;QGrK$4znW@$)
z{avt1e;cNLQLTNz@h^?3yuN4N5L;zq>qWg#s|I<I?!@-qd7Yr8JRNj3c{fTc@)}V@
zo}v7BympoTZ}XgrbIynoB^z%FJ|*H+jwQpAfrVEHSQ#GZ0}Cz3hSu4FPukd-mUU!p
z8E^4A)Rg&cS4dcyzr*wBKOxq+eEW@lXR$V^0td1t=9j1ARqmYFBal4*A~U&nWIp4;
zGWRKV%~SRtwRbEm+M-39Fv|?RWq<Hd{oD3XWu8w;_D{}9f6}~JNzrdqNASOIGVYh6
z4N)d-;&FBC%TMGi82>L{VxAkZPu%NVBHy`dW4Jel7sqh&f^JjO%~KfmsHGY~t3ZCF
zRY%iFsP2M&6$RuU*3ZjlCkN!4zg_8og4?Das^){+556CS`wRc;JC@r!IPS3HE9^ty
Ub37c+vk!sK^Kcvt0>^Or0b`S2*Z=?k

literal 0
HcmV?d00001

diff --git a/linux-x86_64/gnu-efi/lib/elf_x86_64_efi.lds b/linux-x86_64/gnu-efi/lib/elf_x86_64_efi.lds
new file mode 100644
index 0000000..32cf687
--- /dev/null
+++ b/linux-x86_64/gnu-efi/lib/elf_x86_64_efi.lds
@@ -0,0 +1,63 @@
+/* Same as elf_x86_64_fbsd_efi.lds, except for OUTPUT_FORMAT below - KEEP IN SYNC */
+OUTPUT_FORMAT("elf64-x86-64", "elf64-x86-64", "elf64-x86-64")
+OUTPUT_ARCH(i386:x86-64)
+ENTRY(_start)
+SECTIONS
+{
+  . = 0;
+  ImageBase = .;
+  .hash : { *(.hash) }	/* this MUST come first! */
+  . = ALIGN(4096);
+  .eh_frame : 
+  { 
+    *(.eh_frame)
+  }
+  . = ALIGN(4096);
+  .text :
+  {
+   *(.text)
+  }
+  . = ALIGN(4096);
+  .reloc :
+  {
+   *(.reloc)
+  }
+  . = ALIGN(4096);
+  .data :
+  {
+   *(.rodata*)
+   *(.got.plt)
+   *(.got)
+   *(.data*)
+   *(.sdata)
+   /* the EFI loader doesn't seem to like a .bss section, so we stick
+      it all into .data: */
+   *(.sbss)
+   *(.scommon)
+   *(.dynbss)
+   *(.bss)
+   *(COMMON)
+   *(.rel.local)
+  }
+  . = ALIGN(4096);
+  .dynamic  : { *(.dynamic) }
+  . = ALIGN(4096);
+  .rela :
+  {
+    *(.rela.data*)
+    *(.rela.got)
+    *(.rela.stab)
+  }
+  . = ALIGN(4096);
+  .dynsym   : { *(.dynsym) }
+  . = ALIGN(4096);
+  .dynstr   : { *(.dynstr) }
+  . = ALIGN(4096);
+  .ignored.reloc :
+  {
+    *(.rela.reloc)
+    *(.eh_frame)
+    *(.note.GNU-stack)
+  }
+  .comment 0 : { *(.comment) }
+}
diff --git a/linux-x86_64/gnu-efi/lib/libefi.a b/linux-x86_64/gnu-efi/lib/libefi.a
new file mode 100644
index 0000000000000000000000000000000000000000..b09361193161c6d6ba91a72fed7e7f0180c2f79e
GIT binary patch
literal 115022
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

literal 0
HcmV?d00001

diff --git a/linux-x86_64/gnu-efi/lib/libgnuefi.a b/linux-x86_64/gnu-efi/lib/libgnuefi.a
new file mode 100644
index 0000000000000000000000000000000000000000..9e541fecafbb52f76c4df2ba2d828ee92065ade3
GIT binary patch
literal 2472
zcmcIm%}*0S6rZJNmuf;a#vqt<IT$g>(uKBGV@MMOMzav2;=zMusY_95m$chZJXjNG
z;$~yQ!9T)_o;@~@nADT;qVW$PF<dYl{J7w}-5HopN)U__cHX?-{NB7bAMcg!>qa3n
zHx%ku8k;s4zj8Geiw!0fCF)J_y`sbh7=Jp15DJhlkI?Y}_|gS)-pUxZiHfHEIJbc2
zt$Y?F@+Q*dWFno2saC(jd(om%;$pW?Bw|F1X$jxYbf_|-kG4n>apX4%4WT`ap$NU>
zz?284&<P|X?4H$XxcbSS$1g|2T73lmYMZ_7krj`Hmw&g}_emct1+nuB2PS0fyvNJ6
zFm@-mz_61{%B9b`J1WeSHgL7x{%UQ!TDK=xfXIS)zP--Y*WC$u^Nm&;uhyP@)143a
z$Jh4A4TP4LWVzIaou4=$VJUf2`lw5FLaJ<NHDZjk8d>q}?CSP933F_C_?pr)HB-vl
zrGEWU-Y8f~OiieReOk!_<ClCLp)=mD5R#tWMp8K}b)5{#tK@6|KTqe@sPu$dT*}$T
z3{s1B!IyJvWSeChsSgd?K<Z4fh}4Xg%b9tC<t^J($0nxwinft?f>d(DhHB2GXA4Ho
z<X1oPxQkfAl^z#XNKw6E4+IMfyl$d{Jv>pqwF20rwF=lpqRZqvs{LhR3$CK%;~Vqe
z%Y$Uh!eTPcVLY{;5qPi(_ZG!k1YVTdi*dnT`8Gln@l0TT;h4|r@C9lk67GoEGyD|6
z#IpmFY3lzjC|nb_1-ckJ(91NaFVq&w5cn4TLtM@LPty21sXY^-e};<^c&+IBj);RE
z*uBNZ*+A2s0KZv;fYTrwmm#>A4L%{z<fb4WPIK|>=1W5{&Y-=j?XRWy!i$(cf4`>h
z74d^=cyb_4e<}`9!>Ml&DQ}!YL9(|8n3QlQf}N~<4?9*^cd{M2V=20`*rPj@D0UW;
z>&_N-BiPN#*d+{?FkHfL3B#>Kcd|)X?+~@lbN`RsK{X6=jBjGTb(2YWZ{jO?!5eX7
z(SE-g_P6%?<uJ2{8pk&=hd}4w5aX69_?iOns^P`URA)70zZ_QRft;g!CPe=X7bWoi
cXAVP6;&YGrhw}vd0t1-zlS{oL{^u0>1HiQRJOBUy

literal 0
HcmV?d00001

-- 
1.7.4.1

