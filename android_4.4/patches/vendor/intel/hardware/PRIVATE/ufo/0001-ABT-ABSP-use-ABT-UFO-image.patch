From 246f097d74a4c14c5374a588b4741f6551c81773 Mon Sep 17 00:00:00 2001
From: Yong Yao <yong.yao@intel.com>
Date: Tue, 18 Feb 2014 16:33:54 +0800
Subject: [ABT ABSP] use ABT UFO image

Change-Id: I579ebe6370402463562b82cca7f2fb01bbe579ff
Signed-off-by: Yong Yao <yong.yao@intel.com>
---
 graphics.h            |   31 ++
 inc/cm/cm_common.h    |  110 +++++
 inc/cm/cm_rt.h        | 1237 +++++++++++++++++++++++++++++++++++++++++++++++++
 inc/cm/cm_rt_linux.h  |  309 ++++++++++++
 inc/libpavp/libpavp.h |  356 ++++++++++++++
 inc/ufo/gralloc.h     |  107 +++++
 inc/ufo/graphics.h    |  150 ++++++
 7 files changed, 2300 insertions(+), 0 deletions(-)
 create mode 100644 inc/cm/cm_common.h
 create mode 100644 inc/cm/cm_rt.h
 create mode 100644 inc/cm/cm_rt_linux.h
 create mode 100644 inc/libpavp/libpavp.h
 create mode 100644 inc/ufo/gralloc.h
 create mode 100644 inc/ufo/graphics.h

diff --git a/graphics.h b/graphics.h
index ff5ffd3..fb2e9af 100644
--- a/graphics.h
+++ b/graphics.h
@@ -87,6 +87,37 @@ enum {
      * for the PACKED mode, pitch=width and no need any alignment for height
      */
     HAL_PIXEL_FORMAT_NV12_LINEAR_PACKED_INTEL = 0x103,
+
+    /**
+     * Three planes, 8 bit Y plane followed by 8 bit 2x1 subsampled U and V planes.
+     * Similar to IMC3 but U/V are full height.
+     * The width must be even.
+     * There are no specific restrictions on pitch, height and alignment.
+     * It can be linear or tiled if required.
+     *      __________________________
+     *      |Y0|Y1|                  |
+     *      |__|__|                  |
+     *     h|                        |
+     *      |____________w___________|
+     *      |U0|U1|      |
+     *     h|__|__|      |
+     *      |            |
+     *      |_____w/2____|
+     *      |V0|V1|      |
+     *     h|__|__|      |
+     *      |            |
+     *      |______w/2___|
+     */
+    HAL_PIXEL_FORMAT_YCbCr_422_H_INTEL = 0x104, // YU16
+    
+    /**
+     * This is VXD specific NV12 X tile format.
+     * - stride: 512, 1024, 1280, 2048, 4096
+     * - height: must be 32 aligned
+     * - tiling: X-tiled
+     */
+    HAL_PIXEL_FORMAT_NV12_X_TILED_INTEL = 0x105,
+
     
     /**
      * \note THIS WILL BE GOING AWAY!
diff --git a/inc/cm/cm_common.h b/inc/cm/cm_common.h
new file mode 100644
index 0000000..7cf6adb
--- /dev/null
+++ b/inc/cm/cm_common.h
@@ -0,0 +1,110 @@
+/**             
+*** -----------------------------------------------------------------------------------------------
+*** cvs_id[] = "$Id: cm_common.h 25899 2011-08-05 18:44:07Z kchen24 $"
+*** -----------------------------------------------------------------------------------------------
+***
+*** Copyright  (C) 1985-2007 Intel Corporation. All rights reserved.
+***
+*** The information and source code contained herein is the exclusive
+*** property of Intel Corporation. and may not be disclosed, examined
+*** or reproduced in whole or in part without explicit written authorization
+*** from the company.
+***
+***
+*** Authors:             Kaiyu Chen
+***                      
+***                      
+***                      
+***
+*** Description: Cm sampler APIs
+***
+*** -----------------------------------------------------------------------------------------------
+**/
+
+#ifndef CM_COMMON_H
+#define CM_COMMON_H
+
+#ifdef CMRT_EMU
+#define CM_EMU
+#endif
+
+#ifndef CM_NOINLINE
+    #ifndef CM_EMU
+    #ifndef __GNUC__
+    #define CM_NOINLINE __declspec(noinline) 
+    #else
+    #define CM_NOINLINE __attribute__((noinline)) 
+    #endif
+    #else
+    #define CM_NOINLINE
+    #endif /* CM_EMU */
+#endif
+
+class SurfaceIndex
+{
+public:
+    CM_NOINLINE SurfaceIndex() { index = 0; };
+	CM_NOINLINE SurfaceIndex(const SurfaceIndex& _src) { index = _src.index; };
+    CM_NOINLINE SurfaceIndex(const unsigned int& _n) { index = _n; };
+    CM_NOINLINE SurfaceIndex& operator = (const unsigned int& _n) { this->index = _n; return *this; };
+    CM_NOINLINE SurfaceIndex& operator + (const unsigned int& _n) { this->index += _n; return *this; };
+    virtual unsigned int get_data(void) { return index; };
+
+private:
+    unsigned int index;
+#ifdef __GNUC__
+    /*
+     * Do not delete this line:
+     * SurfaceIndex is commonly used as CM kernel function's parameter. 
+     * It has virutal table and has copy constructor, so GNU calling convetion will pass the object's pointer to kernel function.
+     * This is different with Windows VC++, which always copies the entire object transferred on the callee's stack. 
+     * 
+     * Depending on the special object size after adding below "extra_byte",  
+     * SetKernelArg and SetThreadArg can recognize this object and follow GNU's convention to construct kernel function's stack. 
+     * Detail can be found on "http://wiki.ith.intel.com/display/VPGCompiler/CM+Linux"
+     */
+    unsigned char extra_byte;
+#endif
+};
+
+class SamplerIndex
+{
+public:
+    CM_NOINLINE SamplerIndex() { index = 0; };
+    CM_NOINLINE SamplerIndex(SamplerIndex& _src) { index = _src.get_data(); };
+    CM_NOINLINE SamplerIndex(const unsigned int& _n) { index = _n; };
+    CM_NOINLINE SamplerIndex& operator = (const unsigned int& _n) { this->index = _n; return *this; };
+    virtual unsigned int get_data(void) { return index; };
+
+private:
+    unsigned int index;
+#ifdef __GNUC__
+    /*
+     * Do not delete this line:
+     * Same reason as SurfaceIndex.
+     */
+    unsigned char extra_byte;
+#endif
+};
+
+class VmeIndex
+
+{
+public:
+    CM_NOINLINE VmeIndex () { index = 0; };
+    CM_NOINLINE VmeIndex (VmeIndex& _src) { index = _src.get_data(); };
+    CM_NOINLINE VmeIndex (const unsigned int& _n) { index = _n; };
+    CM_NOINLINE VmeIndex & operator = (const unsigned int& _n) { this->index = _n; return *this; };
+    virtual unsigned int get_data(void) { return index; };
+private:
+    unsigned int index;
+#ifdef __GNUC__
+    /*
+     * Do not delete this line:
+     * Same reason as SurfaceIndex.
+     */
+    unsigned char extra_byte;
+#endif
+};
+
+#endif /* CM_SAMPLER_H */
diff --git a/inc/cm/cm_rt.h b/inc/cm/cm_rt.h
new file mode 100644
index 0000000..d136205
--- /dev/null
+++ b/inc/cm/cm_rt.h
@@ -0,0 +1,1237 @@
+/**             
+***
+*** Copyright  (C) 1985-2012 Intel Corporation. All rights reserved.
+***
+*** The information and source code contained herein is the exclusive
+*** property of Intel Corporation. and may not be disclosed, examined
+*** or reproduced in whole or in part without explicit written authorization
+*** from the company.
+***
+*** ----------------------------------------------------------------------------
+**/ 
+#pragma once
+
+#if (!defined(__GNUC__))
+#define __GNUC__
+#endif
+
+//Using CM_DX9 by default
+#if (!defined(__GNUC__)) && (!defined(CM_DX11))
+#ifndef CM_DX9
+#define CM_DX9
+#endif
+#endif
+
+#ifdef __cplusplus
+#   define EXTERN_C     extern "C"
+#else
+#   define EXTERN_C
+#endif
+
+#include "cm_common.h"
+
+#ifdef __GNUC__
+#include "cm_rt_linux.h"
+#else
+#include "cm_rt_win.h"  
+#endif
+
+
+#define CM_KERNEL_FUNCTION(...) CM_KERNEL_FUNCTION2(__VA_ARGS__)
+
+#define CM_RT_API 
+
+#define CM_1_0 100
+#define CM_2_0 200
+#define CM_2_1 201
+#define CM_2_2 202
+#define CM_2_3 203
+#define CM_2_4 204
+#define CM_3_0 300
+
+#define CM_SUCCESS                                  0
+#define CM_FAILURE                                  -1
+#define CM_NOT_IMPLEMENTED                          -2
+#define CM_SURFACE_ALLOCATION_FAILURE               -3
+#define CM_OUT_OF_HOST_MEMORY                       -4
+#define CM_SURFACE_FORMAT_NOT_SUPPORTED             -5
+#define CM_EXCEED_SURFACE_AMOUNT                    -6
+#define CM_EXCEED_KERNEL_ARG_AMOUNT                 -7
+#define CM_EXCEED_KERNEL_ARG_SIZE_IN_BYTE           -8
+#define CM_INVALID_ARG_INDEX                        -9
+#define CM_INVALID_ARG_VALUE                        -10
+#define CM_INVALID_ARG_SIZE                         -11
+#define CM_INVALID_THREAD_INDEX                     -12
+#define CM_INVALID_WIDTH                            -13
+#define CM_INVALID_HEIGHT                           -14
+#define CM_INVALID_DEPTH                            -15
+#define CM_INVALID_COMMON_ISA                       -16
+#define CM_D3DDEVICEMGR_OPEN_HANDLE_FAIL            -17 // IDirect3DDeviceManager9::OpenDeviceHandle fail
+#define CM_D3DDEVICEMGR_DXVA2_E_NEW_VIDEO_DEVICE    -18 // IDirect3DDeviceManager9::LockDevice return DXVA2_E_VIDEO_DEVICE_LOCKED
+#define CM_D3DDEVICEMGR_LOCK_DEVICE_FAIL            -19 // IDirect3DDeviceManager9::LockDevice return other fail than DXVA2_E_VIDEO_DEVICE_LOCKED
+#define CM_EXCEED_SAMPLER_AMOUNT                    -20
+#define CM_EXCEED_MAX_KERNEL_PER_ENQUEUE            -21
+#define CM_EXCEED_MAX_KERNEL_SIZE_IN_BYTE           -22
+#define CM_EXCEED_MAX_THREAD_AMOUNT_PER_ENQUEUE     -23
+#define CM_EXCEED_VME_STATE_G6_AMOUNT               -24
+#define CM_INVALID_THREAD_SPACE                     -25 
+#define CM_EXCEED_MAX_TIMEOUT                       -26
+#define CM_JITDLL_LOAD_FAILURE                      -27
+#define CM_JIT_COMPILE_FAILURE                      -28
+#define CM_JIT_COMPILESIM_FAILURE                   -29
+#define CM_INVALID_THREAD_GROUP_SPACE               -30
+#define CM_THREAD_ARG_NOT_ALLOWED                   -31
+#define CM_INVALID_GLOBAL_BUFFER_INDEX              -32
+#define CM_INVALID_BUFFER_HANDLER                   -33
+#define CM_EXCEED_MAX_SLM_SIZE                      -34
+#define CM_JITDLL_OLDER_THAN_ISA                    -35
+#define CM_INVALID_HARDWARE_THREAD_NUMBER           -36
+#define CM_GTPIN_INVOKE_FAILURE                     -37
+#define CM_INVALIDE_L3_CONFIGURATION                -38
+#define CM_INVALID_D3D11_TEXTURE2D_USAGE            -39
+#define CM_INTEL_GFX_NOTFOUND                       -40
+#define CM_GPUCOPY_INVALID_SYSMEM                   -41
+#define CM_GPUCOPY_INVALID_WIDTH                    -42
+#define CM_GPUCOPY_INVALID_STRIDE                   -43
+#define CM_EVENT_DRIVEN_FAILURE                     -44
+#define CM_LOCK_SURFACE_FAIL                        -45 // Lock surface failed
+#define CM_INVALID_GENX_BINARY                      -46
+#define CM_FEATURE_NOT_SUPPORTED_IN_DRIVER          -47 // driver out-of-sync
+#define CM_QUERY_DLL_VERSION_FAILURE                -48 //Fail in getting DLL file version
+#define CM_KERNELPAYLOAD_PERTHREADARG_MUTEX_FAIL    -49
+#define CM_KERNELPAYLOAD_PERKERNELARG_MUTEX_FAIL    -50
+#define CM_KERNELPAYLOAD_SETTING_FAILURE            -51
+#define CM_KERNELPAYLOAD_SURFACE_INVALID_BTINDEX    -52 
+#define CM_NOT_SET_KERNEL_ARGUMENT                  -53
+#define CM_GPUCOPY_INVALID_SURFACES                 -54
+#define CM_GPUCOPY_INVALID_SIZE                     -55
+#define CM_GPUCOPY_OUT_OF_RESOURCE                  -56
+#define CM_DEVICE_INVALID_D3DDEVICE                 -57
+#define CM_SURFACE_DELAY_DESTROY                    -58
+#define	CM_INVALID_VEBOX_STATE                      -59
+#define CM_INVALID_VEBOX_SURFACE                    -60
+#define CM_FEATURE_NOT_SUPPORTED_BY_HARDWARE        -61
+#define CM_RESOURCE_USAGE_NOT_SUPPORT_READWRITE     -62
+#define CM_MULTIPLE_MIPLEVELS_NOT_SUPPORTED         -63
+#define CM_INVALID_UMD_CONTEXT                      -64
+#define CM_INVALID_LIBVA_SURFACE                    -65
+#define CM_INVALID_LIBVA_INITIALIZE                 -66
+#define CM_INVALIDE_KERNEL_SPILL_CODE               -76
+
+#define CM_MIN_SURF_WIDTH   1
+#define CM_MIN_SURF_HEIGHT  1
+#define CM_MIN_SURF_DEPTH   2
+
+#define CM_MAX_1D_SURF_WIDTH 0X8000000 // 2^27
+
+#define CM_MAX_GPUCOPY_SURFACE_WIDTH_IN_BYTE        65408
+#define CM_MAX_GPUCOPY_SURFACE_HEIGHT  				4088
+
+//IVB+
+#define CM_MAX_2D_SURF_WIDTH_IVB_PLUS   16384
+#define CM_MAX_2D_SURF_HEIGHT_IVB_PLUS  16384
+
+#define CM_MAX_2D_SURF_WIDTH    CM_MAX_2D_SURF_WIDTH_IVB_PLUS
+#define CM_MAX_2D_SURF_HEIGHT   CM_MAX_2D_SURF_HEIGHT_IVB_PLUS
+
+#define CM_MAX_3D_SURF_WIDTH    2048
+#define CM_MAX_3D_SURF_HEIGHT   2048
+#define CM_MAX_3D_SURF_DEPTH    2048
+
+#define CM_MAX_OPTION_SIZE_IN_BYTE          512
+#define CM_MAX_KERNEL_NAME_SIZE_IN_BYTE     256
+#define CM_MAX_ISA_FILE_NAME_SIZE_IN_BYTE   256
+
+#define CM_MAX_THREADSPACE_WIDTH        511
+#define CM_MAX_THREADSPACE_HEIGHT       511
+
+#define IVB_MAX_SLM_SIZE_PER_GROUP   16 // 64KB PER Group on Gen7
+
+#define COMPILER_RESERVED_SURFACE_NUM 5
+
+//Time in seconds before kernel should timeout
+#define CM_MAX_TIMEOUT 2
+//Time in milliseconds before kernel should timeout
+#define CM_MAX_TIMEOUT_MS CM_MAX_TIMEOUT*1000
+#define CM_NO_EVENT  ((CmEvent *)(-1))	//NO Event
+
+#define CM_DEVICE_CREATE_OPTION_DEFAULT                     0
+#define CM_DEVICE_CREATE_OPTION_SCRATCH_SPACE_DISABLE       1
+
+typedef enum _CM_STATUS
+{
+    CM_STATUS_QUEUED         = 0,
+    CM_STATUS_FLUSHED        = 1,
+    CM_STATUS_FINISHED       = 2,
+    CM_STATUS_STARTED        = 3
+} CM_STATUS;
+
+typedef struct _CM_SAMPLER_STATE
+{
+    CM_TEXTURE_FILTER_TYPE minFilterType;
+    CM_TEXTURE_FILTER_TYPE magFilterType;   
+    CM_TEXTURE_ADDRESS_TYPE addressU;   
+    CM_TEXTURE_ADDRESS_TYPE addressV;   
+    CM_TEXTURE_ADDRESS_TYPE addressW; 
+} CM_SAMPLER_STATE;
+
+typedef enum _GPU_PLATFORM{
+    PLATFORM_INTEL_UNKNOWN     = 0,
+    PLATFORM_INTEL_SNB         = 1,   //Sandy Bridge
+    PLATFORM_INTEL_IVB         = 2,   //Ivy Bridge
+    PLATFORM_INTEL_HSW         = 3,   //Haswell
+    PLATFORM_INTEL_BDW         = 4,   //Broadwell
+    PLATFORM_INTEL_VLV         = 5    //ValleyView
+} GPU_PLATFORM;
+
+typedef enum _GPU_GT_PLATFORM{
+    PLATFORM_INTEL_GT_UNKNOWN  = 0,
+    PLATFORM_INTEL_GT1         = 1,
+    PLATFORM_INTEL_GT2         = 2,
+    PLATFORM_INTEL_GT3         = 3,
+    PLATFORM_INTEL_GT4         = 4,
+    PLATFORM_INTEL_GTVLV       = 5,
+    PLATFORM_INTEL_GTVLVPLUS   = 6,
+} GPU_GT_PLATFORM;
+
+typedef enum _CM_DEVICE_CAP_NAME
+{
+    CAP_KERNEL_COUNT_PER_TASK,
+    CAP_KERNEL_BINARY_SIZE,
+    CAP_SAMPLER_COUNT ,
+    CAP_SAMPLER_COUNT_PER_KERNEL,
+    CAP_BUFFER_COUNT ,
+    CAP_SURFACE2D_COUNT,
+    CAP_SURFACE3D_COUNT,
+    CAP_SURFACE_COUNT_PER_KERNEL,
+    CAP_ARG_COUNT_PER_KERNEL,
+    CAP_ARG_SIZE_PER_KERNEL ,
+    CAP_USER_DEFINED_THREAD_COUNT_PER_TASK,
+    CAP_HW_THREAD_COUNT,
+    CAP_SURFACE2D_FORMAT_COUNT,
+    CAP_SURFACE2D_FORMATS,
+    CAP_SURFACE3D_FORMAT_COUNT,
+    CAP_SURFACE3D_FORMATS,
+    CAP_VME_STATE_G6_COUNT,
+    CAP_GPU_PLATFORM,
+    CAP_GT_PLATFORM,
+    CAP_MIN_FREQUENCY,
+    CAP_MAX_FREQUENCY,
+    CAP_L3_CONFIG,
+    CAP_GPU_CURRENT_FREQUENCY
+} CM_DEVICE_CAP_NAME;
+
+typedef enum _CM_FASTCOPY_OPTION
+{
+    CM_FASTCOPY_OPTION_NONBLOCKING  = 0x00,
+    CM_FASTCOPY_OPTION_BLOCKING     = 0x01
+} CM_FASTCOPY_OPTION;
+
+// CM RT DLL File Version
+typedef struct _CM_DLL_FILE_VERSION
+{
+    WORD    wMANVERSION;
+    WORD    wMANREVISION;
+    WORD    wSUBREVISION;
+    WORD    wBUILD_NUMBER; 
+    //Version constructed as : "wMANVERSION.wMANREVISION.wSUBREVISION.wBUILD_NUMBER"
+} CM_DLL_FILE_VERSION, *PCM_DLL_FILE_VERSION;
+
+#define NUM_SEARCH_PATH_STATES_G6       14
+#define NUM_MBMODE_SETS_G6              4
+
+typedef struct _VME_SEARCH_PATH_LUT_STATE_G6
+{
+    // DWORD 0
+    union
+    {
+        struct
+        {
+            DWORD   SearchPathLocation_X_0  : 4;
+            DWORD   SearchPathLocation_Y_0  : 4;
+            DWORD   SearchPathLocation_X_1  : 4;
+            DWORD   SearchPathLocation_Y_1  : 4;
+            DWORD   SearchPathLocation_X_2  : 4;
+            DWORD   SearchPathLocation_Y_2  : 4;
+            DWORD   SearchPathLocation_X_3  : 4;
+            DWORD   SearchPathLocation_Y_3  : 4;
+        };
+        struct
+        {
+            DWORD   Value;
+        };
+    };
+} VME_SEARCH_PATH_LUT_STATE_G6, *PVME_SEARCH_PATH_LUT_STATE_G6;
+
+typedef struct _VME_RD_LUT_SET_G6
+{
+    // DWORD 0
+    union
+    {
+        struct
+        {
+            DWORD   LUT_MbMode_0    : 8;
+            DWORD   LUT_MbMode_1    : 8;
+            DWORD   LUT_MbMode_2    : 8;
+            DWORD   LUT_MbMode_3    : 8;
+        };
+        struct
+        {
+            DWORD   Value;
+        };
+    } DW0;
+
+    // DWORD 1
+    union
+    {
+        struct
+        {
+            DWORD   LUT_MbMode_4    : 8;
+            DWORD   LUT_MbMode_5    : 8;
+            DWORD   LUT_MbMode_6    : 8;
+            DWORD   LUT_MbMode_7    : 8;
+        };
+        struct
+        {
+            DWORD   Value;
+        };
+    } DW1;
+
+    // DWORD 2
+    union
+    {
+        struct 
+        {
+            DWORD   LUT_MV_0        : 8;
+            DWORD   LUT_MV_1        : 8;
+            DWORD   LUT_MV_2        : 8;
+            DWORD   LUT_MV_3        : 8;
+        };
+        struct
+        {
+            DWORD   Value;
+        };
+    } DW2;
+
+    // DWORD 3
+    union
+    {
+        struct
+        {
+            DWORD   LUT_MV_4        : 8;
+            DWORD   LUT_MV_5        : 8;
+            DWORD   LUT_MV_6        : 8;
+            DWORD   LUT_MV_7        : 8;
+        };
+        struct
+        {
+            DWORD   Value;
+        };
+    } DW3;
+} VME_RD_LUT_SET_G6, *PVME_RD_LUT_SET_G6;
+
+
+typedef struct _VME_STATE_G6
+{
+    // DWORD 0 - DWORD 13
+    VME_SEARCH_PATH_LUT_STATE_G6    SearchPath[NUM_SEARCH_PATH_STATES_G6];
+
+    // DWORD 14
+    union
+    {
+        struct
+        {
+            DWORD   LUT_MbMode_8_0  : 8;
+            DWORD   LUT_MbMode_9_0  : 8;
+            DWORD   LUT_MbMode_8_1  : 8;
+            DWORD   LUT_MbMode_9_1  : 8;
+        };
+        struct
+        {
+            DWORD   Value;
+        };
+    } DW14;
+
+    // DWORD 15
+    union
+    {
+        struct
+        {
+            DWORD   LUT_MbMode_8_2  : 8;
+            DWORD   LUT_MbMode_9_2  : 8;
+            DWORD   LUT_MbMode_8_3  : 8;
+            DWORD   LUT_MbMode_9_3  : 8;
+        };
+        struct
+        {
+            DWORD   Value;
+        };
+    } DW15;
+
+    // DWORD 16 - DWORD 31
+    VME_RD_LUT_SET_G6   RdLutSet[NUM_MBMODE_SETS_G6];
+} VME_STATE_G6, *PVME_STATE_G6;
+
+#define CM_MAX_DEPENDENCY_COUNT         8
+
+typedef enum _CM_DEPENDENCY_PATTERN
+{
+    CM_NONE_DEPENDENCY          = 0,    //All threads run parallel, scanline dispatch
+    CM_WAVEFRONT                = 1,
+    CM_WAVEFRONT26              = 2,
+    CM_VERTICAL_DEPENDENCY      = 3,
+    CM_HORIZONTAL_DEPENDENCY    = 4,
+    CM_WAVEFRONT26Z             = 5
+} CM_DEPENDENCY_PATTERN;
+
+typedef struct _CM_DEPENDENCY
+{
+    UINT    count;
+    INT     deltaX[CM_MAX_DEPENDENCY_COUNT];
+    INT     deltaY[CM_MAX_DEPENDENCY_COUNT];
+}CM_DEPENDENCY;
+
+/**************** L3/Cache ***************/
+typedef enum _MEMORY_OBJECT_CONTROL{
+    // SNB
+    MEMORY_OBJECT_CONTROL_USE_GTT_ENTRY,
+    MEMORY_OBJECT_CONTROL_NEITHER_LLC_NOR_MLC,
+    MEMORY_OBJECT_CONTROL_LLC_NOT_MLC,
+    MEMORY_OBJECT_CONTROL_LLC_AND_MLC,
+
+    // IVB
+    MEMORY_OBJECT_CONTROL_FROM_GTT_ENTRY = MEMORY_OBJECT_CONTROL_USE_GTT_ENTRY,                                 // Caching dependent on pte
+    MEMORY_OBJECT_CONTROL_L3,                                             // Cached in L3$
+    MEMORY_OBJECT_CONTROL_LLC,                                            // Cached in LLC 
+    MEMORY_OBJECT_CONTROL_LLC_L3,                                         // Cached in LLC & L3$
+
+    // HSW
+#ifdef CMRT_SIM
+    MEMORY_OBJECT_CONTROL_USE_PTE, // Caching dependent on pte
+#else
+    MEMORY_OBJECT_CONTROL_USE_PTE = MEMORY_OBJECT_CONTROL_FROM_GTT_ENTRY, // Caching dependent on pte
+#endif
+    MEMORY_OBJECT_CONTROL_UC,                                             // Uncached
+    MEMORY_OBJECT_CONTROL_LLC_ELLC,
+    MEMORY_OBJECT_CONTROL_ELLC,
+    MEMORY_OBJECT_CONTROL_L3_USE_PTE,
+    MEMORY_OBJECT_CONTROL_L3_UC,
+    MEMORY_OBJECT_CONTROL_L3_LLC_ELLC,
+    MEMORY_OBJECT_CONTROL_L3_ELLC,
+
+    MEMORY_OBJECT_CONTROL_UNKNOWN = 0xff
+} MEMORY_OBJECT_CONTROL;
+
+typedef enum _MEMORY_TYPE {
+    CM_USE_PTE,
+    CM_UN_CACHEABLE,
+    CM_WRITE_THROUGH,
+    CM_WRITE_BACK
+} MEMORY_TYPE;
+
+typedef enum _CM_BOUNDARY_PIXEL_MODE
+{
+    CM_BOUNDARY_NORMAL  = 0x0,
+    CM_BOUNDARY_PROGRESSIVE_FRAME = 0x2,
+    CM_BOUNARY_INTERLACED_FRAME = 0x3
+}CM_BOUNDARY_PIXEL_MODE;
+
+#define BDW_L3_CONFIG_NUM 8
+#define HSW_L3_CONFIG_NUM 12
+#define IVB_2_L3_CONFIG_NUM 12
+#define IVB_1_L3_CONFIG_NUM 12
+
+typedef struct _L3_CONFIG_REGISTER_VALUES{
+    UINT SQCREG1_VALUE;
+    UINT CNTLREG2_VALUE;
+    UINT CNTLREG3_VALUE;
+} L3_CONFIG_REGISTER_VALUES;
+
+typedef enum _L3_SUGGEST_CONFIG
+{
+    IVB_L3_PLANE_DEFAULT,
+    IVB_L3_PLANE_1,
+    IVB_L3_PLANE_2,
+    IVB_L3_PLANE_3,
+    IVB_L3_PLANE_4,
+    IVB_L3_PLANE_5,
+    IVB_L3_PLANE_6,
+    IVB_L3_PLANE_7,
+    IVB_L3_PLANE_8,
+    IVB_L3_PLANE_9,
+    IVB_L3_PLANE_10,
+    IVB_L3_PLANE_11,
+    
+    HSW_L3_PLANE_DEFAULT = IVB_L3_PLANE_DEFAULT,
+    HSW_L3_PLANE_1,
+    HSW_L3_PLANE_2,
+    HSW_L3_PLANE_3,
+    HSW_L3_PLANE_4,
+    HSW_L3_PLANE_5,
+    HSW_L3_PLANE_6,
+    HSW_L3_PLANE_7,
+    HSW_L3_PLANE_8,
+    HSW_L3_PLANE_9,
+    HSW_L3_PLANE_10,
+    HSW_L3_PLANE_11,
+
+    IVB_SLM_PLANE_DEFAULT = IVB_L3_PLANE_9,
+    HSW_SLM_PLANE_DEFAULT = HSW_L3_PLANE_9
+} L3_SUGGEST_CONFIG;
+
+static const L3_CONFIG_REGISTER_VALUES IVB_L3_PLANE[IVB_1_L3_CONFIG_NUM]  = 
+{                                                                    // SLM    URB   Rest DC     RO     I/S    C    T      Sum
+    {0x01730000, 0x00080040, 0x00000000},     // {0,    256,    0,     0,     256,    0,     0,    0,     512},
+    {0x00730000, 0x02040040, 0x00000000},     //{0,    256,    0,   128,     128,    0,     0,    0,     512},
+    {0x00730000, 0x00800040, 0x00080410},     //{0,    256,    0,    32,       0,   64,    32,  128,     512},
+    {0x00730000, 0x01000038, 0x00080410},     //{0,    224,    0,    64,       0,   64,    32,  128,     512},
+    {0x00730000, 0x02000038, 0x00040410},     //{0,    224,    0,   128,       0,   64,    32,   64,     512},
+    {0x00730000, 0x01000038, 0x00040420},     //{0,    224,    0,    64,       0,  128,    32,   64,     512},
+    {0x01730000, 0x00000038, 0x00080420},     //{0,    224,    0,     0,       0,  128,    32,  128,     512},
+    {0x01730000, 0x00000040, 0x00080020},     //{0,    256,    0,     0,       0,  128,     0,  128,     512},
+    {0x00730000, 0x020400a1, 0x00000000},      //{128,    128,    0,   128,     128,    0,     0,    0,     512},
+    {0x00730000, 0x010000a1, 0x00040810},      // {128,    128,    0,    64,       0,   64,    64,   64,     512},
+    {0x00730000, 0x008000a1, 0x00080410},      //{128,    128,    0,    32,       0,   64,    32,  128,     512},
+    {0x00730000, 0x008000a1, 0x00040420}      //{128,    128,    0,    32,       0,  128,   32,    64,     512}
+};
+
+static const L3_CONFIG_REGISTER_VALUES HSW_L3_PLANE[HSW_L3_CONFIG_NUM]  = 
+{                                                                    // SLM    URB   Rest DC     RO     I/S    C    T      Sum
+    {0x01610000, 0x00080040, 0x00000000},     // {0,    256,    0,     0,     256,    0,     0,    0,     512},
+    {0x00610000, 0x02040040, 0x00000000},     //{0,    256,    0,   128,     128,    0,     0,    0,     512},
+    {0x00610000, 0x00800040, 0x00080410},     //{0,    256,    0,    32,       0,   64,    32,  128,     512},
+    {0x00610000, 0x01000038, 0x00080410},     //{0,    224,    0,    64,       0,   64,    32,  128,     512},
+    {0x00610000, 0x02000038, 0x00040410},     //{0,    224,    0,   128,       0,   64,    32,   64,     512},
+    {0x00610000, 0x01000038, 0x00040420},     //{0,    224,    0,    64,       0,  128,    32,   64,     512},
+    {0x01610000, 0x00000038, 0x00080420},     //{0,    224,    0,     0,       0,  128,    32,  128,     512},
+    {0x01610000, 0x00000040, 0x00080020},     //{0,    256,    0,     0,       0,  128,     0,  128,     512},
+    {0x00610000, 0x020400a1, 0x00000000},      //{128,    128,    0,   128,     128,    0,     0,    0,     512},
+    {0x00610000, 0x010000a1, 0x00040810},      // {128,    128,    0,    64,       0,   64,    64,   64,     512},
+    {0x00610000, 0x008000a1, 0x00080410},      //{128,    128,    0,    32,       0,   64,    32,  128,     512},
+    {0x00610000, 0x008000a1, 0x00040420}      //{128,    128,    0,    32,       0,  128,   32,    64,     512}
+};
+
+static const L3_CONFIG_REGISTER_VALUES BDW_L3_PLANE[BDW_L3_CONFIG_NUM]  = 
+{                                                                    // SLM    URB   Rest DC     RO     I/S    C    T      Sum
+    {0x01610000, 0x00080040, 0x00000000},     //{0,    48,    48,    0,    0,    0,    0,    0,    96},
+    {0x00610000, 0x02040040, 0x00000000},     //{0,    48,    0,    16,    32,    0,    0,    0,    96},
+    {0x00610000, 0x02040040, 0x00000000},     //{0,    32,    0,    16,    48,    0,    0,    0,    96},
+    {0x00610000, 0x02040040, 0x00000000},     //{0,    32,    0,    0,    64,    0,    0,    0,    96},
+    {0x00610000, 0x02040040, 0x00000000},     //{0,    32,    64,    0,    0,    0,    0,    0,    96},
+    {0x00610000, 0x02040040, 0x00000000},     //{32,    16,    48,    0,    0,    0,    0,    0,    96},
+    {0x00610000, 0x02040040, 0x00000000},     //{32,    16,    0,    16,    32,    0,    0,    0,    96},
+    {0x00610000, 0x02040040, 0x00000000}      //{32,    16,    0,    32,    16,    0,    0,    0,    96}
+};
+
+/***********START SAMPLER8X8******************/
+//Sampler8x8 data structures
+
+typedef enum _CM_SAMPLER8x8_SURFACE_
+{
+    CM_AVS_SURFACE = 0,
+    CM_VA_SURFACE = 1
+}CM_SAMPLER8x8_SURFACE;
+
+typedef enum _CM_VA_PLUS_SURFACE_
+{
+    CM_VA_PLUS_OTHER = 0,
+    CM_VA_PLUS_CORRECLATION_SEARCH_SURFACE = 1,
+    CM_VA_PLUS_LBP_CORRELATION_SURFACE = 2
+}CM_VA_PLUS_SURFACE;
+
+typedef enum _CM_SURFACE_ADDRESS_CONTROL_MODE_
+{
+    CM_SURFACE_CLAMP = 0,
+    CM_SURFACE_MIRROR = 1
+}CM_SURFACE_ADDRESS_CONTROL_MODE;
+
+typedef enum _CM_MESSAGE_SEQUENCE_
+{
+    CM_MS_1x1   = 0,
+    CM_MS_16x1  = 1,
+    CM_MS_16x4  = 2,
+    CM_MS_32x1  = 3,
+    CM_MS_32x4  = 4,
+    CM_MS_64x1  = 5,
+    CM_MS_64x4  = 6
+}CM_MESSAGE_SEQUENCE;
+
+typedef enum _CM_MIN_MAX_FILTER_CONTROL_
+{
+    CM_MIN_FILTER   = 0,
+    CM_MAX_FILTER   = 1,
+    CM_BOTH_FILTER  = 3
+}CM_MIN_MAX_FILTER_CONTROL;
+
+typedef enum _CM_VA_FUNCTION_
+{
+    CM_VA_MINMAXFILTER  = 0,
+    CM_VA_DILATE        = 1,
+    CM_VA_ERODE         = 2
+} CM_VA_FUNCTION;
+
+//GT-PIN
+typedef struct _CM_SURFACE_DETAILS{
+    UINT        width; 
+    UINT        height; 
+    UINT        depth; 
+    CM_SURFACE_FORMAT   format; 
+    UINT        planeIndex;
+    UINT        pitch; 
+    UINT        slicePitch;
+    UINT        SurfaceBaseAddress;
+    UINT8       TiledSurface;
+    UINT8       TileWalk;
+    UINT        XOffset;
+    UINT        YOffset; 
+    
+}CM_SURFACE_DETAILS;
+
+
+/*
+ *  AVS SAMPLER8x8 STATE
+ */
+typedef struct _CM_AVS_COEFF_TABLE{
+    float   FilterCoeff_0_0;
+    float   FilterCoeff_0_1;
+    float   FilterCoeff_0_2;
+    float   FilterCoeff_0_3;
+    float   FilterCoeff_0_4;
+    float   FilterCoeff_0_5;
+    float   FilterCoeff_0_6;
+    float   FilterCoeff_0_7;
+}CM_AVS_COEFF_TABLE;
+
+typedef struct _CM_AVS_INTERNEL_COEFF_TABLE{
+    BYTE   FilterCoeff_0_0;
+    BYTE   FilterCoeff_0_1;
+    BYTE   FilterCoeff_0_2;
+    BYTE   FilterCoeff_0_3;
+    BYTE   FilterCoeff_0_4;
+    BYTE   FilterCoeff_0_5;
+    BYTE   FilterCoeff_0_6;
+    BYTE   FilterCoeff_0_7;
+}CM_AVS_INTERNEL_COEFF_TABLE;
+
+#define CM_NUM_COEFF_ROWS 17
+typedef struct _CM_AVS_NONPIPLINED_STATE{
+    bool BypassXAF;
+    bool BypassYAF;
+    BYTE DefaultSharpLvl;
+    BYTE maxDerivative4Pixels;
+    BYTE maxDerivative8Pixels;
+    BYTE transitionArea4Pixels;
+    BYTE transitionArea8Pixels;    
+    CM_AVS_COEFF_TABLE Tbl0X[CM_NUM_COEFF_ROWS];
+    CM_AVS_COEFF_TABLE Tbl0Y[CM_NUM_COEFF_ROWS];
+    CM_AVS_COEFF_TABLE Tbl1X[CM_NUM_COEFF_ROWS];
+    CM_AVS_COEFF_TABLE Tbl1Y[CM_NUM_COEFF_ROWS];
+}CM_AVS_NONPIPLINED_STATE;
+
+typedef struct _CM_AVS_INTERNEL_NONPIPLINED_STATE{
+    bool BypassXAF;
+    bool BypassYAF;
+    BYTE DefaultSharpLvl;
+    BYTE maxDerivative4Pixels;
+    BYTE maxDerivative8Pixels;
+    BYTE transitionArea4Pixels;
+    BYTE transitionArea8Pixels;    
+    CM_AVS_INTERNEL_COEFF_TABLE Tbl0X[CM_NUM_COEFF_ROWS];
+    CM_AVS_INTERNEL_COEFF_TABLE Tbl0Y[CM_NUM_COEFF_ROWS];
+    CM_AVS_INTERNEL_COEFF_TABLE Tbl1X[CM_NUM_COEFF_ROWS];
+    CM_AVS_INTERNEL_COEFF_TABLE Tbl1Y[CM_NUM_COEFF_ROWS];
+}CM_AVS_INTERNEL_NONPIPLINED_STATE;
+
+typedef struct _CM_AVS_STATE_MSG{
+    bool AVSTYPE; //true nearest, false adaptive    
+    bool EightTapAFEnable; //HSW+
+    bool BypassIEF; //ignored for BWL, moved to sampler8x8 payload.
+    bool ShuffleOutputWriteback; //SKL mode only to be set when AVS msg sequence is 4x4 or 8x4
+    unsigned short GainFactor;
+    unsigned char GlobalNoiseEstm;
+    unsigned char StrongEdgeThr;
+    unsigned char WeakEdgeThr;
+    unsigned char StrongEdgeWght;
+    unsigned char RegularWght;
+    unsigned char NonEdgeWght;
+    //For Non-piplined states
+    unsigned short stateID;
+    CM_AVS_NONPIPLINED_STATE * AvsState;
+} CM_AVS_STATE_MSG;
+
+/*
+ *  CONVOLVE STATE DATA STRUCTURES
+ */
+
+typedef struct _CM_CONVOLVE_COEFF_TABLE{
+    float   FilterCoeff_0_0;
+    float   FilterCoeff_0_1;
+    float   FilterCoeff_0_2;
+    float   FilterCoeff_0_3;
+    float   FilterCoeff_0_4;
+    float   FilterCoeff_0_5;
+    float   FilterCoeff_0_6;
+    float   FilterCoeff_0_7;
+    float   FilterCoeff_0_8;
+    float   FilterCoeff_0_9;
+    float   FilterCoeff_0_10;
+    float   FilterCoeff_0_11;
+    float   FilterCoeff_0_12;
+    float   FilterCoeff_0_13;
+    float   FilterCoeff_0_14;
+    float   FilterCoeff_0_15;
+    float   FilterCoeff_0_16;    
+    float   FilterCoeff_0_17;
+    float   FilterCoeff_0_18;
+    float   FilterCoeff_0_19;
+    float   FilterCoeff_0_20;
+    float   FilterCoeff_0_21;
+    float   FilterCoeff_0_22;
+    float   FilterCoeff_0_23;
+    float   FilterCoeff_0_24;
+    float   FilterCoeff_0_25;
+    float   FilterCoeff_0_26;
+    float   FilterCoeff_0_27;
+    float   FilterCoeff_0_28;
+    float   FilterCoeff_0_29;
+    float   FilterCoeff_0_30;
+    float   FilterCoeff_0_31;
+}CM_CONVOLVE_COEFF_TABLE;
+
+#define CM_NUM_CONVOLVE_ROWS 16
+#define CM_NUM_CONVOLVE_ROWS_SKL 32
+typedef struct _CM_CONVOLVE_STATE_MSG{
+        bool CoeffSize; //true 16-bit, false 8-bit
+        byte SclDwnValue; //Scale down value
+        byte Width; //Kernel Width
+        byte Height; //Kernel Height   
+        //SKL mode
+        bool isVertical32Mode;
+        bool isHorizontal32Mode;
+    CM_CONVOLVE_COEFF_TABLE Table[CM_NUM_CONVOLVE_ROWS_SKL];
+} CM_CONVOLVE_STATE_MSG;
+
+/*
+ *   MISC SAMPLER8x8 State
+ */
+typedef struct _CM_MISC_STATE {
+    //DWORD 0
+    union{
+        struct{
+            DWORD   Row0      : 16;
+            DWORD   Reserved  : 8;
+            DWORD   Width     : 4;
+            DWORD   Height    : 4;
+        };
+        struct{
+            DWORD value;
+        };
+    } DW0;
+
+    //DWORD 1
+    union{
+        struct{
+            DWORD   Row1      : 16;
+            DWORD   Row2      : 16;
+        };
+        struct{
+            DWORD value;
+        };
+    } DW1;
+
+    //DWORD 2
+    union{
+        struct{
+            DWORD   Row3      : 16;
+            DWORD   Row4      : 16;
+        };
+        struct{
+            DWORD value;
+        };
+    } DW2;
+
+    //DWORD 3
+    union{
+        struct{
+            DWORD   Row5      : 16;
+            DWORD   Row6      : 16;
+        };
+        struct{
+            DWORD value;
+        };
+    } DW3;
+
+    //DWORD 4
+    union{
+        struct{
+            DWORD   Row7      : 16;
+            DWORD   Row8      : 16;
+        };
+        struct{
+            DWORD value;
+        };
+    } DW4;
+
+    //DWORD 5
+    union{
+        struct{
+            DWORD   Row9      : 16;
+            DWORD   Row10      : 16;
+        };
+        struct{
+            DWORD value;
+        };
+    } DW5;
+
+    //DWORD 6
+    union{
+        struct{
+            DWORD   Row11      : 16;
+            DWORD   Row12      : 16;
+        };
+        struct{
+            DWORD value;
+        };
+    } DW6;
+
+    //DWORD 7
+    union{
+        struct{
+            DWORD   Row13      : 16;
+            DWORD   Row14      : 16;
+        };
+        struct{
+            DWORD value;
+        };
+    } DW7;
+} CM_MISC_STATE;
+ 
+typedef struct _CM_MISC_STATE_MSG{
+    //DWORD 0
+    union{
+        struct{
+            DWORD   Row0      : 16;
+            DWORD   Reserved  : 8;
+            DWORD   Width     : 4;
+            DWORD   Height    : 4;
+        };
+        struct{
+            DWORD value;
+        };
+    }DW0;
+
+    //DWORD 1
+    union{
+        struct{
+            DWORD   Row1      : 16;
+            DWORD   Row2      : 16;
+        };
+        struct{
+            DWORD value;
+        };
+    }DW1;
+
+    //DWORD 2
+    union{
+        struct{
+            DWORD   Row3      : 16;
+            DWORD   Row4      : 16;
+        };
+        struct{
+            DWORD value;
+        };
+    }DW2;
+
+    //DWORD 3
+    union{
+        struct{
+            DWORD   Row5      : 16;
+            DWORD   Row6      : 16;
+        };
+        struct{
+            DWORD value;
+        };
+    }DW3;
+
+    //DWORD 4
+    union{
+        struct{
+            DWORD   Row7      : 16;
+            DWORD   Row8      : 16;
+        };
+        struct{
+            DWORD value;
+        };
+    }DW4;
+
+    //DWORD 5
+    union{
+        struct{
+            DWORD   Row9      : 16;
+            DWORD   Row10      : 16;
+        };
+        struct{
+            DWORD value;
+        };
+    }DW5;
+
+    //DWORD 6
+    union{
+        struct{
+            DWORD   Row11      : 16;
+            DWORD   Row12      : 16;
+        };
+        struct{
+            DWORD value;
+        };
+    }DW6;
+
+    //DWORD 7
+    union{
+        struct{
+            DWORD   Row13      : 16;
+            DWORD   Row14      : 16;
+        };
+        struct{
+            DWORD value;
+        };
+    }DW7;
+} CM_MISC_STATE_MSG;
+
+typedef enum _CM_SAMPLER_STATE_TYPE_
+{
+    CM_SAMPLER8X8_AVS   = 0,
+    CM_SAMPLER8X8_CONV  = 1,
+    CM_SAMPLER8X8_MISC  = 3,
+    CM_SAMPLER8X8_NONE
+}CM_SAMPLER_STATE_TYPE;
+
+typedef struct _CM_SAMPLER_8X8_DESCR{
+    CM_SAMPLER_STATE_TYPE stateType;
+    union
+    {
+        CM_AVS_STATE_MSG * avs;
+        CM_CONVOLVE_STATE_MSG * conv;
+        CM_MISC_STATE_MSG * misc; //ERODE/DILATE/MINMAX
+    };
+} CM_SAMPLER_8X8_DESCR;
+
+typedef  struct _CM_HAL_AVS_PARAM {
+    CM_AVS_STATE_MSG avs;
+    CM_AVS_INTERNEL_NONPIPLINED_STATE avs_nonpipelined;
+} CM_HAL_AVS_PARAM;
+
+typedef struct _CM_SAMPLER_8X8_STATE {
+    CM_SAMPLER_STATE_TYPE stateType;
+    union {
+        CM_HAL_AVS_PARAM           avs_state;
+        CM_CONVOLVE_STATE_MSG convolve_state;
+        CM_MISC_STATE                  misc_state;
+    };
+} CM_SAMPLER_8X8_STATE;
+
+typedef struct _CM_HAL_SAMPLER_8X8_STATE_PARAM{
+    CM_SAMPLER_8X8_STATE    sampler8x8State;
+    DWORD                              dwHandle;                                       // [out] Handle 
+} CM_HAL_SAMPLER_8X8_STATE_PARAM;
+
+//GT-PINS urfaceDetails
+typedef struct _CM_HAL_SURFACE_DETAILS{
+    CM_SAMPLER_8X8_STATE    sampler8x8State;
+    DWORD                   dwHandle;                                       // [out] Handle 
+} CM_HAL_SURFACE_DETAILS;
+
+//!
+//! CM Sampler8X8 
+//!
+class CmSampler8x8
+{
+public:
+    CM_RT_API virtual INT GetIndex( SamplerIndex* & pIndex ) = 0 ;
+
+};
+/***********END SAMPLER8X8********************/
+class CmEvent
+{
+public:
+    CM_RT_API virtual INT GetStatus( CM_STATUS& status) = 0 ;
+    CM_RT_API virtual INT GetExecutionTime(UINT64& time) = 0;
+    CM_RT_API virtual INT WaitForTaskFinished(DWORD dwTimeOutMs = CM_MAX_TIMEOUT_MS) = 0 ;
+};
+
+class CmThreadSpace;
+
+class CmKernel
+{
+public:       
+    CM_RT_API virtual INT SetThreadCount(UINT count ) = 0;
+    CM_RT_API virtual INT SetKernelArg(UINT index, size_t size, const void * pValue ) = 0;
+
+    CM_RT_API virtual INT SetThreadArg(UINT threadId, UINT index, size_t size, const void * pValue ) = 0;
+    CM_RT_API virtual INT SetStaticBuffer(UINT index, const void * pValue ) = 0;
+
+    CM_RT_API virtual INT SetKernelPayloadData(size_t size, const void *pValue) = 0;
+    CM_RT_API virtual INT SetKernelPayloadSurface(UINT surfaceCount, SurfaceIndex** pSurfaces) = 0;
+    CM_RT_API virtual INT SetSurfaceBTI(SurfaceIndex* pSurface, UINT BTIndex) = 0;    
+
+    CM_RT_API virtual INT AssociateThreadSpace(CmThreadSpace* & pTS) = 0;
+};
+
+class CmTask
+{
+public:       
+    CM_RT_API virtual INT AddKernel(CmKernel *pKernel) = 0;
+    CM_RT_API virtual INT Reset(void) = 0;
+    CM_RT_API virtual INT AddSync(void) = 0;
+}; 
+
+class CmProgram;
+class SurfaceIndex;
+class SamplerIndex;
+
+class CmBuffer
+{
+public:
+    CM_RT_API virtual INT GetIndex( SurfaceIndex*& pIndex ) = 0; 
+    CM_RT_API virtual INT ReadSurface( unsigned char* pSysMem, CmEvent* pEvent, UINT64 sysMemSize = 0xFFFFFFFFFFFFFFFFULL ) = 0;
+    CM_RT_API virtual INT WriteSurface( const unsigned char* pSysMem, CmEvent* pEvent, UINT64 sysMemSize = 0xFFFFFFFFFFFFFFFFULL ) = 0;
+    CM_RT_API virtual INT InitSurface(const DWORD initValue, CmEvent* pEvent) = 0;
+    CM_RT_API virtual INT SetMemoryObjectControl(MEMORY_OBJECT_CONTROL mem_ctrl, MEMORY_TYPE mem_type, UINT  age) = 0;
+};
+
+class CmBufferUP
+{
+public:
+    CM_RT_API virtual INT GetIndex( SurfaceIndex*& pIndex ) = 0; 
+    CM_RT_API virtual INT SetMemoryObjectControl(MEMORY_OBJECT_CONTROL mem_ctrl, MEMORY_TYPE mem_type, UINT  age) = 0;
+};
+
+class CmSurface2D
+{
+public:    
+    CM_RT_API virtual INT GetIndex( SurfaceIndex*& pIndex ) = 0; 
+
+#ifdef CM_DX9
+    CM_RT_API virtual INT GetD3DSurface( IDirect3DSurface9*& pD3DSurface) = 0;
+#elif defined(CM_DX11)
+    CM_RT_API virtual INT GetD3DSurface( ID3D11Texture2D*& pD3D11Texture2D) = 0;
+#endif
+
+    CM_RT_API virtual INT ReadSurface( unsigned char* pSysMem, CmEvent* pEvent, UINT64 sysMemSize = 0xFFFFFFFFFFFFFFFFULL ) = 0;
+    CM_RT_API virtual INT WriteSurface( const unsigned char* pSysMem, CmEvent* pEvent, UINT64 sysMemSize = 0xFFFFFFFFFFFFFFFFULL ) = 0;
+    CM_RT_API virtual INT ReadSurfaceStride( unsigned char* pSysMem, CmEvent* pEvent, const UINT stride, UINT64 sysMemSize = 0xFFFFFFFFFFFFFFFFULL ) = 0;
+    CM_RT_API virtual INT WriteSurfaceStride( const unsigned char* pSysMem, CmEvent* pEvent, const UINT stride, UINT64 sysMemSize = 0xFFFFFFFFFFFFFFFFULL ) = 0;
+    CM_RT_API virtual INT InitSurface(const DWORD initValue, CmEvent* pEvent) = 0;
+#ifdef CM_DX11
+    CM_RT_API virtual INT QuerySubresourceIndex(UINT& FirstArraySlice, UINT& FirstMipSlice) = 0;
+#endif
+    CM_RT_API virtual INT SetMemoryObjectControl(MEMORY_OBJECT_CONTROL mem_ctrl, MEMORY_TYPE mem_type, UINT  age) = 0;
+    CM_RT_API virtual INT SetSurfaceState(UINT iWidth, UINT iHeight, CM_SURFACE_FORMAT Format, CM_BOUNDARY_PIXEL_MODE boundaryMode) = 0;
+};
+
+class CmSurface2DUP  
+{
+public:    
+    CM_RT_API virtual INT GetIndex( SurfaceIndex*& pIndex ) = 0; 
+    CM_RT_API virtual INT SetMemoryObjectControl(MEMORY_OBJECT_CONTROL mem_ctrl, MEMORY_TYPE mem_type, UINT  age) = 0;
+};
+
+class CmSurface3D  
+{
+public:    
+    CM_RT_API virtual INT GetIndex( SurfaceIndex*& pIndex ) = 0; 
+    CM_RT_API virtual INT ReadSurface( unsigned char* pSysMem, CmEvent* pEvent, UINT64 sysMemSize = 0xFFFFFFFFFFFFFFFFULL ) = 0;
+    CM_RT_API virtual INT WriteSurface( const unsigned char* pSysMem, CmEvent* pEvent, UINT64 sysMemSize = 0xFFFFFFFFFFFFFFFFULL ) = 0;
+    CM_RT_API virtual INT InitSurface(const DWORD initValue, CmEvent* pEvent) = 0;
+    CM_RT_API virtual INT SetMemoryObjectControl(MEMORY_OBJECT_CONTROL mem_ctrl, MEMORY_TYPE mem_type, UINT  age) = 0;
+};
+
+class CmSampler
+{
+public:
+    CM_RT_API virtual INT GetIndex( SamplerIndex* & pIndex ) = 0 ;
+};
+
+class CmThreadSpace
+{
+public:
+    CM_RT_API virtual INT AssociateThread( UINT x, UINT y, CmKernel* pKernel , UINT threadId ) = 0;
+    CM_RT_API virtual INT SelectThreadDependencyPattern ( CM_DEPENDENCY_PATTERN pattern ) = 0;
+    CM_RT_API virtual INT AssociateThreadWithMask( UINT x, UINT y, CmKernel* pKernel, UINT threadId, BYTE nDependencyMask ) = 0;
+    CM_RT_API virtual INT SetThreadSpaceColorCount( UINT colorCount ) = 0;
+};
+
+class CmThreadGroupSpace;
+
+class CmQueue
+{
+public:    
+    CM_RT_API virtual INT Enqueue( CmTask* pTask, CmEvent* & pEvent, const CmThreadSpace* pTS = NULL ) = 0;
+    CM_RT_API virtual INT DestroyEvent( CmEvent* & pEvent ) = 0; 
+    CM_RT_API virtual INT EnqueueWithGroup( CmTask* pTask, CmEvent* & pEvent, const CmThreadGroupSpace* pTGS = NULL )=0;
+    CM_RT_API virtual INT EnqueueCopyCPUToGPU( CmSurface2D* pSurface, const unsigned char* pSysMem, CmEvent* & pEvent ) = 0; 
+    CM_RT_API virtual INT EnqueueCopyGPUToCPU( CmSurface2D* pSurface, unsigned char* pSysMem, CmEvent* & pEvent ) = 0;
+    CM_RT_API virtual INT EnqueueCopyCPUToGPUStride( CmSurface2D* pSurface, const unsigned char* pSysMem, const UINT stride, CmEvent* & pEvent ) = 0; 
+    CM_RT_API virtual INT EnqueueCopyGPUToCPUStride( CmSurface2D* pSurface, unsigned char* pSysMem, const UINT stride, CmEvent* & pEvent ) = 0;
+    CM_RT_API virtual INT EnqueueInitSurface2D( CmSurface2D* pSurface, const DWORD initValue, CmEvent* &pEvent ) = 0;
+    CM_RT_API virtual INT EnqueueCopyGPUToGPU( CmSurface2D* pOutputSurface, CmSurface2D* pInputSurface, CmEvent* & pEvent ) = 0;
+    CM_RT_API virtual INT EnqueueCopyCPUToCPU( unsigned char* pDstSysMem, unsigned char* pSrcSysMem, UINT size, CmEvent* & pEvent ) = 0;
+    CM_RT_API virtual INT EnqueueCopyCPUToGPUFullStride( CmSurface2D* pSurface, const unsigned char* pSysMem, const UINT widthStride, const UINT heightStride, const UINT option, CmEvent* & pEvent ) = 0;
+    CM_RT_API virtual INT EnqueueCopyGPUToCPUFullStride( CmSurface2D* pSurface, unsigned char* pSysMem, const UINT widthStride, const UINT heightStride, const UINT option, CmEvent* & pEvent ) = 0;
+    CM_RT_API virtual INT EnqueueWithHints( CmTask* pTask, CmEvent* & pEvent, UINT hints = 0) = 0;
+};
+
+class CmVmeState
+{
+public:
+    CM_RT_API virtual INT GetIndex( VmeIndex* & pIndex ) = 0 ;
+};
+
+class CmDevice
+{
+public:
+
+#ifdef CM_DX9
+    CM_RT_API virtual INT GetD3DDeviceManager( IDirect3DDeviceManager9* & pDeviceManager )= 0;
+#endif
+
+    CM_RT_API virtual INT CreateBuffer(UINT size, CmBuffer* & pSurface )=0;
+    CM_RT_API virtual INT CreateSurface2D(UINT width, UINT height, CM_SURFACE_FORMAT format, CmSurface2D* & pSurface ) = 0;
+    CM_RT_API virtual INT CreateSurface3D(UINT width, UINT height, UINT depth, CM_SURFACE_FORMAT format, CmSurface3D* & pSurface ) = 0;
+
+#ifdef CM_DX9
+    CM_RT_API virtual INT CreateSurface2D( IDirect3DSurface9* pD3DSurf, CmSurface2D* & pSurface ) = 0;
+    CM_RT_API virtual INT CreateSurface2D( IDirect3DSurface9** pD3DSurf, const UINT surfaceCount, CmSurface2D**  pSpurface )= 0;
+#elif defined(CM_DX11)
+    CM_RT_API virtual INT CreateSurface2D( ID3D11Texture2D* pD3DSurf, CmSurface2D* & pSurface ) = 0;
+    CM_RT_API virtual INT CreateSurface2D( ID3D11Texture2D** pD3DSurf, const UINT surfaceCount, CmSurface2D**  pSpurface )= 0;
+#elif defined (__GNUC__)
+    CM_RT_API virtual INT CreateSurface2D( VASurfaceID  iVASurface, CmSurface2D* & pSurface ) = 0;
+    CM_RT_API virtual INT CreateSurface2D( VASurfaceID* iVASurface, const UINT surfaceCount, CmSurface2D** pSurface ) = 0;
+#endif
+    
+    CM_RT_API virtual INT DestroySurface( CmBuffer* & pSurface) = 0;
+    CM_RT_API virtual INT DestroySurface( CmSurface2D* & pSurface) = 0;
+    CM_RT_API virtual INT DestroySurface( CmSurface3D* & pSurface) = 0;
+  
+    CM_RT_API virtual INT CreateQueue( CmQueue* & pQueue) = 0; 
+    CM_RT_API virtual INT LoadProgram( void* pCommonISACode, const UINT size, CmProgram*& pProgram, const char* options = NULL ) = 0;
+    CM_RT_API virtual INT CreateKernel( CmProgram* pProgram, const char* kernelName, CmKernel* & pKernel, const char* options = NULL) = 0;
+    CM_RT_API virtual INT CreateKernel( CmProgram* pProgram, const char* kernelName, const void * fncPnt, CmKernel* & pKernel, const char* options = NULL) = 0;
+    CM_RT_API virtual INT CreateSampler( const CM_SAMPLER_STATE & sampleState, CmSampler* & pSampler ) = 0;
+
+    CM_RT_API virtual INT DestroyKernel( CmKernel*& pKernel) = 0;
+    CM_RT_API virtual INT DestroySampler( CmSampler*& pSampler ) = 0;
+    CM_RT_API virtual INT DestroyProgram( CmProgram*& pProgram ) = 0;
+    CM_RT_API virtual INT DestroyThreadSpace( CmThreadSpace* & pTS ) = 0; 
+
+    CM_RT_API virtual INT CreateTask(CmTask *& pTask)=0;
+    CM_RT_API virtual INT DestroyTask(CmTask*& pTask)=0;
+
+    CM_RT_API virtual INT GetCaps(CM_DEVICE_CAP_NAME capName, size_t& capValueSize, void* pCapValue ) = 0;
+
+    CM_RT_API virtual INT CreateVmeStateG6( const VME_STATE_G6 & vmeState, CmVmeState* & pVmeState ) = 0;
+    CM_RT_API virtual INT DestroyVmeStateG6( CmVmeState*& pVmeState ) = 0;
+
+    CM_RT_API virtual INT CreateVmeSurfaceG6( CmSurface2D* pCurSurface, CmSurface2D* pForwardSurface, CmSurface2D* pBackwardSurface, SurfaceIndex* & pVmeIndex ) = 0;
+    CM_RT_API virtual INT DestroyVmeSurfaceG6( SurfaceIndex* & pVmeIndex ) = 0;
+
+    CM_RT_API virtual INT CreateThreadSpace( UINT width, UINT height, CmThreadSpace* & pTS ) = 0;
+
+    CM_RT_API virtual INT CreateBufferUP(UINT size, void* pSystMem, CmBufferUP* & pSurface )=0;
+    CM_RT_API virtual INT DestroyBufferUP( CmBufferUP* & pSurface) = 0;
+
+    CM_RT_API virtual INT GetSurface2DInfo( UINT width, UINT height, CM_SURFACE_FORMAT format, UINT & pitch, UINT & physicalSize)= 0;
+    CM_RT_API virtual INT CreateSurface2DUP( UINT width, UINT height, CM_SURFACE_FORMAT format, void* pSysMem, CmSurface2DUP* & pSurface )= 0;
+    CM_RT_API virtual INT DestroySurface2DUP( CmSurface2DUP* & pSurface) = 0;
+
+    CM_RT_API virtual INT CreateVmeSurfaceG7_5 ( CmSurface2D* pCurSurface, CmSurface2D** pForwardSurface, CmSurface2D** pBackwardSurface, const UINT surfaceCountForward, const UINT surfaceCountBackward, SurfaceIndex* & pVmeIndex )=0;
+    CM_RT_API virtual INT DestroyVmeSurfaceG7_5( SurfaceIndex* & pVmeIndex ) = 0;
+    CM_RT_API virtual INT CreateSampler8x8(const CM_SAMPLER_8X8_DESCR  & smplDescr, CmSampler8x8*& psmplrState)=0;
+    CM_RT_API virtual INT DestroySampler8x8( CmSampler8x8*& pSampler )=0;
+    CM_RT_API virtual INT CreateSampler8x8Surface(CmSurface2D* p2DSurface, SurfaceIndex* & pDIIndex, CM_SAMPLER8x8_SURFACE surf_type = CM_VA_SURFACE, CM_SURFACE_ADDRESS_CONTROL_MODE = CM_SURFACE_CLAMP )=0;
+    CM_RT_API virtual INT DestroySampler8x8Surface(SurfaceIndex* & pDIIndex)=0;
+
+    CM_RT_API virtual INT CreateThreadGroupSpace( UINT thrdSpaceWidth, UINT thrdSpaceHeight, UINT grpSpaceWidth, UINT grpSpaceHeight, CmThreadGroupSpace*& pTGS ) = 0;
+    CM_RT_API virtual INT DestroyThreadGroupSpace(CmThreadGroupSpace*& pTGS) = 0;
+    CM_RT_API virtual INT SetL3Config( L3_CONFIG_REGISTER_VALUES *l3_c) = 0;
+    CM_RT_API virtual INT SetSuggestedL3Config( L3_SUGGEST_CONFIG l3_s_c) = 0;
+
+    CM_RT_API virtual INT SetCaps(CM_DEVICE_CAP_NAME capName, size_t capValueSize, void* pCapValue) = 0;
+
+    CM_RT_API virtual INT CreateGroupedVAPlusSurface(CmSurface2D* p2DSurface1, CmSurface2D* p2DSurface2, SurfaceIndex* & pDIIndex, CM_SURFACE_ADDRESS_CONTROL_MODE = CM_SURFACE_CLAMP)=0;
+    CM_RT_API virtual INT DestroyGroupedVAPlusSurface(SurfaceIndex* & pDIIndex)=0;
+
+#ifdef CM_DX11
+    CM_RT_API virtual INT GetD3D11Device(ID3D11Device* &pD3D11Device) = 0;
+#endif
+
+    CM_RT_API virtual INT CreateSamplerSurface2D(CmSurface2D* p2DSurface, SurfaceIndex* & pSamplerSurfaceIndex) = 0;
+    CM_RT_API virtual INT CreateSamplerSurface3D(CmSurface3D* p3DSurface, SurfaceIndex* & pSamplerSurfaceIndex) = 0;
+    CM_RT_API virtual INT DestroySamplerSurface(SurfaceIndex* & pSamplerSurfaceIndex) = 0;
+    CM_RT_API virtual INT GetRTDllVersion(CM_DLL_FILE_VERSION* pFileVersion) = 0;
+    CM_RT_API virtual INT GetJITDllVersion(CM_DLL_FILE_VERSION* pFileVersion) = 0;
+
+    CM_RT_API virtual INT InitPrintBuffer(size_t printbufsize = 1048576) = 0; 
+    CM_RT_API virtual INT FlushPrintBuffer() = 0;
+
+#ifdef CM_DX11
+    CM_RT_API virtual INT CreateSurface2DSubresource( ID3D11Texture2D* pD3D11Texture2D, UINT subresourceCount, CmSurface2D** ppSurfaces, UINT& createdSurfaceCount, UINT option = 0 ) = 0;
+    CM_RT_API virtual INT CreateSurface2DbySubresourceIndex( ID3D11Texture2D* pD3D11Texture2D, UINT FirstArraySlice, UINT FirstMipSlice, CmSurface2D* &pSurface) = 0;
+#endif
+};
+
+typedef void (*IMG_WALKER_FUNTYPE)(void* img, void* arg);
+
+EXTERN_C CM_RT_API void  CMRT_SetHwDebugStatus(bool bInStatus);
+EXTERN_C CM_RT_API bool CMRT_GetHwDebugStatus();
+EXTERN_C CM_RT_API INT CMRT_GetSurfaceDetails(CmEvent* pEvent, UINT kernIndex, UINT surfBTI, CM_SURFACE_DETAILS& outDetails);
+EXTERN_C CM_RT_API void CMRT_PrepareGTPinBuffers(void* ptr0, int size0InBytes, void* ptr1, int size1InBytes, void* ptr2, int size2InBytes);
+EXTERN_C CM_RT_API void CMRT_SetGTPinArguments(char* commandLine, void* gtpinInvokeStruct);
+EXTERN_C CM_RT_API void CMRT_EnableGTPinMarkers(void);
+
+EXTERN_C CM_RT_API INT DestroyCmDevice(CmDevice* &pD);
+
+#define CM_CALLBACK __cdecl
+typedef void (CM_CALLBACK *callback_function)(CmEvent*, void *);
+
+EXTERN_C CM_RT_API UINT CMRT_GetKernelCount(CmEvent *pEvent);
+EXTERN_C CM_RT_API INT CMRT_GetKernelName(CmEvent *pEvent, UINT index, char** KernelName);
+EXTERN_C CM_RT_API INT CMRT_GetKernelThreadSpace(CmEvent *pEvent, UINT index, UINT* localWidth, UINT* localHeight, UINT* globalWidth, UINT* globalHeight);
+EXTERN_C CM_RT_API INT CMRT_GetSubmitTime(CmEvent *pEvent, LARGE_INTEGER* time);
+EXTERN_C CM_RT_API INT CMRT_GetHWStartTime(CmEvent *pEvent, LARGE_INTEGER* time);
+EXTERN_C CM_RT_API INT CMRT_GetHWEndTime(CmEvent *pEvent, LARGE_INTEGER* time);
+EXTERN_C CM_RT_API INT CMRT_GetCompleteTime(CmEvent *pEvent, LARGE_INTEGER* time);
+EXTERN_C CM_RT_API INT CMRT_SetEventCallback(CmEvent* pEvent, callback_function function, void* user_data);
+EXTERN_C CM_RT_API INT CMRT_Enqueue(CmQueue* pQueue, CmTask* pTask, CmEvent** pEvent, const CmThreadSpace* pTS = NULL);
+
+#ifdef CM_DX9
+    EXTERN_C CM_RT_API INT CreateCmDevice(CmDevice* &pD, UINT& version, IDirect3DDeviceManager9* pD3DDeviceMgr = NULL );
+    EXTERN_C CM_RT_API INT CreateCmDeviceEx(CmDevice* &pD, UINT & version, IDirect3DDeviceManager9* pD3DDeviceMgr, UINT  DevCreateOption = CM_DEVICE_CREATE_OPTION_DEFAULT);
+    EXTERN_C CM_RT_API INT CreateCmDeviceEmu(CmDevice* &pDevice, UINT& version, IDirect3DDeviceManager9* pD3DDeviceMgr = NULL );
+    EXTERN_C CM_RT_API INT DestroyCmDeviceEmu(CmDevice* &pDevice, IDirect3DDeviceManager9* pD3DDeviceMgr = NULL );
+    EXTERN_C CM_RT_API INT CreateCmDeviceSim(CmDevice* &pDevice, UINT& version, IDirect3DDeviceManager9* pD3DDeviceMgr = NULL );
+    EXTERN_C CM_RT_API INT DestroyCmDeviceSim(CmDevice* &pDevice, IDirect3DDeviceManager9* pD3DDeviceMgr = NULL );
+#elif defined(CM_DX11)
+    EXTERN_C CM_RT_API INT CreateCmDevice(CmDevice* &pD, UINT& version, ID3D11Device* pD3D11Device = NULL);
+    EXTERN_C CM_RT_API INT CreateCmDeviceEx(CmDevice* &pD, UINT & version, ID3D11Device* pD3D11Device, UINT  DevCreateOption = CM_DEVICE_CREATE_OPTION_DEFAULT);
+    EXTERN_C CM_RT_API INT CreateCmDeviceEmu(CmDevice* &pDevice, UINT& version, ID3D11Device* pD3DDeviceMgr = NULL );
+    EXTERN_C CM_RT_API INT DestroyCmDeviceEmu(CmDevice* &pDevice, ID3D11Device* pD3DDeviceMgr = NULL );
+    EXTERN_C CM_RT_API INT CreateCmDeviceSim(CmDevice* &pDevice, UINT& version, ID3D11Device* pD3DDeviceMgr = NULL );
+    EXTERN_C CM_RT_API INT DestroyCmDeviceSim(CmDevice* &pDevice, ID3D11Device* pD3DDeviceMgr = NULL );
+#elif defined(__GNUC__)
+    EXTERN_C CM_RT_API INT CreateCmDevice(CmDevice* &pD, UINT& version, VADisplay va_dpy = NULL);
+    EXTERN_C CM_RT_API INT CreateCmDeviceEx(CmDevice* &pD, UINT & version, VADisplay va_dpy, UINT  DevCreateOption = CM_DEVICE_CREATE_OPTION_DEFAULT);
+    EXTERN_C CM_RT_API INT CreateCmDeviceEmu(CmDevice* &pDevice, UINT& version, VADisplay va_dpy = NULL);
+    EXTERN_C CM_RT_API INT DestroyCmDeviceEmu(CmDevice* &pDevice);
+    EXTERN_C CM_RT_API INT CreateCmDeviceSim(CmDevice* &pDevice, UINT& version);
+    EXTERN_C CM_RT_API INT DestroyCmDeviceSim(CmDevice* &pDevice);
+#endif
+
+#ifdef CMRT_EMU
+    #define CreateCmDevice CreateCmDeviceEmu
+    #define DestroyCmDevice DestroyCmDeviceEmu
+#elif CMRT_SIM
+    #define CreateCmDevice CreateCmDeviceSim
+    #define DestroyCmDevice DestroyCmDeviceSim
+#endif
diff --git a/inc/cm/cm_rt_linux.h b/inc/cm/cm_rt_linux.h
new file mode 100644
index 0000000..07208ac
--- /dev/null
+++ b/inc/cm/cm_rt_linux.h
@@ -0,0 +1,309 @@
+/**             
+***
+*** Copyright  (C) 1985-2011 Intel Corporation. All rights reserved.
+***
+*** The information and source code contained herein is the exclusive
+*** property of Intel Corporation. and may not be disclosed, examined
+*** or reproduced in whole or in part without explicit written authorization
+*** from the company.
+***
+*** ----------------------------------------------------------------------------
+**/  
+#pragma once
+#include <time.h>
+#include <va/va.h>
+
+#define _tmain main
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <math.h>
+#include <malloc.h>
+#include <string.h>
+#include <sys/time.h>
+#include <pthread.h>
+
+typedef int                BOOL;
+typedef char               byte;
+typedef unsigned char      BYTE;
+typedef unsigned int       UINT32;
+typedef unsigned int       DWORD;
+typedef int                INT;
+typedef unsigned int       UINT;
+typedef signed char        INT8;
+typedef unsigned char      UINT8;
+typedef signed short       INT16;
+typedef unsigned short     UINT16;
+typedef signed int         INT32;
+typedef signed long long   INT64;
+typedef unsigned long long UINT64;
+
+typedef enum _VACMTEXTUREADDRESS {
+    VACMTADDRESS_WRAP            = 1,
+    VACMTADDRESS_MIRROR          = 2,
+    VACMTADDRESS_CLAMP           = 3,
+    VACMTADDRESS_BORDER          = 4,
+    VACMTADDRESS_MIRRORONCE      = 5,
+
+    VACMTADDRESS_FORCE_DWORD     = 0x7fffffff
+} VACMTEXTUREADDRESS;
+
+typedef enum _VACMTEXTUREFILTERTYPE {
+    VACMTEXF_NONE            = 0,
+    VACMTEXF_POINT           = 1,
+    VACMTEXF_LINEAR          = 2,
+    VACMTEXF_ANISOTROPIC     = 3,
+    VACMTEXF_FLATCUBIC       = 4,
+    VACMTEXF_GAUSSIANCUBIC   = 5,
+    VACMTEXF_PYRAMIDALQUAD   = 6,
+    VACMTEXF_GAUSSIANQUAD    = 7,
+    VACMTEXF_CONVOLUTIONMONO = 8,    // Convolution filter for monochrome textures
+    VACMTEXF_FORCE_DWORD     = 0x7fffffff
+} VACMTEXTUREFILTERTYPE;
+
+#define CM_MAX_TIMEOUT 2
+
+#define CM_ATTRIBUTE(attribute) __attribute__((attribute))
+
+typedef enum _VA_CM_FORMAT {
+
+    VA_CM_FMT_UNKNOWN              =  0,
+
+    VA_CM_FMT_A8R8G8B8             =  21,
+    VA_CM_FMT_X8R8G8B8             =  22,
+    VA_CM_FMT_A8                   =  28,
+    VA_CM_FMT_A2B10G10R10          =  31,
+    VA_CM_FMT_A16B16G16R16         =  36,
+    VA_CM_FMT_P8                   =  41,
+    VA_CM_FMT_L8                   =  50,
+    VA_CM_FMT_A8L8                 =  51,
+    VA_CM_FMT_V8U8                 =  60,
+    VA_CM_FMT_D16                  =  80,
+    VA_CM_FMT_L16                  =  81,
+    VA_CM_FMT_A16B16G16R16F        =  113,
+    VA_CM_FMT_R32F                 =  114,
+    VA_CM_FMT_NV12                 =  VA_FOURCC_NV12,
+    VA_CM_FMT_UYVY                 =  VA_FOURCC_UYVY,
+    VA_CM_FMT_YUY2                 =  VA_FOURCC_YUY2,
+
+    VA_CM_FMT_MAX                   = 0xFFFFFFFF
+} VA_CM_FORMAT;
+
+// FIXME temp solution to have same type name as generated by VC++
+template<typename T>
+inline const char * CM_TYPE_NAME_UNMANGLED();
+
+// FIXME need inline below functions, otherwise it will cause multiple definition when ld
+template<> inline const char * CM_TYPE_NAME_UNMANGLED<char>() { return "char"; }
+template<> inline const char * CM_TYPE_NAME_UNMANGLED<signed char>() { return "signed char"; }
+template<> inline const char * CM_TYPE_NAME_UNMANGLED<unsigned char>() { return "unsigned char"; }
+template<> inline const char * CM_TYPE_NAME_UNMANGLED<short>() { return "short"; }
+template<> inline const char * CM_TYPE_NAME_UNMANGLED<unsigned short>() { return "unsigned short"; }
+template<> inline const char * CM_TYPE_NAME_UNMANGLED<int>() { return "int"; }
+template<> inline const char * CM_TYPE_NAME_UNMANGLED<unsigned int>() { return "unsigned int"; }
+template<> inline const char * CM_TYPE_NAME_UNMANGLED<long>() { return "long"; }
+template<> inline const char * CM_TYPE_NAME_UNMANGLED<unsigned long>() { return "unsigned long"; }
+template<> inline const char * CM_TYPE_NAME_UNMANGLED<float>() { return "float"; }
+template<> inline const char * CM_TYPE_NAME_UNMANGLED<double>() { return "double"; }
+
+#define CM_TYPE_NAME(type)   CM_TYPE_NAME_UNMANGLED<type>()
+
+inline void * CM_ALIGNED_MALLOC(size_t size, size_t alignment) 
+{
+  return memalign(alignment, size);
+} 
+
+inline void CM_ALIGNED_FREE(void * memory) 
+{
+  free(memory);
+}
+
+//multi-thread API: 
+#define THREAD_HANDLE pthread_t
+inline void CM_THREAD_CREATE(THREAD_HANDLE *handle, void * start_routine, void * arg) 
+{
+    int err = 0;
+    err = pthread_create(handle , NULL, (void * (*)(void *))start_routine, arg);
+    if (err) {
+        printf(" cm create thread failed! \n");
+        exit(-1);
+    }
+}
+
+inline void CM_THREAD_EXIT(void * retval) 
+{
+    pthread_exit(retval);
+}
+
+inline int CM_THREAD_JOIN(THREAD_HANDLE *handle_array, int thread_cnt) 
+{
+    void *tret;
+    for(int i = 0; i < thread_cnt; i++)
+    {
+        pthread_join( handle_array[i], &tret);
+    }
+    return 0;
+}
+
+#define CM_SURFACE_FORMAT                       VA_CM_FORMAT
+
+#define CM_SURFACE_FORMAT_UNKNOWN               VA_CM_FMT_UNKNOWN
+#define CM_SURFACE_FORMAT_A8R8G8B8              VA_CM_FMT_A8R8G8B8
+#define CM_SURFACE_FORMAT_X8R8G8B8              VA_CM_FMT_X8R8G8B8
+#define CM_SURFACE_FORMAT_A8                    VA_CM_FMT_A8
+#define CM_SURFACE_FORMAT_P8                    VA_CM_FMT_P8
+#define CM_SURFACE_FORMAT_R32F                  VA_CM_FMT_R32F
+#define CM_SURFACE_FORMAT_NV12                  VA_CM_FMT_NV12
+#define CM_SURFACE_FORMAT_UYVY                  VA_CM_FMT_UYVY
+#define CM_SURFACE_FORMAT_YUY2                  VA_CM_FMT_YUY2
+#define CM_SURFACE_FORMAT_V8U8					VA_CM_FMT_V8U8
+
+#define CM_TEXTURE_ADDRESS_TYPE                 VACMTEXTUREADDRESS
+#define CM_TEXTURE_ADDRESS_WRAP                 VACMTADDRESS_WRAP
+#define CM_TEXTURE_ADDRESS_MIRROR               VACMTADDRESS_MIRROR
+#define CM_TEXTURE_ADDRESS_CLAMP                VACMTADDRESS_CLAMP
+#define CM_TEXTURE_ADDRESS_BORDER               VACMTADDRESS_BORDER
+#define CM_TEXTURE_ADDRESS_MIRRORONCE           VACMTADDRESS_MIRRORONCE
+
+#define CM_TEXTURE_FILTER_TYPE                  VACMTEXTUREFILTERTYPE
+#define CM_TEXTURE_FILTER_TYPE_NONE             VACMTEXF_NONE
+#define CM_TEXTURE_FILTER_TYPE_POINT            VACMTEXF_POINT
+#define CM_TEXTURE_FILTER_TYPE_LINEAR           VACMTEXF_LINEAR
+#define CM_TEXTURE_FILTER_TYPE_ANISOTROPIC      VACMTEXF_ANISOTROPIC
+#define CM_TEXTURE_FILTER_TYPE_FLATCUBIC        VACMTEXF_FLATCUBIC
+#define CM_TEXTURE_FILTER_TYPE_GAUSSIANCUBIC    VACMTEXF_GAUSSIANCUBIC
+#define CM_TEXTURE_FILTER_TYPE_PYRAMIDALQUAD    VACMTEXF_PYRAMIDALQUAD
+#define CM_TEXTURE_FILTER_TYPE_GAUSSIANQUAD     VACMTEXF_GAUSSIANQUAD
+#define CM_TEXTURE_FILTER_TYPE_CONVOLUTIONMONO  VACMTEXF_CONVOLUTIONMONO
+
+/* Surrport for common-used data type */
+#define  _TCHAR char
+#define __cdecl 
+#ifndef TRUE
+#define TRUE 1
+#endif
+
+typedef int           HKEY;
+typedef unsigned int  uint;
+typedef unsigned int* PUINT;
+
+typedef float         FLOAT;
+typedef unsigned long long DWORDLONG;
+#ifndef ULONG_PTR 
+#define ULONG_PTR     unsigned long 
+#endif 
+
+/* Handle Type */
+typedef void           *HMODULE;
+typedef void           *HINSTANCE;
+typedef int            HANDLE;
+typedef void           *PVOID;
+typedef int            WINBOOL;
+typedef BOOL           *PBOOL;
+typedef unsigned long  ULONG;
+typedef ULONG          *PULONG;
+typedef unsigned short USHORT;
+typedef USHORT         *PUSHORT;
+typedef unsigned char  UCHAR;
+typedef UCHAR          *PUCHAR;
+typedef char           CHAR;
+typedef short          SHORT;
+typedef long           LONG;
+typedef double         DOUBLE;
+
+#define __int8  char
+#define __int16 short
+#define __int32 int
+#define __int64 long long
+
+typedef unsigned short WORD;
+typedef float          FLOAT;
+typedef FLOAT          *PFLOAT;
+typedef BYTE           *PBYTE;
+typedef int            *PINT;
+typedef WORD           *PWORD;
+typedef DWORD          *PDWORD;
+typedef unsigned int   *PUINT;
+typedef LONG           HRESULT;
+typedef long long      LONGLONG; 
+
+typedef union _LARGE_INTEGER {
+    struct {
+        uint32_t LowPart;
+        int32_t HighPart;
+    } u;
+    int64_t QuadPart;
+} LARGE_INTEGER;
+
+//Performace
+EXTERN_C INT QueryPerformanceFrequency(LARGE_INTEGER *lpFrequency);
+EXTERN_C INT QueryPerformanceCounter(LARGE_INTEGER *lpPerformanceCount);    
+inline uint64_t rdtsc()
+{
+    uint32_t lo, hi;
+    __asm__ __volatile__ ("rdtsc" : "=a" (lo), "=d" (hi));
+    return (uint64_t)hi << 32 | lo;
+}
+
+#ifndef __rdtsc
+#define __rdtsc rdtsc
+#endif
+
+struct BITMAPFILEHEADER
+{
+  WORD  bfType;
+  DWORD bfSize;
+  WORD  bfReserved1;
+  WORD  bfReserved2;
+  DWORD bfOffBits;
+}  __attribute__((packed)) ;
+
+struct BITMAPINFOHEADER
+{
+  DWORD  biSize;
+  DWORD  biWidth;
+  DWORD  biHeight;
+  WORD   biPlanes;
+  WORD   biBitCount;
+  DWORD  biCompression;
+  DWORD  biSizeImage;
+  DWORD  biXPelsPerMeter;
+  DWORD  biYPelsPerMeter;
+  DWORD  biClrUsed;
+  DWORD  biClrImportant;
+};
+
+struct RGBQUAD 
+{
+  BYTE rgbBlue;
+  BYTE rgbGreen;
+  BYTE rgbRed;
+  BYTE rgbReserved;
+};
+
+#define BI_RGB   0L
+
+#ifdef CMRT_EMU
+  // below macro definition is to workaround a bug in g++4.4
+  template<typename kernelFunctionTy>
+  inline void * CM_KERNEL_FUNCTION_TO_POINTER(kernelFunctionTy kernelFunction)
+  {
+    return (void *)kernelFunction;
+  }
+  #define CM_KERNEL_FUNCTION2(...) #__VA_ARGS__, CM_KERNEL_FUNCTION_TO_POINTER(__VA_ARGS__)
+#else
+  #define CM_KERNEL_FUNCTION2(...) #__VA_ARGS__
+#endif
+
+#ifdef CMRT_EMU
+  // below macro definition is to workaround a bug in g++4.4
+  template<typename kernelFunctionTy>
+  inline void * CM_KERNEL_FUNCTION_POINTER(kernelFunctionTy kernelFunction)
+  {
+    return (void *)kernelFunction;
+  }
+  #define _NAME(...) #__VA_ARGS__, CM_KERNEL_FUNCTION_POINTER(__VA_ARGS__)
+#else
+  #define _NAME(...) #__VA_ARGS__
+#endif
diff --git a/inc/libpavp/libpavp.h b/inc/libpavp/libpavp.h
new file mode 100644
index 0000000..f8a19bd
--- /dev/null
+++ b/inc/libpavp/libpavp.h
@@ -0,0 +1,356 @@
+/*===================== begin_copyright_notice ==================================
+
+INTEL CONFIDENTIAL
+Copyright 2013
+Intel Corporation All Rights Reserved.
+
+The source code contained or described herein and all documents related to the
+source code ("Material") are owned by Intel Corporation or its suppliers or
+licensors. Title to the Material remains with Intel Corporation or its suppliers
+and licensors. The Material contains trade secrets and proprietary and confidential
+information of Intel or its suppliers and licensors. The Material is protected by
+worldwide copyright and trade secret laws and treaty provisions. No part of the
+Material may be used, copied, reproduced, modified, published, uploaded, posted,
+transmitted, distributed, or disclosed in any way without Intel's prior express
+written permission.
+
+No license under any patent, copyright, trade secret or other intellectual
+property right is granted to or conferred upon you by disclosure or delivery
+of the Materials, either expressly, by implication, inducement, estoppel or
+otherwise. Any license under such intellectual property rights must be express
+and approved by Intel in writing.
+
+File Name: libpavp.h
+Abstract: PAVP library for Android - header file for external use.
+
+Environment: Linux/Android
+
+Notes:  
+
+======================= end_copyright_notice ==================================*/
+
+#ifndef _LIBPAVP_H_
+#define _LIBPAVP_H_
+
+#ifndef _MSC_VER
+#include <cstdint>
+typedef uint8_t     UINT8;
+typedef uint8_t     BYTE;
+typedef uint16_t    UINT16;
+typedef uint32_t    UINT32;
+typedef uint32_t    ULONG;
+typedef void*       PVOID;
+typedef uint32_t*   PUINT;
+typedef uint32_t    UINT;
+typedef uint32_t    DWORD;
+#endif
+
+/// \def INTERFACE_VERSION
+/// The interface version the library was compiled with.
+#define INTERFACE_VERSION 0x06
+
+class pavp_lib_session
+{
+public:
+
+    /// \enum pavp_lib_session::pavp_lib_code
+    /// Libpavp Error Codes
+    /// @{
+    typedef enum {
+        status_ok                     = 0,
+        invalid_arg                   = 1,
+        session_already_initialized   = 2,
+        session_uninitialized         = 3,
+        insufficient_memory           = 4,
+        internal_error                = 5,
+        not_implemented               = 6,
+        pavp_not_supported            = 7,
+        hdcp1_not_supported           = 8,
+        hdcp2_not_supported           = 9,
+        hdcp2_timeout                 = 10,
+        operation_failed              = 11,
+        api_version_mismatch          = 12,
+        signature_verify_failed       = 13,
+        pavp_lib_status_count         = 14,
+    } pavp_lib_code;
+    ///@}
+
+    /// \enum pavp_lib_session::hdcp2_content_stream_type
+    /// HDCP2 Stream Types
+    /// @{
+    typedef enum {
+        content_stream_type0     = 0,   //!< May be transmitted by the HDCP repeater to all HDCP devices.
+        content_stream_type1     = 1,   //!< Must not be transmitted by the HDCP repeater to HDCP 1.x-compliant devices and HDCP 2.0-compliant repeaters.
+        max_content_stream_types = 2
+    } hdcp2_content_stream_type;
+    ///@}
+
+    /// \enum pavp_lib_session::key_type
+    /// PAVP Key Types
+    /// @{
+    typedef enum
+    {
+        pavp_key_decrypt    = 1,    //!< Decrypt key.
+        pavp_key_encrypt    = 2,    //!< Encrypt key.
+        pavp_key_both       = 4,    //!< Decrypt and encrypt key.
+    } key_type;
+    ///@}
+
+    /// \typedef pavp_lib_session::pavp_lib_version
+    /// Libpavp Version Number
+    typedef UINT32 pavp_lib_version;
+
+    /// \typedef pavp_lib_session::PFNWIDIAGENT_HDCPSENDMESSAGE
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////
+    /// \brief       A callback function used to send data to the wireless receiver.
+    /// \param       hWiDiHandle    [in] Not used in Android, reserved.
+    /// \param       pData          [in] a caller-allocated input buffer containing an HDCP2 message.
+    /// \param       uiDataLen      [in] The size of the data in the buffer pointed to by pData. 
+    /// \return      status_ok on success, error codes on failure.
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////
+    typedef pavp_lib_code (*PFNWIDIAGENT_HDCPSENDMESSAGE)
+    (
+        PVOID    hWiDiHandle,
+        PVOID    pData,
+        UINT32   uiDataLen
+    );
+
+    /// \typedef pavp_lib_session::PFNWIDIAGENT_HDCPRECEIVEMESSAGE
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////
+    /// \brief       A callback function used to receive data from the wireless receiver.
+    /// \param       hWiDiHandle        [in] Not used in Android, reserved.
+    /// \param       pData              [in/out] a caller-allocated input buffer to be filled with the received HDCP2 message.
+    /// \param       uiDataLen          [in] The size of the buffer pointed to by pData. 
+    /// \param       pReceivedDataLen   [out] If pData was null, returns size required to receive the next message.
+    ///                                       If pData was not null, returns the size of the data written to pData.
+    /// \return      status_ok on success, error codes on failure.
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////
+    typedef pavp_lib_code (*PFNWIDIAGENT_HDCPRECEIVEMESSAGE)
+    (
+        PVOID   hWiDiHandle,
+        PVOID   pData,
+        UINT32  uiDataLen,
+        PUINT   pReceivedDataLen
+    );
+
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////
+    /// \brief       Initializes the libary.
+    /// \param       interface_version          [in] Should be set to INTERFACE_VERSION.
+    /// \param       pavp_lib_session_instance  [out] The library session object to be used for using this library.
+    /// \return      status_ok on success, error codes on failure.
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////
+    static pavp_lib_code pavp_lib_init(
+        pavp_lib_version    interface_version,
+        pavp_lib_session    **pavp_lib_session_instance);
+
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////
+    /// \brief       Destroy resources allocated for the libary use. Must be called if a successful pavp_lib_init call has been made.
+    /// \param       pavp_lib_session_instance  [in] The library session object to be destroyed.
+    /// \return      status_ok on success, error codes on failure.
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////
+    static pavp_lib_code pavp_lib_cleanup(pavp_lib_session *pavp_lib_session_instance);
+
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////
+    /// \brief       Allows direct communication with the SEC FW. This function can be used for DRM initialization and key exchange.
+    /// \par         Details:
+    /// \li          This function can be called any time after pavp_lib_init().
+    /// \param       pInput     [in] The SEC command to be sent.
+    /// \param       ulInSize   [in] The size of the SEC command to be sent.
+    /// \param       pOutput    [out] A buffer to contain the SEC response.
+    /// \param       ulOutSize  [in] The SEC response buffer size.
+    /// \return      status_ok on success, error codes on failure.
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////
+    virtual pavp_lib_code sec_pass_through(
+        BYTE* pInput,
+        ULONG ulInSize,
+        BYTE* pOutput,
+        ULONG ulOutSize) = 0;
+
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////
+    /// \brief       Provides an HDCP System Renewability Message.
+    /// \par         Details:
+    /// \li          The SRM's digital signature will be verified and revoked KSVs will be extracted to check during activation of HDCP1.
+    /// \li          Can be called when using either HDCP1 or HDCP2, but must be called before activation or authentication.
+    /// \param       srm_data       [in] Binary data that contains revoked KSVs formatted according to the HDCP specification.
+    /// \param       srm_data_size  [in] The size of the binary data.
+    /// \return      status_ok on success, error codes on failure.
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////
+    virtual pavp_lib_code hdcp_set_srm(UINT8* srmData, UINT32 srmDataSize) = 0;
+    
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////
+    /// \brief       Enables HDCP1 and creates a PAVP session and initializes the required private variables.
+    /// \par         Details:
+    /// \li          This must be called when the host process needs to create a session for protected decoding.
+    /// \li          If any digital outputs are enabled, this function will also attempt to activate HDCP1.x on them.
+    /// \li          If this is called, hdcp2_create() will be unavailable until pavp_destroy_session() is called.
+    /// \li          This call will fail if hdcp2_create() was already called (PAVP and HDCP2 library usages are mutually exclusive).
+    /// \param       is_heavy_mode          [in, optional] Indicates whether the session to be created should be a heavy mode session (default: true).
+    /// \param       is_transcode_session   [in, optional] Indicates whether the session to be created should be a transcode session (default: false).
+    /// \return      status_ok on success, error codes on failure.
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////
+    virtual pavp_lib_code pavp_create_session(
+        bool    is_heavy_mode           = true,
+        bool    is_transcode_session    = false) = 0;
+
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////
+    /// \brief       Returns the app ID of the PAVP session created by the library.
+    /// \par         Details:
+    /// \li          This call fails if no PAVP session has been created.
+    /// \li          If the call failed, app_id value is undefined.
+    /// \param       app_id [out] The created PAVP session app ID.
+    /// \return      status_ok on success, error codes on failure.
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////
+    virtual pavp_lib_code pavp_get_app_id(UINT& app_id) = 0;
+
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////
+    /// \brief       Releases the PAVP session and all resources allocated in pavp_create_session().
+    /// \par         Details:
+    /// \li          Can be called if for any reason PAVP needs to be recreated without re-creating a pavp_lib_session object.
+    /// \return      status_ok on success, error codes on failure.
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////
+    virtual pavp_lib_code pavp_destroy_session() = 0;
+
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////
+    /// \brief       Reports whether the PAVP session is alive at the hardware level.
+    /// \par         Details:
+    /// \li          If the session is not alive, the host application should immediately halt playback, destroy the current session and create a new one.
+    /// \param       bIsAlive   [out] If the returned status is status_ok, bIsAlive will be true if the PAVP session is alive, false otherwise.
+    /// \return      status_ok on success, error codes on failure.
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////
+    virtual pavp_lib_code pavp_is_session_alive(bool *bIsAlive) = 0;
+
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////
+    /// \brief       Sets the steam key to be used with the previouly created PAVP session.
+    /// \par         Details:
+    /// \li          If the session is not alive, the host application should immediately halt playback, destroy the current session and create a new one.
+    /// \param       key_type               [in] The key type to set (decrypt/encrypt/both).
+    /// \param       encrypted_decrypt_key  [in] Encrpted decrypt key to set (ignored if the requested key type is encrypt only).
+    /// \param       encrypted_encrypt_key  [in] Encrpted encrypt key to set (ignored if the requested key type is decrypt only).
+    /// \return      status_ok on success, error codes on failure.
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////
+    virtual pavp_lib_code pavp_set_stream_key(
+        key_type    key_type,
+        DWORD       encrypted_decrypt_key[4],
+        DWORD       encrypted_encrypt_key[4]) = 0;
+    
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////
+    /// \brief       Queries the device if HDCP2 for WiDi is suppored.
+    /// \return      hdcp2_supported if supported, hdcp2_not_supported if not supported.
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////
+    virtual pavp_lib_code hdcp2_is_support_available() = 0;
+
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////
+    /// \brief       Releases HDCP2 usage. Frees all resources associated with HDCP2.
+    /// \return      status_ok on success, error codes on failure.
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////
+    virtual pavp_lib_code hdcp2_destroy() = 0;
+
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////
+    /// \brief       An optional call for HDCP2.1+. Allows the player to set certain restrictions on the HDCP topology.
+    /// \param       content_stream_type    [in] A stream type for the content being played.
+    /// \return      status_ok on success, error codes on failure.
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////
+    virtual pavp_lib_code hdcp2_set_stream_types(hdcp2_content_stream_type content_stream_type) = 0;
+    
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////
+    /// \brief       Rerforms the full HDCP2.x AKE between the wireless adapter and Widi Transmitter (SEC).
+    /// \par         Details:
+    /// \li          The send and receive callbacks will not be cached and will only be used within the scope of this function call.
+    /// \li          Therefore the caller does not need to guarantee the validity of the function pointers afterwards.
+    /// \li          This call will fail if pavp_create_session() was already called (PAVP and HDCP2 library usages are mutually exclusive).
+    /// \param       pSend      [in] A callback function to send a message to the wireless adapter.
+    /// \param       pReceive   [in] A callback function to receive a response from the wireless adapter.
+    /// \return      status_ok on success, error codes on failure.
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////
+    virtual pavp_lib_code hdcp2_create_and_authenticate(
+        PFNWIDIAGENT_HDCPSENDMESSAGE    pSend,
+        PFNWIDIAGENT_HDCPRECEIVEMESSAGE pReceive) = 0;
+
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////
+    /// \brief       Encrypts an uncompressed clear surface, to pass back to the application. 
+    ///              Adding this function "declaration but disabling definition" in release driver will remove qualms for running P4 release-internal 
+    ///              driver on release OTC build. 
+    /// \param       src_resource   [in] The source resource which contains the clear data. 
+    /// \param       dst_Resource   [out] The Destination resource. This resource will contain the encrypted data. It should be allocated by the caller.
+    /// \param       width  [in] The width of the surface in Bytes.
+    /// \param       height [in] The height of the surface in Bytes (pay attention that for NV12 the height(Bytes) = 1.5*height(Pixel)).
+    /// \return     status_ok on success, error codes on failure.
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////
+    virtual pavp_lib_code encryption_blt(
+        BYTE*   src_resource,
+        BYTE*   dst_Resource,
+        DWORD   width,
+        DWORD   height) = 0;
+
+    //HSW Android WideVine Stuff
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////
+    /// \brief       Start HSW WideVine connection status heart beat message.
+    /// \par         Details:
+    /// \li          This function should be called after set entitlement key and before first video process frame.
+    ///              Algorithm -
+    ///              - App -
+    ///              check_connection_status_heart_beat()
+    ///              first_video_process_frame()
+    ///              while playback
+    ///                 for i = 1 to 100
+    ///                     do nothing
+    ///                 check_connection_status_heart_beat()
+    ///              end while
+    ///              - Driver -
+    ///              Call Get WideVine Nonce (It is different from regular gent nonce)
+    ///              Program Nonce to GPU and Get Connection Status
+    ///              Verify Connection Status and return T/F if HDCP alive 
+    ///              - Firmware -
+    ///              Wait for Connection Status before Xscripting first Video Frame
+    ///              Receive request for connection status and verify
+    ///              Start counter till 100 frames
+    ///                 Process video frames
+    ///              if on 100th frame and connection status is not received then stop doing Xscripting 
+    ///              
+    /// \param       bStartCSHeartBeat  [out] 
+    /// 
+    /// \return      status_ok on success, error codes on failure.
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////
+    virtual pavp_lib_code check_connection_status_heart_beat(
+        bool        *bCSHeartBeatStatus) = 0;
+
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////
+    /// \brief       Start HSW WideVine crypto init dma message.
+    /// \par         Details:
+    /// \li          This function should be called to get handle to DMA message.
+    /// \param       pMessage  [in] 
+    /// \param       msg_length  [in] 
+    /// \param       handle  [out] 
+    /// 
+    /// \return      status_ok on success, error codes on failure.
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////
+    virtual pavp_lib_code oem_crypto_init_dma(
+        UINT8       *pMessage,
+        UINT32      msg_length,
+        UINT32      *handle) = 0;
+
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////
+    /// \brief       Start HSW WideVine crypto uninit dma message.
+    /// \par         Details:
+    /// \li          This function should be called to free handle to DMA message.
+    /// \param       handle  [in]
+    ///
+    /// \return      status_ok on success, error codes on failure.
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////
+    virtual pavp_lib_code oem_crypto_uninit_dma(
+        UINT32      *handle) = 0;
+
+protected:
+
+    pavp_lib_session() { }    // It is never called. Needed for compilation.
+    virtual ~pavp_lib_session();
+
+private:
+
+    // Default constructor, copy constructor and assignment operator should not be used.
+    pavp_lib_session& operator=(const pavp_lib_session& other);
+    pavp_lib_session(const pavp_lib_session& other);
+        
+};
+
+#endif
diff --git a/inc/ufo/gralloc.h b/inc/ufo/gralloc.h
new file mode 100644
index 0000000..5b3ba84
--- /dev/null
+++ b/inc/ufo/gralloc.h
@@ -0,0 +1,107 @@
+/*
+ * INTEL CONFIDENTIAL
+ *
+ * Copyright 2013 Intel Corporation All Rights Reserved.
+ *
+ * The source code contained or described herein and all documents related to the
+ * source code ("Material") are owned by Intel Corporation or its suppliers or
+ * licensors. Title to the Material remains with Intel Corporation or its suppliers
+ * and licensors. The Material contains trade secrets and proprietary and confidential
+ * information of Intel or its suppliers and licensors. The Material is protected by
+ * worldwide copyright and trade secret laws and treaty provisions. No part of the
+ * Material may be used, copied, reproduced, modified, published, uploaded, posted,
+ * transmitted, distributed, or disclosed in any way without Intels prior express
+ * written permission.
+ *
+ * No license under any patent, copyright, trade secret or other intellectual
+ * property right is granted to or conferred upon you by disclosure or delivery
+ * of the Materials, either expressly, by implication, inducement, estoppel
+ * or otherwise. Any license under such intellectual property rights must be
+ * express and approved by Intel in writing.
+ *
+ */
+
+/**
+ * This <ufo/gralloc.h> file contains public extensions provided by UFO GRALLOC HAL.
+ */
+
+#ifndef INTEL_UFO_GRALLOC_H
+#define INTEL_UFO_GRALLOC_H
+
+#include <hardware/gralloc.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+// Enable for FB reference counting.
+#define INTEL_UFO_GRALLOC_HAVE_FB_REF_COUNTING 1
+// Enable for PAVP query.
+#define INTEL_UFO_GRALLOC_HAVE_QUERY_PAVP_SESSION 1
+
+
+/** Operations for the (*perform)() hook
+ * \see gralloc_module_t::perform
+ */
+enum {
+    INTEL_UFO_GRALLOC_MODULE_PERFORM_CHECK_VERSION  = 0, // (void)
+    INTEL_UFO_GRALLOC_MODULE_PERFORM_GET_DRM_FD     = 1, // (int*)
+    INTEL_UFO_GRALLOC_MODULE_PERFORM_SET_DISPLAY    = 2, // (int display, uint32_t width, uint32_t height, uint32_t xdpi, uint32_t ydpi)
+    INTEL_UFO_GRALLOC_MODULE_PERFORM_GET_BO_HANDLE  = 3, // (buffer_handle_t, int*)
+    INTEL_UFO_GRALLOC_MODULE_PERFORM_GET_BO_NAME    = 4, // (buffer_handle_t, uint32_t*)
+    INTEL_UFO_GRALLOC_MODULE_PERFORM_GET_BO_FBID    = 5, // (buffer_handle_t, uint32_t*)
+    INTEL_UFO_GRALLOC_MODULE_PERFORM_GET_BO_INFO    = 6, // (buffer_handle_t, buffer_info_t*)
+    INTEL_UFO_GRALLOC_MODULE_PERFORM_GET_BO_STATUS  = 7, // (buffer_handle_t)
+#if INTEL_UFO_GRALLOC_HAVE_FB_REF_COUNTING
+    INTEL_UFO_GRALLOC_MODULE_PERFORM_FB_ACQUIRE     = 8, // (uint32_t)
+    INTEL_UFO_GRALLOC_MODULE_PERFORM_FB_RELEASE     = 9, // (uint32_t)
+#endif
+    INTEL_UFO_GRALLOC_MODULE_PERFORM_QUERY_PAVP_SESSION = 10,// (buffer_handle_t, buffer_pavp_session_t*)
+};
+
+
+/** Simple version control
+ * \see gralloc_module_t::perform
+ * \see INTEL_UFO_GRALLOC_MODULE_PERFORM_CHECK_VERSION
+ */
+enum {
+    INTEL_UFO_GRALLOC_MODULE_VERSION_0 = ANDROID_NATIVE_MAKE_CONSTANT('I','N','T','C'),
+    INTEL_UFO_GRALLOC_MODULE_VERSION_LATEST = INTEL_UFO_GRALLOC_MODULE_VERSION_0,
+};
+
+
+/** Structure with detailed info about allocated buffer.
+ * \see INTEL_UFO_GRALLOC_MODULE_PERFORM_GET_BO_INFO
+ */
+typedef struct intel_ufo_buffer_details_t
+{
+    int width;       // \see alloc_device_t::alloc
+    int height;      // \see alloc_device_t::alloc
+    int format;      // \see alloc_device_t::alloc
+    int usage;       // \see alloc_device_t::alloc
+    int name;        // flink
+    uint32_t fb;     // framebuffer id
+    int drmformat;   // drm format
+    int pitch;       // buffer pitch (in bytes)
+    int size;        // buffer size (in bytes)
+
+    int allocWidth;  // allocated buffer width in pixels.
+    int allocHeight; // allocated buffer height in lines.
+    int allocOffsetX;// horizontal pixel offset to content origin within allocated buffer.
+    int allocOffsetY;// vertical line offset to content origin within allocated buffer.
+} intel_ufo_buffer_details_t;
+
+/** Structure with info about buffer PAVP sesssion.
+ * \see INTEL_UFO_GRALLOC_MODULE_PERFORM_QUERY_PAVP_SESSION
+ */
+typedef struct intel_ufo_buffer_pavp_session_t
+{
+    uint32_t sessionID; // Session ID.
+    uint32_t instance;  // Instance.
+} intel_ufo_buffer_pavp_session_t;
+
+#ifdef __cplusplus
+} // extern "C"
+#endif
+
+#endif /* INTEL_UFO_GRALLOC_H */
diff --git a/inc/ufo/graphics.h b/inc/ufo/graphics.h
new file mode 100644
index 0000000..f2ddf71
--- /dev/null
+++ b/inc/ufo/graphics.h
@@ -0,0 +1,150 @@
+/*
+ * INTEL CONFIDENTIAL
+ *
+ * Copyright 2013 Intel Corporation All Rights Reserved.
+ *
+ * The source code contained or described herein and all documents related to the
+ * source code ("Material") are owned by Intel Corporation or its suppliers or
+ * licensors. Title to the Material remains with Intel Corporation or its suppliers
+ * and licensors. The Material contains trade secrets and proprietary and confidential
+ * information of Intel or its suppliers and licensors. The Material is protected by
+ * worldwide copyright and trade secret laws and treaty provisions. No part of the
+ * Material may be used, copied, reproduced, modified, published, uploaded, posted,
+ * transmitted, distributed, or disclosed in any way without Intels prior express
+ * written permission.
+ *
+ * No license under any patent, copyright, trade secret or other intellectual
+ * property right is granted to or conferred upon you by disclosure or delivery
+ * of the Materials, either expressly, by implication, inducement, estoppel
+ * or otherwise. Any license under such intellectual property rights must be
+ * express and approved by Intel in writing.
+ *
+ */
+
+/**
+ * This <ufo/graphics.h> file contains UFO specific pixel formats.
+ *
+ * \remark This file is Android specific
+ * \remark Do not put any internal definitions here!
+ */
+
+#ifndef INTEL_UFO_GRAPHICS_H
+#define INTEL_UFO_GRAPHICS_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * UFO specific pixel format definitions
+ *
+ * Range 0x100 - 0x1FF is reserved for pixel formats specific to the HAL implementation
+ *
+ * \see #include <system/graphics.h>
+ */
+enum {
+    /**
+     * A format in which all Y samples are found first in memory as an array
+     * of unsigned char with an even number of lines (possibly with a larger
+     * stride for memory alignment). This is followed immediately by an array
+     * of unsigned char containing interleaved Cb and Cr samples. If these
+     * samples are addressed as a little-endian WORD type, Cb would be in the
+     * least significant bits and Cr would be in the most significant bits
+     * with the same total stride as the Y samples.
+     * NV12 is the preferred 4:2:0 pixel format.
+     */
+    HAL_PIXEL_FORMAT_NV12_Y_TILED_INTEL = 0x100,
+
+    /**
+     * \deprecated alias name
+     * \see HAL_PIXEL_FORMAT_NV12_Y_TILED_INTEL
+     */
+    HAL_PIXEL_FORMAT_NV12_TILED_INTEL = HAL_PIXEL_FORMAT_NV12_Y_TILED_INTEL,
+
+    /**
+     * \todo
+     *
+     * Same as NV12_INTEL, but with additional restrictions:
+     * - tiling: linear
+     * - pitch: 512, 1024, 1280, 2048, 4096
+     * - height: need be 32 aligned
+     */
+    HAL_PIXEL_FORMAT_NV12_LINEAR_INTEL = 0x101,
+
+    /**
+     * \deprecated alias name for use by legacy apps only
+     * \see HAL_PIXEL_FORMAT_NV12_Y_TILED_INTEL
+     */
+    HAL_PIXEL_FORMAT_NV12_INTEL = HAL_PIXEL_FORMAT_NV12_Y_TILED_INTEL,
+
+    /**
+     * \deprecated alias name for use by legacy apps only
+     * \see HAL_PIXEL_FORMAT_NV12_INTEL
+     */
+    HAL_PIXEL_FORMAT_INTEL_NV12 = HAL_PIXEL_FORMAT_NV12_INTEL,
+
+    /**
+     * HAL_PIXEL_FORMAT_YCrCb_422_H_INTEL is not defined in
+     * ./system/core/include/system/graphics.h
+     */
+    HAL_PIXEL_FORMAT_YCrCb_422_H_INTEL = 0x102, // YV16
+
+    /**
+     * for the PACKED mode, pitch=width and no need any alignment for height
+     */
+    HAL_PIXEL_FORMAT_NV12_LINEAR_PACKED_INTEL = 0x103,
+
+    /**
+     * Three planes, 8 bit Y plane followed by 8 bit 2x1 subsampled U and V planes.
+     * Similar to IMC3 but U/V are full height.
+     * The width must be even.
+     * There are no specific restrictions on pitch, height and alignment.
+     * It can be linear or tiled if required.
+     *      __________________________
+     *      |Y0|Y1|                  |
+     *      |__|__|                  |
+     *     h|                        |
+     *      |____________w___________|
+     *      |U0|U1|      |
+     *     h|__|__|      |
+     *      |            |
+     *      |_____w/2____|
+     *      |V0|V1|      |
+     *     h|__|__|      |
+     *      |            |
+     *      |______w/2___|
+     */
+    HAL_PIXEL_FORMAT_YCbCr_422_H_INTEL = 0x104, // YU16
+    
+    /**
+     * This is VXD specific NV12 X tile format.
+     * - stride: 512, 1024, 1280, 2048, 4096
+     * - height: must be 32 aligned
+     * - tiling: X-tiled
+     */
+    HAL_PIXEL_FORMAT_NV12_X_TILED_INTEL = 0x105,
+
+    /**
+     * \note THIS WILL BE GOING AWAY!
+     *
+     * \deprecated value out of range of reserved pixel formats
+     * \see #include <openmax/OMX_IVCommon.h>
+     * \see OMX_INTEL_COLOR_FormatYUV420PackedSemiPlanar
+     */
+    HAL_PIXEL_FORMAT_YUV420PackedSemiPlanar_INTEL = 0x7FA00E00,
+
+    /**
+     * \note THIS WILL BE GOING AWAY!
+     *
+     * \deprecated value out of range of reserved pixel formats
+     * \see #include <openmax/OMX_IVCommon.h>
+     * \see OMX_INTEL_COLOR_FormatYUV420PackedSemiPlanar
+     */
+    HAL_PIXEL_FORMAT_YUV420PackedSemiPlanar_Tiled_INTEL = 0x7FA00F00,
+};
+
+#ifdef __cplusplus
+} // extern "C"
+#endif
+
+#endif /* INTEL_UFO_GRAPHICS_H */
-- 
1.7.4.1

