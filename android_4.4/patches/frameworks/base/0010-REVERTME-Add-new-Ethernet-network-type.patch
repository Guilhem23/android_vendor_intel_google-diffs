From f370837e5e0b5ebb2685289172fa7b7cad510cf3 Mon Sep 17 00:00:00 2001
From: Matt Gumbel <matthew.k.gumbel@linux.intel.com>
Date: Thu, 18 Oct 2012 17:43:28 -0700
Subject: REVERTME Add new Ethernet network type

This patchset does the following:
* Exposes EthernetManager for controlling attached ethernet devices
* Adds new ethernet network type to ConnectivityManager
* Adds ethernet notification icons to the system bar

Icons were created in GIMP by Anton Cherkashyn
<antonx.t.cherkashyn@intel.com>.

Author: Matt Gumbel <matthew.k.gumbel@linux.intel.com>
Author: juntingwang <Junting.Wang@windriver.com>
Author: Sal Quintanilla <sal.quintanilla@windriver.com>
Author: Robert Chiras <robert.chiras@intel.com>
Author: suyyala <suyyala@intel.com>

Category: AOSP improvement
Domain: AOSP.Connectivity
Origin: internal
Upstream-Candidate: yes, requires rework

Issue: APDEV-459
Change-Id: Iac46e135b65fa2b5d1f155dfdc99c22dda62eb7b
Depends-Change-Id: I0836173813a60c9413e225942d3965a4267b6ed5
Depends-Change-Id: Ia089dfd98ce529ad88ba1523927887fdb1987ac5
Signed-off-by: Markus Grape <markus.grape@intel.com>
---
 Android.mk                                         |    1 +
 core/java/android/app/ContextImpl.java             |   13 +
 core/java/android/content/Context.java             |   11 +
 core/java/android/net/DhcpStateMachine.java        |   11 +-
 core/java/android/net/EthernetDataTracker.java     |  426 ---------------
 core/java/android/net/LinkProperties.java          |   22 +
 core/java/com/android/internal/util/Protocol.java  |    1 +
 core/res/res/values/config.xml                     |    2 +
 .../android/internal/ethernet/EthernetInfo.aidl    |   19 +
 .../android/internal/ethernet/EthernetInfo.java    |  410 +++++++++++++++
 .../android/internal/ethernet/EthernetManager.java |  224 ++++++++
 .../internal/ethernet/EthernetStateMachine.java    |  353 +++++++++++++
 .../internal/ethernet/IEthernetManager.aidl        |   37 ++
 .../com/android/internal/ethernet/package.html     |    5 +
 .../drawable-hdpi/stat_sys_ethernet_connected.png  |  Bin 0 -> 689 bytes
 .../stat_sys_ethernet_disconnected.png             |  Bin 0 -> 577 bytes
 .../stat_sys_ethernet_transitional.png             |  Bin 0 -> 632 bytes
 .../drawable-mdpi/stat_sys_ethernet_connected.png  |  Bin 0 -> 447 bytes
 .../stat_sys_ethernet_disconnected.png             |  Bin 0 -> 394 bytes
 .../stat_sys_ethernet_transitional.png             |  Bin 0 -> 405 bytes
 .../stat_sys_ethernet_connected.png                |  Bin 0 -> 622 bytes
 .../stat_sys_ethernet_disconnected.png             |  Bin 0 -> 511 bytes
 .../stat_sys_ethernet_transitional.png             |  Bin 0 -> 528 bytes
 .../stat_sys_ethernet_connected.png                |  Bin 0 -> 595 bytes
 .../stat_sys_ethernet_disconnected.png             |  Bin 0 -> 518 bytes
 .../stat_sys_ethernet_transitional.png             |  Bin 0 -> 542 bytes
 .../stat_sys_ethernet_connected.png                |  Bin 0 -> 790 bytes
 .../stat_sys_ethernet_disconnected.png             |  Bin 0 -> 653 bytes
 .../stat_sys_ethernet_transitional.png             |  Bin 0 -> 686 bytes
 .../drawable-xhdpi/stat_sys_ethernet_connected.png |  Bin 0 -> 622 bytes
 .../stat_sys_ethernet_disconnected.png             |  Bin 0 -> 511 bytes
 .../stat_sys_ethernet_transitional.png             |  Bin 0 -> 528 bytes
 .../SystemUI/res/layout/signal_cluster_view.xml    |   27 +
 packages/SystemUI/res/values/strings.xml           |    8 +
 .../systemui/statusbar/SignalClusterView.java      |   57 ++-
 .../statusbar/phone/PhoneStatusBarPolicy.java      |    7 +
 .../policy/AccessibilityContentDescriptions.java   |    5 +
 .../systemui/statusbar/policy/EthernetIcons.java   |   27 +
 .../statusbar/policy/NetworkController.java        |  160 ++++++-
 .../com/android/server/ConnectivityService.java    |    4 +-
 .../java/com/android/server/EthernetService.java   |  551 ++++++++++++++++++++
 services/java/com/android/server/SystemServer.java |   10 +-
 42 files changed, 1948 insertions(+), 443 deletions(-)
 delete mode 100644 core/java/android/net/EthernetDataTracker.java
 create mode 100644 ethernet/java/com/android/internal/ethernet/EthernetInfo.aidl
 create mode 100644 ethernet/java/com/android/internal/ethernet/EthernetInfo.java
 create mode 100644 ethernet/java/com/android/internal/ethernet/EthernetManager.java
 create mode 100644 ethernet/java/com/android/internal/ethernet/EthernetStateMachine.java
 create mode 100644 ethernet/java/com/android/internal/ethernet/IEthernetManager.aidl
 create mode 100644 ethernet/java/com/android/internal/ethernet/package.html
 create mode 100644 packages/SystemUI/res/drawable-hdpi/stat_sys_ethernet_connected.png
 create mode 100644 packages/SystemUI/res/drawable-hdpi/stat_sys_ethernet_disconnected.png
 create mode 100644 packages/SystemUI/res/drawable-hdpi/stat_sys_ethernet_transitional.png
 create mode 100644 packages/SystemUI/res/drawable-mdpi/stat_sys_ethernet_connected.png
 create mode 100644 packages/SystemUI/res/drawable-mdpi/stat_sys_ethernet_disconnected.png
 create mode 100644 packages/SystemUI/res/drawable-mdpi/stat_sys_ethernet_transitional.png
 create mode 100644 packages/SystemUI/res/drawable-sw600dp-hdpi/stat_sys_ethernet_connected.png
 create mode 100644 packages/SystemUI/res/drawable-sw600dp-hdpi/stat_sys_ethernet_disconnected.png
 create mode 100644 packages/SystemUI/res/drawable-sw600dp-hdpi/stat_sys_ethernet_transitional.png
 create mode 100644 packages/SystemUI/res/drawable-sw600dp-mdpi/stat_sys_ethernet_connected.png
 create mode 100644 packages/SystemUI/res/drawable-sw600dp-mdpi/stat_sys_ethernet_disconnected.png
 create mode 100644 packages/SystemUI/res/drawable-sw600dp-mdpi/stat_sys_ethernet_transitional.png
 create mode 100644 packages/SystemUI/res/drawable-sw600dp-xhdpi/stat_sys_ethernet_connected.png
 create mode 100644 packages/SystemUI/res/drawable-sw600dp-xhdpi/stat_sys_ethernet_disconnected.png
 create mode 100644 packages/SystemUI/res/drawable-sw600dp-xhdpi/stat_sys_ethernet_transitional.png
 create mode 100644 packages/SystemUI/res/drawable-xhdpi/stat_sys_ethernet_connected.png
 create mode 100644 packages/SystemUI/res/drawable-xhdpi/stat_sys_ethernet_disconnected.png
 create mode 100644 packages/SystemUI/res/drawable-xhdpi/stat_sys_ethernet_transitional.png
 create mode 100644 packages/SystemUI/src/com/android/systemui/statusbar/policy/EthernetIcons.java
 create mode 100644 services/java/com/android/server/EthernetService.java

diff --git a/Android.mk b/Android.mk
index b0a27e4..b1c3933 100644
--- a/Android.mk
+++ b/Android.mk
@@ -233,6 +233,7 @@ LOCAL_SRC_FILES += \
 	core/java/com/android/internal/widget/ILockSettings.aidl \
 	core/java/com/android/internal/widget/IRemoteViewsFactory.aidl \
 	core/java/com/android/internal/widget/IRemoteViewsAdapterConnection.aidl \
+	ethernet/java/com/android/internal/ethernet/IEthernetManager.aidl \
 	keystore/java/android/security/IKeyChainAliasCallback.aidl \
 	keystore/java/android/security/IKeyChainService.aidl \
 	location/java/android/location/ICountryDetector.aidl \
diff --git a/core/java/android/app/ContextImpl.java b/core/java/android/app/ContextImpl.java
index 190ddb4..d9c8194 100644
--- a/core/java/android/app/ContextImpl.java
+++ b/core/java/android/app/ContextImpl.java
@@ -17,6 +17,8 @@
 package android.app;
 
 import android.os.Build;
+import static com.android.internal.util.Preconditions.checkNotNull;
+
 import com.android.internal.policy.PolicyManager;
 import com.android.internal.util.Preconditions;
 
@@ -117,6 +119,8 @@ import android.app.admin.DevicePolicyManager;
 import com.android.internal.annotations.GuardedBy;
 import com.android.internal.app.IAppOpsService;
 import com.android.internal.os.IDropBoxManagerService;
+import com.android.internal.ethernet.EthernetManager;
+import com.android.internal.ethernet.IEthernetManager;
 
 import java.io.File;
 import java.io.FileInputStream;
@@ -378,6 +382,15 @@ class ContextImpl extends Context {
                     return new DownloadManager(ctx.getContentResolver(), ctx.getPackageName());
                 }});
 
+        registerService(ETHERNET_SERVICE, new ServiceFetcher() {
+                public Object createService(ContextImpl ctx) {
+                    IBinder b = checkNotNull(ServiceManager.getService(ETHERNET_SERVICE),
+                            "No ETHERNET_SERVICE");
+                    IEthernetManager service = checkNotNull(IEthernetManager.Stub.asInterface(b),
+                            "No IEthernetManager");
+                    return checkNotNull(new EthernetManager(service), "No EthernetManager");
+                }});
+
         registerService(NFC_SERVICE, new ServiceFetcher() {
                 public Object createService(ContextImpl ctx) {
                     return new NfcManager(ctx);
diff --git a/core/java/android/content/Context.java b/core/java/android/content/Context.java
index 2e4e209..8d8c46f 100644
--- a/core/java/android/content/Context.java
+++ b/core/java/android/content/Context.java
@@ -2223,6 +2223,17 @@ public abstract class Context {
 
     /**
      * Use with {@link #getSystemService} to retrieve a {@link
+     * android.net.ethernet.EthernetManager} for handling management of
+     * Ethernet access.
+     *
+     * @see #getSystemService
+     * @see android.net.ethernet.EthernetManager
+     * @hide
+     */
+    public static final String ETHERNET_SERVICE = "ethernet";
+
+    /**
+     * Use with {@link #getSystemService} to retrieve a {@link
      * android.net.nsd.NsdManager} for handling management of network service
      * discovery
      *
diff --git a/core/java/android/net/DhcpStateMachine.java b/core/java/android/net/DhcpStateMachine.java
index 5151a04..d4f11cd 100644
--- a/core/java/android/net/DhcpStateMachine.java
+++ b/core/java/android/net/DhcpStateMachine.java
@@ -50,7 +50,7 @@ import android.util.Log;
 public class DhcpStateMachine extends StateMachine {
 
     private static final String TAG = "DhcpStateMachine";
-    private static final boolean DBG = false;
+    private static final boolean DBG = true;
 
 
     /* A StateMachine that controls the DhcpStateMachine */
@@ -174,6 +174,15 @@ public class DhcpStateMachine extends StateMachine {
         quit();
     }
 
+    /**
+     * Quit the DhcpStateMachine Now.
+     *
+     * @hide
+     */
+    public void doQuitNow() {
+        quitNow();
+    }
+
     protected void onQuitting() {
         mController.sendMessage(CMD_ON_QUIT);
     }
diff --git a/core/java/android/net/EthernetDataTracker.java b/core/java/android/net/EthernetDataTracker.java
deleted file mode 100644
index 501484c..0000000
--- a/core/java/android/net/EthernetDataTracker.java
+++ /dev/null
@@ -1,426 +0,0 @@
-/*
- * Copyright (C) 2010 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package android.net;
-
-import android.content.Context;
-import android.net.NetworkInfo.DetailedState;
-import android.os.Handler;
-import android.os.IBinder;
-import android.os.INetworkManagementService;
-import android.os.Message;
-import android.os.Messenger;
-import android.os.RemoteException;
-import android.os.ServiceManager;
-import android.util.Log;
-
-import com.android.server.net.BaseNetworkObserver;
-
-import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.concurrent.atomic.AtomicInteger;
-
-/**
- * This class tracks the data connection associated with Ethernet
- * This is a singleton class and an instance will be created by
- * ConnectivityService.
- * @hide
- */
-public class EthernetDataTracker extends BaseNetworkStateTracker {
-    private static final String NETWORKTYPE = "ETHERNET";
-    private static final String TAG = "Ethernet";
-
-    private AtomicBoolean mTeardownRequested = new AtomicBoolean(false);
-    private AtomicBoolean mPrivateDnsRouteSet = new AtomicBoolean(false);
-    private AtomicInteger mDefaultGatewayAddr = new AtomicInteger(0);
-    private AtomicBoolean mDefaultRouteSet = new AtomicBoolean(false);
-
-    private static boolean mLinkUp;
-    private InterfaceObserver mInterfaceObserver;
-    private String mHwAddr;
-
-    /* For sending events to connectivity service handler */
-    private Handler mCsHandler;
-
-    private static EthernetDataTracker sInstance;
-    private static String sIfaceMatch = "";
-    private static String mIface = "";
-
-    private INetworkManagementService mNMService;
-
-    private static class InterfaceObserver extends BaseNetworkObserver {
-        private EthernetDataTracker mTracker;
-
-        InterfaceObserver(EthernetDataTracker tracker) {
-            super();
-            mTracker = tracker;
-        }
-
-        @Override
-        public void interfaceStatusChanged(String iface, boolean up) {
-            Log.d(TAG, "Interface status changed: " + iface + (up ? "up" : "down"));
-        }
-
-        @Override
-        public void interfaceLinkStateChanged(String iface, boolean up) {
-            if (mIface.equals(iface)) {
-                Log.d(TAG, "Interface " + iface + " link " + (up ? "up" : "down"));
-                mLinkUp = up;
-                mTracker.mNetworkInfo.setIsAvailable(up);
-
-                // use DHCP
-                if (up) {
-                    mTracker.reconnect();
-                } else {
-                    mTracker.disconnect();
-                }
-            }
-        }
-
-        @Override
-        public void interfaceAdded(String iface) {
-            mTracker.interfaceAdded(iface);
-        }
-
-        @Override
-        public void interfaceRemoved(String iface) {
-            mTracker.interfaceRemoved(iface);
-        }
-    }
-
-    private EthernetDataTracker() {
-        mNetworkInfo = new NetworkInfo(ConnectivityManager.TYPE_ETHERNET, 0, NETWORKTYPE, "");
-        mLinkProperties = new LinkProperties();
-        mLinkCapabilities = new LinkCapabilities();
-    }
-
-    private void interfaceAdded(String iface) {
-        if (!iface.matches(sIfaceMatch))
-            return;
-
-        Log.d(TAG, "Adding " + iface);
-
-        synchronized(this) {
-            if(!mIface.isEmpty())
-                return;
-            mIface = iface;
-        }
-
-        // we don't get link status indications unless the iface is up - bring it up
-        try {
-            mNMService.setInterfaceUp(iface);
-        } catch (Exception e) {
-            Log.e(TAG, "Error upping interface " + iface + ": " + e);
-        }
-
-        mNetworkInfo.setIsAvailable(true);
-        Message msg = mCsHandler.obtainMessage(EVENT_CONFIGURATION_CHANGED, mNetworkInfo);
-        msg.sendToTarget();
-    }
-
-    public void disconnect() {
-
-        NetworkUtils.stopDhcp(mIface);
-
-        mLinkProperties.clear();
-        mNetworkInfo.setIsAvailable(false);
-        mNetworkInfo.setDetailedState(DetailedState.DISCONNECTED, null, mHwAddr);
-
-        Message msg = mCsHandler.obtainMessage(EVENT_CONFIGURATION_CHANGED, mNetworkInfo);
-        msg.sendToTarget();
-
-        msg = mCsHandler.obtainMessage(EVENT_STATE_CHANGED, mNetworkInfo);
-        msg.sendToTarget();
-
-        IBinder b = ServiceManager.getService(Context.NETWORKMANAGEMENT_SERVICE);
-        INetworkManagementService service = INetworkManagementService.Stub.asInterface(b);
-        try {
-            service.clearInterfaceAddresses(mIface);
-        } catch (Exception e) {
-            Log.e(TAG, "Failed to clear addresses or disable ipv6" + e);
-        }
-    }
-
-    private void interfaceRemoved(String iface) {
-        if (!iface.equals(mIface))
-            return;
-
-        Log.d(TAG, "Removing " + iface);
-        disconnect();
-        mIface = "";
-    }
-
-    private void runDhcp() {
-        Thread dhcpThread = new Thread(new Runnable() {
-            public void run() {
-                DhcpResults dhcpResults = new DhcpResults();
-                if (!NetworkUtils.runDhcp(mIface, dhcpResults)) {
-                    Log.e(TAG, "DHCP request error:" + NetworkUtils.getDhcpError());
-                    return;
-                }
-                mLinkProperties = dhcpResults.linkProperties;
-
-                mNetworkInfo.setIsAvailable(true);
-                mNetworkInfo.setDetailedState(DetailedState.CONNECTED, null, mHwAddr);
-                Message msg = mCsHandler.obtainMessage(EVENT_STATE_CHANGED, mNetworkInfo);
-                msg.sendToTarget();
-            }
-        });
-        dhcpThread.start();
-    }
-
-    public static synchronized EthernetDataTracker getInstance() {
-        if (sInstance == null) sInstance = new EthernetDataTracker();
-        return sInstance;
-    }
-
-    public Object Clone() throws CloneNotSupportedException {
-        throw new CloneNotSupportedException();
-    }
-
-    public void setTeardownRequested(boolean isRequested) {
-        mTeardownRequested.set(isRequested);
-    }
-
-    public boolean isTeardownRequested() {
-        return mTeardownRequested.get();
-    }
-
-    /**
-     * Begin monitoring connectivity
-     */
-    public void startMonitoring(Context context, Handler target) {
-        mContext = context;
-        mCsHandler = target;
-
-        // register for notifications from NetworkManagement Service
-        IBinder b = ServiceManager.getService(Context.NETWORKMANAGEMENT_SERVICE);
-        mNMService = INetworkManagementService.Stub.asInterface(b);
-
-        mInterfaceObserver = new InterfaceObserver(this);
-
-        // enable and try to connect to an ethernet interface that
-        // already exists
-        sIfaceMatch = context.getResources().getString(
-            com.android.internal.R.string.config_ethernet_iface_regex);
-        try {
-            final String[] ifaces = mNMService.listInterfaces();
-            for (String iface : ifaces) {
-                if (iface.matches(sIfaceMatch)) {
-                    mIface = iface;
-                    mNMService.setInterfaceUp(iface);
-                    InterfaceConfiguration config = mNMService.getInterfaceConfig(iface);
-                    mLinkUp = config.hasFlag("up");
-                    if (config != null && mHwAddr == null) {
-                        mHwAddr = config.getHardwareAddress();
-                        if (mHwAddr != null) {
-                            mNetworkInfo.setExtraInfo(mHwAddr);
-                        }
-                    }
-
-                    // if a DHCP client had previously been started for this interface, then stop it
-                    NetworkUtils.stopDhcp(mIface);
-
-                    reconnect();
-                    break;
-                }
-            }
-        } catch (RemoteException e) {
-            Log.e(TAG, "Could not get list of interfaces " + e);
-        }
-
-        try {
-            mNMService.registerObserver(mInterfaceObserver);
-        } catch (RemoteException e) {
-            Log.e(TAG, "Could not register InterfaceObserver " + e);
-        }
-    }
-
-    /**
-     * Disable connectivity to a network
-     * TODO: do away with return value after making MobileDataStateTracker async
-     */
-    public boolean teardown() {
-        mTeardownRequested.set(true);
-        NetworkUtils.stopDhcp(mIface);
-        return true;
-    }
-
-    /**
-     * Re-enable connectivity to a network after a {@link #teardown()}.
-     */
-    public boolean reconnect() {
-        if (mLinkUp) {
-            mTeardownRequested.set(false);
-            runDhcp();
-        }
-        return mLinkUp;
-    }
-
-    @Override
-    public void captivePortalCheckComplete() {
-        // not implemented
-    }
-
-    @Override
-    public void captivePortalCheckCompleted(boolean isCaptivePortal) {
-        // not implemented
-    }
-
-    /**
-     * Turn the wireless radio off for a network.
-     * @param turnOn {@code true} to turn the radio on, {@code false}
-     */
-    public boolean setRadio(boolean turnOn) {
-        return true;
-    }
-
-    /**
-     * @return true - If are we currently tethered with another device.
-     */
-    public synchronized boolean isAvailable() {
-        return mNetworkInfo.isAvailable();
-    }
-
-    /**
-     * Tells the underlying networking system that the caller wants to
-     * begin using the named feature. The interpretation of {@code feature}
-     * is completely up to each networking implementation.
-     * @param feature the name of the feature to be used
-     * @param callingPid the process ID of the process that is issuing this request
-     * @param callingUid the user ID of the process that is issuing this request
-     * @return an integer value representing the outcome of the request.
-     * The interpretation of this value is specific to each networking
-     * implementation+feature combination, except that the value {@code -1}
-     * always indicates failure.
-     * TODO: needs to go away
-     */
-    public int startUsingNetworkFeature(String feature, int callingPid, int callingUid) {
-        return -1;
-    }
-
-    /**
-     * Tells the underlying networking system that the caller is finished
-     * using the named feature. The interpretation of {@code feature}
-     * is completely up to each networking implementation.
-     * @param feature the name of the feature that is no longer needed.
-     * @param callingPid the process ID of the process that is issuing this request
-     * @param callingUid the user ID of the process that is issuing this request
-     * @return an integer value representing the outcome of the request.
-     * The interpretation of this value is specific to each networking
-     * implementation+feature combination, except that the value {@code -1}
-     * always indicates failure.
-     * TODO: needs to go away
-     */
-    public int stopUsingNetworkFeature(String feature, int callingPid, int callingUid) {
-        return -1;
-    }
-
-    @Override
-    public void setUserDataEnable(boolean enabled) {
-        Log.w(TAG, "ignoring setUserDataEnable(" + enabled + ")");
-    }
-
-    @Override
-    public void setPolicyDataEnable(boolean enabled) {
-        Log.w(TAG, "ignoring setPolicyDataEnable(" + enabled + ")");
-    }
-
-    /**
-     * Check if private DNS route is set for the network
-     */
-    public boolean isPrivateDnsRouteSet() {
-        return mPrivateDnsRouteSet.get();
-    }
-
-    /**
-     * Set a flag indicating private DNS route is set
-     */
-    public void privateDnsRouteSet(boolean enabled) {
-        mPrivateDnsRouteSet.set(enabled);
-    }
-
-    /**
-     * Fetch NetworkInfo for the network
-     */
-    public synchronized NetworkInfo getNetworkInfo() {
-        return mNetworkInfo;
-    }
-
-    /**
-     * Fetch LinkProperties for the network
-     */
-    public synchronized LinkProperties getLinkProperties() {
-        return new LinkProperties(mLinkProperties);
-    }
-
-   /**
-     * A capability is an Integer/String pair, the capabilities
-     * are defined in the class LinkSocket#Key.
-     *
-     * @return a copy of this connections capabilities, may be empty but never null.
-     */
-    public LinkCapabilities getLinkCapabilities() {
-        return new LinkCapabilities(mLinkCapabilities);
-    }
-
-    /**
-     * Fetch default gateway address for the network
-     */
-    public int getDefaultGatewayAddr() {
-        return mDefaultGatewayAddr.get();
-    }
-
-    /**
-     * Check if default route is set
-     */
-    public boolean isDefaultRouteSet() {
-        return mDefaultRouteSet.get();
-    }
-
-    /**
-     * Set a flag indicating default route is set for the network
-     */
-    public void defaultRouteSet(boolean enabled) {
-        mDefaultRouteSet.set(enabled);
-    }
-
-    /**
-     * Return the system properties name associated with the tcp buffer sizes
-     * for this network.
-     */
-    public String getTcpBufferSizesPropName() {
-        return "net.tcp.buffersize.wifi";
-    }
-
-    public void setDependencyMet(boolean met) {
-        // not supported on this network
-    }
-
-    @Override
-    public void addStackedLink(LinkProperties link) {
-        mLinkProperties.addStackedLink(link);
-    }
-
-    @Override
-    public void removeStackedLink(LinkProperties link) {
-        mLinkProperties.removeStackedLink(link);
-    }
-
-    @Override
-    public void supplyMessenger(Messenger messenger) {
-        // not supported on this network
-    }
-}
diff --git a/core/java/android/net/LinkProperties.java b/core/java/android/net/LinkProperties.java
index b4d07a1..8f6652c 100644
--- a/core/java/android/net/LinkProperties.java
+++ b/core/java/android/net/LinkProperties.java
@@ -30,6 +30,7 @@ import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.Hashtable;
+import java.util.Iterator;
 
 /**
  * Describes the properties of a network link.
@@ -180,6 +181,13 @@ public class LinkProperties implements Parcelable {
         return mLinkAddresses.remove(toRemove);
     }
 
+    public void setLinkAddress(LinkAddress address) {
+        if (address != null) {
+            mLinkAddresses.clear();
+            addLinkAddress(address);
+        }
+    }
+
     /**
      * Returns all the addresses on this link.
      */
@@ -240,6 +248,10 @@ public class LinkProperties implements Parcelable {
             mIfaceName);
     }
 
+    public void setDnses(Collection<InetAddress> dnses) {
+        mDnses =  dnses;
+    }
+
     public void addRoute(RouteInfo route) {
         if (route != null) {
             String routeIface = route.getInterface();
@@ -252,6 +264,16 @@ public class LinkProperties implements Parcelable {
         }
     }
 
+    public void setDefaultGateway(InetAddress gw) {
+        Iterator<RouteInfo> iter = mRoutes.iterator();
+        while (iter.hasNext()) {
+            RouteInfo route = iter.next();
+            if (route.isDefaultRoute()) {
+                iter.remove();
+            }
+        }
+    }
+
     /**
      * Returns all the routes on this link.
      */
diff --git a/core/java/com/android/internal/util/Protocol.java b/core/java/com/android/internal/util/Protocol.java
index b380403..dd2b800 100644
--- a/core/java/com/android/internal/util/Protocol.java
+++ b/core/java/com/android/internal/util/Protocol.java
@@ -53,5 +53,6 @@ public class Protocol {
     public static final int BASE_DNS_PINGER                                         = 0x00050000;
     public static final int BASE_NSD_MANAGER                                        = 0x00060000;
     public static final int BASE_NETWORK_STATE_TRACKER                              = 0x00070000;
+    public static final int BASE_ETHERNET                                           = 0x00080000;
     //TODO: define all used protocols
 }
diff --git a/core/res/res/values/config.xml b/core/res/res/values/config.xml
index b34c792..a8c1463 100644
--- a/core/res/res/values/config.xml
+++ b/core/res/res/values/config.xml
@@ -188,6 +188,7 @@
         <item>"mobile_mms,2,0,2,60000,true"</item>
         <item>"mobile_supl,3,0,2,60000,true"</item>
         <item>"mobile_hipri,5,0,3,60000,true"</item>
+        <item>"ethernet",9,9,0,-1,true"</item>
         <item>"mobile_fota,10,0,2,60000,true"</item>
         <item>"mobile_ims,11,0,2,60000,true"</item>
         <item>"mobile_cbs,12,0,2,60000,true"</item>
@@ -212,6 +213,7 @@
     <string-array translatable="false" name="radioAttributes">
         <item>"1,1"</item>
         <item>"0,1"</item>
+        <item>"9,1"</item>
     </string-array>
 
     <!-- Set of NetworkInfo.getType() that reflect data usage. -->
diff --git a/ethernet/java/com/android/internal/ethernet/EthernetInfo.aidl b/ethernet/java/com/android/internal/ethernet/EthernetInfo.aidl
new file mode 100644
index 0000000..674505f
--- /dev/null
+++ b/ethernet/java/com/android/internal/ethernet/EthernetInfo.aidl
@@ -0,0 +1,19 @@
+/**
+ * Copyright (c) 2012, The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.internal.ethernet;
+
+parcelable EthernetInfo;
diff --git a/ethernet/java/com/android/internal/ethernet/EthernetInfo.java b/ethernet/java/com/android/internal/ethernet/EthernetInfo.java
new file mode 100644
index 0000000..8a6b643
--- /dev/null
+++ b/ethernet/java/com/android/internal/ethernet/EthernetInfo.java
@@ -0,0 +1,410 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.internal.ethernet;
+
+import android.net.ConnectivityManager;
+import android.net.InterfaceConfiguration;
+import android.net.LinkAddress;
+import android.net.LinkProperties;
+import android.net.NetworkInfo;
+import android.net.NetworkInfo.DetailedState;
+import android.net.ProxyProperties;
+import android.net.RouteInfo;
+import android.os.Parcel;
+import android.os.Parcelable;
+import android.os.ServiceManager;
+import android.util.JsonReader;
+import android.util.JsonWriter;
+import android.util.Slog;
+import java.io.IOException;
+import java.net.InetAddress;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Iterator;
+
+public class EthernetInfo implements Parcelable, Comparable<EthernetInfo> {
+    private static final String TAG = "EthernetInfo";
+
+    public enum IpAssignment {
+        /* Use statically configured IP settings. Configuration can be accessed
+         * with linkProperties */
+        STATIC,
+        /* Use dynamically configured IP settigns */
+        DHCP
+    }
+
+    private IpAssignment mIpAssignment;
+
+    public enum ProxySettings {
+        /* No proxy is to be used. Any existing proxy settings
+         * should be cleared. */
+        NONE,
+        /* Use statically configured proxy. Configuration can be accessed
+         * with linkProperties */
+        STATIC,
+        /* no proxy details are assigned, this is used to indicate
+         * that any existing proxy settings should be retained */
+        UNASSIGNED
+    }
+
+    private ProxySettings mProxySettings;
+    public enum InterfaceStatus { DISABLED, ENABLED }
+    private InterfaceStatus mInterfaceStatus;
+    private LinkProperties mLinkProperties;
+    private NetworkInfo mNetworkInfo;
+    private String mHwAddress;
+
+    public EthernetInfo() {
+        mInterfaceStatus = InterfaceStatus.DISABLED;
+        mIpAssignment = IpAssignment.DHCP;
+        mProxySettings = ProxySettings.UNASSIGNED;
+        mLinkProperties = new LinkProperties();
+        mNetworkInfo = newNetworkInfo();
+        mHwAddress = "";
+    }
+
+    public static NetworkInfo newNetworkInfo() {
+        return new NetworkInfo(ConnectivityManager.TYPE_ETHERNET,
+                                       0, /*subtype*/
+                                       "Ethernet", /*name*/
+                                       "" /*subtype name*/
+                                       );
+    }
+
+    public EthernetInfo(String ifaceName, String hwAddress) {
+        mInterfaceStatus = InterfaceStatus.DISABLED;
+        mIpAssignment = IpAssignment.DHCP;
+        mProxySettings = ProxySettings.UNASSIGNED;
+        mLinkProperties = new LinkProperties();
+        mLinkProperties.setInterfaceName(ifaceName);
+        mNetworkInfo = newNetworkInfo();
+        mHwAddress = hwAddress;
+    }
+
+    public EthernetInfo(EthernetInfo source) {
+        mInterfaceStatus = source.mInterfaceStatus;
+        mIpAssignment = source.mIpAssignment;
+        mProxySettings = source.mProxySettings;
+        mLinkProperties = new LinkProperties(source.mLinkProperties);
+        mNetworkInfo = new NetworkInfo(source.mNetworkInfo);
+        mHwAddress = source.mHwAddress;
+    }
+
+    public EthernetInfo(JsonReader reader) throws IOException {
+        mInterfaceStatus = InterfaceStatus.DISABLED;
+        mIpAssignment = IpAssignment.DHCP;
+        mProxySettings = ProxySettings.UNASSIGNED;
+        mLinkProperties = new LinkProperties();
+        mNetworkInfo = newNetworkInfo();
+        mHwAddress = "";
+        mLinkProperties.setInterfaceName("foobar");
+        String proxy_host = null;
+        int proxy_port = -1;
+        String proxy_exclusion = null;
+        String ip_address = null;
+        int netmask = -1;
+        String dns1 = null;
+        String dns2 = null;
+        String default_route = null;
+
+        reader.beginObject();
+        while (reader.hasNext()) {
+            String key = reader.nextName();
+            if (key.equals("interface_status")) {
+                setInterfaceStatus(InterfaceStatus.values()[reader.nextInt()]);
+            } else if (key.equals("ip_assignment")) {
+                setIpAssignment(IpAssignment.values()[reader.nextInt()]);
+            } else if (key.equals("proxy_settings")) {
+                setProxySettings(ProxySettings.values()[reader.nextInt()]);
+            } else if (key.equals("interface_name")) {
+                mLinkProperties.setInterfaceName(reader.nextString());
+            } else if (key.equals("proxy_host")) {
+                proxy_host = reader.nextString();
+            } else if (key.equals("proxy_port")) {
+                proxy_port = reader.nextInt();
+            } else if (key.equals("proxy_exclusion")) {
+                proxy_exclusion = reader.nextString();
+            } else if (key.equals("ip_address")) {
+                ip_address = reader.nextString();
+            } else if (key.equals("netmask")) {
+                netmask = reader.nextInt();
+            } else if (key.equals("dns1")) {
+                dns1 = reader.nextString();
+            } else if (key.equals("dns2")) {
+                dns2 = reader.nextString();
+            } else if (key.equals("default_route")) {
+                default_route = reader.nextString();
+            } else if (key.equals("hw_address")) {
+                mHwAddress = reader.nextString();
+            }
+        }
+        reader.endObject();
+
+        if (proxy_host != null && proxy_port > 0 && proxy_exclusion != null) {
+            mLinkProperties.setHttpProxy(
+                    new ProxyProperties(proxy_host, proxy_port, proxy_exclusion));
+        }
+        if (ip_address != null && netmask != -1) {
+            InetAddress inetaddr = InetAddress.getAllByName(ip_address)[0];
+            mLinkProperties.addLinkAddress( new LinkAddress( inetaddr, netmask));
+        }
+        if (dns1 != null) {
+            mLinkProperties.addDns(InetAddress.getAllByName(dns1)[0]);
+        }
+        if (dns2 != null) {
+            mLinkProperties.addDns(InetAddress.getAllByName(dns2)[0]);
+        }
+        if (default_route != null) {
+            InetAddress gw_addr = InetAddress.getAllByName(default_route)[0];
+            mLinkProperties.addRoute(new RouteInfo(gw_addr));
+        }
+    }
+
+    public String getHwAddress() { return mHwAddress; }
+    public void setHwAddress(String addr) { mHwAddress = addr; }
+    public IpAssignment getIpAssignment() { return mIpAssignment; }
+    public void setIpAssignment(IpAssignment ipAssignment) { mIpAssignment = ipAssignment; }
+    public boolean isStaticIpAssignment() { return mIpAssignment == IpAssignment.STATIC; }
+    public ProxySettings getProxySettings() { return mProxySettings; }
+    public void setProxySettings(ProxySettings proxySettings) { mProxySettings = proxySettings; }
+    public InterfaceStatus getInterfaceStatus() { return mInterfaceStatus; }
+    public void setInterfaceStatus(InterfaceStatus is) { mInterfaceStatus = is; }
+    public void enable() { mInterfaceStatus = InterfaceStatus.ENABLED; }
+    public void disable() { mInterfaceStatus = InterfaceStatus.DISABLED; }
+    public boolean isEnabled() { return mInterfaceStatus == InterfaceStatus.ENABLED; }
+    public DetailedState getDetailedState() { return mNetworkInfo.getDetailedState(); }
+
+    public void setDetailedState(DetailedState ds, String reason, String extraInfo) {
+        mNetworkInfo.setDetailedState(ds, reason, extraInfo);
+    }
+
+    public void setIsAvailable(boolean flag) { mNetworkInfo.setIsAvailable(flag); }
+    public LinkProperties getLinkProperties() { return mLinkProperties; }
+    public void setLinkProperties(LinkProperties lp) { mLinkProperties = lp; }
+    public void setDefaultGateway(InetAddress gw) { mLinkProperties.setDefaultGateway(gw); }
+    public NetworkInfo getNetworkInfo() { return new NetworkInfo(mNetworkInfo); }
+    public void setNetworkInfo(NetworkInfo ni) { mNetworkInfo = ni; }
+    public void setLinkAddress(LinkAddress addr) { mLinkProperties.setLinkAddress(addr); }
+    public void setHttpProxy(ProxyProperties props) { mLinkProperties.setHttpProxy(props); }
+    public ProxyProperties getHttpProxy() { return mLinkProperties.getHttpProxy(); }
+
+    public InetAddress getDefaultGateway() {
+        boolean foundDefault = false;
+        InetAddress retval = null;
+        for (RouteInfo route : mLinkProperties.getRoutes()) {
+            if (route.isDefaultRoute()) {
+                if (!foundDefault) {
+                    retval = route.getGateway();
+                    foundDefault = true;
+                } else {
+                    Slog.e(TAG, "Consistency error: Multiple default routes");
+                    break;
+                }
+            }
+        }
+        return retval;
+    }
+
+    public InetAddress getDNS1() {
+        Iterator<InetAddress> dnsIterator = mLinkProperties.getDnses().iterator();
+        if (dnsIterator.hasNext()) {
+            return dnsIterator.next();
+        }
+        return null;
+    }
+
+    public void setDNS(InetAddress dns1, InetAddress dns2) {
+        Collection<InetAddress> addrs = new ArrayList<InetAddress>();
+        if (dns1 != null) {
+            addrs.add(dns1);
+        }
+        if (dns2 != null) {
+            addrs.add(dns2);
+        }
+        mLinkProperties.setDnses(addrs);
+    }
+
+    public InetAddress getDNS2() {
+        Iterator<InetAddress> dnsIterator = mLinkProperties.getDnses().iterator();
+        if (dnsIterator.hasNext()) {
+            dnsIterator.next();
+            if (dnsIterator.hasNext()) {
+                return dnsIterator.next();
+            }
+        }
+        return null;
+    }
+
+    @Override
+    public int describeContents() { return 0; }
+
+    public String getName() {
+        return mLinkProperties == null ? "none" : mLinkProperties.getInterfaceName();
+    }
+
+    public void setName(String name) { mLinkProperties.setInterfaceName(name); }
+
+    public LinkAddress getLinkAddress() {
+        Collection<LinkAddress> addresses = mLinkProperties.getLinkAddresses();
+        if (addresses.size() == 0) {
+            return null;
+        } else if (addresses.size() > 1) {
+            Slog.e(TAG, "Consistency error: Multiple link addresses");
+        }
+        return addresses.iterator().next();
+    }
+
+    public void write(JsonWriter writer) throws IOException {
+        // NetworkInfo member is not persisted to json because
+        // it is essentially a "read-only" parameter. i.e. it is ignored
+        // by EthernetStateMachine.updateInterface().
+        writer.beginObject();
+        writer.name("interface_status").value(mInterfaceStatus.ordinal());
+        writer.name("ip_assignment").value(mIpAssignment.ordinal());
+        writer.name("proxy_settings").value(mProxySettings.ordinal());
+        writer.name("interface_name").value( mLinkProperties.getInterfaceName());
+        writer.name("hw_address").value(mHwAddress);
+
+        ProxyProperties proxy = mLinkProperties.getHttpProxy();
+        if (proxy != null) {
+            Slog.d(TAG, "Persisting proxy properties.");
+            writer.name("proxy_host").value(proxy.getHost());
+            writer.name("proxy_port").value(proxy.getPort());
+            writer.name("proxy_exclusion").value(proxy.getExclusionList());
+        } else {
+            Slog.d(TAG, "Not persisting proxy properties.");
+        }
+
+        if (mIpAssignment != IpAssignment.DHCP) {
+            // IP Address
+            Collection<LinkAddress> addresses = mLinkProperties.getLinkAddresses();
+            if (addresses.size() > 1) {
+                Slog.w(TAG, "Found multiple InetAddresses, only persisting first.");
+            }
+            if (!addresses.isEmpty()) {
+                LinkAddress la = (LinkAddress) addresses.toArray()[0];
+                String ip_address = la.getAddress().getHostAddress();
+                writer.name("ip_address").value(ip_address);
+                writer.name("netmask").value(la.getNetworkPrefixLength());
+            }
+
+            // DNS1:
+            Collection<InetAddress> dnses = mLinkProperties.getDnses();
+            if (dnses.size() > 0) {
+                InetAddress ia = (InetAddress) dnses.toArray()[0];
+                String dns1 = ia.getHostAddress();
+                writer.name("dns1").value(dns1);
+            }
+
+            // DNS2:
+            if (dnses.size() > 1) {
+                InetAddress ia = (InetAddress) dnses.toArray()[1];
+                String dns2 = ia.getHostAddress();
+                writer.name("dns2").value(dns2);
+            }
+
+            // Default gateway:
+            Collection<RouteInfo> routes = mLinkProperties.getRoutes();
+            if (routes.size() > 1) {
+                Slog.w(TAG, "Found multiple routes, only persisting first.");
+            }
+            if (!routes.isEmpty()) {
+                RouteInfo ri = (RouteInfo) routes.toArray()[0];
+                String route = ri.getGateway().getHostAddress();
+                writer.name("default_route").value(route);
+            }
+        }
+        writer.endObject();
+    }
+
+    @Override
+    public String toString() {
+        StringBuffer sb = new StringBuffer();
+        String none = "<none>";
+        String lpString = mLinkProperties == null ? none : mLinkProperties.toString();
+        String niString = mNetworkInfo == null ? none : mNetworkInfo.toString();
+
+        sb.append(" Device name: ").append(getName()).
+           append(", Interface Status: ").append(mInterfaceStatus.name()).
+           append(", MAC Address: ").append(mHwAddress).
+           append(", IP assignment: ").append(mIpAssignment.name()).
+           append(", Proxy Settings: ").append(mProxySettings.name()).
+           append(", Link properties: ").append(lpString).
+           append(", Network info: ").append(niString);
+
+        return sb.toString();
+    }
+
+    @Override
+    public void writeToParcel(Parcel dest, int flags) {
+        dest.writeString(mInterfaceStatus.name());
+        dest.writeString(mIpAssignment.name());
+        dest.writeString(mProxySettings.name());
+        dest.writeParcelable(mLinkProperties, flags);
+        dest.writeParcelable(mNetworkInfo, flags);
+        dest.writeString(mHwAddress);
+    }
+
+    @Override
+    public boolean equals(Object that)
+    {
+        if (that instanceof EthernetInfo) {
+            EthernetInfo thatEI = (EthernetInfo) that;
+            if (! this.mInterfaceStatus.equals(thatEI.mInterfaceStatus)) {
+                return false;
+            } else if (! this.mIpAssignment.equals(thatEI.mIpAssignment)) {
+                return false;
+            } else if (! this.mProxySettings.equals(thatEI.mProxySettings)) {
+               return false;
+            } else if (! this.mLinkProperties.equals(thatEI.mLinkProperties)) {
+               return false;
+            } else if (! this.mNetworkInfo.equals(thatEI.mNetworkInfo)) {
+                return false;
+            } else if (! this.mHwAddress.equals(thatEI.mHwAddress)) {
+                return false;
+            } else {
+                return true;
+            }
+        } else {
+            return false;
+        }
+    }
+
+    public static final Creator<EthernetInfo> CREATOR = new
+            Creator<EthernetInfo>() {
+                @Override
+                public EthernetInfo createFromParcel(Parcel in) {
+                    EthernetInfo info = new EthernetInfo();
+                    info.setInterfaceStatus(InterfaceStatus.valueOf(in.readString()));
+                    info.setIpAssignment(IpAssignment.valueOf(in.readString()));
+                    info.setProxySettings(ProxySettings.valueOf(in.readString()));
+                    info.setLinkProperties((LinkProperties)in.readParcelable(null));
+                    info.setNetworkInfo((NetworkInfo)in.readParcelable(null));
+                    info.setHwAddress(in.readString());
+                    return info;
+                }
+
+                @Override
+                public EthernetInfo[] newArray(int size) {
+                    return new EthernetInfo[size];
+                }
+            };
+
+    public int compareTo(EthernetInfo o) {
+        return mHwAddress.compareTo(o.getHwAddress());
+    }
+}
diff --git a/ethernet/java/com/android/internal/ethernet/EthernetManager.java b/ethernet/java/com/android/internal/ethernet/EthernetManager.java
new file mode 100644
index 0000000..75d6b12
--- /dev/null
+++ b/ethernet/java/com/android/internal/ethernet/EthernetManager.java
@@ -0,0 +1,224 @@
+/**
+ * Copyright (c) 2012, The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.internal.ethernet;
+
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.net.ConnectivityManager;
+import android.net.DhcpInfo;
+import android.net.LinkCapabilities;
+import android.net.LinkProperties;
+import android.net.LinkQualityInfo;
+import android.net.NetworkInfo;
+import android.net.NetworkStateTracker;
+import android.net.NetworkUtils;
+import android.net.SamplingDataTracker;
+import android.os.Handler;
+import android.os.IBinder;
+import android.os.Message;
+import android.os.Messenger;
+import android.os.RemoteException;
+import android.os.ServiceManager;
+import android.util.Log;
+import com.android.internal.ethernet.EthernetInfo;
+import com.android.internal.ethernet.IEthernetManager;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.List;
+import java.net.InetAddress;
+
+/**
+ * EthernetManager provides access to ethernet to system apps (such as
+ * settings).
+
+ * They can query for and configure any interfaces available on the system. In
+ * addition, EthernetManager implements NetworkStateTracker, the generic
+ * abstraction of a network type used by ConnectivityService.
+ */
+public class EthernetManager implements NetworkStateTracker {
+    private IEthernetManager mService;
+    private static final String TAG = "EthernetManager";
+    private static final String PACKAGE = "com.android.internal.ethernet";
+
+    /**
+     * Broadcast when the NetworkInfo representing Ethernet as a whole changes.
+     */
+    public static final String NETWORK_STATE_CHANGED_ACTION =
+                   PACKAGE + ".NETWORK_STATE_CHANGED_ACTION";
+
+    /**
+     * Broadcast when the NetworkInfo or EthernetInfo representing an
+     * individual interface changes.
+     */
+    public static final String INTERFACE_STATE_CHANGED_ACTION =
+                   PACKAGE + ".INTERFACE_STATE_CHANGED_ACTION";
+
+    /**
+     * Broadcast when an interface is removed.
+     */
+    public static final String INTERFACE_REMOVED_ACTION = PACKAGE+".INTERFACE_REMOVED_ACTION";
+
+    public static final String EXTRA_LINK_PROPERTIES   = "EXTRA_LINK_PROPERTIES";
+    public static final String EXTRA_ETHERNET_INFO     = "EXTRA_ETHERNET_INFO";
+    public static final String EXTRA_INTERFACE_NAME    = "EXTRA_INTERFACE_NAME";
+    public static final int DATA_ACTIVITY_NOTIFICATION = 0;
+    public static final int DATA_ACTIVITY_NONE         = 1;
+    public static final int DATA_ACTIVITY_IN           = 2;
+    public static final int DATA_ACTIVITY_OUT          = 3;
+    public static final int DATA_ACTIVITY_INOUT        = 4;
+    public static final int ENABLE_TRAFFIC_STATS_POLL  = 5;
+    public static final int TRAFFIC_STATS_POLL         = 6;
+
+    public EthernetInfo getCurrentInterface() {
+        try {
+            return mService.getCurrentInterface();
+        } catch (RemoteException e) {
+            Log.e(TAG, "Failed to communicate with EthernetService: " + e.getMessage());
+            return null;
+        }
+    }
+
+    public void updateInterface(EthernetInfo info) {
+        try {
+            mService.updateInterface(info);
+        } catch (RemoteException e) {
+            Log.e(TAG, "Failed to communicate with EthernetService: " + e.getMessage());
+        }
+    }
+
+    public boolean isEnabled() {
+        try {
+            return mService.isEnabled();
+        } catch (RemoteException e) {
+            Log.e(TAG, "Failed to communicate with EthernetService: " + e.getMessage());
+        }
+        return false;
+    }
+
+    /**
+     * Sends callbacks to ConnectivityService.
+     */
+    private Handler mCsHandler;
+    private Context mContext;
+    private NetworkInfo mNetworkInfo;
+    private LinkProperties mLinkProperties;
+    private AtomicBoolean mPrivateDnsRouteSet = new AtomicBoolean(false);
+    private AtomicBoolean mDefaultRouteSet = new AtomicBoolean(false);
+    private AtomicBoolean mTeardownRequested = new AtomicBoolean(false);
+
+    private class EthernetStateReceiver extends BroadcastReceiver {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            if (intent.getAction().equals(NETWORK_STATE_CHANGED_ACTION)) {
+                EthernetInfo ei = (EthernetInfo) intent.getParcelableExtra(
+                        EthernetManager.EXTRA_ETHERNET_INFO);
+                if (ei != null) {
+                    mLinkProperties = ei.getLinkProperties();
+                    mNetworkInfo = ei.getNetworkInfo();
+                    Message msg = mCsHandler.obtainMessage(EVENT_STATE_CHANGED,
+                            new NetworkInfo(mNetworkInfo));
+                    msg.sendToTarget();
+                }
+            }
+        }
+    }
+
+    public void startMonitoring(Context context, Handler target) {
+        mCsHandler = target;
+        mContext = context;
+        IntentFilter filter = new IntentFilter();
+        filter.addAction(NETWORK_STATE_CHANGED_ACTION);
+        mContext.registerReceiver(new EthernetStateReceiver(), filter);
+    }
+
+    public boolean teardown() {
+        try {
+            return mService.teardown();
+        } catch (RemoteException e) {
+            Log.e(TAG, "Failed to communicate with EthernetService: " +
+            e.getMessage());
+        }
+        return false;
+    }
+
+    @Override
+    public void captivePortalCheckComplete() {
+        // not implemented
+    }
+
+    public boolean reconnect() {
+        try {
+            return mService.reconnect();
+        } catch (RemoteException e) {
+            Log.e(TAG, "Failed to communicate with EthernetService: " +
+            e.getMessage());
+        }
+        return false;
+    }
+
+    public boolean isAvailable() { return mNetworkInfo.isAvailable(); }
+    public NetworkInfo getNetworkInfo() { return new NetworkInfo(mNetworkInfo); }
+    public LinkProperties getLinkProperties() {
+        return new LinkProperties(mLinkProperties);
+    }
+    // Wifi does the same thing:
+    public LinkCapabilities getLinkCapabilities() { return new LinkCapabilities(); }
+    public String getTcpBufferSizesPropName() { return "net.tcp.buffersize.ethernet"; }
+    public boolean setRadio(boolean turnOn) { return true; }
+    public void setUserDataEnable(boolean enabled) { }
+    public void setPolicyDataEnable(boolean enabled) { }
+    public boolean isPrivateDnsRouteSet() { return mPrivateDnsRouteSet.get(); }
+    public void privateDnsRouteSet(boolean enabled) { mPrivateDnsRouteSet.set(enabled); }
+    public boolean isDefaultRouteSet() { return mDefaultRouteSet.get(); }
+    public void defaultRouteSet(boolean enabled) { mDefaultRouteSet.set(enabled); }
+    public boolean isTeardownRequested() { return mTeardownRequested.get(); }
+    public void setTeardownRequested(boolean enabled) { mTeardownRequested.set(enabled); }
+    public void setDependencyMet(boolean met) { }
+    public void addStackedLink(LinkProperties link) { }
+    public void removeStackedLink(LinkProperties link) { }
+    public void supplyMessenger(Messenger messenger) { }
+    public String getNetworkInterfaceName() { return ""; }
+    public void startSampling(SamplingDataTracker.SamplingSnapshot s) { }
+    public void stopSampling(SamplingDataTracker.SamplingSnapshot s) { }
+    public void captivePortalCheckCompleted(boolean isCaptive) { }
+    public LinkQualityInfo getLinkQualityInfo() { return new LinkQualityInfo(); }
+
+    /**
+     * Create a new EthernetManager instance.
+     * Applications will almost always want to use
+     * {@link android.content.Context#getSystemService Context.getSystemService()} to retrieve
+     * the standard {@link android.content.Context#ETHERNET_SERVICE Context.ETHERNET_SERVICE}.
+     * @param service the Binder interface
+     * @hide - hide this because it takes in a parameter of type
+     * IEthernetManager, which
+     * is a system private class.
+     */
+    public EthernetManager(IEthernetManager service) {
+        mService = service;
+        mNetworkInfo = EthernetInfo.newNetworkInfo();
+        mLinkProperties = new LinkProperties();
+    }
+
+    public Messenger getEthernetServiceMessenger() {
+        try {
+            return mService.getEthernetServiceMessenger();
+        } catch (RemoteException e) {
+            return null;
+        }
+    }
+}
diff --git a/ethernet/java/com/android/internal/ethernet/EthernetStateMachine.java b/ethernet/java/com/android/internal/ethernet/EthernetStateMachine.java
new file mode 100644
index 0000000..fe9014f
--- /dev/null
+++ b/ethernet/java/com/android/internal/ethernet/EthernetStateMachine.java
@@ -0,0 +1,353 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.internal.ethernet;
+
+import java.net.InetAddress;
+import java.util.ArrayList;
+import android.content.Context;
+import android.content.Intent;
+import android.net.ConnectivityManager;
+import android.net.DhcpResults;
+import android.net.DhcpStateMachine;
+import android.net.DhcpStateMachine;
+import android.net.InterfaceConfiguration;
+import android.net.LinkProperties;
+import android.net.NetworkInfo.DetailedState;
+import android.net.RouteInfo;
+import android.os.INetworkManagementService;
+import android.os.Message;
+import android.os.RemoteException;
+import android.os.ServiceManager;
+import android.util.Slog;
+import com.android.internal.util.Protocol;
+import com.android.internal.util.State;
+import com.android.internal.util.StateMachine;
+
+public class EthernetStateMachine extends StateMachine {
+    private static final String TAG = "EthernetStateMachine";
+    private static final boolean DBG = true;
+    public static final int BASE = Protocol.BASE_ETHERNET;
+    public static final int CMD_UPDATE_INTERFACE = BASE + 1;
+    public static final int CMD_SHUTDOWN = BASE + 2;
+    public static final int CMD_INTERFACE_GONE = BASE + 3;
+    private Context mContext;
+    private EthernetInfo mEthernetInfo;
+    private DhcpStateMachine mDhcpStateMachine;
+    private State mRootState = new RootState();
+    private State mIdleState = new IdleState();
+    //private State mObtainingLinkState = new ObtainingLinkState();
+    private State mObtainingIpState = new ObtainingIpState();
+    private State mIPConnectedState = new IPConnectedState();
+    private State mDisconnectingState = new DisconnectingState();
+    private INetworkManagementService mNetd;
+
+    public EthernetStateMachine(Context context, String ifaceName, String hwAddr) {
+        super(TAG);
+        mEthernetInfo = new EthernetInfo(ifaceName, hwAddr);
+        initialize(context);
+    }
+
+    public EthernetStateMachine(Context context, EthernetInfo info) {
+        super(TAG);
+        mEthernetInfo = info;
+        initialize(context);
+    }
+
+    protected void onQuitting() {
+        if (DBG) Slog.d(TAG, "EtherNetStateMachine.onQuitting");
+        mContext = null;
+        mEthernetInfo = null;
+        mDhcpStateMachine = null;
+    }
+
+    /*
+     * Quit the EthernetStateMachine.
+     */
+    public void doQuit() {
+        if (mDhcpStateMachine != null) {
+            /*
+             * restore DhcpState to stop.
+             */
+            mDhcpStateMachine.sendMessage(DhcpStateMachine.CMD_STOP_DHCP);
+            if (DBG) Slog.d(TAG, "Quit DHCP stateMachine");
+            mDhcpStateMachine.doQuitNow();
+        }
+    }
+
+    private void initialize(Context context) {
+        mContext = context;
+        mNetd = INetworkManagementService.Stub.asInterface(
+                ServiceManager.getService(Context.NETWORKMANAGEMENT_SERVICE));
+        addState(mRootState);
+            addState(mIdleState, mRootState);
+            //addState(mObtainingLinkState, mRootState);
+            addState(mObtainingIpState, mRootState);
+            addState(mIPConnectedState, mRootState);
+            addState(mDisconnectingState, mRootState);
+
+        setInitialState(mIdleState);
+
+        mDhcpStateMachine = DhcpStateMachine.makeDhcpStateMachine(
+                mContext, EthernetStateMachine.this,
+                mEthernetInfo.getName());
+
+        sendInterfaceStateChangedBroadcast();
+        start();
+    }
+
+    public EthernetInfo getInfo() {
+        return new EthernetInfo(mEthernetInfo);
+    }
+
+    private void sendInterfaceStateChangedBroadcast() {
+        if (DBG) Slog.d(TAG, "Sending INTERFACE_STATE_CHANGED_ACTION for "
+                + mEthernetInfo.getName());
+        Intent intent = new Intent(EthernetManager.INTERFACE_STATE_CHANGED_ACTION);
+        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
+        intent.putExtra(EthernetManager.EXTRA_ETHERNET_INFO, new EthernetInfo(mEthernetInfo));
+        mContext.sendBroadcast(intent);
+    }
+
+    private void setNetworkDetailedState(DetailedState state) {
+        if (DBG) Slog.d(TAG, mEthernetInfo.getName() + " setDetailed state, old ="
+                + mEthernetInfo.getDetailedState() + " and new state=" + state);
+        if (state != mEthernetInfo.getDetailedState()) {
+            mEthernetInfo.setDetailedState(state, null, null);
+            mEthernetInfo.setIsAvailable(true);
+            sendInterfaceStateChangedBroadcast();
+        }
+    }
+
+    public boolean isEnabled() {
+        return mEthernetInfo.isEnabled();
+    }
+
+    class RootState extends State {
+        @Override
+        public boolean processMessage(Message message) {
+            if (DBG) Slog.d(TAG, mEthernetInfo.getName()
+                    + " RootState.processMessage: " + message.toString());
+            switch (message.what) {
+                case CMD_UPDATE_INTERFACE:
+                    if (DBG) Slog.d(TAG, "RootState: received CMD_UPDATE_INTERFACE");
+                    EthernetInfo newInfo = (EthernetInfo) message.obj;
+                    if (newInfo != mEthernetInfo) {
+                        if (mEthernetInfo.isEnabled()) {
+                            setNetworkDetailedState(DetailedState.DISCONNECTING);
+                            transitionTo(mDisconnectingState);
+                        } else {
+                            transitionTo(mIdleState);
+                        }
+                        mEthernetInfo = newInfo;
+                    }
+                    return HANDLED;
+                case CMD_SHUTDOWN:
+                    shutdown();
+                    return HANDLED;
+                case DhcpStateMachine.CMD_ON_QUIT:
+                    if (DBG) Slog.d(TAG, "Received CMD_ON_QUIT");
+                    mDhcpStateMachine = null;
+                    //Quit EthernetStateMachine now.
+                    quitNow();
+                    return HANDLED;
+                default:
+                    Slog.e(TAG, mEthernetInfo.getName()
+                            + " Unhandled message in EthernetStateMachine: "
+                            + message.toString());
+                    return NOT_HANDLED;
+            }
+        }
+    }
+
+    private void shutdown() {
+        mEthernetInfo.disable();
+        setNetworkDetailedState(DetailedState.DISCONNECTING);
+        transitionTo(mDisconnectingState);
+    }
+
+    class IdleState extends State {
+        @Override
+        public void enter() {
+            if (DBG) Slog.d(TAG, mEthernetInfo.getName() + " Entered IdleState");
+            if (mEthernetInfo.isEnabled()) {
+                if (DBG) Slog.d(TAG, mEthernetInfo.getName()
+                        + " is enabled in IdleState.enter()");
+                setNetworkDetailedState(DetailedState.OBTAINING_IPADDR);
+                transitionTo(mObtainingIpState);
+                //setNetworkDetailedState(DetailedState.SCANNING);
+                //transitionTo(mObtainingLinkState);
+            }
+        }
+        public boolean processMessage(Message message) {
+            switch (message.what) {
+                case CMD_SHUTDOWN:
+                    return HANDLED;
+                default:
+                    return NOT_HANDLED;
+            }
+        }
+    }
+
+    /*
+    class ObtainingLinkState extends State {
+        @Override
+        public void enter() {
+            if (DBG) Slog.d(TAG, mEthernetInfo.getName() + " Entered ObtainingLinkState");
+            String ifaceName = mEthernetInfo.getName();
+            try {
+                InterfaceConfiguration config =
+                    mNetd.getInterfaceConfig(ifaceName);
+                config.setInterfaceUp();
+                mNetd.setInterfaceConfig(ifaceName, config);
+            } catch (RemoteException re) {
+                Slog.e(TAG, "Failed to bring up " + mEthernetInfo.getName()
+                        + ": " + re);
+            } catch (IllegalStateException e) {
+                Slog.e(TAG, "Failed to bring up " + mEthernetInfo.getName()
+                        + ": " + e);
+            }
+            shutdown();
+        }
+        @Override
+        public boolean processMessage(Message message) {
+            if (DBG) Slog.d(TAG, mEthernetInfo.getName()
+                    + " ObtainingLinkState.processMessage: " + message.toString());
+            switch (message.what) {
+                case CMD_LINK_UP:
+                    setNetworkDetailedState(DetailedState.OBTAINING_IPADDR);
+                    transitionTo(mObtainingIpState);
+                    return HANDLED;
+                default:
+                    return NOT_HANDLED;
+            }
+        }
+    }
+    */
+
+    class ObtainingIpState extends State {
+        @Override
+        public void enter() {
+            if (DBG) Slog.d(TAG, mEthernetInfo.getName() + " Entered ObtainingIpState");
+            String ifaceName = mEthernetInfo.getName();
+            if (mEthernetInfo.isStaticIpAssignment()) {
+                try {
+                    InterfaceConfiguration config =
+                        mNetd.getInterfaceConfig(ifaceName);
+                    config.setLinkAddress(mEthernetInfo.getLinkAddress());
+                    config.setInterfaceUp();
+                    mNetd.setInterfaceConfig(ifaceName, config);
+                    if (DBG) Slog.d(TAG, mEthernetInfo.getName()
+                            + " Transitioning to IPConnectedState");
+                    setNetworkDetailedState(DetailedState.CONNECTED);
+                    transitionTo(mIPConnectedState);
+                    return;
+                } catch (RemoteException re) {
+                    Slog.e(TAG, mEthernetInfo.getName()
+                            + " Static IP configuration failed: " + re);
+                } catch (IllegalStateException e) {
+                    Slog.e(TAG, mEthernetInfo.getName()
+                            + " Static IP configuration failed: " + e);
+                }
+                shutdown();
+            } else {
+                if (DBG) Slog.d(TAG, "Starting DhcpStateMachine for " + mEthernetInfo.getName());
+                mDhcpStateMachine.sendMessage(DhcpStateMachine.CMD_START_DHCP);
+            }
+        }
+        @Override
+        public boolean processMessage(Message message) {
+            if (DBG) Slog.d(TAG, mEthernetInfo.getName()
+                    + " ObtainingIpState.processMessage: " + message.toString());
+            switch (message.what) {
+                case DhcpStateMachine.CMD_POST_DHCP_ACTION:
+                    if (message.arg1 == DhcpStateMachine.DHCP_SUCCESS) {
+                        dhcpSuccess((DhcpResults) message.obj);
+                        transitionTo(mIPConnectedState);
+                    } else if (message.arg1 == DhcpStateMachine.DHCP_FAILURE) {
+                        if (DBG) Slog.d(TAG, mEthernetInfo.getName() + " DHCP failed; retrying in 10s");
+                        mDhcpStateMachine.sendMessageDelayed(DhcpStateMachine.CMD_START_DHCP, 10000);
+                    }
+                    return HANDLED;
+                default: return NOT_HANDLED;
+            }
+        }
+    }
+
+    void dhcpSuccess(DhcpResults dr) {
+        if (DBG) Slog.d(TAG, mEthernetInfo.getName() + " DHCP successful");
+        LinkProperties lp = dr.linkProperties;
+        lp.setHttpProxy(mEthernetInfo.getHttpProxy());
+        lp.setInterfaceName(mEthernetInfo.getName());
+        if (!lp.equals(mEthernetInfo.getLinkProperties())) {
+            Slog.i(TAG, "Link configuration changed for: " + mEthernetInfo.getName()
+                    + " old: " + mEthernetInfo.getLinkProperties() + "new: " + lp);
+            mEthernetInfo.setLinkProperties(lp);
+        }
+        setNetworkDetailedState(DetailedState.CONNECTED);
+    }
+
+    class IPConnectedState extends State {
+        public void enter() {
+            if (DBG) Slog.d(TAG, mEthernetInfo.getName() + " Entered IPConnectedState");
+        }
+        @Override
+        public boolean processMessage(Message message) {
+            if (DBG) Slog.d(TAG, mEthernetInfo.getName()
+                    + " IPConnectedState.processMessage: " + message.toString());
+            switch (message.what) {
+                case CMD_UPDATE_INTERFACE:
+                    if (DBG) Slog.d(TAG, "IPConnectedState: received CMD_UPDATE_INTERFACE");
+                    EthernetInfo newInfo = (EthernetInfo) message.obj;
+                    if (!newInfo.equals(mEthernetInfo)) {
+                        setNetworkDetailedState(DetailedState.DISCONNECTING);
+                        transitionTo(mDisconnectingState);
+                        mEthernetInfo = newInfo;
+                    }
+                    return HANDLED;
+
+                case DhcpStateMachine.CMD_POST_DHCP_ACTION:
+                    if (message.arg1 == DhcpStateMachine.DHCP_SUCCESS) {
+                        dhcpSuccess((DhcpResults) message.obj);
+                        setNetworkDetailedState(DetailedState.CONNECTED);
+                    } else if (message.arg1 == DhcpStateMachine.DHCP_FAILURE) {
+                        if (DBG) Slog.d(TAG, mEthernetInfo.getName() + " DHCP failed");
+                        shutdown();
+                    }
+                    return HANDLED;
+                default: return NOT_HANDLED;
+            }
+        }
+    }
+
+    class DisconnectingState extends State {
+        public void enter() {
+            if (DBG) Slog.d(TAG, mEthernetInfo.getName() + " Entered DisconnectingState");
+            try {
+                mNetd.setInterfaceDown(mEthernetInfo.getName());
+            } catch (RemoteException re) {
+                Slog.e(TAG, mEthernetInfo.getName() + " Failed to bring down interface: " + re);
+            } catch (IllegalStateException ise) {
+                // Oftentimes interface may not exist anymore:
+                if (DBG) Slog.d(TAG, "Failed to bring down "
+                        + mEthernetInfo.getName() + ": " + ise);
+            }
+            mDhcpStateMachine.sendMessage(DhcpStateMachine.CMD_STOP_DHCP);
+            setNetworkDetailedState(DetailedState.DISCONNECTED);
+            transitionTo(mIdleState);
+        }
+    }
+}
diff --git a/ethernet/java/com/android/internal/ethernet/IEthernetManager.aidl b/ethernet/java/com/android/internal/ethernet/IEthernetManager.aidl
new file mode 100644
index 0000000..1270473
--- /dev/null
+++ b/ethernet/java/com/android/internal/ethernet/IEthernetManager.aidl
@@ -0,0 +1,37 @@
+/**
+ * Copyright (c) 2012, The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.internal.ethernet;
+
+import android.os.Messenger;
+import android.os.Parcel;
+import android.os.Parcelable;
+import com.android.internal.ethernet.EthernetInfo;
+
+/**
+ * Interface that allows Ethernet device discovery as well as querying
+ * and setting Ethernet configuration information.
+ * {@hide}
+ */
+interface IEthernetManager
+{
+    EthernetInfo getCurrentInterface();
+    void updateInterface(in EthernetInfo info);
+    boolean teardown();
+    boolean reconnect();
+    boolean isEnabled();
+    Messenger getEthernetServiceMessenger();
+}
diff --git a/ethernet/java/com/android/internal/ethernet/package.html b/ethernet/java/com/android/internal/ethernet/package.html
new file mode 100644
index 0000000..6377c18
--- /dev/null
+++ b/ethernet/java/com/android/internal/ethernet/package.html
@@ -0,0 +1,5 @@
+<html>
+<body>
+{@hide}
+</body>
+</html>
diff --git a/packages/SystemUI/res/drawable-hdpi/stat_sys_ethernet_connected.png b/packages/SystemUI/res/drawable-hdpi/stat_sys_ethernet_connected.png
new file mode 100644
index 0000000000000000000000000000000000000000..442f95247ded173706895d1313d4896d14fc80a3
GIT binary patch
literal 689
zcmV;i0#5yjP)<h;3K|Lk000e1NJLTq0015U000{Z1^@s6YyCeF00001b5ch_0Itp)
z=>Px#24YJ`L;(K){{a7>y{D4^000SaNLh0L01FcU01FcV0GgZ_00007bV*G`2iyk(
z77r#wgG2fN000?uMObu0Z*6U5Zgc=ca%Ew3Wn>_CX>@2HM@dakSAh-}0006ENkl<Z
zNXPA#Jx^0%7>2L=oYN1nAy^F>bx;RLm`qGCad9#3kZ9sBDL(-w2WO+d00wk&H4ZKg
zy0i(21DYs`LHTG;d*0gtZGkpI(;^Gcc23Tl>%Gr&KOb-!|0%ThVRB(9IcA=#m6>cG
zcw&BWMA8GKlqd!~Tzw&nu-9$Bs?E)|+6pC&+kWoG4%yDu(51#BC6p_yNV*AZc7AOX
z2huvf-oIhv^-Gem3*aHBmT3O?O8MSHN>kI@<O%>Jdq1#^(>nPp*ExUx5l-s^bEABb
zwHMEDTE`AZIsk58AR;$frf}&Rp|LYKxNwHJGzN<Hz3=H_hk!#1LN>UKLk14r7dojr
zJ_VnGk1cwZlcESk36A2y8&?!})o^dH1FfwMn%_PXhS9kSMY8RmUA5c++eku5p2q45
zYs*g|gdrp|BK@*TY3epY?f%~Zhb$saI6E~>;qr~6w4`>AKQPvNPQ~20afp-B-)@+6
z1pB+BN-|n*<jNNhna4`qYCZv^D1J<&k3jq{vRh3NvNhX{t_@^jez7R&&{<fm%rqwE
z7gI?xzKeM)=?G4=tCiWb%Urd&*}mLlgQWH9+)N8-_2u@-g{7<5%a$5_oXfy>*ad$u
zY#yHIcDjqUZzbM6ofCvUq~;9oc89txl<()P5DDfJ@^rsjj@kl+@zHlfNwq(l=842_
XH3ZA;ZP(e300000NkvXXu0mjfW-%sV

literal 0
HcmV?d00001

diff --git a/packages/SystemUI/res/drawable-hdpi/stat_sys_ethernet_disconnected.png b/packages/SystemUI/res/drawable-hdpi/stat_sys_ethernet_disconnected.png
new file mode 100644
index 0000000000000000000000000000000000000000..4a771d91b146ba20ac6d6fb449ee40d9830d7494
GIT binary patch
literal 577
zcmV-H0>1r;P)<h;3K|Lk000e1NJLTq0015U000{Z1^@s6YyCeF00001b5ch_0Itp)
z=>Px#24YJ`L;(K){{a7>y{D4^000SaNLh0L01FcU01FcV0GgZ_00007bV*G`2iyk(
z77j3}OvmZ~000?uMObu0Z*6U5Zgc=ca%Ew3Wn>_CX>@2HM@dakSAh-}0004;Nkl<Z
zNXPA#J#O1T5Jumu)+7<JqmasgbOZwiT%^%nB4^1lQse@@L&`L()=iqU1l*_+tVV+V
zR^+6JX(%RbnKqpi_EcN~GjC@;%<RBhGdVms=j<!<)O%n21s;#bA4KFcuoIE)iK+&e
ztLl%*WU{}@P((he>SbA$gb=EKT>udgthE?pauGQLmWSZ7EK6py8Pn;MIF38ZcC*<q
z91h8{Y-NlApr&b26r^d&Xf&cIiWftBy&id<*J9bGvP4ltzu)f+97R!0Hv5=1s@jRh
zO>xZs>f?9tJNVV?!FCdnPDbWKacooHg%DV;*PRWJ5JIh&?fu&sV^}N}<ayr701**Z
zs}+O6pc$;HMnuT6j5JN3G?Ci8U`di7B5CD!2)+@KFL4}ilO#D7XQ!&){&3|ha1Hd1
zTvSwbrmEYf4I}}M*4KN#b<XW>{l~!7G4R0#va4zAz27`T#<}-?5A0iM@0>dYz60A9
zeg*L9_WKvGykEV?<Oa^Gj8A~F1^5K`S(OinTKZyvDRA*GH`{8{d|UP#g>9?m4(1Za
P00000NkvXXu0mjf*!}h%

literal 0
HcmV?d00001

diff --git a/packages/SystemUI/res/drawable-hdpi/stat_sys_ethernet_transitional.png b/packages/SystemUI/res/drawable-hdpi/stat_sys_ethernet_transitional.png
new file mode 100644
index 0000000000000000000000000000000000000000..359b089ab6a594d2d00ab77e3e6525e5cb82f779
GIT binary patch
literal 632
zcmV-;0*C#HP)<h;3K|Lk000e1NJLTq0015U000{Z1^@s6YyCeF00001b5ch_0Itp)
z=>Px#24YJ`L;(K){{a7>y{D4^000SaNLh0L01FcU01FcV0GgZ_00007bV*G`2iyk(
z77q>RKf1aA000?uMObu0Z*6U5Zgc=ca%Ew3Wn>_CX>@2HM@dakSAh-}0005gNkl<Z
zNXPA#v5rzf6o$WZE*BP&a4Q0dJ)tu(v9KXLgwJBR!xLEe0=|O{#1|koHipi`MjDY&
zEa07R=WGKvu%HBCwb(t$B==@A^W{G?^Pd9`EoA%0Iaj!6o;l~T9q{$_^%D_!Eh1i3
zF|*656Cs44W;QjmkG)=RRoI%Wo7sEsJ<H|t;!?}yGI1P#6_Mw_O%7Jo;Js%w8ZjIW
zsnu#1Q7t0OW-~gS4y{&e5yvqA+lnzW(ln*nY|`y^@!p>eE*6Un1_QkJm>D9n3*M+x
zRjSo0^?Lmx;8LkXrBXpvcQ^-caR?zF=SG%gnAzU3>Hm7ikKjk}y~V-jq^kKiH=-y)
zL~`TU18*im2+Zemrqk)goNKXI<eqTQxkQ9Gjv0@~^!xpb7>KGenM`Q6+qo_8fI|ox
zMG>u5i$<eyys)k}xSPV?6^bNDP}Qd!G24oNipZO4wVEbLa%?Z3W!XDGRQ0Whd;_8*
z)+r%`A7+*w>Oii5qqWdEmpbSCdVL4@bPT-Jf%v^!?VS7d7soht&aHseNp;#e_YC*|
zq^A@e;MMy33vhEcdw+;4;KfF944iU>W8m{9eL(TVwG@Ewz{`Kx*={<`hZVQucEz#g
Sn-`D(0000<MNUMnLSTZwClj#%

literal 0
HcmV?d00001

diff --git a/packages/SystemUI/res/drawable-mdpi/stat_sys_ethernet_connected.png b/packages/SystemUI/res/drawable-mdpi/stat_sys_ethernet_connected.png
new file mode 100644
index 0000000000000000000000000000000000000000..3d9559b682db630c3142fec30377ae35ccb2bc01
GIT binary patch
literal 447
zcmeAS@N?(olHy`uVBq!ia0vp^B0wy}!3HFwFZ>e#QjEnx?oJHr&dIz4a@dl*-CY>|
zgW!U_%O?XxI14-?iy0WWg+Z8+Vb&Z8pdfpRr>`sf9d>3hKAtw^-MK&^$r9Iy66gHf
z+|;}h2Ir#G#FEq$h4Rdj3<Y;j-+=H&K5?K`Ql2i3Ar`04PO<l54isqLfAg*fQ<taU
zn%tfWMnM~g5BwQ^6AoEN+@2}jk?@%DPSksa2<?bYj<QZS=9@nwkLc`{N)*;Hx;p!N
z+x?pSw0q5!=F<97b1PV%7@wN);Pby98>D-;tL*)8{B}-JU}wU@8eWrN$M@eWc3CXk
zwwK+GHABFtqHf8)dJ~2d0#-|xN}ZnVJB4TYqUzrBLH4KQyqxAWs2}CDJ;D6HeERcv
zgH!&K6U7u}E1mDZp`mS7^Zru(4r$Y6E8-*`&HNE!prIdhKUewt8|Ghm`~8<N20RMc
zUgi*YQn>A5Rch(u?=IYlF-)PI(<CQ<@V%g2v(`<0UuMap+fJ$x)_b!O%kma@GD?Xa
kFnTAiHrZmv@Anh*tGZ*<51(Z&2L>gBr>mdKI;Vst07|r~y#N3J

literal 0
HcmV?d00001

diff --git a/packages/SystemUI/res/drawable-mdpi/stat_sys_ethernet_disconnected.png b/packages/SystemUI/res/drawable-mdpi/stat_sys_ethernet_disconnected.png
new file mode 100644
index 0000000000000000000000000000000000000000..c24ac7ca29df7fdffc48d2c615ecfee1f03ab26d
GIT binary patch
literal 394
zcmeAS@N?(olHy`uVBq!ia0vp^B0wy}!3HFwFZ>e#QjEnx?oJHr&dIz4a@dl*-CY>|
zgW!U_%O?XxI14-?iy0WWg+Z8+Vb&Z8pdfpRr>`sf9d>3hUcHLEm0mz0$r9Iy66gHf
z+|;}h2Ir#G#FEq$h4Rdj3<Y;j-+=H&K5?L;r=Bj3Ar_~vPT81u$bqMA|L!>=hONA=
zC(F3|A8u5B^iiU+yX+Kq$;nyb3EeD`4m*#<dWi_=dfsN#nOkBPz5n0md}+D6XMQRv
zaWDAId~Tyg*Iw)WD_-ffe9$(@)(sTd%cO6cz|pu#=j3OZP+9-860?>atgdI0FjDDD
zzGO0&C1dT<RjclmA6~HPTl$*PyQw$d*0284(r|1>CU3>m_ic^aa#y~tD!R?n`cl&B
z`G<S=S$=y~hN_-6YPe~7ICYZBb~pb<T?6)O2acOBE|>VLD_AK!@q3`Ez(msxKa+~`
iJMWy1wEbiCMEJEu$ljlFKXZT{X7F_Nb6Mw<&;$UhjF{*E

literal 0
HcmV?d00001

diff --git a/packages/SystemUI/res/drawable-mdpi/stat_sys_ethernet_transitional.png b/packages/SystemUI/res/drawable-mdpi/stat_sys_ethernet_transitional.png
new file mode 100644
index 0000000000000000000000000000000000000000..3bca5bf87639c0e8febea5a214176486de3ee406
GIT binary patch
literal 405
zcmeAS@N?(olHy`uVBq!ia0vp^B0wy}!3HFwFZ>e#QjEnx?oJHr&dIz4a@dl*-CY>|
zgW!U_%O?XxI14-?iy0WWg+Z8+Vb&Z8pdfpRr>`sf9d>3hK8F6O-`#*hk|nMYCC>S|
zxv6<249-QVi6yBi3gww484B*6z5(HleBwYwA3R+gLo808onn~RVj$ouf6Qr-!!144
zT)qYYb%!adZ7<GIPTj%eThuPoIO|F$%MydlXE!C9N9u+JJvjC4%%93>>1^BfHB~Ar
z@gMlYJ~z<C?oG|&Rqr2LELwFh>sr(zjVi`fn;#hPTq*Sp6!E!Sb-{q=<*vR}tM)NW
zYf<rZnwDzue9wzn%YNGF_pa(HKG*%hYUj`Q@%Q#E_&f2S#QIBy$L@%|`8{u2?%vaB
zFYCp69?#gM6Byd0u!Cb3^SaEm=y}gqWYs8U^i=v>{$g&zI<HZ-fZ<N>wcjy+bp$I#
uCvFe*)m37D@Y1CyzvIs5oB4GzMJ!Iuv5PnT;xh&Mox#)9&t;ucLK6UIrJ%(C

literal 0
HcmV?d00001

diff --git a/packages/SystemUI/res/drawable-sw600dp-hdpi/stat_sys_ethernet_connected.png b/packages/SystemUI/res/drawable-sw600dp-hdpi/stat_sys_ethernet_connected.png
new file mode 100644
index 0000000000000000000000000000000000000000..f88bdc47ccec05e30a2c6dce596c93b18dbc683d
GIT binary patch
literal 622
zcmV-!0+IcRP)<h;3K|Lk000e1NJLTq001Wd001Ni1^@s63O6I000001b5ch_0Itp)
z=>Px#24YJ`L;(K){{a7>y{D4^000SaNLh0L01FcU01FcV0GgZ_00007bV*G`2iyk(
z77Qu>5e=vS000?uMObu0Z*6U5Zgc=ca%Ew3Wn>_CX>@2HM@dakSAh-}0005WNkl<Z
zSi|j@y>8P`7>1wMK8gDy!2m)Sq)-?L8v}PyF%U-7p;u6KB3uF)kXY!*9Y6*Ku7HWP
z5-J;lMiC-XC4NL2`+N*gXksE790v>e-Rxr@J$~Qw`Fu81s#NKxbo`*%>8=9T{~=ER
z?C!N&2LNtt$hc;*7aC_?n9K~Jb>Mjx4oryT;{l&vy+lE<7%1;qYBY(?Hvs(6d6&5m
zWAvd%|H%%~*%(wXpv3U~JI>wQB#JMA8B^hoZU}328e0ztmRE~q3v0Z2xQ&7^Gv=n%
zhymtP@V;Q@(lNItt0NO^SrlY_Q+eUa<69ML6>AmipJKH#$6D$&SDski)PgY2XwWB(
zR*KzPox?_lCx!d&o+SxyAGH_akoTU`Cxa8w#Vf4c-C0=W8b-KsD$|`z!W{zpL9K4}
zGx2Qm!v!Gx(aH9YceFE1vjqD3TR4MVnO(M-4bw<i4-{j3G3*9n@D~;Wmdw30o1JbC
zh=EVQ+FrXgDBx9+W9j@-I){fvSMPTtiN}@$RE8mL0m}x7jAtf>Ild9o*Y|F3IAPAv
z9p%}zG*M)trTn|#hC>VmTWCHJYYwZ~P)eEA>^!Z07X6?420j{#?pfQ>y#N3J07*qo
IM6N<$g5xv+lK=n!

literal 0
HcmV?d00001

diff --git a/packages/SystemUI/res/drawable-sw600dp-hdpi/stat_sys_ethernet_disconnected.png b/packages/SystemUI/res/drawable-sw600dp-hdpi/stat_sys_ethernet_disconnected.png
new file mode 100644
index 0000000000000000000000000000000000000000..de138e8d747bea7981322bd97ad524ef4215f25e
GIT binary patch
literal 511
zcmV<b0RaAqP)<h;3K|Lk000e1NJLTq001Wd001Ni1^@s63O6I000001b5ch_0Itp)
z=>Px#24YJ`L;(K){{a7>y{D4^000SaNLh0L01FcU01FcV0GgZ_00007bV*G`2iyk(
z76~nd3qAAz000?uMObu0Z*6U5Zgc=ca%Ew3Wn>_CX>@2HM@dakSAh-}00046Nkl<Z
zSi|j?yH3L}6hMz1SCB^S4ihK~8&Vm%dS-$Z^&9vkexd`b7q&=Uy7U7;ERh%}4GBqD
zQdFUkDt)98^4XkNSI72^?+sWimLJ6GKx^#*mk0Ebz|<J?2B3buya1jKWtQhTLWpbN
zu}m%ph~t<r3>y{e_xpIB2aqkFsj`WS#e&&vMz`BV2(fpu`FxJ=`%5`0<p3PVVK5k=
zl-h5SNl6d{rJEqv<v<g8R`qqX7At4vtelmza#pUK%Bmhk5lNElz3^vQR!=TXQzny1
zBRf<}uGi}^91a^j!cM2NRxSpfrIfkry0tnV;1qC*PWE-RqpiU)5d9@L1<p4JngB1r
z3Ge}20h{*uU!{Lv+n}{x%Dn?;#+a~8SIKHio9<w-2(9%I@UW$54%`54aV%rtbBlPX
zF=nKSyt~`+-Fdr%I3rc8@V;f$BBjk}t+D(|z5%$TT12Nt;i3Ql002ovPDHLkV1nc%
B%~SvY

literal 0
HcmV?d00001

diff --git a/packages/SystemUI/res/drawable-sw600dp-hdpi/stat_sys_ethernet_transitional.png b/packages/SystemUI/res/drawable-sw600dp-hdpi/stat_sys_ethernet_transitional.png
new file mode 100644
index 0000000000000000000000000000000000000000..56e2c56456f14c13e9f3ad78062db14fd2fde318
GIT binary patch
literal 528
zcmV+r0`L8aP)<h;3K|Lk000e1NJLTq001Wd001Ni1^@s63O6I000001b5ch_0Itp)
z=>Px#24YJ`L;(K){{a7>y{D4^000SaNLh0L01FcU01FcV0GgZ_00007bV*G`2iyk(
z7706X--x9E000?uMObu0Z*6U5Zgc=ca%Ew3Wn>_CX>@2HM@dakSAh-}0004NNkl<Z
zSi|j?J5Iwu5Qe`s8(~6cDUomyK}Scy9a2z1i_)j_8RiygA}-;A6L5nxIRJ<vRwx|A
z!|~EM$O=v%FULarcYbL6&CF`%H&|I&eM{vpMC2H_*dvbv3`FDwK+ioq2OjoCW{g28
zbp_lP!5M%!ju{SzIF3^aRGOx=S}hul20%KyuZv!eqKGgI@jR~-z|m+#yWOVQY+{UI
zDV$P@TCGO6+r@R=oq}nt>GgVrMbN*MJD<s}TDs^PPL)TAg|l!L&cazZ3%6kJF7sC7
z@tDbEvh&5CB*|)UNs`d-_e=A0e}?mYpCAZIZDGA$|KU#N;XZ&zt+nwyZzYEf_`pHt
zWS{enb_Kb>+akCDaJEL!Pv8kS0bYSiAX>ACN#WnuCK8buTnwCwNK~a!l0PuhEhLK)
zkwf5aLr?=;14mg~Lg0OacvBJS=<M9xZh3azY#~lZXBh?++ZI!*ED^!#U+N32d2RgR
S>oQ0H0000<MNUMnLSTZ%?9*ic

literal 0
HcmV?d00001

diff --git a/packages/SystemUI/res/drawable-sw600dp-mdpi/stat_sys_ethernet_connected.png b/packages/SystemUI/res/drawable-sw600dp-mdpi/stat_sys_ethernet_connected.png
new file mode 100644
index 0000000000000000000000000000000000000000..8ef0df53254278519b21240954d6a8ad28e94577
GIT binary patch
literal 595
zcmV-Z0<8UsP)<h;3K|Lk000e1NJLTq000^Q000;W1^@s6<bv(R00001b5ch_0Itp)
z=>Px#24YJ`L;(K){{a7>y{D4^000SaNLh0L01FcU01FcV0GgZ_00007bV*G`2iyk(
z77GtzT^^DE000?uMObu0Z*6U5Zgc=ca%Ew3Wn>_CX>@2HM@dakSAh-}00055Nkl<Z
zNXPA#y>1gh6h_ZCJC5ThU;+dr9>A$6p{GcV08#J;6e*A>pn)0}6j1R36f|*#sCWP*
z3R-B85J4b>ltjX;?cMn(vILws4zdG65x2aWx##}Rz@e0-cIS`UZ?#v^FR(@ICXx@3
zk!*i>bNg~H{?ORIE9p8RD-RA+t^*f=7uz7kTI_#*A3r|6AG5|hFkN8EYMi>dQm-9b
z3;;ht2={Xcfz#J+;9fpCB?LY_d4P*PXsbGLhaY711~Vtmkn(R+fmEvxsp76f2B!p0
zQ`BYz`)`fVf6%`ViX*i)_T&RQYKz68zE+^<ZnF9E`PQ&aObVny4=L;hIi-3$x<K>%
zGR4N1ar>)EdN!8TJhx0}%+I+TgdL!=lg%AjJAUEHn4GEWqJIa-$l@bO>wDGNHtyxQ
z%ktfD>cmqgKTCOcPt5CEmx@+<^`^`WgZ{%L-U^Kj%@`1%5+JtP9RYPw>BmbUB+Ce8
z*by-jq-|r4OZPgtTJ6qR;FVxwKZ?PE+3E@DRUNdSdkfenqF@bJsV<IhCM-~@LYIF7
hV|y0y_3(Xwz5_IXon2qJ@Js*z002ovPDHLkV1mdv_D=u+

literal 0
HcmV?d00001

diff --git a/packages/SystemUI/res/drawable-sw600dp-mdpi/stat_sys_ethernet_disconnected.png b/packages/SystemUI/res/drawable-sw600dp-mdpi/stat_sys_ethernet_disconnected.png
new file mode 100644
index 0000000000000000000000000000000000000000..47728e8179589de93ed5ea4b7d403bafc2d63aa8
GIT binary patch
literal 518
zcmV+h0{Q)kP)<h;3K|Lk000e1NJLTq000^Q000;W1^@s6<bv(R00001b5ch_0Itp)
z=>Px#24YJ`L;(K){{a7>y{D4^000SaNLh0L01FcU01FcV0GgZ_00007bV*G`2iyk(
z778rcAzq;X000?uMObu0Z*6U5Zgc=ca%Ew3Wn>_CX>@2HM@dakSAh-}0004DNkl<Z
zNXPA#y-or_5P-kg+uVVTF~;HwYC_>V>>KzR7IxP95LUj0m9f3n&WeP}!~{c$g~El~
z9h-xIC<h)IL!4@NlbLURcNcb2oO3^JU*<MPz&@Z`WCY+j%d*@~PgM0%L{3G-Z;PU;
zLsdNi?q?ulj2(?ew%hGmYi(_aF@|=#og_(O02VBI?-3C?oetjD3#`}cE!bFcJ&Gcl
z%_c=rd>bMn7-JSA{35q?YqOln-x{HR(BB8yO*&_j_Ff4R5hjxfgTa6hLahj<!@mSl
z)g+E%(ljN{^U4|d%<Fkc(-dp%o~oLUpc`v#ztw83%Gp~8;R1+^G1tIwRh_-};}F8r
z0!Tz|fxA_AT$W{pbM737z4uqZBM?>8%L7>FoB+w1sV`vmhDD{LQB}h^=f>ikI|d$r
zmvyc&pi!>#axWD+2f(2P`oLMKSlPMdtH~OGsWgDs-TMH&14@p2zI)HG<^TWy07*qo
IM6N<$f*SAD=>Px#

literal 0
HcmV?d00001

diff --git a/packages/SystemUI/res/drawable-sw600dp-mdpi/stat_sys_ethernet_transitional.png b/packages/SystemUI/res/drawable-sw600dp-mdpi/stat_sys_ethernet_transitional.png
new file mode 100644
index 0000000000000000000000000000000000000000..a5a904864baa71f37162893533013ab57ff501c7
GIT binary patch
literal 542
zcmV+(0^$9MP)<h;3K|Lk000e1NJLTq000^Q000;W1^@s6<bv(R00001b5ch_0Itp)
z=>Px#24YJ`L;(K){{a7>y{D4^000SaNLh0L01FcU01FcV0GgZ_00007bV*G`2iyk(
z77GCK;sXN!000?uMObu0Z*6U5Zgc=ca%Ew3Wn>_CX>@2HM@dakSAh-}0004bNkl<Z
zNXPA#J!%_46o9|^k=GLt!U!KD)wa5WK&Nn#&b7@ugDc-bg(~ASq*87W2soX<5m<Of
zJNsOCC2SdKMOHD!WU84rKi}j14t&ZXBLDn-^I~xd^Z-2|qXK@5Na0r!RlPLEoLOtr
z!6;RAuc|}f`x@k&^RwB^kH=#lLTC+f&M_PgvtF-f0oEX63^7KmwTwn1VvK(cvDPw~
zOeo6|W1hX^HxFf5M!(;uD2i5~PN(xq_6DS?R8@tlw(-qd_<N<$f6&JV`E46*qHdKt
zTS3-Z7K;Vb>6Ef8TY+MXuYmqV>}TC>mpspz&*zOfV(o6L=Xp*D;Y&)%Zh|HuguB6D
zpgS~OESJlR=ThdbjWPGz{H&_P7#~wgzcy>#jjG=6Dm@}nipV)|lv26^egdw+j0wPt
zhyk)a&0oU0hq+o&*A#Ff@@PclEARvOvj<3l<9c4yYtwM&1n7I<4)|7IYz(NnYqAGm
gHI9LY&-Vd(0;pe%DA~PVl>h($07*qoM6N<$g3_(yGXMYp

literal 0
HcmV?d00001

diff --git a/packages/SystemUI/res/drawable-sw600dp-xhdpi/stat_sys_ethernet_connected.png b/packages/SystemUI/res/drawable-sw600dp-xhdpi/stat_sys_ethernet_connected.png
new file mode 100644
index 0000000000000000000000000000000000000000..aa945263e111114ddee6b1ad32b6d0592d58647b
GIT binary patch
literal 790
zcmV+x1L^#UP)<h;3K|Lk000e1NJLTq001-q001xu1^@s6Ug=r=00001b5ch_0Itp)
z=>Px#24YJ`L;(K){{a7>y{D4^000SaNLh0L01FcU01FcV0GgZ_00007bV*G`2iyk(
z76>vC7y&>4000?uMObu0Z*6U5Zgc=ca%Ew3Wn>_CX>@2HM@dakSAh-}0007UNkl<Z
zXx{CZy-!n77{-6kxwkDAQ6a{U!LP(n<6@kQvx6~lfrQC8I5`+M6Z{kGZsP3d0M*4m
zKo{fCg^<_;WHC|W2Sx=d+}_ur6e_e7p|!Vop6TA+b94GT=e*B*-xs{Ryu7>;u3Wyb
zcCC#MhaXG|xG8D52UrBWE{%`O)_w>#jgUga9vehGK;wYhKy#q#KmmkSiHKL00ZSH$
z0+h~xwCR+EP2UOvmS(4zfAJKnL=an2XviEp#n6>8g6zPi$6@pL9F_0$EW9a_K6--G
z;1RHHLmB0FGsNWuELv$eq9Kr(RrgUs&T;7SH4a|7ibY-aiP-o!@sO1-AL>q;wFZ*@
zG(QC)F5QPY*WLYzV{kzOqg$6_kLmvaGP52+u+~5uV<`C_3qFQCP|{3+y=Dq{Q}8k5
z6RS_GK86yhtqZ)mdPu2s_j?OwNN&p*3R|B`@pJkW(T{nkL|x`F%J1iJsm$N)khHoQ
zVTz!CfTg$7EY3_N!vdTmbuw3%{k6R&iNzKAPM_oWje7~}Vi_)zCD_-${T-^+@8SMI
z!UIF?uvJ^Xv34+l#no7s!d5`BnLU!U2)5gP+_D*C5@*4{^bPS0_(X#?^v+hxip{f9
z2Q-{7ObAA+%c>c$>!tD0Qak6!<qMR?NB&J7(%KwrZQFFa=cvK>FNGbdQmYsZi_KW<
z-0_}7xqQI^w}3l9x!o{kc3#rZYGy1Wl?+=@d&|fy#@*8Wk(VKuKxcr99f_g(|1I?a
z7t{eSGVJiGZOec;%!)|AdNg#hl0Mh+Pz*dldTxgGCXY$z>s~WBa`{QTyu5a&->Ue_
UIyOWzrT_o{07*qoM6N<$g1CETLI3~&

literal 0
HcmV?d00001

diff --git a/packages/SystemUI/res/drawable-sw600dp-xhdpi/stat_sys_ethernet_disconnected.png b/packages/SystemUI/res/drawable-sw600dp-xhdpi/stat_sys_ethernet_disconnected.png
new file mode 100644
index 0000000000000000000000000000000000000000..7da6ba1a3091c124db7a9f9aae04e5ba695bbf3c
GIT binary patch
literal 653
zcmeAS@N?(olHy`uVBq!ia0vp^CO~Y!!3HGbUPk@}QjEnx?oJHr&dIz4a@dl*-CY>|
zgW!U_%O?XxI14-?iy0WWg+Z8+Vb&Z8pdfpRr>`sf9d>3h4vABXPfP;}NtU=qlsM<-
z=BDPAFgO>bCYGe8D3oWGWGJ|M`UZqI@`(ejdg1Bf7?N@C?acl8mmNfo+rKaJ3(!>+
zO7fh>vC=z2;QztDj6NPcJU%=f``c$uY+T6w+4HW%4e3S+Bd0nIuUW^q%$UnuZy({D
zde`FWZ@+!kzt7FDet-ApT*swBD?>!57r*-yb<Kq916K!MgKLBSz2EO6TVsnSv)VDN
zW@a!tAgv(&Vv}xP@*|6N^CDdgjwvXa?>Y0#)?}`qBoEuvX0F2%^0s>muw>uOUOerz
z>f(zX20WQ2Qq}C9lUi=(9Lw5z%i?6&>`d2|vfaMRFW=m~bdt)#`|meL=$IWp={GT*
zXKR%1=bL+(a;w>k?|)Na4N^csTHe-Aog?|;TYI(&EO=PpA>wLX8nNx!=gN0a@_Y|A
zD<l}rG?44pei)?WwE5<p89Q&;eBKtNTeUat>!Tx4YqtL94_SY`+v@Gfn$WJErC)ju
z<}r6Qepf2mm#y$jgDH;bcxENj90vRDhROTuzJK+Kz4`9poZl>aJi6~UJiqsQbJOty
z)%EGWC+sw9{JMz!M8X&Ehtq!5>e`+6F3CS)nci^yK=gw}EHl&(9NtpHIEV3b)8p?P
z70>tDZ_Pa3-<V#Wu$KM6<w?Klrs&@0{Gc5BZyLLlmHUD9JQ{3vO!NQWWZ?H@>UnpY
ksr>2ljb2N4&HcylrK9uy_fuD%0TTv;r>mdKI;Vst0Ny_tv;Y7A

literal 0
HcmV?d00001

diff --git a/packages/SystemUI/res/drawable-sw600dp-xhdpi/stat_sys_ethernet_transitional.png b/packages/SystemUI/res/drawable-sw600dp-xhdpi/stat_sys_ethernet_transitional.png
new file mode 100644
index 0000000000000000000000000000000000000000..0529b1f0283b02f9b63c6ad5a6c3eba5cebf1637
GIT binary patch
literal 686
zcmV;f0#W^mP)<h;3K|Lk000e1NJLTq001-q001xu1^@s6Ug=r=00001b5ch_0Itp)
z=>Px#24YJ`L;(K){{a7>y{D4^000SaNLh0L01FcU01FcV0GgZ_00007bV*G`2iyk(
z76}R<0f?Uf000?uMObu0Z*6U5Zgc=ca%Ew3Wn>_CX>@2HM@dakSAh-}0006BNkl<Z
zXx{CZy{Z#I6vuyOn0##r0g<FiK(MkAVf(y*m5|cH>K5WV%v)GnT3Dp<1tg7ybuLko
zR3Ruv61?2pWOppg2JbardUun}W&W_RGrN0sezWJC**W0k<mBX(av5V*=d$La0MCJ|
z6JQbGqcP@7)S=hhq=7fU;sk&ca0YAzT3ri*fcbo$J_@DCWHN}zUtXrSJ=E{_X}8-1
zL4dV3H9*yBl}4jMp-@=sUK@cXlL_5!mrA8Vxm->K)NnXtHk+|ntdEF|K-OAB1f>+d
z@8kRaMk9xkwU$<^#dtj494Gr2(pr<vW>HEV6(|hDonuhkF*zUy<bWKI19CtP$N@PZ
z2jqZ~(q8)^r4(B0qYu_vyK_IZ*C;!k4%6wBFbt0lH5!e!POjdyQ}sNL!C*kI*Gq*<
zi3qh?EvoqJ4-^Ce^?IFVvze-j4?r%LBcIRz8<4e@VzEf6REov@qX~{HmZC#M^e&(f
zcr79qQDNd1x&oTO!)5yi&;q{30Vlux?$fotq}{_9^A32nY<>ow8e`65e#fd{e~5KR
z-I%~^0+Z(c6mFy7Mtoi*=-!AiMgcE?m%wELFpq$H%l0L34*ZNcem&roG3J9_8h!vg
zIl$M-1CJB3eLqUu7U(V0-|R#~#{<4aKq2rJc>l)&cxn>h`&~<L*V4C>lhgm{7t9rx
UiEP%*3;+NC07*qoM6N<$f+pA|w*UYD

literal 0
HcmV?d00001

diff --git a/packages/SystemUI/res/drawable-xhdpi/stat_sys_ethernet_connected.png b/packages/SystemUI/res/drawable-xhdpi/stat_sys_ethernet_connected.png
new file mode 100644
index 0000000000000000000000000000000000000000..f88bdc47ccec05e30a2c6dce596c93b18dbc683d
GIT binary patch
literal 622
zcmV-!0+IcRP)<h;3K|Lk000e1NJLTq001Wd001Ni1^@s63O6I000001b5ch_0Itp)
z=>Px#24YJ`L;(K){{a7>y{D4^000SaNLh0L01FcU01FcV0GgZ_00007bV*G`2iyk(
z77Qu>5e=vS000?uMObu0Z*6U5Zgc=ca%Ew3Wn>_CX>@2HM@dakSAh-}0005WNkl<Z
zSi|j@y>8P`7>1wMK8gDy!2m)Sq)-?L8v}PyF%U-7p;u6KB3uF)kXY!*9Y6*Ku7HWP
z5-J;lMiC-XC4NL2`+N*gXksE790v>e-Rxr@J$~Qw`Fu81s#NKxbo`*%>8=9T{~=ER
z?C!N&2LNtt$hc;*7aC_?n9K~Jb>Mjx4oryT;{l&vy+lE<7%1;qYBY(?Hvs(6d6&5m
zWAvd%|H%%~*%(wXpv3U~JI>wQB#JMA8B^hoZU}328e0ztmRE~q3v0Z2xQ&7^Gv=n%
zhymtP@V;Q@(lNItt0NO^SrlY_Q+eUa<69ML6>AmipJKH#$6D$&SDski)PgY2XwWB(
zR*KzPox?_lCx!d&o+SxyAGH_akoTU`Cxa8w#Vf4c-C0=W8b-KsD$|`z!W{zpL9K4}
zGx2Qm!v!Gx(aH9YceFE1vjqD3TR4MVnO(M-4bw<i4-{j3G3*9n@D~;Wmdw30o1JbC
zh=EVQ+FrXgDBx9+W9j@-I){fvSMPTtiN}@$RE8mL0m}x7jAtf>Ild9o*Y|F3IAPAv
z9p%}zG*M)trTn|#hC>VmTWCHJYYwZ~P)eEA>^!Z07X6?420j{#?pfQ>y#N3J07*qo
IM6N<$g5xv+lK=n!

literal 0
HcmV?d00001

diff --git a/packages/SystemUI/res/drawable-xhdpi/stat_sys_ethernet_disconnected.png b/packages/SystemUI/res/drawable-xhdpi/stat_sys_ethernet_disconnected.png
new file mode 100644
index 0000000000000000000000000000000000000000..de138e8d747bea7981322bd97ad524ef4215f25e
GIT binary patch
literal 511
zcmV<b0RaAqP)<h;3K|Lk000e1NJLTq001Wd001Ni1^@s63O6I000001b5ch_0Itp)
z=>Px#24YJ`L;(K){{a7>y{D4^000SaNLh0L01FcU01FcV0GgZ_00007bV*G`2iyk(
z76~nd3qAAz000?uMObu0Z*6U5Zgc=ca%Ew3Wn>_CX>@2HM@dakSAh-}00046Nkl<Z
zSi|j?yH3L}6hMz1SCB^S4ihK~8&Vm%dS-$Z^&9vkexd`b7q&=Uy7U7;ERh%}4GBqD
zQdFUkDt)98^4XkNSI72^?+sWimLJ6GKx^#*mk0Ebz|<J?2B3buya1jKWtQhTLWpbN
zu}m%ph~t<r3>y{e_xpIB2aqkFsj`WS#e&&vMz`BV2(fpu`FxJ=`%5`0<p3PVVK5k=
zl-h5SNl6d{rJEqv<v<g8R`qqX7At4vtelmza#pUK%Bmhk5lNElz3^vQR!=TXQzny1
zBRf<}uGi}^91a^j!cM2NRxSpfrIfkry0tnV;1qC*PWE-RqpiU)5d9@L1<p4JngB1r
z3Ge}20h{*uU!{Lv+n}{x%Dn?;#+a~8SIKHio9<w-2(9%I@UW$54%`54aV%rtbBlPX
zF=nKSyt~`+-Fdr%I3rc8@V;f$BBjk}t+D(|z5%$TT12Nt;i3Ql002ovPDHLkV1nc%
B%~SvY

literal 0
HcmV?d00001

diff --git a/packages/SystemUI/res/drawable-xhdpi/stat_sys_ethernet_transitional.png b/packages/SystemUI/res/drawable-xhdpi/stat_sys_ethernet_transitional.png
new file mode 100644
index 0000000000000000000000000000000000000000..56e2c56456f14c13e9f3ad78062db14fd2fde318
GIT binary patch
literal 528
zcmV+r0`L8aP)<h;3K|Lk000e1NJLTq001Wd001Ni1^@s63O6I000001b5ch_0Itp)
z=>Px#24YJ`L;(K){{a7>y{D4^000SaNLh0L01FcU01FcV0GgZ_00007bV*G`2iyk(
z7706X--x9E000?uMObu0Z*6U5Zgc=ca%Ew3Wn>_CX>@2HM@dakSAh-}0004NNkl<Z
zSi|j?J5Iwu5Qe`s8(~6cDUomyK}Scy9a2z1i_)j_8RiygA}-;A6L5nxIRJ<vRwx|A
z!|~EM$O=v%FULarcYbL6&CF`%H&|I&eM{vpMC2H_*dvbv3`FDwK+ioq2OjoCW{g28
zbp_lP!5M%!ju{SzIF3^aRGOx=S}hul20%KyuZv!eqKGgI@jR~-z|m+#yWOVQY+{UI
zDV$P@TCGO6+r@R=oq}nt>GgVrMbN*MJD<s}TDs^PPL)TAg|l!L&cazZ3%6kJF7sC7
z@tDbEvh&5CB*|)UNs`d-_e=A0e}?mYpCAZIZDGA$|KU#N;XZ&zt+nwyZzYEf_`pHt
zWS{enb_Kb>+akCDaJEL!Pv8kS0bYSiAX>ACN#WnuCK8buTnwCwNK~a!l0PuhEhLK)
zkwf5aLr?=;14mg~Lg0OacvBJS=<M9xZh3azY#~lZXBh?++ZI!*ED^!#U+N32d2RgR
S>oQ0H0000<MNUMnLSTZ%?9*ic

literal 0
HcmV?d00001

diff --git a/packages/SystemUI/res/layout/signal_cluster_view.xml b/packages/SystemUI/res/layout/signal_cluster_view.xml
index 2b9cef9..0de487d 100644
--- a/packages/SystemUI/res/layout/signal_cluster_view.xml
+++ b/packages/SystemUI/res/layout/signal_cluster_view.xml
@@ -46,6 +46,33 @@
         android:visibility="gone"
         android:id="@+id/spacer"
         />
+    <FrameLayout
+        android:id="@+id/ethernet_combo"
+        android:layout_height="wrap_content"
+        android:layout_width="wrap_content"
+        android:layout_marginRight="-6dp"
+        >
+        <ImageView
+            android:id="@+id/ethernet_status"
+            android:layout_height="wrap_content"
+            android:layout_width="wrap_content"
+            android:layout_alignParentRight="true"
+            android:layout_centerVertical="true"
+            android:scaleType="center"
+            />
+        <ImageView
+            android:id="@+id/ethernet_inout"
+            android:layout_height="wrap_content"
+            android:layout_width="wrap_content"
+            android:layout_gravity="center|bottom"
+            />
+    </FrameLayout>
+    <View
+        android:layout_height="6dp"
+        android:layout_width="6dp"
+        android:visibility="gone"
+        android:id="@+id/spacer2"
+        />
     <!--<FrameLayout
         android:id="@+id/wimax_combo"
         android:layout_height="wrap_content"
diff --git a/packages/SystemUI/res/values/strings.xml b/packages/SystemUI/res/values/strings.xml
index e36ca8e..6a9db23 100644
--- a/packages/SystemUI/res/values/strings.xml
+++ b/packages/SystemUI/res/values/strings.xml
@@ -256,6 +256,11 @@
     <!-- Content description of the WIFI signal when it is full for accessibility (not shown on the screen). [CHAR LIMIT=NONE] -->
     <string name="accessibility_wifi_signal_full">Wifi signal full.</string>
 
+    <!-- Content description of Ethernet when no connection for accessibility (not shown on the screen). [CHAR LIMIT=NONE] -->
+    <string name="accessibility_no_ethernet">No Ethernet.</string>
+    <!-- Content description of Ethernet when connection is present for accessibility (not shown on the screen). [CHAR LIMIT=NONE] -->
+    <string name="accessibility_ethernet_connected">Ethernet connected.</string>
+
     <!-- Content description of the WiMAX signal when no signal for accessibility (not shown on the screen). [CHAR LIMIT=NONE] -->
     <string name="accessibility_no_wimax">No WiMAX.</string>
     <!-- Content description of the WiMAX signal when it is one bar for accessibility (not shown on the screen). [CHAR LIMIT=NONE] -->
@@ -322,6 +327,9 @@
     <!-- Content description of the data connection type WiFi for accessibility (not shown on the screen). [CHAR LIMIT=NONE] -->
     <string name="accessibility_data_connection_wifi">Wi-Fi</string>
 
+    <!-- Content description of the data connection type Ethernet for accessibility (not shown on the screen). [CHAR LIMIT=NONE] -->
+    <string name="accessibility_data_connection_ethernet">Ethernet</string>
+
     <!-- Content description of the data connection with no SIM for accessibility (not shown on the screen). [CHAR LIMIT=NONE] -->
     <string name="accessibility_no_sim">No SIM.</string>
 
diff --git a/packages/SystemUI/src/com/android/systemui/statusbar/SignalClusterView.java b/packages/SystemUI/src/com/android/systemui/statusbar/SignalClusterView.java
index f1c8e01..2a69405 100644
--- a/packages/SystemUI/src/com/android/systemui/statusbar/SignalClusterView.java
+++ b/packages/SystemUI/src/com/android/systemui/statusbar/SignalClusterView.java
@@ -25,6 +25,8 @@ import android.view.accessibility.AccessibilityEvent;
 import android.widget.ImageView;
 import android.widget.LinearLayout;
 
+import android.widget.Toast;
+
 import com.android.systemui.R;
 import com.android.systemui.statusbar.policy.NetworkController;
 
@@ -40,15 +42,20 @@ public class SignalClusterView
 
     private boolean mWifiVisible = false;
     private int mWifiStrengthId = 0;
+    private boolean mEthernetVisible = false;
+    private int mEthernetStatusId, mEthernetActivityId = 0;
     private boolean mMobileVisible = false;
     private int mMobileStrengthId = 0, mMobileTypeId = 0;
     private boolean mIsAirplaneMode = false;
     private int mAirplaneIconId = 0;
-    private String mWifiDescription, mMobileDescription, mMobileTypeDescription;
+    private String mWifiDescription, mMobileDescription, mMobileTypeDescription,
+            mEthernetDescription;
 
-    ViewGroup mWifiGroup, mMobileGroup;
-    ImageView mWifi, mMobile, mMobileType, mAirplane;
+    ViewGroup mWifiGroup, mEthernetGroup, mMobileGroup;
+    ImageView mWifi, mEthernet, mMobile, mMobileType, mAirplane,
+            mEthernetActivity;
     View mSpacer;
+    View mSpacer2;
 
     public SignalClusterView(Context context) {
         this(context, null);
@@ -73,10 +80,14 @@ public class SignalClusterView
 
         mWifiGroup      = (ViewGroup) findViewById(R.id.wifi_combo);
         mWifi           = (ImageView) findViewById(R.id.wifi_signal);
+        mEthernetGroup  = (ViewGroup) findViewById(R.id.ethernet_combo);
+        mEthernet       = (ImageView) findViewById(R.id.ethernet_status);
+        mEthernetActivity = (ImageView) findViewById(R.id.ethernet_inout);
         mMobileGroup    = (ViewGroup) findViewById(R.id.mobile_combo);
         mMobile         = (ImageView) findViewById(R.id.mobile_signal);
         mMobileType     = (ImageView) findViewById(R.id.mobile_type);
         mSpacer         =             findViewById(R.id.spacer);
+        mSpacer2        =             findViewById(R.id.spacer2);
         mAirplane       = (ImageView) findViewById(R.id.airplane);
 
         apply();
@@ -86,10 +97,14 @@ public class SignalClusterView
     protected void onDetachedFromWindow() {
         mWifiGroup      = null;
         mWifi           = null;
+        mEthernetGroup  = null;
+        mEthernet       = null;
+        mEthernetActivity = null;
         mMobileGroup    = null;
         mMobile         = null;
         mMobileType     = null;
         mSpacer         = null;
+        mSpacer2        = null;
         mAirplane       = null;
 
         super.onDetachedFromWindow();
@@ -104,6 +119,15 @@ public class SignalClusterView
         apply();
     }
 
+    public void setEthernetIndicators(boolean visible, int statusIcon, int activityIcon, String contentDescription) {
+        mEthernetVisible = visible;
+        mEthernetStatusId = statusIcon;
+        mEthernetActivityId = activityIcon;
+        mEthernetDescription = contentDescription;
+
+        apply();
+    }
+
     @Override
     public void setMobileDataIndicators(boolean visible, int strengthIcon,
             int typeIcon, String contentDescription, String typeContentDescription) {
@@ -130,6 +154,8 @@ public class SignalClusterView
         // ignore content description, so populate manually
         if (mWifiVisible && mWifiGroup != null && mWifiGroup.getContentDescription() != null)
             event.getText().add(mWifiGroup.getContentDescription());
+        if (mEthernetVisible && mEthernetGroup.getContentDescription() != null)
+            event.getText().add(mEthernetGroup.getContentDescription());
         if (mMobileVisible && mMobileGroup != null && mMobileGroup.getContentDescription() != null)
             event.getText().add(mMobileGroup.getContentDescription());
         return super.dispatchPopulateAccessibilityEvent(event);
@@ -176,6 +202,20 @@ public class SignalClusterView
                     (mWifiVisible ? "VISIBLE" : "GONE"),
                     mWifiStrengthId));
 
+        if(mEthernetVisible) {
+            mEthernetGroup.setVisibility(View.VISIBLE);
+            mEthernet.setImageResource(mEthernetStatusId);
+            mEthernetActivity.setImageResource(mEthernetActivityId);
+            mEthernetGroup.setContentDescription(mEthernetDescription);
+        } else {
+            mEthernetGroup.setVisibility(View.GONE);
+        }
+
+        if (DEBUG) Log.d(TAG,
+                String.format("ethernet: %s sig=%d act=%d",
+                        (mEthernetVisible ? "VISIBLE" : "GONE"),
+                        mEthernetStatusId, mEthernetActivityId));
+
         if (mMobileVisible && !mIsAirplaneMode) {
             mMobile.setImageResource(mMobileStrengthId);
             mMobileType.setImageResource(mMobileTypeId);
@@ -193,19 +233,24 @@ public class SignalClusterView
             mAirplane.setVisibility(View.GONE);
         }
 
-        if (mMobileVisible && mWifiVisible && mIsAirplaneMode) {
+        if(mEthernetVisible) {
             mSpacer.setVisibility(View.INVISIBLE);
         } else {
             mSpacer.setVisibility(View.GONE);
         }
 
+        if (mMobileVisible && (mWifiVisible || mEthernetVisible) && mIsAirplaneMode) {
+            mSpacer2.setVisibility(View.INVISIBLE);
+        } else {
+            mSpacer2.setVisibility(View.GONE);
+        }
+
         if (DEBUG) Log.d(TAG,
                 String.format("mobile: %s sig=%d typ=%d",
                     (mMobileVisible ? "VISIBLE" : "GONE"),
                     mMobileStrengthId, mMobileTypeId));
 
-        mMobileType.setVisibility(
-                !mWifiVisible ? View.VISIBLE : View.GONE);
+        mMobileType.setVisibility( !(mWifiVisible || mEthernetVisible) ? View.VISIBLE : View.GONE);
     }
 }
 
diff --git a/packages/SystemUI/src/com/android/systemui/statusbar/phone/PhoneStatusBarPolicy.java b/packages/SystemUI/src/com/android/systemui/statusbar/phone/PhoneStatusBarPolicy.java
index 8957a77..c5454e4 100644
--- a/packages/SystemUI/src/com/android/systemui/statusbar/phone/PhoneStatusBarPolicy.java
+++ b/packages/SystemUI/src/com/android/systemui/statusbar/phone/PhoneStatusBarPolicy.java
@@ -69,6 +69,13 @@ public class PhoneStatusBarPolicy {
     private int mLastWifiSignalLevel = -1;
     private boolean mIsWifiConnected = false;
 
+    //ethernet
+    private static final int[] sEthernetImages = {
+        R.drawable.stat_sys_ethernet_transitional,
+        R.drawable.stat_sys_ethernet_connected
+    };
+    private boolean mIsEthernetConnected = false;
+
     // state of inet connection - 0 not connected, 100 connected
     private int mInetCondition = 0;
 
diff --git a/packages/SystemUI/src/com/android/systemui/statusbar/policy/AccessibilityContentDescriptions.java b/packages/SystemUI/src/com/android/systemui/statusbar/policy/AccessibilityContentDescriptions.java
index 7ac2a98..3b60e61 100644
--- a/packages/SystemUI/src/com/android/systemui/statusbar/policy/AccessibilityContentDescriptions.java
+++ b/packages/SystemUI/src/com/android/systemui/statusbar/policy/AccessibilityContentDescriptions.java
@@ -40,4 +40,9 @@ public class AccessibilityContentDescriptions {
         R.string.accessibility_wimax_three_bars,
         R.string.accessibility_wimax_signal_full
     };
+
+    static final int[] ETHERNET_CONNECTION_STRENGTH = {
+        R.string.accessibility_no_ethernet,
+        R.string.accessibility_ethernet_connected,
+    };
 }
diff --git a/packages/SystemUI/src/com/android/systemui/statusbar/policy/EthernetIcons.java b/packages/SystemUI/src/com/android/systemui/statusbar/policy/EthernetIcons.java
new file mode 100644
index 0000000..ace7b78
--- /dev/null
+++ b/packages/SystemUI/src/com/android/systemui/statusbar/policy/EthernetIcons.java
@@ -0,0 +1,27 @@
+/**
+ * Copyright (c) 2012, The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.systemui.statusbar.policy;
+
+import com.android.systemui.R;
+
+class EthernetIcons {
+    static final int [] ETHERNET_STATE = {
+        R.drawable.stat_sys_ethernet_disconnected,
+        R.drawable.stat_sys_ethernet_transitional,
+        R.drawable.stat_sys_ethernet_connected
+    };
+}
diff --git a/packages/SystemUI/src/com/android/systemui/statusbar/policy/NetworkController.java b/packages/SystemUI/src/com/android/systemui/statusbar/policy/NetworkController.java
index 09f1695..4a42649 100644
--- a/packages/SystemUI/src/com/android/systemui/statusbar/policy/NetworkController.java
+++ b/packages/SystemUI/src/com/android/systemui/statusbar/policy/NetworkController.java
@@ -38,8 +38,11 @@ import android.telephony.SignalStrength;
 import android.telephony.TelephonyManager;
 import android.util.Log;
 import android.view.View;
+import android.widget.ImageView;
 import android.widget.TextView;
 
+import com.android.internal.ethernet.EthernetInfo;
+import com.android.internal.ethernet.EthernetManager;
 import com.android.internal.telephony.IccCardConstants;
 import com.android.internal.telephony.TelephonyIntents;
 import com.android.internal.telephony.cdma.EriInfo;
@@ -91,6 +94,7 @@ public class NetworkController extends BroadcastReceiver implements DemoMode {
 
     String mContentDescriptionPhoneSignal;
     String mContentDescriptionWifi;
+    String mContentDescriptionEthernet;
     String mContentDescriptionWimax;
     String mContentDescriptionCombinedSignal;
     String mContentDescriptionDataType;
@@ -105,6 +109,14 @@ public class NetworkController extends BroadcastReceiver implements DemoMode {
     int mQSWifiIconId = 0;
     int mWifiActivity = WifiManager.DATA_ACTIVITY_NONE;
 
+    //ethernet
+    final EthernetManager mEthernetManager;
+    AsyncChannel mEthernetChannel;
+    boolean mEthernetEnabled, mEthernetConnected;
+    int mEthernetIconId = 0;
+    int mEthernetActivityIconId = 0;
+    int mEthernetActivity = EthernetManager.DATA_ACTIVITY_NONE;
+
     // bluetooth
     private boolean mBluetoothTethered = false;
     private int mBluetoothTetherIconId =
@@ -136,16 +148,19 @@ public class NetworkController extends BroadcastReceiver implements DemoMode {
 
     // our ui
     Context mContext;
+    ArrayList<ImageView> mEthernetIconViews = new ArrayList<ImageView>();
     ArrayList<TextView> mCombinedLabelViews = new ArrayList<TextView>();
     ArrayList<TextView> mMobileLabelViews = new ArrayList<TextView>();
     ArrayList<TextView> mWifiLabelViews = new ArrayList<TextView>();
     ArrayList<TextView> mEmergencyLabelViews = new ArrayList<TextView>();
+    ArrayList<TextView> mEthernetLabelViews = new ArrayList<TextView>();
     ArrayList<SignalCluster> mSignalClusters = new ArrayList<SignalCluster>();
     ArrayList<NetworkSignalChangedCallback> mSignalsChangedCallbacks =
             new ArrayList<NetworkSignalChangedCallback>();
     int mLastPhoneSignalIconId = -1;
     int mLastDataDirectionIconId = -1;
     int mLastWifiIconId = -1;
+    int mLastEthernetIconId = -1;
     int mLastWimaxIconId = -1;
     int mLastCombinedSignalIconId = -1;
     int mLastDataTypeIconId = -1;
@@ -158,6 +173,7 @@ public class NetworkController extends BroadcastReceiver implements DemoMode {
     public interface SignalCluster {
         void setWifiIndicators(boolean visible, int strengthIcon,
                 String contentDescription);
+        void setEthernetIndicators(boolean visible, int statusIcon, int activityIcon, String contentDescription);
         void setMobileDataIndicators(boolean visible, int strengthIcon,
                 int typeIcon, String contentDescription, String typeContentDescription);
         void setIsAirplaneMode(boolean is, int airplaneIcon);
@@ -192,6 +208,7 @@ public class NetworkController extends BroadcastReceiver implements DemoMode {
 
         // set up the default wifi icon, used when no radios have ever appeared
         updateWifiIcons();
+        updateEthernetIcons();
         updateWimaxIcons();
 
         // telephony
@@ -218,11 +235,22 @@ public class NetworkController extends BroadcastReceiver implements DemoMode {
             mWifiChannel.connect(mContext, handler, wifiMessenger);
         }
 
+        // ethernet
+        mEthernetManager = (EthernetManager) context.getSystemService(Context.ETHERNET_SERVICE);
+        Handler ethernetHandler = new EthernetHandler();
+        mEthernetChannel = new AsyncChannel();
+        Messenger ethernetMessenger = mEthernetManager.getEthernetServiceMessenger();
+
+        if(ethernetMessenger != null) {
+            mEthernetChannel.connect(mContext, ethernetHandler, ethernetMessenger);
+        }
+
         // broadcasts
         IntentFilter filter = new IntentFilter();
         filter.addAction(WifiManager.RSSI_CHANGED_ACTION);
         filter.addAction(WifiManager.WIFI_STATE_CHANGED_ACTION);
         filter.addAction(WifiManager.NETWORK_STATE_CHANGED_ACTION);
+        filter.addAction(EthernetManager.NETWORK_STATE_CHANGED_ACTION);
         filter.addAction(TelephonyIntents.ACTION_SIM_STATE_CHANGED);
         filter.addAction(TelephonyIntents.SPN_STRINGS_UPDATED_ACTION);
         filter.addAction(ConnectivityManager.CONNECTIVITY_ACTION);
@@ -252,6 +280,10 @@ public class NetworkController extends BroadcastReceiver implements DemoMode {
         return mPhone.getPhoneType() != TelephonyManager.PHONE_TYPE_NONE;
     }
 
+    public void addEthernetIconView(ImageView v) {
+        mEthernetIconViews.add(v);
+    }
+
     public boolean isEmergencyOnly() {
         return (mServiceState != null && mServiceState.isEmergencyOnly());
     }
@@ -272,6 +304,10 @@ public class NetworkController extends BroadcastReceiver implements DemoMode {
         mEmergencyLabelViews.add(v);
     }
 
+    public void addEthernetLabelView(TextView v) {
+        mEthernetLabelViews.add(v);
+    }
+
     public void addSignalCluster(SignalCluster cluster) {
         mSignalClusters.add(cluster);
         refreshSignalCluster(cluster);
@@ -290,6 +326,12 @@ public class NetworkController extends BroadcastReceiver implements DemoMode {
                 mWifiIconId,
                 mContentDescriptionWifi);
 
+        cluster.setEthernetIndicators(
+                mEthernetEnabled && mEthernetConnected,
+                mEthernetIconId,
+                mEthernetActivityIconId,
+                mContentDescriptionEthernet);
+
         if (mIsWimaxEnabled && mWimaxConnected) {
             // wimax is special
             cluster.setMobileDataIndicators(
@@ -360,6 +402,9 @@ public class NetworkController extends BroadcastReceiver implements DemoMode {
                 || action.equals(WifiManager.NETWORK_STATE_CHANGED_ACTION)) {
             updateWifiState(intent);
             refreshViews();
+        } else if (action.equals(EthernetManager.NETWORK_STATE_CHANGED_ACTION)) {
+            updateEthernetState(intent);
+            refreshViews();
         } else if (action.equals(TelephonyIntents.ACTION_SIM_STATE_CHANGED)) {
             updateSimState(intent);
             updateDataIcon();
@@ -890,6 +935,55 @@ public class NetworkController extends BroadcastReceiver implements DemoMode {
         return null;
     }
 
+    // ===== Ethernet ================================================================
+    class EthernetHandler extends Handler {
+        @Override
+        public void handleMessage(Message msg) {
+            switch (msg.what) {
+                case AsyncChannel.CMD_CHANNEL_HALF_CONNECTED:
+                    if (msg.arg1 == AsyncChannel.STATUS_SUCCESSFUL) {
+                        mEthernetChannel.sendMessage(Message.obtain(this,
+                                AsyncChannel.CMD_CHANNEL_FULL_CONNECTION));
+                    } else {
+                        Log.e(TAG, "Failed to connect to ethernet service");
+                    }
+                    break;
+                case EthernetManager.DATA_ACTIVITY_NOTIFICATION:
+                    if (msg.arg1 != mEthernetActivity) {
+                        mEthernetActivity = msg.arg1;
+                        refreshViews();
+                    }
+                    break;
+                default:
+                    //Ignore
+                    break;
+            }
+        }
+    }
+
+    private void updateEthernetState(Intent intent) {
+        final String action = intent.getAction();
+
+        if( action.equals(EthernetManager.NETWORK_STATE_CHANGED_ACTION)) {
+            mEthernetEnabled = true;
+            final EthernetInfo ei = (EthernetInfo)
+                    intent.getParcelableExtra(EthernetManager.EXTRA_ETHERNET_INFO);
+            final NetworkInfo networkInfo = ei.getNetworkInfo();
+            mEthernetConnected = networkInfo != null && networkInfo.isConnected();
+        }
+        updateEthernetIcons();
+    }
+
+    private void updateEthernetIcons() {
+        if (mEthernetConnected) {
+            Log.d(TAG, "mInetCondition is " + mInetCondition);
+            mEthernetIconId = EthernetIcons.ETHERNET_STATE[mInetCondition + 1]; //TODO: Check this after all the stuff is in place
+            mContentDescriptionEthernet = mContext.getString(R.string.accessibility_ethernet_connected);
+        } else {
+            mEthernetIconId = 0;
+            mContentDescriptionEthernet = mContext.getString(R.string.accessibility_no_ethernet);
+        }
+    }
 
     // ===== Wimax ===================================================================
     private final void updateWimaxState(Intent intent) {
@@ -976,6 +1070,7 @@ public class NetworkController extends BroadcastReceiver implements DemoMode {
         updateDataIcon();
         updateTelephonySignalStrength();
         updateWifiIcons();
+        updateEthernetIcons();
     }
 
 
@@ -987,6 +1082,7 @@ public class NetworkController extends BroadcastReceiver implements DemoMode {
         int combinedSignalIconId = 0;
         String combinedLabel = "";
         String wifiLabel = "";
+        String ethernetLabel = "";
         String mobileLabel = "";
         int N;
         final boolean emergencyOnly = isEmergencyOnly();
@@ -1050,6 +1146,13 @@ public class NetworkController extends BroadcastReceiver implements DemoMode {
             }
         }
 
+        if (mEthernetConnected) {
+            ethernetLabel = "Ethernet is ON";
+            combinedLabel = ethernetLabel;
+            combinedSignalIconId = mEthernetIconId; // set by updateEthernetIcons()
+            mContentDescriptionCombinedSignal = mContentDescriptionEthernet;
+        }
+
         if (mBluetoothTethered) {
             combinedLabel = mContext.getString(R.string.bluetooth_tethered);
             combinedSignalIconId = mBluetoothTetherIconId;
@@ -1057,11 +1160,6 @@ public class NetworkController extends BroadcastReceiver implements DemoMode {
                     R.string.accessibility_bluetooth_tether);
         }
 
-        final boolean ethernetConnected = (mConnectedNetworkType == ConnectivityManager.TYPE_ETHERNET);
-        if (ethernetConnected) {
-            combinedLabel = context.getString(R.string.ethernet_label);
-        }
-
         if (mAirplaneMode &&
                 (mServiceState == null || (!hasService() && !mServiceState.isEmergencyOnly()))) {
             // Only display the flight-mode icon if not in "emergency calls only" mode.
@@ -1074,7 +1172,9 @@ public class NetworkController extends BroadcastReceiver implements DemoMode {
             mQSPhoneSignalIconId = 0;
 
             // combined values from connected wifi take precedence over airplane mode
-            if (mWifiConnected) {
+            if(mEthernetConnected) {
+                mobileLabel = "";
+            } else if (mWifiConnected) {
                 // Suppress "No internet connection." from mobile if wifi connected.
                 mobileLabel = "";
             } else {
@@ -1089,7 +1189,7 @@ public class NetworkController extends BroadcastReceiver implements DemoMode {
                 combinedSignalIconId = mDataSignalIconId;
             }
         }
-        else if (!mDataConnected && !mWifiConnected && !mBluetoothTethered && !mWimaxConnected && !ethernetConnected) {
+        else if (!mDataConnected && !mWifiConnected && !mBluetoothTethered && !mWimaxConnected && !mEthernetConnected) {
             // pretty much totally disconnected
 
             combinedLabel = context.getString(R.string.status_bar_settings_signal_meter_disconnected);
@@ -1115,6 +1215,7 @@ public class NetworkController extends BroadcastReceiver implements DemoMode {
         if (DEBUG) {
             Log.d(TAG, "refreshViews connected={"
                     + (mWifiConnected?" wifi":"")
+                    + (mEthernetConnected?" ethernet":"")
                     + (mDataConnected?" data":"")
                     + " } level="
                     + ((mSignalStrength == null)?"??":Integer.toString(mSignalStrength.getLevel()))
@@ -1124,6 +1225,7 @@ public class NetworkController extends BroadcastReceiver implements DemoMode {
                     + " mobileLabel=" + mobileLabel
                     + " wifiLabel=" + wifiLabel
                     + " emergencyOnly=" + emergencyOnly
+                    + " ethernetLabel=" + ethernetLabel
                     + " combinedLabel=" + combinedLabel
                     + " mAirplaneMode=" + mAirplaneMode
                     + " mDataActivity=" + mDataActivity
@@ -1135,6 +1237,7 @@ public class NetworkController extends BroadcastReceiver implements DemoMode {
                     + " mQSDataTypeIconId=0x" + Integer.toHexString(mQSDataTypeIconId)
                     + " mWifiIconId=0x" + Integer.toHexString(mWifiIconId)
                     + " mQSWifiIconId=0x" + Integer.toHexString(mQSWifiIconId)
+                    + " mEthernetIconId=0x" + Integer.toHexString(mEthernetIconId)
                     + " mBluetoothTetherIconId=0x" + Integer.toHexString(mBluetoothTetherIconId));
         }
 
@@ -1145,6 +1248,7 @@ public class NetworkController extends BroadcastReceiver implements DemoMode {
 
         if (mLastPhoneSignalIconId          != mPhoneSignalIconId
          || mLastWifiIconId                 != mWifiIconId
+         || mLastEthernetIconId             != mEthernetIconId
          || mLastWimaxIconId                != mWimaxIconId
          || mLastDataTypeIconId             != mDataTypeIconId
          || mLastAirplaneMode               != mAirplaneMode
@@ -1179,6 +1283,22 @@ public class NetworkController extends BroadcastReceiver implements DemoMode {
             mLastWifiIconId = mWifiIconId;
         }
 
+        //ethernet icons on phones
+        if (mLastEthernetIconId != mEthernetIconId) {
+            mLastEthernetIconId = mEthernetIconId;
+            N = mEthernetIconViews.size();
+            for (int i=0; i<N; i++) {
+                final ImageView v = mEthernetIconViews.get(i);
+                if (mEthernetIconId == 0) {
+                    v.setVisibility(View.GONE);
+                } else {
+                    v.setVisibility(View.VISIBLE);
+                    v.setImageResource(mEthernetIconId);
+                    v.setContentDescription(mContentDescriptionEthernet);
+                }
+            }
+        }
+
         // the wimax icon on phones
         if (mLastWimaxIconId != mWimaxIconId) {
             mLastWimaxIconId = mWimaxIconId;
@@ -1215,6 +1335,18 @@ public class NetworkController extends BroadcastReceiver implements DemoMode {
             }
         }
 
+        //ethernet label
+        N = mEthernetLabelViews.size();
+        for(int i=0; i<N; i++) {
+            TextView v = mEthernetLabelViews.get(i);
+            v.setText(ethernetLabel);
+            if("".equals(ethernetLabel)) {
+                v.setVisibility(View.GONE);
+            } else {
+                v.setVisibility(View.VISIBLE);
+            }
+        }
+
         // mobile label
         N = mMobileLabelViews.size();
         for (int i=0; i<N; i++) {
@@ -1320,6 +1452,16 @@ public class NetworkController extends BroadcastReceiver implements DemoMode {
         pw.print("  mWifiActivity=");
         pw.println(mWifiActivity);
 
+        pw.println("  - ethernet ------");
+        pw.print("  mEthernetEnabled=");
+        pw.println(mEthernetEnabled);
+        pw.print("  mEthernetConnected=");
+        pw.println(mEthernetConnected);
+        pw.println(String.format("  mEthernetIconId=0x%08x/%s",
+                mEthernetIconId, getResourceName(mEthernetIconId)));
+        pw.print("  mEthernetActivity=");
+        pw.println(mEthernetActivity);
+
         if (mWimaxSupported) {
             pw.println("  - wimax ------");
             pw.print("  mIsWimaxEnabled="); pw.println(mIsWimaxEnabled);
@@ -1353,6 +1495,10 @@ public class NetworkController extends BroadcastReceiver implements DemoMode {
         pw.print(Integer.toHexString(mLastWifiIconId));
         pw.print("/");
         pw.println(getResourceName(mLastWifiIconId));
+        pw.print("  mLastEthernetIconId=0x");
+        pw.print(Integer.toHexString(mLastEthernetIconId));
+        pw.print("/");
+        pw.println(getResourceName(mLastEthernetIconId));
         pw.print("  mLastCombinedSignalIconId=0x");
         pw.print(Integer.toHexString(mLastCombinedSignalIconId));
         pw.print("/");
diff --git a/services/java/com/android/server/ConnectivityService.java b/services/java/com/android/server/ConnectivityService.java
index baff661..83868d7 100644
--- a/services/java/com/android/server/ConnectivityService.java
+++ b/services/java/com/android/server/ConnectivityService.java
@@ -50,7 +50,6 @@ import android.database.ContentObserver;
 import android.net.CaptivePortalTracker;
 import android.net.ConnectivityManager;
 import android.net.DummyDataStateTracker;
-import android.net.EthernetDataTracker;
 import android.net.IConnectivityManager;
 import android.net.INetworkManagementEventObserver;
 import android.net.INetworkPolicyListener;
@@ -106,6 +105,7 @@ import android.util.Xml;
 
 import com.android.internal.R;
 import com.android.internal.annotations.GuardedBy;
+import com.android.internal.ethernet.EthernetManager;
 import com.android.internal.net.LegacyVpnInfo;
 import com.android.internal.net.VpnConfig;
 import com.android.internal.net.VpnProfile;
@@ -728,7 +728,7 @@ public class ConnectivityService extends IConnectivityManager.Stub {
                 case TYPE_WIMAX:
                     return makeWimaxStateTracker(mContext, mTrackerHandler);
                 case TYPE_ETHERNET:
-                    return EthernetDataTracker.getInstance();
+                    return (NetworkStateTracker) mContext.getSystemService(Context.ETHERNET_SERVICE);
                 default:
                     throw new IllegalArgumentException(
                             "Trying to create a NetworkStateTracker for an unknown radio type: "
diff --git a/services/java/com/android/server/EthernetService.java b/services/java/com/android/server/EthernetService.java
new file mode 100644
index 0000000..e761543
--- /dev/null
+++ b/services/java/com/android/server/EthernetService.java
@@ -0,0 +1,551 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server;
+
+import static com.android.internal.util.Preconditions.checkNotNull;
+
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.net.ConnectivityManager;
+import android.net.DhcpInfo;
+import android.net.DhcpStateMachine;
+import android.net.INetworkManagementEventObserver;
+import android.net.InterfaceConfiguration;
+import android.net.LinkAddress;
+import android.net.LinkProperties;
+import android.net.NetworkInfo;
+import android.net.NetworkInfo.DetailedState;
+import android.net.NetworkUtils;
+import android.net.ProxyProperties;
+import android.net.RouteInfo;
+import android.net.TrafficStats;
+import android.os.Binder;
+import android.os.Environment;
+import android.os.Handler;
+import android.os.HandlerThread;
+import android.os.IBinder;
+import android.os.INetworkManagementService;
+import android.os.Message;
+import android.os.Messenger;
+import android.os.Parcelable;
+import android.os.RemoteException;
+import android.os.ServiceManager;
+import android.os.SystemProperties;
+import android.provider.Settings;
+import android.util.JsonReader;
+import android.util.JsonWriter;
+import android.util.Slog;
+
+import com.android.internal.ethernet.EthernetInfo;
+import com.android.internal.ethernet.EthernetManager;
+import com.android.internal.ethernet.EthernetStateMachine;
+import com.android.internal.ethernet.IEthernetManager;
+import com.android.internal.util.AsyncChannel;
+import com.android.internal.util.StateMachine;
+
+import java.io.BufferedOutputStream;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.FileOutputStream;
+import java.io.InputStreamReader;
+import java.io.IOException;
+import java.io.OutputStreamWriter;
+import java.io.UnsupportedEncodingException;
+import java.lang.Runnable;
+import java.net.InetAddress;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Set;
+
+public class EthernetService extends IEthernetManager.Stub {
+    private static final String TAG = "EthernetService";
+    private static final boolean DBG = true;
+    private static final String PERSIST_FILE = Environment.getDataDirectory() +
+            "/misc/ethernet_interfaces.json";
+    private static final int POLL_TRAFFIC_STATS_INTERVAL_MSECS = 1000;
+    private INetworkManagementService mNetd;
+    private Context mContext;
+    private EthernetStateMachine mAvailableInterface;
+    private HashMap<String, EthernetInfo> mUnavailableInterfaces =
+            new HashMap<String, EthernetInfo>();
+    private List<AsyncChannel> mClients = new ArrayList<AsyncChannel>();
+    private boolean mEnableTrafficStatsPoll = false;
+    private int mTrafficStatsPollToken = 0;
+    private long mTxPkts;
+    private long mRxPkts;
+    private int mDataActivity;
+    private boolean mScreenOff;
+
+    private class AsyncServiceHandler extends Handler {
+
+        AsyncServiceHandler(android.os.Looper looper) {
+            super(looper);
+        }
+
+        @Override
+        public void handleMessage(Message msg) {
+            switch (msg.what) {
+                case AsyncChannel.CMD_CHANNEL_HALF_CONNECTED: {
+                    if (msg.arg1 == AsyncChannel.STATUS_SUCCESSFUL) {
+                        if (DBG) Slog.d(TAG, "New client listening to asynchronous messages");
+                        mClients.add((AsyncChannel) msg.obj);
+                    } else {
+                        Slog.e(TAG, "Client connection failure, error=" + msg.arg1);
+                    }
+                    break;
+                }
+                case AsyncChannel.CMD_CHANNEL_DISCONNECTED: {
+                    if (msg.arg1 == AsyncChannel.STATUS_SEND_UNSUCCESSFUL) {
+                        if (DBG) Slog.d(TAG, "Send failed, client connection lost");
+                    } else {
+                        if (DBG) Slog.d(TAG, "Client connection lost with reason: " + msg.arg1);
+                    }
+                    mClients.remove((AsyncChannel) msg.obj);
+                    break;
+                }
+                case AsyncChannel.CMD_CHANNEL_FULL_CONNECTION: {
+                    AsyncChannel ac = new AsyncChannel();
+                    ac.connect(mContext, this, msg.replyTo);
+                    break;
+                }
+                case EthernetManager.ENABLE_TRAFFIC_STATS_POLL: {
+                    mEnableTrafficStatsPoll = (msg.arg1 == 1);
+                    mTrafficStatsPollToken++;
+                    if (mEnableTrafficStatsPoll) {
+                        notifyOnDataActivity();
+                        sendMessageDelayed(Message.obtain(this, EthernetManager.TRAFFIC_STATS_POLL,
+                                mTrafficStatsPollToken, 0), POLL_TRAFFIC_STATS_INTERVAL_MSECS);
+                    }
+                    break;
+                }
+                case EthernetManager.TRAFFIC_STATS_POLL: {
+                    if (msg.arg1 == mTrafficStatsPollToken) {
+                        notifyOnDataActivity();
+                        sendMessageDelayed(Message.obtain(this, EthernetManager.TRAFFIC_STATS_POLL,
+                                mTrafficStatsPollToken, 0), POLL_TRAFFIC_STATS_INTERVAL_MSECS);
+                    }
+                    break;
+                }
+                default: {
+                    if (DBG) Slog.d(TAG, "EthernetServicehandler.handleMessage ignoring msg=" + msg);
+                    break;
+                }
+            }
+        }
+    }
+
+    private AsyncServiceHandler mAsyncServiceHandler;
+
+    private class NetworkManagementEventObserver extends INetworkManagementEventObserver.Stub {
+        public void interfaceAdded(String iface) {
+            if(DBG) Slog.d(TAG, "interfaceAdded: " + iface);
+            addInterface(iface);
+        }
+        public void interfaceRemoved(String iface) {
+            if(DBG) Slog.d(TAG, "interfaceRemoved: " + iface);
+            removeInterface(iface);
+        }
+        public void limitReached(String limitName, String iface) {}
+        public void interfaceClassDataActivityChanged(String label, boolean active) {}
+        public void interfaceLinkStateChanged(String iface, boolean up) {
+            if(DBG) Slog.d(TAG, "interfaceLinkStateChanged for " + iface + ", up = " + up);
+            if (mAvailableInterface != null && up) {
+                //sendMessage(mAvailableInterface, 
+                //EthernetStateMachine.CMD_LINK_UP);
+            }
+        }
+        public void interfaceStatusChanged(String iface, boolean up) {
+            if(DBG) Slog.d(TAG, "interfaceStatusChanged for " + iface + ", up = " + up);
+            //addInterface(iface);
+        }
+        public void addressUpdated(String address, String iface, int flags, int scope) {}
+        public void addressRemoved(String address, String iface, int flags, int scope) {}
+    }
+
+    private String getUtilityInterface() {
+        String retval = SystemProperties.get("persist.sys.utility_iface");
+        if(DBG) Slog.d(TAG, "getUtilityInterface: "  + retval);
+        return retval;
+    }
+
+    private class InterfaceStateReceiver extends BroadcastReceiver {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            if (intent.getAction().equals(EthernetManager.INTERFACE_STATE_CHANGED_ACTION)) {
+                EthernetInfo ei = intent.getParcelableExtra(
+                        EthernetManager.EXTRA_ETHERNET_INFO);
+                if (ei == null) {
+                    Slog.e(TAG, "Could not get EXTRA_ETHERNET_INFO!");
+                    return;
+                }
+                String name = ei.getName();
+                if(DBG) Slog.d(TAG, "INTERFACE_STATE_CHANGED_ACTION: "  + name);
+
+                // Forward it up to ConnectivityService (via EthernetManager)
+                // Don't forward events for inactive interface
+                Intent newIntent = new Intent(EthernetManager.NETWORK_STATE_CHANGED_ACTION);
+                newIntent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
+                newIntent.putExtra(EthernetManager.EXTRA_ETHERNET_INFO, ei);
+                if(DBG) Slog.d(TAG, "Sending EthernetManager.NETWORK_STATE_CHANGED_ACTION");
+                mContext.sendBroadcast(newIntent);
+
+                // If it's the utility interface or not our active interface,
+                // do nothing:
+                if (name.equals(getUtilityInterface())
+                        || mAvailableInterface == null
+                        || ! name.equals(mAvailableInterface.getInfo().getName())) {
+                    return;
+                }
+
+                saveConfig();
+                evaluateTrafficStatsPolling();
+            } else if (intent.getAction().equals(Intent.ACTION_SCREEN_ON)) {
+                mScreenOff = false;
+                evaluateTrafficStatsPolling();
+            } else if (intent.getAction().equals(Intent.ACTION_SCREEN_OFF)) {
+                mScreenOff = true;
+                evaluateTrafficStatsPolling();
+            }
+        }
+    }
+
+    private void removeInterface(String iface) {
+        if(DBG) Slog.d(TAG, "removeInterface: " + iface);
+
+        if ( ! iface.equals(mAvailableInterface.getInfo().getName())) {
+            if(DBG) Slog.d(TAG, "removeInterface: won't remove " + iface);
+            return;
+        }
+
+        if (mAvailableInterface == null) {
+            if(DBG) Slog.d(TAG, "removeInterface: won't remove " + iface + " because mAvailableInterface == null");
+            return;
+        }
+
+        EthernetInfo info = mAvailableInterface.getInfo();
+        // info.isEnabled() is still true here and that is what we want. On
+        // device suspend, USB ethernet devices will come through this
+        // path. We want any enabled device to remain enabled after
+        // resuming from suspend and thus we leave its EthernetInfo object
+        // in the enabled state when putting it into
+        // mUnavailableInterfaces.
+        sendMessage(mAvailableInterface, EthernetStateMachine.CMD_INTERFACE_GONE, info);
+        sendMessage(mAvailableInterface, EthernetStateMachine.CMD_SHUTDOWN, info);
+        mUnavailableInterfaces.put(info.getHwAddress(), info);
+        mAvailableInterface.doQuit();
+        mAvailableInterface = null;
+
+        saveConfig();
+
+        Intent newIntent = new Intent(EthernetManager.INTERFACE_REMOVED_ACTION);
+        newIntent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
+        newIntent.putExtra(EthernetManager.EXTRA_INTERFACE_NAME, iface);
+        mContext.sendBroadcast(newIntent);
+    }
+
+    private void addInterface(String iface) {
+        if(DBG) Slog.d(TAG, "addInterface: " + iface);
+
+        String eth_regex = mContext.getResources().getString(
+            com.android.internal.R.string.config_ethernet_iface_regex);
+
+        // If it's not an ethernet interface, or it is the utility interface,
+        // do nothing:
+        if ( ! iface.matches(eth_regex)
+                || iface.equals(getUtilityInterface())) {
+            if(DBG) Slog.d(TAG, "addInterface: I cannot manage " + iface);
+            return;
+        }
+
+        String hwAddr = getHwAddr(iface);
+        EthernetStateMachine sm;
+
+        if (mUnavailableInterfaces.containsKey(hwAddr)) {
+            // We've seen this interface before
+            if(DBG) Slog.d(TAG, "Found " + iface + " in mUnavailableInterfaces");
+            if (mAvailableInterface == null) { // Nothing currently active
+                EthernetInfo ei = mUnavailableInterfaces.get(hwAddr);
+
+                // Interface name may have changed since last time due to
+                // device insertion order, etc.:
+                ei.setName(iface);
+
+                ei.setInterfaceStatus(EthernetInfo.InterfaceStatus.ENABLED);
+                sm = new EthernetStateMachine(mContext, ei);
+                mUnavailableInterfaces.remove(hwAddr);
+                mAvailableInterface = sm;
+            }
+        } else {
+            // This is a new interface
+            if(DBG) Slog.d(TAG, "Found new interface " + iface + " at " + hwAddr);
+            EthernetInfo ei = new EthernetInfo(iface, hwAddr);
+
+            if (mAvailableInterface == null) {
+                mAvailableInterface = new EthernetStateMachine(mContext, ei);
+                if (mUnavailableInterfaces.isEmpty()) {
+                    if(DBG) Slog.d(TAG, "New interface " + iface
+                            + " is first interface we've ever seen.");
+                    ei.enable();
+                    ei.setIpAssignment(EthernetInfo.IpAssignment.DHCP);
+                    sendMessage(mAvailableInterface,
+                            EthernetStateMachine.CMD_UPDATE_INTERFACE,
+                            ei);
+                }
+            } else {
+                mUnavailableInterfaces.put(hwAddr, ei);
+            }
+        }
+
+        saveConfig();
+    }
+
+    private void saveConfig() {
+        if(DBG) Slog.d(TAG, "Storing Ethernet interface configs to disk.");
+        JsonWriter writer = null;
+        try {
+            FileOutputStream fos = new FileOutputStream(PERSIST_FILE);
+            writer = new JsonWriter(new OutputStreamWriter(fos, "UTF-8"));
+            writer.setIndent("  ");
+            writer.beginArray();
+            if (mAvailableInterface != null) {
+                mAvailableInterface.getInfo().write(writer);
+            }
+            for (EthernetInfo info : mUnavailableInterfaces.values()) {
+                info.write(writer);
+            }
+            writer.endArray();
+        } catch (Exception e) {
+            Slog.e(TAG, "Failed to store ethernet config: " + e);
+        } finally {
+            try { writer.close(); } catch(Exception e) {}
+        }
+    }
+
+    public EthernetService(Context context) {
+        mContext = context;
+        mNetd = INetworkManagementService.Stub.asInterface(
+                ServiceManager.getService(Context.NETWORKMANAGEMENT_SERVICE)
+        );
+
+        try {
+            mNetd.registerObserver(new NetworkManagementEventObserver());
+        } catch (RemoteException e) {
+            Slog.e(TAG, "Remote NetworkManagementService error: " + e);
+        }
+
+        IntentFilter filter = new IntentFilter();
+        filter.addAction(EthernetManager.INTERFACE_STATE_CHANGED_ACTION);
+        filter.addAction(Intent.ACTION_SCREEN_ON);
+        filter.addAction(Intent.ACTION_SCREEN_OFF);
+        mContext.registerReceiver(new InterfaceStateReceiver(), filter);
+
+        HandlerThread ethernetThread = new HandlerThread("EthernetService");
+        ethernetThread.start();
+        mAsyncServiceHandler = new AsyncServiceHandler(ethernetThread.getLooper());
+
+        try {
+            if(DBG) Slog.d(TAG, "Reading " + PERSIST_FILE);
+            FileInputStream fis = new FileInputStream(PERSIST_FILE);
+            JsonReader reader = new JsonReader(new InputStreamReader(fis, "UTF-8"));
+            reader.beginArray();
+            while (reader.hasNext()) {
+                EthernetInfo newInfo = new EthernetInfo(reader);
+                if(DBG) Slog.d(TAG, "Found " + newInfo.getName() + " in " + PERSIST_FILE);
+                mUnavailableInterfaces.put(newInfo.getHwAddress(), newInfo);
+            }
+            reader.endArray();
+            reader.close();
+        } catch (IOException e) {
+            Slog.i(TAG, "While reading interface config: " + e.toString());
+        } catch (IllegalStateException e) {
+            Slog.e(TAG, "Invalid JSON in " + PERSIST_FILE + ": " + e);
+            File f = new File(PERSIST_FILE);
+            try { f.delete(); } catch (Exception ex) {}
+        }
+
+        for (String iface : getInterfaceNames()) {
+            addInterface(iface);
+        }
+
+        if(DBG) Slog.d(TAG, "EthernetService initialized");
+    }
+
+    public EthernetInfo getCurrentInterface() {
+        return mAvailableInterface == null ? null : mAvailableInterface.getInfo();
+    }
+
+    public boolean teardown() {
+        if(DBG) Slog.d(TAG, "Teardown requested.");
+
+        if (mAvailableInterface == null) {
+            return true;
+        }
+
+        EthernetInfo info = mAvailableInterface.getInfo();
+        if(DBG) Slog.d(TAG, "Requesting interface shut down for " + info.getName());
+        sendMessage(mAvailableInterface, EthernetStateMachine.CMD_SHUTDOWN, info);
+        return true;
+    }
+
+    public boolean isEnabled() {
+        if (mAvailableInterface == null) {
+            return false;
+        }
+        return mAvailableInterface.isEnabled();
+    }
+
+    public boolean reconnect() {
+        if (isEnabled()) {
+            return true;
+        }
+        if (mAvailableInterface == null) {
+            return false;
+        }
+        if(DBG) Slog.d(TAG, "Reconnecting " + mAvailableInterface.getInfo().getName());
+        EthernetInfo newInfo = mAvailableInterface.getInfo();
+        newInfo.enable();
+        sendMessage(mAvailableInterface,
+                EthernetStateMachine.CMD_UPDATE_INTERFACE,
+                newInfo);
+        return true;
+    }
+
+    public void updateInterface(EthernetInfo newInfo) {
+        if (newInfo == null) {
+            Slog.e(TAG, "Null EthernetInfo");
+            return;
+        }
+        if (mAvailableInterface == null) {
+            Slog.e(TAG, "Unable to find statemachine for interface " + newInfo.getName());
+            return;
+        }
+
+        sendMessage(mAvailableInterface,
+                EthernetStateMachine.CMD_UPDATE_INTERFACE,
+                newInfo);
+
+        if(DBG) Slog.d(TAG, newInfo.getName() + " updateInterface done");
+    }
+
+    private void sendMessage(StateMachine sm, int what, Parcelable obj) {
+        Message msg = sm.obtainMessage(what);
+        msg.obj = obj;
+        sm.sendMessage(msg);
+    }
+
+    private void sendMessage(StateMachine sm, int what) {
+        Message msg = sm.obtainMessage(what);
+        sm.sendMessage(msg);
+    }
+
+    private String getHwAddr(String ifaceName) {
+        try {
+            InterfaceConfiguration ic = mNetd.getInterfaceConfig(ifaceName);
+            return ic.getHardwareAddress();
+        } catch (RemoteException e) {
+            Slog.e(TAG, "Remote NetworkManagementService error: " + e);
+        }
+        return "";
+    }
+
+    private Set<String> getInterfaceNames() {
+        // () Call the NetworkManagementService to list interfaces that exist
+        //    now
+        // () filter these to the set of ones matching the ethernet interface
+        //    regular expression
+        Set<String> sNames = new HashSet<String>();
+        String eth_regex = mContext.getResources().getString(
+            com.android.internal.R.string.config_ethernet_iface_regex);
+        String[] ifaces;
+        try {
+            ifaces = mNetd.listInterfaces();
+        } catch (RemoteException e) {
+            Slog.e(TAG, "Remote NetworkManagementService error " + e);
+            ifaces = new String[0];
+        }
+        for (String iface : ifaces) {
+            if (iface.matches(eth_regex)) {
+                if(DBG) Slog.d(TAG, "Found " + iface + " in getInterfaceNames.");
+                sNames.add(iface);
+            } else {
+                if(DBG) Slog.d(TAG, "Found and filtered " + iface + " in getInterfaceNames.");
+            }
+        }
+        return sNames;
+    }
+
+    public Messenger getEthernetServiceMessenger() {
+        return new Messenger(mAsyncServiceHandler);
+    }
+
+    private void notifyOnDataActivity() {
+        long sent, received;
+        long preTxPkts = mTxPkts, preRxPkts = mRxPkts;
+        int dataActivity = EthernetManager.DATA_ACTIVITY_NONE;
+
+        if (mAvailableInterface != null) {
+            mTxPkts = TrafficStats.getTxPackets(mAvailableInterface.getInfo().getName());
+            mRxPkts = TrafficStats.getRxPackets(mAvailableInterface.getInfo().getName());
+        }
+
+        if (preTxPkts > 0 || preRxPkts > 0) {
+            sent = mTxPkts - preTxPkts;
+            received = mRxPkts - preRxPkts;
+            if (sent > 0) {
+                dataActivity |= EthernetManager.DATA_ACTIVITY_OUT;
+            }
+            if (received > 0) {
+                dataActivity |= EthernetManager.DATA_ACTIVITY_IN;
+            }
+
+            if (dataActivity != mDataActivity && !mScreenOff) {
+                mDataActivity = dataActivity;
+                for (AsyncChannel client : mClients) {
+                    client.sendMessage(EthernetManager.DATA_ACTIVITY_NOTIFICATION, mDataActivity);
+                }
+            }
+        }
+    }
+
+    private DetailedState getDetailedState() {
+        if (mAvailableInterface != null) {
+            return mAvailableInterface.getInfo().getDetailedState();
+        }
+        if (DBG) Slog.d(TAG, "getDetailedState: state is DISCONNECTED");
+        return DetailedState.DISCONNECTED;
+    }
+
+    private void evaluateTrafficStatsPolling() {
+        Message msg;
+        if (getDetailedState() == DetailedState.CONNECTED && !mScreenOff) {
+            msg = Message.obtain(mAsyncServiceHandler,
+                    EthernetManager.ENABLE_TRAFFIC_STATS_POLL, 1, 0);
+        } else {
+            msg = Message.obtain(mAsyncServiceHandler,
+                    EthernetManager.ENABLE_TRAFFIC_STATS_POLL, 0, 0);
+        }
+        msg.sendToTarget();
+    }
+}
+
diff --git a/services/java/com/android/server/SystemServer.java b/services/java/com/android/server/SystemServer.java
index a42cbcf..6ba1cc4 100644
--- a/services/java/com/android/server/SystemServer.java
+++ b/services/java/com/android/server/SystemServer.java
@@ -69,7 +69,6 @@ import com.android.server.search.SearchManagerService;
 import com.android.server.usb.UsbService;
 import com.android.server.wifi.WifiService;
 import com.android.server.wm.WindowManagerService;
-
 import dalvik.system.VMRuntime;
 import dalvik.system.Zygote;
 
@@ -156,6 +155,7 @@ class ServerThread {
         InputManagerService inputManager = null;
         TelephonyRegistry telephonyRegistry = null;
         ConsumerIrService consumerIr = null;
+        EthernetService eth = null;
 
         // Create a handler thread just for the window manager to enjoy.
         HandlerThread wmHandlerThread = new HandlerThread("WindowManager");
@@ -511,6 +511,14 @@ class ServerThread {
                 }
 
                 try {
+                    Slog.i(TAG, "Ethernet Service");
+                    eth = new EthernetService(context);
+                    ServiceManager.addService(Context.ETHERNET_SERVICE, eth);
+                } catch (Throwable e) {
+                    reportWtf("starting Ethernet Service", e);
+                }
+
+                try {
                     Slog.i(TAG, "Connectivity Service");
                     connectivity = new ConnectivityService(
                             context, networkManagement, networkStats, networkPolicy);
-- 
1.7.4.1

