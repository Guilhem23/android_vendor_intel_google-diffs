From f87e41c12d7c79ae5570a8568e5ff889870e4c39 Mon Sep 17 00:00:00 2001
From: Jianxun Zhang <jianxun.zhang@intel.com>
Date: Mon, 2 Jul 2012 11:32:30 -0700
Subject: add modprobe-like capability and automatic ueventd loading

Author: Jianxun Zhang <jianxun.zhang@intel.com>
Author: Daniel Leung <daniel.leung@intel.com>
Author: Robert Chiras <robert.chiras@intel.com>
Author: Andrew Boie <andrew.p.boie@intel.com>

- insmod_by_dep() added to libcutils; loads a module into kernel.
Modules the target module depends on will be loaded first. Loading
will be stopped when an error occurs.

- get_module_name_from_alias() maps module names from modalias
info in the uevent. Returns as a list in case there are multiple
matches for a single modalias.

- rmmod_by_dep() added to libcutils; removes a module from kernel.
It also tries to remove other modules the target module depends
on until an error occurs.

- uevent buffer max size increased to 1MB. This memory isn't permanently
lost and is used and released on demand by the kernel.

- modules.blacklist works as a blacklist for the insmod_by_dep()
API. Every module in the dependency chain will be checked by this
file and any supplemental blacklist files porivided by the caller.
The whole dependency chain is checked before any modules are loaded.

- Implement wildcard matching for ueventd rules.
The PCI and USB addresses for devices can change from devices
from devices for a particular class of peripheral, for example,
bluetooth. The ueventd rules created with these addresses are
then device-specific.

This changes the way ueventd rules with wildcard are handled.
Instead of matching just the prefix with a trailing wildcard,
now these rules can have wildcard anywhere in the rule.
The wildcard matching is implemented using fnmatch(), where
its matching is simliar to shell pathname expansion. It suits
this particular usage model well.

For example, instead of creating a rule to match:

  /sys/devices/pci0000:00/0000:00:1d.0/usb2/2-1/2-1.3/2-1.3:1.0/bluetooth/hci0/rfkill*

, this would suffice:

  /sys/devices/*/bluetooth/hci0/rfkill*

- Let ueventd auto-load kernel modules. Implements the functionality
for ueventd to auto-load kernel modules when uevents are triggered.
Since /system may not be mounted when uevents are fired,
a deferred loading mechanism is implemented. Once mapping of
module and alias is available, these modules are then loaded.
Modules can also be blacklisted so they will not be loaded
automatically. One example would be the Wifi driver, as
Android's has to control its loading and unloading.

Some drivers may make a request to load some firmware. We take care
of driver and firmware loading in separate processes so that they
don't block each other.

- add 'probemod' builtin command. This command accepts the name of a
kernel module plus a set of command line arguments. The module will
be loaded, along with all its dependencies, using the libcutils
insmod_by_dep() API.

- Drivers in kernel can request modules by launching a program in
user space, the program's path by default is "/sbin/modprobe".
Because Android system has no modprobe and ueventd is the only
program handling the module aliases so far, This patch provides a
cheap approach to handle kernel's requests in ueventd executable.

- Add new builtin init command "coldboot". The main purpose is to
provide an approach in init.*.rc files to fire uevents for devices
under the path which is passed as the the argument. This should be
called after /system is mounted so any queued events that need to
load a module can be fired.

Bug: ADEV-107
Change-Id: Id0f35c56368c05f48fc4587e8731a3658cf52419
Category: Device Enablement
Domain: AOSP-init
Origin: Internal
Upstream-candidate: Yes
---
 include/cutils/module_parsers.h |   46 +++
 include/cutils/probe_module.h   |  106 +++++++
 init/Android.mk                 |   11 +
 init/builtins.c                 |   47 +++
 init/devices.c                  |  140 ++++++---
 init/devices.h                  |   23 ++-
 init/init.c                     |    6 +-
 init/init_parser.c              |    3 +
 init/keywords.h                 |    4 +
 init/ueventd.c                  |   87 ++++--
 libcutils/Android.mk            |    2 +
 libcutils/module_parsers.c      |  396 +++++++++++++++++++++++
 libcutils/probe_module.c        |  659 +++++++++++++++++++++++++++++++++++++++
 13 files changed, 1468 insertions(+), 62 deletions(-)
 create mode 100644 include/cutils/module_parsers.h
 create mode 100644 include/cutils/probe_module.h
 create mode 100644 libcutils/module_parsers.c
 create mode 100644 libcutils/probe_module.c

diff --git a/include/cutils/module_parsers.h b/include/cutils/module_parsers.h
new file mode 100644
index 0000000..c53d46a
--- /dev/null
+++ b/include/cutils/module_parsers.h
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/* parsers for module loading */
+
+#include <cutils/list.h>
+
+struct module_alias_node {
+    char *name;
+    char *pattern;
+    struct listnode list;
+};
+
+struct module_blacklist_node {
+    char *name;
+    struct listnode list;
+};
+
+int is_module_blacklisted(const char *name, struct listnode *black_list);
+int parse_alias_to_list(const char *file_name, struct listnode *head);
+int parse_blacklist_to_list(const char *file_name, struct listnode *head);
+void free_alias_list(struct listnode *head);
+void free_black_list(struct listnode *head);
+/* return a module's name from its alias.
+ * id             : alias string passed by caller
+ * module_aliases : list head of a list where the matched aliases will be put.
+ * alias_list     : list head of an alias map. The map is a list of struct module_alias_node.
+ * return         : 0 when no matching alias was found.
+ *                : the number of matching aliases when module name is found and name holds the valid
+ *                  content.
+ *                : -1 when it failed to allocate name string's memory, or the id is NULL.
+ */
+int get_module_name_from_alias(const char *id, struct listnode *module_aliases, struct listnode *alias_list);
diff --git a/include/cutils/probe_module.h b/include/cutils/probe_module.h
new file mode 100644
index 0000000..a739a3d
--- /dev/null
+++ b/include/cutils/probe_module.h
@@ -0,0 +1,106 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef _LIBS_CUTILS_PROBEMODULE_H
+#define _LIBS_CUTILS_PROBEMODULE_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define MOD_NO_ERR                  (0)         /* The operation is successful. */
+#define MOD_UNKNOWN                 (1 << 0)    /* unknown errors */
+#define MOD_IN_BLACK                (1 << 1)    /* A module is in base black list. */
+#define MOD_IN_CALLER_BLACK         (1 << 2)    /* A module is in caller's black list. */
+#define MOD_BAD_DEP                 (1 << 3)    /* Invalid module dependency file or it's parsing failed. */
+#define MOD_BAD_ALIAS               (1 << 4)    /* Invalid module alias file or it's parsing failed. */
+#define MOD_DEP_NOT_FOUND           (1 << 5)    /* Cannot find module's dependency chain */
+#define MOD_INVALID_CALLER_BLACK    (1 << 6)    /* Caller provides invalid black list or it's parsing failed. */
+#define MOD_INVALID_NAME            (1 << 7)    /* The module's name or alias is invalid */
+
+
+/* insmod_by_dep() - load a kernel module (target) with its dependency
+ * The module's dependency must be described in the provided dependency file.
+ * other modules in the dependency chain will be loaded prior to the target.
+ *
+ * module_name: Name of the target module. e.g. name "MyModule" is for
+ *              module file MyModule.ko.
+ *
+ * args       : A string of target module's parameters. NOTE: we only
+ *              support parameters of the target module.
+ *
+ * dep_name   : Name of dependency file. If it is NULL, we will look
+ *              up /system/lib/modules/modules.dep by default.
+ *
+ * strip      : Non-zero values remove paths of modules in dependency.
+ *              before loading them. The final path of a module will be
+ *              base/MyModule.ko. This is for devices which put every
+ *              modules into a single directory.
+ *
+ *              Passing 0 to strip keeps module paths in dependency file.
+ *              e.g. "kernel/drivers/.../MyModule.ko" in dep file will
+ *              be loaded as base/kernel/drivers/.../MyModule.ko .
+ *
+ * base       : Base dir, a prefix to be added to module's path prior to
+ *              loading. The last character prior to base string's terminator
+ *              must be a '/'. If it is NULL, we will take
+ *              /system/lib/modules/modules.dep by default.
+ *
+ * blacklist  : A file of modules you don't want to loaded. It is optional.
+ *              If a valid file is provided, modules in it will be parsed
+ *              and used along with the base module black list in insmod.c to
+ *              scan the dependency chain BEFORE any actual module loading.
+ *              The black list will always be applied in insmod_by_dep().
+ *              The typical format of a module in the black list file is shown
+ *              at below. Note, specify module's name instead of alias.
+ *
+ *              blacklist your_module_name
+ *
+ * return     : 0 (MOD_NO_ERR) for success;
+ *              >0 refer to defined error macros in this file.
+ *              <0 errors returned from lower levels.
+ * Note:
+ * When loading modules, function will not fail for any modules which are
+ * already in kernel. The module parameters passed to function will not be
+ * effective in this case if target module is already loaded into kernel.
+ */
+extern int insmod_by_dep(
+        const char *module_name,
+        const char *args,
+        const char *dep_name,
+        int strip,
+        const char *base,
+        const char *blacklist);
+
+/* rmmod_by_dep() - remove a module (target) from kernel with its dependency
+ * The module's dependency must be described in the provided dependency file.
+ * This function will try to remove other modules in the dependency chain too
+ *
+ * module_name: Name of the target module. e.g. name "MyModule" is for
+ *              module file MyModule.ko.
+ *
+ * dep_name   : Name of dependency file. If it is NULL, we will look
+ *              up /system/lib/modules/modules.dep by default.
+ *
+ * return     : 0 for success; non-zero for any errors.
+ */
+extern int rmmod_by_dep(const char *module_name, const char *dep_name);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /*_LIBS_CUTILS_PROBEMODULE_H*/
diff --git a/init/Android.mk b/init/Android.mk
index abfc68a..0847cb2 100644
--- a/init/Android.mk
+++ b/init/Android.mk
@@ -63,3 +63,14 @@ ALL_DEFAULT_INSTALLED_MODULES += $(SYMLINKS)
 # local module name
 ALL_MODULES.$(LOCAL_MODULE).INSTALLED := \
     $(ALL_MODULES.$(LOCAL_MODULE).INSTALLED) $(SYMLINKS)
+
+# make a link of modprobe to init
+SYMLINK_MODPROBE := $(TARGET_ROOT_OUT)/sbin/modprobe
+$(SYMLINK_MODPROBE): MODPROBE_BINARY := $(LOCAL_MODULE)
+$(SYMLINK_MODPROBE): $(LOCAL_INSTALLED_MODULE) $(LOCAL_PATH)/Android.mk
+	@echo "Symlink: $@ -> ../$(MODPROBE_BINARY)"
+	@mkdir -p $(dir $@)
+	@rm -rf $@
+	$(hide) ln -sf ../$(MODPROBE_BINARY) $@
+
+ALL_DEFAULT_INSTALLED_MODULES += $(SYMLINK_MODPROBE)
diff --git a/init/builtins.c b/init/builtins.c
index 97b181e..8f153d1 100644
--- a/init/builtins.c
+++ b/init/builtins.c
@@ -35,6 +35,9 @@
 #include <cutils/android_reboot.h>
 #include <sys/system_properties.h>
 #include <fs_mgr.h>
+#include <fnmatch.h>
+#include <dirent.h>
+#include <cutils/probe_module.h>
 
 #include <selinux/selinux.h>
 #include <selinux/label.h>
@@ -290,6 +293,40 @@ int do_insmod(int nargs, char **args)
     return do_insmod_inner(nargs, args, size);
 }
 
+static int do_probemod_inner(int nargs, char **args, int opt_len)
+{
+    char options[opt_len + 1];
+    int i;
+    int ret;
+
+    options[0] = '\0';
+    if (nargs > 2) {
+        strcpy(options, args[2]);
+        for (i = 3; i < nargs; ++i) {
+            strcat(options, " ");
+            strcat(options, args[i]);
+        }
+    }
+
+    ret = insmod_by_dep(args[1], options, NULL, 1, NULL, NULL);
+    if (ret)
+        ERROR("Couldn't probe module '%s'\n", args[1]);
+    return ret;
+}
+
+int do_probemod(int nargs, char **args)
+{
+    int i;
+    int size = 0;
+
+    if (nargs > 2) {
+        for (i = 2; i < nargs; ++i)
+            size += strlen(args[i]) + 1;
+    }
+
+    return do_probemod_inner(nargs, args, size);
+}
+
 int do_mkdir(int nargs, char **args)
 {
     mode_t mode = 0755;
@@ -555,6 +592,16 @@ int do_setkey(int nargs, char **args)
     return setkey(&kbe);
 }
 
+int do_builtin_coldboot(int nargs, char **args)
+{
+    if (nargs != 2 || !args[1] || *args[1] == '\0')
+        return -1;
+
+    coldboot(args[1]);
+
+    return 0;
+}
+
 int do_setprop(int nargs, char **args)
 {
     const char *name = args[1];
diff --git a/init/devices.c b/init/devices.c
index 1ab8153..1060dff 100644
--- a/init/devices.c
+++ b/init/devices.c
@@ -15,6 +15,7 @@
  */
 
 #include <errno.h>
+#include <fnmatch.h>
 #include <stddef.h>
 #include <stdio.h>
 #include <stdlib.h>
@@ -40,40 +41,32 @@
 #include <sys/wait.h>
 
 #include <cutils/list.h>
+#include <cutils/probe_module.h>
 #include <cutils/uevent.h>
+#include <cutils/module_parsers.h>
 
 #include "devices.h"
 #include "util.h"
 #include "log.h"
+#include "parser.h"
 
 #define SYSFS_PREFIX    "/sys"
 #define FIRMWARE_DIR1   "/etc/firmware"
 #define FIRMWARE_DIR2   "/vendor/firmware"
 #define FIRMWARE_DIR3   "/firmware/image"
+#define MODULES_BLKLST  "/system/etc/ueventd.modules.blacklist"
 
 extern struct selabel_handle *sehandle;
 
 static int device_fd = -1;
 
-struct uevent {
-    const char *action;
-    const char *path;
-    const char *subsystem;
-    const char *firmware;
-    const char *partition_name;
-    const char *device_name;
-    int partition_num;
-    int major;
-    int minor;
-};
-
 struct perms_ {
     char *name;
     char *attr;
     mode_t perm;
     unsigned int uid;
     unsigned int gid;
-    unsigned short prefix;
+    unsigned short wildcard;
 };
 
 struct perm_node {
@@ -91,10 +84,11 @@ struct platform_node {
 static list_declare(sys_perms);
 static list_declare(dev_perms);
 static list_declare(platform_names);
+static list_declare(deferred_module_loading_list);
 
 int add_dev_perms(const char *name, const char *attr,
                   mode_t perm, unsigned int uid, unsigned int gid,
-                  unsigned short prefix) {
+                  unsigned short wildcard) {
     struct perm_node *node = calloc(1, sizeof(*node));
     if (!node)
         return -ENOMEM;
@@ -112,7 +106,7 @@ int add_dev_perms(const char *name, const char *attr,
     node->dp.perm = perm;
     node->dp.uid = uid;
     node->dp.gid = gid;
-    node->dp.prefix = prefix;
+    node->dp.wildcard = wildcard;
 
     if (attr)
         list_add_tail(&sys_perms, &node->plist);
@@ -134,8 +128,8 @@ void fixup_sys_perms(const char *upath)
          */
     list_for_each(node, &sys_perms) {
         dp = &(node_to_item(node, struct perm_node, plist))->dp;
-        if (dp->prefix) {
-            if (strncmp(upath, dp->name + 4, strlen(dp->name + 4)))
+        if (dp->wildcard) {
+            if (fnmatch(dp->name + 4, upath, 0) != 0)
                 continue;
         } else {
             if (strcmp(upath, dp->name + 4))
@@ -174,8 +168,8 @@ static mode_t get_device_perm(const char *path, unsigned *uid, unsigned *gid)
         perm_node = node_to_item(node, struct perm_node, plist);
         dp = &perm_node->dp;
 
-        if (dp->prefix) {
-            if (strncmp(path, dp->name, strlen(dp->name)))
+        if (dp->wildcard) {
+            if (fnmatch(dp->name, path, 0) != 0)
                 continue;
         } else {
             if (strcmp(path, dp->name))
@@ -324,6 +318,7 @@ static void parse_event(const char *msg, struct uevent *uevent)
     uevent->partition_name = NULL;
     uevent->partition_num = -1;
     uevent->device_name = NULL;
+    uevent->modalias = NULL;
 
         /* currently ignoring SEQNUM */
     while(*msg) {
@@ -354,6 +349,9 @@ static void parse_event(const char *msg, struct uevent *uevent)
         } else if(!strncmp(msg, "DEVNAME=", 8)) {
             msg += 8;
             uevent->device_name = msg;
+        } else if(!strncmp(msg, "MODALIAS=", 9)) {
+            msg += 9;
+            uevent->modalias = msg;
         }
 
         /* advance to after the next \0 */
@@ -667,8 +665,72 @@ static void handle_generic_device_event(struct uevent *uevent)
              uevent->major, uevent->minor, links);
 }
 
-static void handle_device_event(struct uevent *uevent)
+static void handle_deferred_module_loading()
+{
+    struct listnode *node = NULL;
+    struct listnode *next = NULL;
+    struct module_alias_node *alias = NULL;
+    int ret = -1;
+
+    list_for_each_safe(node, next, &deferred_module_loading_list) {
+        alias = node_to_item(node, struct module_alias_node, list);
+
+        if (alias && alias->pattern) {
+            INFO("deferred loading of module for %s\n", alias->pattern);
+            ret = insmod_by_dep(alias->pattern, "", NULL, 1, NULL,
+                    MODULES_BLKLST);
+            /* if it looks like file system where these files are is not
+             * ready, keep the module in defer list for retry. */
+            if (!(ret & (MOD_BAD_DEP | MOD_INVALID_CALLER_BLACK | MOD_BAD_ALIAS))) {
+                free(alias->pattern);
+                list_remove(node);
+                free(alias);
+            }
+        }
+    }
+}
+
+int module_probe(const char *modalias)
+{
+    return insmod_by_dep(modalias, "", NULL, 1, NULL, NULL);    /* not to reuse ueventd's black list. */
+}
+
+static void handle_module_loading(const char *modalias)
+{
+    char *tmp;
+    struct module_alias_node *node;
+    int ret;
+
+
+    handle_deferred_module_loading();
+
+    if (!modalias) return;
+
+    ret = insmod_by_dep(modalias, "", NULL, 1, NULL, MODULES_BLKLST);
+
+    if (ret & (MOD_BAD_DEP | MOD_INVALID_CALLER_BLACK | MOD_BAD_ALIAS)) {
+        node = calloc(1, sizeof(*node));
+        if (node) {
+            node->pattern = strdup(modalias);
+            if (!node->pattern) {
+                free(node);
+            } else {
+                list_add_tail(&deferred_module_loading_list, &node->list);
+                INFO("add to queue for deferred module loading: %s",
+                        node->pattern);
+            }
+        } else {
+            ERROR("failed to allocate memory to store device id for deferred module loading.\n");
+        }
+    }
+}
+
+void handle_device_event(struct uevent *uevent)
 {
+    if (!strcmp(uevent->action,"add")) {
+        handle_module_loading(uevent->modalias);
+    }
+
     if (!strcmp(uevent->action,"add") || !strcmp(uevent->action, "change"))
         fixup_sys_perms(uevent->path);
 
@@ -817,7 +879,7 @@ root_free_out:
     free(root);
 }
 
-static void handle_firmware_event(struct uevent *uevent)
+void handle_firmware_event(struct uevent *uevent)
 {
     pid_t pid;
     int ret;
@@ -828,16 +890,11 @@ static void handle_firmware_event(struct uevent *uevent)
     if(strcmp(uevent->action, "add"))
         return;
 
-    /* we fork, to avoid making large memory allocations in init proper */
-    pid = fork();
-    if (!pid) {
-        process_firmware_event(uevent);
-        exit(EXIT_SUCCESS);
-    }
+    process_firmware_event(uevent);
 }
 
 #define UEVENT_MSG_LEN  1024
-void handle_device_fd()
+void handle_events_fd(void (*handle_event_fp)(struct uevent*))
 {
     char msg[UEVENT_MSG_LEN+2];
     int n;
@@ -851,8 +908,7 @@ void handle_device_fd()
         struct uevent uevent;
         parse_event(msg, &uevent);
 
-        handle_device_event(&uevent);
-        handle_firmware_event(&uevent);
+        handle_event_fp(&uevent);
     }
 }
 
@@ -876,7 +932,7 @@ static void do_coldboot(DIR *d)
     if(fd >= 0) {
         write(fd, "add\n", 4);
         close(fd);
-        handle_device_fd();
+        handle_events_fd(handle_device_event);
     }
 
     while((de = readdir(d))) {
@@ -899,7 +955,7 @@ static void do_coldboot(DIR *d)
     }
 }
 
-static void coldboot(const char *path)
+void coldboot(const char *path)
 {
     DIR *d = opendir(path);
     if(d) {
@@ -918,14 +974,7 @@ void device_init(void)
     if (is_selinux_enabled() > 0) {
         sehandle = selinux_android_file_context_handle();
     }
-
-    /* is 256K enough? udev uses 16MB! */
-    device_fd = uevent_open_socket(256*1024, true);
-    if(device_fd < 0)
-        return;
-
-    fcntl(device_fd, F_SETFD, FD_CLOEXEC);
-    fcntl(device_fd, F_SETFL, O_NONBLOCK);
+    uevent_fd_init();
 
     if (stat(coldboot_done, &info) < 0) {
         t0 = get_usecs();
@@ -941,6 +990,17 @@ void device_init(void)
     }
 }
 
+void uevent_fd_init(void)
+{
+   /* is 1MB enough? udev uses 16MB! */
+    device_fd = uevent_open_socket(1024*1024, true);
+    if(device_fd < 0)
+        return;
+
+    fcntl(device_fd, F_SETFD, FD_CLOEXEC);
+    fcntl(device_fd, F_SETFL, O_NONBLOCK);
+}
+
 int get_device_fd()
 {
     return device_fd;
diff --git a/init/devices.h b/init/devices.h
index a84fa58..1718109 100644
--- a/init/devices.h
+++ b/init/devices.h
@@ -19,10 +19,29 @@
 
 #include <sys/stat.h>
 
-extern void handle_device_fd();
+struct uevent {
+    const char *action;
+    const char *path;
+    const char *subsystem;
+    const char *firmware;
+    const char *partition_name;
+    const char *device_name;
+    const char *modalias;
+    const char *product;
+    int partition_num;
+    int major;
+    int minor;
+};
+
+extern void handle_events_fd(void (*handle_event_fp)(struct uevent*));
+extern void handle_device_event(struct uevent*);
+extern void handle_firmware_event(struct uevent*);
 extern void device_init(void);
+extern void uevent_fd_init(void);
+extern int module_probe(const char *alias);
 extern int add_dev_perms(const char *name, const char *attr,
                          mode_t perm, unsigned int uid,
-                         unsigned int gid, unsigned short prefix);
+                         unsigned int gid, unsigned short wildcard);
 int get_device_fd();
+void coldboot(const char *path);
 #endif	/* _INIT_DEVICES_H */
diff --git a/init/init.c b/init/init.c
index 2a611c6..7a8550e 100644
--- a/init/init.c
+++ b/init/init.c
@@ -1023,7 +1023,11 @@ int main(int argc, char **argv)
     int keychord_fd_init = 0;
     bool is_charger = false;
 
-    if (!strcmp(basename(argv[0]), "ueventd"))
+    /* If we are called as 'modprobe' command, we run as a
+     * standalone executable and reuse ueventd's logic to do the job.
+     */
+    if (!strcmp(basename(argv[0]), "ueventd")
+            || !strcmp(basename(argv[0]), "modprobe"))
         return ueventd_main(argc, argv);
 
     if (!strcmp(basename(argv[0]), "watchdogd"))
diff --git a/init/init_parser.c b/init/init_parser.c
index 0d0a5ee..8c01ae8 100644
--- a/init/init_parser.c
+++ b/init/init_parser.c
@@ -93,6 +93,7 @@ int lookup_keyword(const char *s)
         if (!strcmp(s, "onsole")) return K_console;
         if (!strcmp(s, "hown")) return K_chown;
         if (!strcmp(s, "hmod")) return K_chmod;
+        if (!strcmp(s, "oldboot")) return K_coldboot;
         if (!strcmp(s, "ritical")) return K_critical;
         break;
     case 'd':
@@ -134,6 +135,8 @@ int lookup_keyword(const char *s)
         break;
     case 'p':
         if (!strcmp(s, "owerctl")) return K_powerctl;
+        if (!strcmp(s, "robemod")) return K_probemod;
+        break;
     case 'r':
         if (!strcmp(s, "estart")) return K_restart;
         if (!strcmp(s, "estorecon")) return K_restorecon;
diff --git a/init/keywords.h b/init/keywords.h
index 5a44df3..efba30d 100644
--- a/init/keywords.h
+++ b/init/keywords.h
@@ -1,5 +1,6 @@
 
 #ifndef KEYWORD
+int do_builtin_coldboot(int nargs, char **args);
 int do_chroot(int nargs, char **args);
 int do_chdir(int nargs, char **args);
 int do_class_start(int nargs, char **args);
@@ -15,6 +16,7 @@ int do_mkdir(int nargs, char **args);
 int do_mount_all(int nargs, char **args);
 int do_mount(int nargs, char **args);
 int do_powerctl(int nargs, char **args);
+int do_probemod(int nargs, char **args);
 int do_restart(int nargs, char **args);
 int do_restorecon(int nargs, char **args);
 int do_rm(int nargs, char **args);
@@ -69,6 +71,7 @@ enum {
     KEYWORD(oneshot,     OPTION,  0, 0)
     KEYWORD(onrestart,   OPTION,  0, 0)
     KEYWORD(powerctl,    COMMAND, 1, do_powerctl)
+    KEYWORD(probemod,    COMMAND, 1, do_probemod)
     KEYWORD(restart,     COMMAND, 1, do_restart)
     KEYWORD(restorecon,  COMMAND, 1, do_restorecon)
     KEYWORD(rm,          COMMAND, 1, do_rm)
@@ -98,6 +101,7 @@ enum {
     KEYWORD(loglevel,    COMMAND, 1, do_loglevel)
     KEYWORD(load_persist_props,    COMMAND, 0, do_load_persist_props)
     KEYWORD(ioprio,      OPTION,  0, 0)
+    KEYWORD(coldboot,    COMMAND, 1, do_builtin_coldboot)
 #ifdef __MAKE_KEYWORD_ENUM__
     KEYWORD_COUNT,
 };
diff --git a/init/ueventd.c b/init/ueventd.c
index a41c31e..6f2574f 100644
--- a/init/ueventd.c
+++ b/init/ueventd.c
@@ -21,7 +21,8 @@
 #include <stdio.h>
 #include <ctype.h>
 #include <signal.h>
-
+#include <libgen.h>
+#include <errno.h>
 #include <private/android_filesystem_config.h>
 
 #include "ueventd.h"
@@ -47,11 +48,54 @@ static void import_kernel_nv(char *name, int in_qemu)
     }
 }
 
-int ueventd_main(int argc, char **argv)
+static void do_event_loop(void (*handle_event_fp)(struct uevent*)) __attribute__ ((noreturn));
+static void do_event_loop(void (*handle_event_fp)(struct uevent*))
 {
     struct pollfd ufd;
     int nr;
+
+    ufd.events = POLLIN;
+    ufd.fd = get_device_fd();
+
+    while(1) {
+        ufd.revents = 0;
+        nr = poll(&ufd, 1, -1);
+        if (nr <= 0)
+            continue;
+        if (ufd.revents == POLLIN)
+            handle_events_fd(handle_event_fp);
+    }
+}
+
+
+int ueventd_main(int argc, char **argv)
+{
     char tmp[32];
+    pid_t pid;
+
+    /* kernel will launch a program in user space to load
+     * modules, by default it is modprobe.
+     * Kernel doesn't send module parameters, so we don't
+     * need to support them.
+     * No deferred loading in this case.
+     */
+    if (!strcmp(basename(argv[0]), "modprobe")) {
+        if (argc >= 4
+                && argv[3] != NULL
+                && *argv[3] != '\0') {
+            uid_t uid;
+
+            /* We only accept requests from root user (kernel) */
+            uid = getuid();
+            if (uid)
+                return -EPERM;
+
+            return module_probe(argv[3]);
+        } else {
+            /* modprobe is called without enough arguments */
+            return -EINVAL;
+        }
+    }
 
     /*
      * init sets the umask to 077 for forked processes. We need to
@@ -84,18 +128,25 @@ int ueventd_main(int argc, char **argv)
     snprintf(tmp, sizeof(tmp), "/ueventd.%s.rc", hardware);
     ueventd_parse_config_file(tmp);
 
-    device_init();
-
-    ufd.events = POLLIN;
-    ufd.fd = get_device_fd();
+    pid = fork();
 
-    while(1) {
-        ufd.revents = 0;
-        nr = poll(&ufd, 1, -1);
-        if (nr <= 0)
-            continue;
-        if (ufd.revents == POLLIN)
-               handle_device_fd();
+    /* We fork here because we want to process the device drivers loading
+     * independently from the device firmware loading.
+     * If we do drivers and firmware events processing in the same process we
+     * will block the driver loading because ueventd cannot load it's corresponding
+     * firmware (requested by driver).
+     */
+    if (pid < 0) {
+        ERROR("Failed to fork in ueventd!\n");
+        return -1;
+    } else if (pid > 0) {
+        /* In parent we loop for device events for loading drivers */
+        device_init();
+        do_event_loop(handle_device_event);
+    } else {
+        /* In child we loop for device events for loading firmware */
+        uevent_fd_init();
+        do_event_loop(handle_firmware_event);
     }
 }
 
@@ -115,7 +166,7 @@ void set_device_permission(int nargs, char **args)
     mode_t perm;
     uid_t uid;
     gid_t gid;
-    int prefix = 0;
+    int wildcard = 0;
     char *endptr;
     int ret;
     char *tmp = 0;
@@ -147,10 +198,8 @@ void set_device_permission(int nargs, char **args)
             asprintf(&tmp, "/dev/mtd/mtd%d", n);
         name = tmp;
     } else {
-        int len = strlen(name);
-        if (name[len - 1] == '*') {
-            prefix = 1;
-            name[len - 1] = '\0';
+        if (strchr(name, '*')) {
+            wildcard = 1;
         }
     }
 
@@ -177,6 +226,6 @@ void set_device_permission(int nargs, char **args)
     }
     gid = ret;
 
-    add_dev_perms(name, attr, perm, uid, gid, prefix);
+    add_dev_perms(name, attr, perm, uid, gid, wildcard);
     free(tmp);
 }
diff --git a/libcutils/Android.mk b/libcutils/Android.mk
index 0fd5a57..994dccf 100644
--- a/libcutils/Android.mk
+++ b/libcutils/Android.mk
@@ -46,7 +46,9 @@ commonSources := \
 	threads.c \
 	sched_policy.c \
 	iosched_policy.c \
+	probe_module.c \
 	str_parms.c \
+	module_parsers.c \
 
 commonHostSources := \
         ashmem-host.c
diff --git a/libcutils/module_parsers.c b/libcutils/module_parsers.c
new file mode 100644
index 0000000..61d4307
--- /dev/null
+++ b/libcutils/module_parsers.c
@@ -0,0 +1,396 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/* parsers for module alias and blacklists */
+
+#define _GNU_SOURCE 1
+
+#include <stdio.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <string.h>
+#include <cutils/list.h>
+#include <stdlib.h>
+#include <fnmatch.h>
+
+#define LOG_TAG "ModuleParsers"
+#include <cutils/log.h>
+
+#include <cutils/misc.h>
+#include <cutils/module_parsers.h>
+
+
+#define READ_MODULES_ALIAS  1
+#define READ_MODULES_BLKLST 2
+
+/* These macros, parse_state and next_token are copied
+ * from parser in init with modifications.
+ */
+#define T_EOF 0
+#define T_TEXT 1
+#define T_NEWLINE 2
+
+struct parse_state
+{
+    char *ptr;
+    char *text;
+    int line;
+    int nexttoken;
+    void *context;
+    void (*parse_line)(struct parse_state *state, int nargs, char **args, struct listnode *head);
+    void *priv;
+};
+
+static int next_token(struct parse_state *state)
+{
+    char *x = state->ptr;
+    char *s;
+
+    if (state->nexttoken) {
+        int t = state->nexttoken;
+        state->nexttoken = 0;
+        return t;
+    }
+
+    for (;;) {
+        switch (*x) {
+        case 0:
+            state->ptr = x;
+            return T_EOF;
+        case '\n':
+            x++;
+            state->ptr = x;
+            return T_NEWLINE;
+        case ' ':
+        case '\t':
+        case '\r':
+            x++;
+            continue;
+        case '#':
+            while (*x && (*x != '\n')) x++;
+            if (*x == '\n') {
+                state->ptr = x+1;
+                return T_NEWLINE;
+            } else {
+                state->ptr = x;
+                return T_EOF;
+            }
+        default:
+            goto text;
+        }
+    }
+
+textdone:
+    state->ptr = x;
+    *s = 0;
+    return T_TEXT;
+text:
+    state->text = s = x;
+textresume:
+    for (;;) {
+        switch (*x) {
+        case 0:
+            goto textdone;
+        case ' ':
+        case '\t':
+        case '\r':
+            x++;
+            goto textdone;
+        case '\n':
+            state->nexttoken = T_NEWLINE;
+            x++;
+            goto textdone;
+        case '"':
+            x++;
+            for (;;) {
+                switch (*x) {
+                case 0:
+                        /* unterminated quoted thing */
+                    state->ptr = x;
+                    return T_EOF;
+                case '"':
+                    x++;
+                    goto textresume;
+                default:
+                    *s++ = *x++;
+                }
+            }
+            break;
+        case '\\':
+            x++;
+            switch (*x) {
+            case 0:
+                goto textdone;
+            case 'n':
+                *s++ = '\n';
+                break;
+            case 'r':
+                *s++ = '\r';
+                break;
+            case 't':
+                *s++ = '\t';
+                break;
+            case '\\':
+                *s++ = '\\';
+                break;
+            case '\r':
+                    /* \ <cr> <lf> -> line continuation */
+                if (x[1] != '\n') {
+                    x++;
+                    continue;
+                }
+            case '\n':
+                    /* \ <lf> -> line continuation */
+                state->line++;
+                x++;
+                    /* eat any extra whitespace */
+                while((*x == ' ') || (*x == '\t')) x++;
+                continue;
+            default:
+                    /* unknown escape -- just copy */
+                *s++ = *x++;
+            }
+            continue;
+        default:
+            *s++ = *x++;
+        }
+    }
+    return T_EOF;
+}
+
+void free_alias_list(struct listnode *head)
+{
+    struct listnode *node = NULL;
+    struct listnode *next = NULL;
+    struct module_alias_node *alias = NULL;
+
+    list_for_each_safe(node, next, head)
+    {
+        alias = node_to_item(node, struct module_alias_node, list);
+        if (alias) {
+            free(alias->pattern);
+            free(alias->name);
+            list_remove(node);
+            free(alias);
+        }
+    }
+}
+
+void free_black_list(struct listnode *head)
+{
+
+    struct listnode *node = NULL;
+    struct listnode *next = NULL;
+    struct module_blacklist_node *black = NULL;
+
+    list_for_each_safe(node, next, head)
+    {
+        black = node_to_item(node, struct module_blacklist_node, list);
+        if (black) {
+            free(black->name);
+            list_remove(node);
+            free(black);
+        }
+    }
+}
+
+int get_module_name_from_alias(const char *id, struct listnode *module_aliases, struct listnode *alias_list)
+{
+    struct listnode *alias_node;
+    struct module_alias_node *alias;
+    struct module_alias_node *node;
+    int num = 0;
+
+    if (!id)
+        return -1;
+
+    list_for_each(alias_node, alias_list)
+    {
+        alias = node_to_item(alias_node, struct module_alias_node, list);
+        if (alias && alias->name && alias->pattern) {
+            if (fnmatch(alias->pattern, id, 0) == 0) {
+                node = calloc(1, sizeof(*node));
+                if (!node) {
+                    num = -1;
+                    break;
+                }
+                node->name = strdup(alias->name);
+                if (!node->name) {
+                    free(node);
+                    num = -1;
+                    break;
+                }
+                list_add_tail(module_aliases, &node->list);
+                num++;
+            }
+        }
+    }
+
+    if (num < 0) {
+        /* In case of an error, free existing aliases in the list */
+        free_alias_list(module_aliases);
+    }
+
+    return num;
+}
+
+int is_module_blacklisted(const char *name, struct listnode *black_list_head)
+{
+    struct listnode *blklst_node;
+    struct module_blacklist_node *blacklist;
+    int ret = 0;
+
+    if (!name)
+        return ret;
+
+    /* See if module is blacklisted, skip if it is */
+    list_for_each(blklst_node, black_list_head) {
+        blacklist = node_to_item(blklst_node,
+                                 struct module_blacklist_node,
+                                 list);
+        if (!strcmp(name, blacklist->name)) {
+            ALOGI("modules %s is blacklisted\n", name);
+            ret = 1;
+
+            break;
+        }
+    }
+
+    return ret;
+}
+
+static void parse_line_module_blacklist(struct parse_state *state, int nargs, char **args, struct listnode *head)
+{
+    struct module_blacklist_node *node;
+
+    /* empty line or not enough arguments */
+    if (!args ||
+        (nargs != 2) ||
+            !args[0] || !args[1])
+        return;
+
+    /* this line does not begin with "blacklist" */
+    if (strncmp(args[0], "blacklist", 9))
+        return;
+
+    node = calloc(1, sizeof(*node));
+    if (!node)
+        return;
+
+    node->name = strdup(args[1]);
+    if (!node->name) {
+        free(node);
+        return;
+    }
+
+    list_add_tail(head, &node->list);
+}
+
+static void parse_line_module_alias(struct parse_state *state, int nargs, char **args, struct listnode *head)
+{
+    struct module_alias_node *node;
+
+    /* empty line or not enough arguments */
+    if (!args ||
+        (nargs != 3) ||
+            !args[0] || !args[1] || !args[2])
+        return;
+
+    node = calloc(1, sizeof(*node));
+    if (!node)
+        return;
+
+    node->name = strdup(args[2]);
+    if (!node->name) {
+        free(node);
+        return;
+    }
+
+    node->pattern = strdup(args[1]);
+    if (!node->pattern) {
+        free(node->name);
+        free(node);
+        return;
+    }
+
+    list_add_tail(head, &node->list);
+
+}
+
+int module_parser(const char *file_name, int mode, struct listnode *head)
+{
+    struct parse_state state;
+    char *args[3];
+    int nargs;
+    char *data = NULL;
+    int ret = -1;
+    int args_to_read = 0;
+
+    /* read the whole file */
+    data = load_file(file_name, 0);
+    if (!data)
+        goto out;
+
+    /* invoke tokenizer */
+    nargs = 0;
+    state.line = 1;
+    state.ptr = data;
+    state.nexttoken = 0;
+    if (mode == READ_MODULES_ALIAS) {
+        state.parse_line = parse_line_module_alias;
+        args_to_read = 3;
+    } else if (mode == READ_MODULES_BLKLST) {
+        state.parse_line = parse_line_module_blacklist;
+        args_to_read = 2;
+    }
+    for (;;) {
+        int token = next_token(&state);
+        switch (token) {
+        case T_EOF:
+            state.parse_line(&state, 0, 0, head);
+            ret = 0;
+            goto out;
+        case T_NEWLINE:
+            if (nargs) {
+                state.parse_line(&state, nargs, args, head);
+                nargs = 0;
+            }
+            break;
+        case T_TEXT:
+            if (nargs < args_to_read) {
+                args[nargs++] = state.text;
+            }
+            break;
+        }
+    }
+    ret = 0;
+
+out:
+
+    free(data);
+    return ret;
+}
+
+int parse_alias_to_list(const char *file_name, struct listnode *head)
+{
+    return module_parser(file_name, READ_MODULES_ALIAS, head);
+}
+
+int parse_blacklist_to_list(const char *file_name, struct listnode *head)
+{
+    return module_parser(file_name, READ_MODULES_BLKLST, head);
+}
diff --git a/libcutils/probe_module.c b/libcutils/probe_module.c
new file mode 100644
index 0000000..6953cf5
--- /dev/null
+++ b/libcutils/probe_module.c
@@ -0,0 +1,659 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define _GNU_SOURCE
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <cutils/misc.h>
+#include <cutils/list.h>
+#include <cutils/module_parsers.h>
+#include <cutils/probe_module.h>
+
+#define LOG_TAG "ProbeModule"
+#include <cutils/log.h>
+
+
+#define LDM_DEFAULT_DEP_FILE "/system/lib/modules/modules.dep"
+#define LDM_DEFAULT_MOD_PATH "/system/lib/modules/"
+#define LDM_INIT_DEP_NUM 10
+#define LDM_DEFAULT_LINE_SZ 1024
+
+extern int init_module(void *, unsigned long, const char *);
+extern int delete_module(const char *, unsigned int);
+
+static void dump_dep(char **dep)
+{
+    int d;
+
+    for (d = 0; dep[d]; d++)
+        ALOGD("DUMP DEP: %s\n", dep[d]);
+}
+
+static char * strip_path(const char * const str)
+{
+    char *ptr;
+    int i;
+
+    /* initialize pos to terminator */
+    for (i = strlen(str); i > 0; i--)
+        if (str[i - 1] == '/')
+            break;
+
+    return (char *)&str[i];
+}
+
+static void hyphen_to_underscore(char *str)
+{
+    while (str && *str != '\0') {
+        if (*str == '-')
+            *str = '_';
+        str++;
+    }
+}
+
+/* Compare module names, but don't differentiate '_' and '-'.
+ * return: 0 when s1 is matched to s2 or size is zero.
+ *         non-zero in any other cases.
+ */
+static int match_name(const char *s1, const char *s2, const size_t size)
+{
+    size_t i;
+
+    if (!size)
+        return 0;
+
+    for (i = 0; i < size; i++, s1++, s2++) {
+
+        if ((*s1 == '_' || *s1 == '-') && (*s2 == '_' || *s2 == '-'))
+            continue;
+
+        if (*s1 != *s2)
+            return -1;
+
+        if (*s1 == '\0')
+            return 0;
+    }
+
+    return 0;
+}
+
+/* check if a line in dep file is target module's dependency.
+ * return 1 when it is, otherwise 0 in any other cases.
+ */
+static int is_target_module(char *line, const char *target)
+{
+    char *token;
+    char *name;
+    size_t name_len;
+    const char *suffix = ".ko";
+    const char *delimiter = ":";
+    int ret = 0;
+
+    /* search token */
+    token = strstr(line, delimiter);
+
+    if (!token) {
+        ALOGE("invalid line: no token\n");
+        return 0;
+    }
+
+    /* only take stuff before the token */
+    *token = '\0';
+
+    /* use "module.ko" in comparision */
+    name_len = strlen(suffix) + strlen(target) + 1;
+
+    name = malloc(sizeof(char) * name_len);
+
+    if (!name) {
+        ALOGE("cannot alloc ram for comparision\n");
+        return 0;
+    }
+
+    snprintf(name, name_len, "%s%s", target, suffix);
+
+    ret = !match_name(strip_path(line), name, name_len);
+
+    /* restore [single] token, keep line unchanged until we parse it later */
+    *token = *delimiter;
+
+    free(name);
+
+    return ret;
+
+}
+
+/* turn a single string into an array of dependency.
+ *
+ * return: dependency array's address if it succeeded. Caller
+ *         is responsible to free the array's memory and also
+ *         the array items' memory.
+ *         NULL when any error happens.
+ */
+static char** setup_dep(char *line)
+{
+    char *token;
+    unsigned int token_size = 0;
+    char *start;
+    char *end;
+    int dep_num = LDM_INIT_DEP_NUM;
+    char **new;
+    int i;
+    char **dep = NULL;
+
+    dep = malloc(sizeof(char *) * dep_num);
+
+    if (!dep) {
+        ALOGE("cannot alloc dep array\n");
+        return dep;
+    }
+    start = line;
+
+    /* All the modules are separated by space, except for the first
+     * module which also has a ':'. A normal line should look like:
+     * dependant_module.ko: dependency1.ko dependency2.ko
+     */
+    for (i = 0; (end = strchr(start, ' ')) != NULL; i++) {
+        token_size = (end - start);
+        if (token_size == 0)
+            break;
+        /* check if we need enlarge dep array */
+        if (!(i < dep_num - 1)) {
+            dep_num += LDM_INIT_DEP_NUM;
+            new = realloc(dep, dep_num);
+            if (!new) {
+                ALOGE("failed to enlarge dep buffer\n");
+                free(dep);
+                return NULL;
+            }
+            else
+                dep = new;
+        }
+        token = (char*) malloc(sizeof(char) * (token_size + 1));
+        if (!token) {
+            ALOGE("failed to alloc dep token\n");
+            free(dep);
+            return NULL;
+        }
+        strncpy(token, start, token_size);
+        start += (token_size + 1);
+        /* If the token ends with ':', this is the module depending on the others
+         * We will insert it also, but remove the ':', first
+         */
+        if (i == 0 && token[token_size - 1] == ':')
+            token_size -= 1;
+        token[token_size] = '\0';
+
+        dep[i] = token;
+
+    }
+    /* terminate array with a null pointer */
+    dep[i] = NULL;
+
+    return dep;
+}
+
+static int insmod(const char *path_name, const char *args)
+{
+    void *data;
+    unsigned int len;
+    int ret;
+
+    data = load_file(path_name, &len);
+
+    if (!data) {
+        ALOGE("%s: Failed to load module file [%s]\n", __FUNCTION__, path_name);
+        return -1;
+    }
+
+    ret = init_module(data, len, args);
+
+    if (ret != 0 && errno != EEXIST) {
+        ALOGE("%s: Failed to insmod [%s] with args [%s] error: %s ret: %d\n",
+                __FUNCTION__, path_name, args, strerror(errno), ret);
+        ret = -1;
+    }
+    else
+        ret = 0;    /* if module is already in kernel, return success. */
+
+    free(data);
+
+    return ret;
+}
+
+/* install all modules in the dependency chain
+ * deps    : A array of module file names, must be terminated by a NULL pointer
+ * args    : The module parameters for target module.
+ * strip   : Non-zero to strip out path info in the file name;
+ *           0 to keep path info when loading modules.
+ * base    : a prefix to module path, it will NOT be affected by strip flag.
+ * return  : 0 for success or nothing to do; non-zero when any error occurs.
+ */
+static int insmod_s(char *dep[], const char *args, int strip, const char *base)
+{
+    char *name;
+    char *path_name;
+    int cnt;
+    size_t len;
+    int ret = 0;
+    const char * base_dir = LDM_DEFAULT_MOD_PATH;
+
+    if (base && strlen(base))
+        base_dir = base;
+
+    /* load modules in reversed order */
+    for (cnt = 0; dep[cnt]; cnt++)
+        ;
+
+    while (cnt--) {
+
+        name = strip ? strip_path(dep[cnt]) : dep[cnt];
+
+        len = strlen(base_dir) + strlen(name) + 1;
+
+        path_name = malloc(sizeof(char) * len);
+
+        if (!path_name) {
+            ALOGE("alloc module [%s] path failed\n", path_name);
+            return -1;
+        }
+
+        snprintf(path_name, len, "%s%s", base_dir, name);
+
+        if (cnt)
+            ret = insmod(path_name, "");
+        else
+            ret = insmod(path_name, args);
+
+        free(path_name);
+
+        if (ret)
+            break;
+    }
+
+    return ret;
+}
+
+static int rmmod(const char *mod_name, unsigned int flags)
+{
+    return delete_module(mod_name, flags);
+}
+
+/* remove all modules in a dependency chain
+ * NOTE: We assume module name in kernel is same as the file name without .ko
+ */
+static int rmmod_s(char *dep[], unsigned int flags)
+{
+    int i;
+    int ret = 0;
+    char * mod_name;
+
+    for (i = 0; dep[i]; i++) {
+        size_t len;
+        mod_name = strip_path(dep[i]);
+        len = strlen(mod_name);
+
+        if (len > strlen(".ko")
+                && mod_name[len - 1] == 'o'
+                        && mod_name[len - 2] == 'k'
+                                && mod_name[len - 3] == '.') {
+
+            mod_name[len - 3] = '\0';
+
+            hyphen_to_underscore(mod_name);
+
+            ret = rmmod(mod_name, flags);
+
+            if (ret) {
+                ALOGE("%s: Failed to remove module [%s] error (%s)\n",
+                        __FUNCTION__, mod_name, strerror(errno));
+                break;
+
+            }
+        }
+    }
+
+    return ret;
+}
+
+/* look_up_dep() find and setup target module's dependency in modules.dep
+ *
+ * dep_file:    a pointer to module's dep file loaded in memory, its content
+ *              won't be changed, so it can be reused after parsing.
+ *
+ * return:      a pointer to an array which holds the dependency strings and
+ *              terminated by a NULL pointer. Caller is responsible to free the
+ *              array's memory and also the array items' memory.
+ *
+ *              non-zero in any other cases. Content of dep array is invalid.
+ */
+static char ** look_up_dep(const char *module_name, void *dep_file)
+{
+    char *line;
+    char *new_line;
+    unsigned int line_size = 0;
+    char *start;
+    char *end;
+    char **dep = NULL;
+
+    if (!dep_file || !module_name || *module_name == '\0')
+        return NULL;
+
+    start = (char *)dep_file;
+    line = (char *)malloc(sizeof(char) * LDM_DEFAULT_LINE_SZ);
+    if (!line) {
+        ALOGE("failed to alloc dep line buffer\n");
+        return NULL;
+    }
+
+    /* We expect modules.dep file has a new line char before EOF. */
+    while ((end = strchr(start, '\n')) != NULL) {
+        line_size = (end - start);
+        /* line_size + 1, because we will add a space at the end of line */
+        if (line_size + 1 >= LDM_DEFAULT_LINE_SZ) {
+            new_line = realloc(line, LDM_DEFAULT_LINE_SZ * 2);
+            if (!new_line) {
+                ALOGE("failed to enlarge dep line buffer\n");
+                free(line);
+                return NULL;
+            } else {
+                line = new_line;
+            }
+        }
+        strncpy(line, start, line_size);
+        /* Add a space to identify last token */
+        line[line_size] = ' ';
+        line[line_size  + 1] = '\0';
+        start += (line_size + 1);
+
+        if (is_target_module(line, module_name)) {
+
+            dep = setup_dep(line);
+            /* job done */
+            break;
+        }
+    }
+
+    free(line);
+
+    return dep;
+}
+
+/* load_dep_file() load a dep file (usually it is modules.dep)
+ * into memory. Caller is responsible to free the memory.
+ *
+ * file_name:   dep file's name, if it is NULL or an empty string,
+ *              This function will try to load a dep file in the
+ *              default path defined in LDM_DEFAULT_DEP_FILE
+ *
+ * return:      a pointer to the allocated mem which holds all
+ *              content of the depfile. a zero pointer will be
+ *              returned for any errors.
+ * */
+static void *load_dep_file(const char *file_name)
+{
+    const char *dep_file_name = LDM_DEFAULT_DEP_FILE;
+    unsigned int len;
+
+    if (file_name && *file_name != '\0')
+        dep_file_name = file_name;
+
+    return load_file(dep_file_name, &len);
+}
+
+/* is_dep_in_blacklist() checks if any module in dependency
+ * is in a blacklilst
+ * dep:         dependency array
+ * blacklist :  head of a black list.
+ * return:      1 if any module in dep is in black list.
+ *              -1 when any error happens
+ *              0 none of modules in dep is in black list.
+ * */
+static int is_dep_in_blacklist(char *dep[], struct listnode *blacklist)
+{
+    int i;
+    char *tmp;
+    int ret = 0;
+    size_t len;
+
+    for (i = 0; dep[i]; i++) {
+        tmp = dep[i];
+        len = strlen(tmp);
+
+        if (!(len > strlen(".ko")
+                && tmp[len - 1] == 'o'
+                        && tmp[len - 2] == 'k'
+                                && tmp[len - 3] == '.')) {
+            ret = -1;
+
+            break;
+        }
+
+        if (asprintf(&tmp, "%s", dep[i]) <= 0) {
+            ret = -1;
+
+            break;
+        }
+
+        tmp[len - 3] = '\0';
+        if (is_module_blacklisted(strip_path(tmp), blacklist)) {
+            ALOGE("found module [%s] is in black list\n", tmp);
+            free(tmp);
+            ret = 1;
+
+            break;
+        }
+        free(tmp);
+    }
+
+    return ret;
+}
+static void dump_black_list(struct listnode *black_list_head)
+{
+    struct listnode *blklst_node;
+    struct module_blacklist_node *blacklist;
+
+    list_for_each(blklst_node, black_list_head) {
+        blacklist = node_to_item(blklst_node,
+                                 struct module_blacklist_node,
+                                 list);
+
+            ALOGE("DUMP BLACK: [%s]\n", blacklist->name);
+    }
+}
+/* insmod_by_dep() interface to outside,
+ * refer to its description in probe_module.h
+ */
+int insmod_by_dep(const char *module_name,
+        const char *args,
+        const char *dep_name,
+        int strip,
+        const char *base,
+        const char *blacklist)
+{
+    void *dep_file = NULL;
+    char **dep = NULL;
+    int ret = MOD_UNKNOWN;
+    int i = 0;
+    struct listnode *alias_node;
+    struct module_alias_node *alias;
+    list_declare(base_blacklist);
+    list_declare(extra_blacklist);
+    list_declare(alias_list);
+    list_declare(module_aliases);
+
+    if (!module_name || *module_name == '\0') {
+        ALOGE("need valid module name\n");
+
+        return MOD_INVALID_NAME;
+    }
+
+    ret = parse_alias_to_list("/system/lib/modules/modules.alias", &alias_list);
+
+    if (ret) {
+        ALOGE("%s: parse alias error %d\n", __FUNCTION__, ret);
+        ret = MOD_BAD_ALIAS;
+
+        goto free_file;
+    }
+
+    /* We allow no base blacklist. */
+    /* TODO: tell different cases between no caller black list and parsing failures. */
+    ret = parse_blacklist_to_list("/system/etc/modules.blacklist", &base_blacklist);
+
+    if (ret)
+        ALOGI("%s: parse base black list error %d\n", __FUNCTION__, ret);
+
+    if (blacklist && *blacklist != '\0') {
+        ret = parse_blacklist_to_list(blacklist, &extra_blacklist);
+        if (ret) {
+            ALOGI("%s: parse extra black list error %d\n", __FUNCTION__, ret);
+
+            /* A black list from caller is optional, but when caller does
+             * give us a file and something's wrong with it, we will stop going further*/
+            ret = MOD_INVALID_CALLER_BLACK;
+
+            goto free_file;
+        }
+    }
+    dep_file = load_dep_file(dep_name);
+
+    if (!dep_file) {
+        ALOGE("cannot load dep file : %s\n", dep_name);
+        ret = MOD_BAD_DEP;
+
+        goto free_file;
+    }
+
+    /* check if module name is an alias. */
+    if (get_module_name_from_alias(module_name, &module_aliases, &alias_list) <= 0) {
+        /* If no alias found, put a single node in list containing module_name, so it will
+         * be processed in the loop below. This is done for simplifying the code. */
+        alias = calloc(1, sizeof(*alias));
+        if (!alias) {
+            ret = MOD_BAD_ALIAS;
+            goto free_file;
+        }
+        alias->name = strdup(module_name);
+        if (!alias->name) {
+            free(alias);
+            ret = MOD_BAD_ALIAS;
+            goto free_file;
+        }
+        list_add_tail(&module_aliases, &alias->list);
+    }
+
+    list_for_each(alias_node, &module_aliases) {
+        alias = node_to_item(alias_node, struct module_alias_node, list);
+        /* Before looking for deps, check if we have previous deps, because we need to free them */
+        if (dep) {
+            for (i = 0; dep[i]; i++) {
+                free(dep[i]);
+            }
+            free(dep);
+            dep = NULL;
+        }
+        dep = look_up_dep(alias->name, dep_file);
+
+        if (!dep) {
+            ALOGE("%s: cannot find module's dependency info: [%s]\n", __FUNCTION__, alias->name);
+            ret = MOD_DEP_NOT_FOUND;
+            continue;
+        }
+
+        if (is_dep_in_blacklist(dep, &extra_blacklist)) {
+            ALOGE("%s: a module is in caller's black list, stop further loading\n", __FUNCTION__);
+            ret = MOD_IN_CALLER_BLACK;
+            continue;
+        }
+
+        if (is_dep_in_blacklist(dep, &base_blacklist)) {
+            ALOGE("%s: a module is in system black list, stop further loading\n", __FUNCTION__);
+            ret = MOD_IN_BLACK;
+            continue;
+        }
+
+        if (ret) /* if we reach here for a dep, update ret to the latest result */
+            ret = insmod_s(dep, args, strip, base);
+        else /* we have had a successfull loading, ignore further errors */
+            insmod_s(dep, args, strip, base);
+    }
+
+free_file:
+    if (dep) {
+        for (i = 0; dep[i]; i++) {
+            free(dep[i]);
+        }
+        free(dep);
+    }
+    free(dep_file);
+    free_alias_list(&alias_list);
+    free_alias_list(&module_aliases);
+    free_black_list(&base_blacklist);
+    free_black_list(&extra_blacklist);
+
+    return ret;
+}
+
+/* rmmod_by_dep() interface to outside,
+ * refer to its description in probe_module.h
+ */
+int rmmod_by_dep(const char *module_name,
+        const char *dep_name)
+{
+    void *dep_file;
+    char **dep = NULL;
+    int ret = MOD_UNKNOWN;
+
+    if (!module_name || *module_name == '\0') {
+        ALOGE("need valid module name\n");
+        ret = MOD_INVALID_NAME;
+
+        return ret;
+    }
+
+    dep_file = load_dep_file(dep_name);
+
+    if (!dep_file) {
+        ALOGE("cannot load dep file : %s\n", dep_name);
+        ret = MOD_BAD_DEP;
+
+        return ret;
+    }
+
+    dep = look_up_dep(module_name, dep_file);
+
+    if (!dep) {
+        ALOGE("%s: cannot remove module: [%s]\n", __FUNCTION__, module_name);
+        ret = MOD_DEP_NOT_FOUND;
+
+        goto free_file;
+    }
+
+    ret = rmmod_s(dep, O_NONBLOCK);
+
+    free(dep);
+
+free_file:
+    free(dep_file);
+
+    return ret;
+}
+
+/* end of file */
-- 
1.7.4.1

