From b0f120e30312aa29021f5197dc6f563366eb560d Mon Sep 17 00:00:00 2001
From: Jean Christophe Beyler <jean.christophe.beyler@intel.com>
Date: Fri, 2 Aug 2013 10:31:08 -0700
Subject: Dalvik: LoopOpt Should be Renamed to PassDriver

BZ: 128188

The LoopOpt API should be renamed to PassDriver to really reflect its
dual use for loops and traces (and probably future Methods).

Category: device-enablement
Domain: AOSP-Dalvik-Compiler-CG; AOSP-Dalvik-Compiler-ME; AOSP-Dalvik-Runtime
Origin: internal
Upstream-Candidate: no, needs rework

Change-Id: I9cc1ff0e694517afb7a6a76bd1f69f5aea97e66b
Orig-MCG-Change-Id: Ibca5b78dc0191d5b9279031788e1f53bd72cd9b6
Signed-off-by: Jean Christophe Beyler <jean.christophe.beyler@intel.com>
Reviewed-on: http://android.intel.com:8080/123166
Reviewed-by: Dower, Robert <robert.dower@intel.com>
Tested-by: Dower, Robert <robert.dower@intel.com>
Signed-off-by: Serguei Katkov <serguei.i.katkov@intel.com>
---
 vm/Dvm.mk                                    |    2 +-
 vm/Init.cpp                                  |    2 +-
 vm/compiler/AccumulationSinking.cpp          |    2 +-
 vm/compiler/BBOptimization.cpp               |    2 +-
 vm/compiler/Checks.cpp                       |    2 +-
 vm/compiler/Frontend.cpp                     |    1 -
 vm/compiler/InvariantRemoval.cpp             |    8 +-
 vm/compiler/Loop.cpp                         |   11 +-
 vm/compiler/LoopOpt.cpp                      |  783 --------------------------
 vm/compiler/LoopOpt.h                        |  165 ------
 vm/compiler/PassDriver.cpp                   |  783 ++++++++++++++++++++++++++
 vm/compiler/PassDriver.h                     |  166 ++++++
 vm/compiler/RegisterizationME.cpp            |    2 +-
 vm/compiler/SinkCastOpt.cpp                  |    4 +-
 vm/compiler/Vectorization.cpp                |    2 +-
 vm/compiler/codegen/x86/pcg/PcgInterface.cpp |    2 +-
 vm/compiler/codegen/x86/pcg/UtilityPCG.cpp   |    2 +-
 17 files changed, 968 insertions(+), 971 deletions(-)
 delete mode 100644 vm/compiler/LoopOpt.cpp
 delete mode 100644 vm/compiler/LoopOpt.h
 create mode 100644 vm/compiler/PassDriver.cpp
 create mode 100644 vm/compiler/PassDriver.h

diff --git a/vm/Dvm.mk b/vm/Dvm.mk
index ddd536b..0dcd3fd 100644
--- a/vm/Dvm.mk
+++ b/vm/Dvm.mk
@@ -374,7 +374,7 @@ ifeq ($(dvm_arch),x86)
               compiler/codegen/$(dvm_arch_variant)/lightcg/CompileTable.cpp \
               compiler/codegen/$(dvm_arch_variant)/lightcg/Profile.cpp \
               compiler/codegen/$(dvm_arch_variant)/x86Specific.cpp \
-              compiler/LoopOpt.cpp \
+              compiler/PassDriver.cpp \
               compiler/Checks.cpp \
               compiler/LoopRegisterUsage.cpp \
               compiler/InvariantRemoval.cpp \
diff --git a/vm/Init.cpp b/vm/Init.cpp
index 1ded570..a424f7e 100644
--- a/vm/Init.cpp
+++ b/vm/Init.cpp
@@ -48,7 +48,7 @@
 #include "compiler/codegen/x86/lightcg/Lower.h"
 #include "compiler/codegen/x86/x86Specific.h"
 #include "compiler/CompilerUtility.h"
-#include "compiler/LoopOpt.h"
+#include "compiler/PassDriver.h"
 #endif
 
 #if defined(WITH_JIT)
diff --git a/vm/compiler/AccumulationSinking.cpp b/vm/compiler/AccumulationSinking.cpp
index 1a23cf5..61286a8 100644
--- a/vm/compiler/AccumulationSinking.cpp
+++ b/vm/compiler/AccumulationSinking.cpp
@@ -20,7 +20,7 @@
 #include "Dataflow.h"
 #include "Expression.h"
 #include "LoopInformation.h"
-#include "LoopOpt.h"
+#include "PassDriver.h"
 
 #include <algorithm>
 
diff --git a/vm/compiler/BBOptimization.cpp b/vm/compiler/BBOptimization.cpp
index f4d9dc1..b15f3cc 100644
--- a/vm/compiler/BBOptimization.cpp
+++ b/vm/compiler/BBOptimization.cpp
@@ -19,7 +19,7 @@
 #include "Dataflow.h"
 #include "Loop.h"
 #include "LoopInformation.h"
-#include "LoopOpt.h"
+#include "PassDriver.h"
 #include "Utility.h"
 
 /**
diff --git a/vm/compiler/Checks.cpp b/vm/compiler/Checks.cpp
index 4e9df66..2a1c2bb 100644
--- a/vm/compiler/Checks.cpp
+++ b/vm/compiler/Checks.cpp
@@ -18,7 +18,7 @@
 #include "Dalvik.h"
 #include "Dataflow.h"
 #include "Loop.h"
-#include "LoopOpt.h"
+#include "PassDriver.h"
 #include "Pass.h"
 #include "LoopInformation.h"
 
diff --git a/vm/compiler/Frontend.cpp b/vm/compiler/Frontend.cpp
index 63880bf..d8820c6 100644
--- a/vm/compiler/Frontend.cpp
+++ b/vm/compiler/Frontend.cpp
@@ -21,7 +21,6 @@
 #include "CompilerInternals.h"
 #include "Dataflow.h"
 #include "Loop.h"
-#include "LoopOpt.h"
 #include "LoopInformation.h"
 #include "RegisterizationME.h"
 #include "Utility.h"
diff --git a/vm/compiler/InvariantRemoval.cpp b/vm/compiler/InvariantRemoval.cpp
index 14a4e0b..11dc4b36 100644
--- a/vm/compiler/InvariantRemoval.cpp
+++ b/vm/compiler/InvariantRemoval.cpp
@@ -15,18 +15,18 @@
  */
 
 #include "BBOptimization.h"
+#include "Checks.h"
 #include "CompilerIR.h"
 #include "Dalvik.h"
 #include "Dataflow.h"
 #include "InvariantRemoval.h"
 #include "LoopInformation.h"
 #include "Pass.h"
-#include "BBOptimization.h"
-#include "LoopOpt.h"
-#include "Checks.h"
+#include "PassDriver.h"
+#include "Utility.h"
+
 #include <set>
 #include <vector>
-#include "Utility.h"
 
 /**
  * @brief Are the uses of the MIR instruction all defined in the chosen map
diff --git a/vm/compiler/Loop.cpp b/vm/compiler/Loop.cpp
index 5c8582c..7f5bbd1 100644
--- a/vm/compiler/Loop.cpp
+++ b/vm/compiler/Loop.cpp
@@ -20,7 +20,7 @@
 #include "Loop.h"
 
 #ifdef ARCH_IA32
-#include "LoopOpt.h"
+#include "PassDriver.h"
 #endif
 
 
@@ -1695,15 +1695,12 @@ bool dvmCompilerFilterLoopBlocks(CompilationUnit *cUnit)
 
 #ifdef ARCH_IA32
 /*
- * Main entry point to do loop optimization.
- * Return false if sanity checks for loop formation/optimization failed.
+ * Main entry point to do loop, trace, method optimizations
+ * Name is remaining the same as ARM for the moment...
  */
 bool dvmCompilerLoopOpt(CompilationUnit *cUnit)
 {
-    //Create the loop analysis
-
-    //Call the loop optimizer driver
-    dvmCompilerLoopOptimizationDriver (cUnit);
+    dvmCompilerLaunchPassDriver (cUnit);
 
     return true;
 }
diff --git a/vm/compiler/LoopOpt.cpp b/vm/compiler/LoopOpt.cpp
deleted file mode 100644
index e7ec54b..0000000
--- a/vm/compiler/LoopOpt.cpp
+++ /dev/null
@@ -1,783 +0,0 @@
-/*
-* Copyright (C) 2012 Intel Corporation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-*      http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
-
-#include <dlfcn.h>
-
-#include "AccumulationSinking.h"
-#include "BBOptimization.h"
-#include "Checks.h"
-#include "Dalvik.h"
-#include "Dataflow.h"
-#include "InvariantRemoval.h"
-#include "Loop.h"
-#include "LoopOpt.h"
-#include "SinkCastOpt.h"
-#include "LoopRegisterUsage.h"
-#include "Pass.h"
-#include "RegisterizationME.h"
-#include "Vectorization.h"
-#include "Utility.h"
-
-/**
- * @brief Static functions defined below
- */
-static void handlePassFlag (CompilationUnit *cUnit, Pass *pass);
-static bool checkLoopsGate (const CompilationUnit *cUnit, Pass *pass);
-
-/**
- * @brief Three macros to help pass definitions
- */
-#define START_PASSES \
-    static Pass gPasses[] = {
-
-#define NEW_PASS(NAME,TYPE,DATA,GATE,START,END,WORK,FREE,FLAG) \
-        Pass ( \
-            NAME, TYPE, DATA, GATE, START, END, WORK, FREE, FLAG \
-        )
-
-#define END_PASSES \
-    };
-
-START_PASSES
-    //Check if the loops are like we want right now (nested or not, branches or not)
-    NEW_PASS ("Reject_Loops", kAllNodes, 0, checkLoopsGate, 0, 0, 0, 0, 0),
-    //This loop formation is used when the new loop filtering is active
-    NEW_PASS ("Form_Loop", kAllNodes, 0, dvmCompilerTraceIsLoopNewSystem,
-                dvmCompilerFormLoop, 0, 0, 0, kOptimizationBasicBlockChange | kLoopStructureChange),
-    NEW_PASS ("Test_Loop", kAllNodes, 0, dvmCompilerTraceIsLoopNewSystem,
-                dvmCompilerTestLoop, 0, 0, 0, 0),
-    //This loop formation is used when the old loop filtering is active
-    NEW_PASS ("Old_Loop_Formation", kAllNodesAndNew, 0, dvmCompilerTraceIsLoopOldSystem,
-                dvmCompilerFormOldLoop, 0, 0, 0, kOptimizationBasicBlockChange | kLoopStructureChange),
-    //Now check that bytecodes reference fully resolved classes, methods, and fields.
-    //We only do this check for loops because we can bring in parts that are not so hot.
-    NEW_PASS ("Check_References", kAllNodes, 0, dvmCompilerTraceIsLoopNewSystem,
-            0, 0, dvmCompilerCheckReferences, 0, 0),
-    //At this point, we finish with the loops, so to increase optimization scope we start inlining
-    NEW_PASS ("Method_Inlining", kAllNodesAndNew, 0, 0,
-                0, 0, dvmCompilerMethodInlining, 0, kOptimizationBasicBlockChange | kLoopStructureChange),
-    NEW_PASS ("Check_Removal", kPredecessorsFirstTraversal, 0, 0,
-                dvmCompilerStartCheckRemoval, dvmCompilerEndCheckRemoval, dvmCompilerCheckRemoval, 0, kOptimizationDefUsesChange),
-    //The 2addr pass should come before any pass that need register rewriting.
-    NEW_PASS ("Convert_2addr_to_normal", kAllNodes, 0, 0,
-                0, 0, dvmCompilerConvert2addr, 0, kOptimizationBasicBlockChange),
-    //Memory Aliasing only works on one basic block so let's try to merge first
-    //For the moment, no pass will create new blocks, etc. so this is fine up here
-    //Otherwise, we might want to duplicate the merge or make the gate for memory aliasing smarter
-    NEW_PASS ("Remove_Gotos", kAllNodes, 0, 0, 0, NULL, dvmCompilerRemoveGoto, 0, kOptimizationBasicBlockChange),
-    NEW_PASS ("Merge_Blocks", kAllNodes, 0, 0,
-                0, 0, dvmCompilerMergeBasicBlocks, 0,
-                kOptimizationBasicBlockChange | kLoopStructureChange | kOptimizationNeedIterative),
-    NEW_PASS ("Memory_Aliasing", kAllNodes, 0, dvmCompilerVerySimpleLoopGate,
-              0, 0, dvmCompilerMemoryAliasing, 0, 0),
-    NEW_PASS ("Local_Value_Numbering", kAllNodes, 0, dvmCompilerVerySimpleLoopGate,
-              0, 0, dvmCompilerLocalValueNumbering, 0, 0),
-    NEW_PASS ("Variant", kAllNodes, 0, dvmCompilerVerySimpleLoopGate,
-              0, dvmCompilerVariant, 0, 0, 0),
-    NEW_PASS ("Invariant_Removal", kAllNodes, 0, dvmCompilerInvariantRemovalGate,
-              dvmCompilerInvariantRemoval, 0, 0, 0, kOptimizationBasicBlockChange),
-    NEW_PASS ("Variant", kAllNodes, 0, dvmCompilerVerySimpleLoopGate,
-              0, dvmCompilerVariant, 0, 0, 0),
-    NEW_PASS ("Iget_Iput_Removal", kAllNodes, 0, dvmCompilerInvariantRemovalGate,
-              dvmCompilerIgetIputRemoval, 0, 0, 0, kOptimizationBasicBlockChange),
-    NEW_PASS ("Sink_Casts", kAllNodes, 0, dvmCompilerTraceIsLoopNewSystem,
-               dvmCompilerSinkCasts, 0, 0, 0, kOptimizationBasicBlockChange),
-    NEW_PASS ("Accumulation_Sinking", kAllNodes, 0, dvmCompilerSinkAccumulationsGate,
-            0, dvmCompilerAccumulationSinking, 0, 0, kOptimizationBasicBlockChange),
-    NEW_PASS ("Vectorization", kAllNodes, 0, dvmCompilerTraceIsLoopNewSystem,
-            dvmCompilerVectorize, 0, 0, 0, kOptimizationBasicBlockChange | kLoopStructureChange),
-    NEW_PASS ("Invariant_sinking", kAllNodes, 0, dvmCompilerInvariantSinkingGate,
-            dvmCompilerInvariantSinking, 0, 0, 0, kOptimizationBasicBlockChange),
-    //This should be after the last optimization that changes instruction sequence or BB logic
-    //Note: reorder is safe and should be after
-    //We do registerization for all traces to provide spill information to the BE
-    NEW_PASS ("Write_Back_Registers", kAllNodes, 0, 0, 0, 0, dvmCompilerWriteBackAll, 0, 0),
-    NEW_PASS ("Registerization_ME", kAllNodes, 0, dvmCompilerTraceIsLoopNewSystem,
-                0, dvmCompilerRegisterize, 0, 0, 0),
-    //From here we start preparing the CFG for the backend
-    NEW_PASS ("Fix_Chaining_Cells", kAllNodesAndNew, 0, 0,
-                0, 0, dvmCompilerFixChainingCellPredecessors, 0, kOptimizationBasicBlockChange | kLoopStructureChange),
-    NEW_PASS ("Add_Invoke_ChainingCells", kAllNodesAndNew, 0, 0,
-                0, 0, dvmCompilerAddInvokeSupportBlocks, 0, kOptimizationBasicBlockChange),
-    NEW_PASS ("Insert_LoopHelper_Blocks", kAllNodesAndNew, 0, 0,
-                    0, dvmCompilerInsertLoopHelperBlocks, 0, 0, kOptimizationBasicBlockChange | kLoopStructureChange),
-    NEW_PASS ("Reorder_Blocks", kBreadthFirstTraversal, 0, 0,
-                dvmCompilerReorder, 0, 0, 0, kOptimizationBasicBlockChange | kLoopStructureChange),
-
-    /* Last element must have and be the only one to have a NULL name, it's our ending check */
-    NEW_PASS ("",       /** Pass name */
-         kAllNodes,     /** Type of traversal */
-         0,             /** Data */
-         0,             /** Gate function */
-         0,             /** Start function */
-         0,             /** End function */
-         0,             /** Work function */
-         0,             /** Free function */
-         0              /** Flags */
-         ),
-END_PASSES
-
-void dvmCompilerBuildPassList (void)
-{
-    //Our pass system above is a table and is easy to create as it is, but our plugin system might want to reorder things,
-    //So let's make it a pass list
-    unsigned int max = sizeof (gPasses) / sizeof (gPasses[0]);
-
-    //If at least one, we have work to do
-    if (max > 0)
-    {
-        //Attach first
-        gDvmJit.jitFramework.firstPass = gPasses;
-
-        //Set last
-        Pass *last = gPasses;
-
-        for (unsigned int i = 1; i < max; i++)
-        {
-            //Get local version
-            Pass *ptr = gPasses + i;
-
-            //Paranoid
-            assert (ptr != 0);
-
-            //Attach it to last
-            last->setNext (ptr);
-            ptr->setPrevious (last);
-
-            //Update last
-            last = ptr;
-        }
-    }
-}
-
-/**
-  * @brief Handle any pass flag that requires clean-up
-  * @param cUnit the CompilationUnit
-  * @param pass the Pass
-  */
-void handlePassFlag (CompilationUnit *cUnit, Pass *pass)
-{
-    if ((pass->getFlag (kOptimizationBasicBlockChange) == true) ||
-            (pass->getFlag (kOptimizationDefUsesChange) == true))
-    {
-        bool buildLoopInfo = pass->getFlag (kLoopStructureChange) == true;
-        dvmCompilerCalculateBasicBlockInformation (cUnit, false, buildLoopInfo);
-    }
-}
-
-bool dvmCompilerRunPass (CompilationUnit *cUnit, Pass *curPass)
-{
-    //Paranoid
-    if (cUnit == 0 || curPass == 0 || curPass->getName() == "")
-    {
-        return false;
-    }
-
-    //Check the pass gate first
-    bool applyPass = curPass->gate (cUnit, curPass);
-
-    //If the pass gate said ok
-    if (applyPass == true)
-    {
-        //Applying the pass: first start, doWork, and end calls
-        curPass->start (cUnit, curPass);
-
-        //Get work function
-        bool (*doWork) (CompilationUnit *, BasicBlock *) = curPass->getWork ();
-
-        if (doWork != 0)
-        {
-            //Set the data in cUnit
-            cUnit->passData = curPass->getData ();
-
-            //Determine if pass is iterative
-            bool isIterative = curPass->getFlag (kOptimizationNeedIterative);
-
-            dvmCompilerDataFlowAnalysisDispatcher (cUnit, doWork, curPass->getTraversal (), isIterative);
-            cUnit->passData = 0;
-        }
-
-        curPass->end (cUnit, curPass);
-
-        //Do we need any clean up?
-        handlePassFlag (cUnit, curPass);
-
-        //Let's clean up any data we used during the pass
-        curPass->freePassData ();
-    }
-
-    //If the pass gate passed, we can declare success
-    return applyPass;
-}
-
-bool dvmCompilerRunPass (CompilationUnit *cUnit, const char *passName)
-{
-    //Paranoid
-    if (cUnit == 0 || passName == 0)
-    {
-        return false;
-    }
-
-    //Go through all the passes and find the requested pass
-    Pass *pass = gDvmJit.jitFramework.firstPass;
-
-    //To record successful application of a pass
-    bool success = false;
-
-    //Now loop and check the name
-    while (pass != 0 && pass->getName() != "")
-    {
-        //See if the name matches
-        if (strcmp(pass->getName().c_str(), passName) == 0)
-        {
-            success = dvmCompilerRunPass (cUnit, pass);
-
-            //There will be only one matching pass
-            break;
-        }
-
-        //Go to the next pass
-        pass = pass->getNext ();
-    }
-
-    return success;
-}
-
- /**
-  * @brief The loop
-  * @param cUnit the CompilationUnit
-  */
-void dvmCompilerLoopOptimizationDriver (CompilationUnit *cUnit)
-{
-    //Go through the different elements
-    Pass *curPass = gDvmJit.jitFramework.firstPass;
-
-    //As long as we have a pass and we haven't decided to quit the loop mode
-    while (curPass->getName () != "" && cUnit->quitLoopMode == false)
-    {
-        //First, did someone want us to skip this pass?
-        //If they did, they used the option -Xjitignorepass:"Pass name"
-        //So if strstr returns something, someone wanted to ignore that pass
-        if (gDvmJit.ignorePasses != 0 && strstr (gDvmJit.ignorePasses, curPass->getName ().c_str ()) != 0)
-        {
-            curPass = curPass->getNext ();
-            continue;
-        }
-
-        //Save the print pass flag because we may be updating it.
-        //At end of pass, we always restore the printPass flag because it is a compilation unit property and we
-        //don't want to leave it permanently changed. For example, someone may enable verbosity by creating a plugin
-        //that changes the printPass flag for just a single trace and not globally.
-        bool oldPrintPass = cUnit->printPass;
-
-        //Now check if this pass is requested for debug. First we check if all passes should be debugged.
-        //Then we check whether just this particular pass should be debugged.
-        if (gDvmJit.debugAllPasses == true
-                || (gDvmJit.debugPasses != 0 && strstr (gDvmJit.debugPasses, curPass->getName ().c_str ()) != 0))
-        {
-            cUnit->printPass = true;
-        }
-
-        //Do we have a general gate defined?
-        bool (*generalGate) (const CompilationUnit *, Pass *) = gDvmJit.jitFramework.generalGate;
-
-        //We suppose we can apply the pass
-        bool applyPass = true;
-
-        //Apply the general gate
-        if (generalGate != 0)
-        {
-            applyPass = generalGate (cUnit, curPass);
-        }
-
-        //If the general gate did not invalidate the pass, continue
-        if (applyPass == true)
-        {
-            //Apply the pass (Ignore the return value of this call)
-            dvmCompilerRunPass (cUnit, curPass);
-        }
-
-        //Now restore the printPass flag. For explanation why we restore it, please see description of when we save.
-        cUnit->printPass = oldPrintPass;
-
-        //Go to next pass
-        curPass = curPass->getNext ();
-    }
-}
-
-bool dvmCompilerTraceIsLoop (const CompilationUnit *cUnit, Pass *curPass)
-{
-    (void) curPass;
-    return cUnit->jitMode == kJitLoop;
-}
-
-bool dvmCompilerTraceIsLoopNewSystem (const CompilationUnit *cUnit, Pass *curPass)
-{
-    (void) curPass;
-    return dvmCompilerTraceIsLoop (cUnit, curPass) && (gDvmJit.oldLoopDetection == false);
-}
-
-bool dvmCompilerTraceIsLoopOldSystem (const CompilationUnit *cUnit, Pass *curPass)
-{
-    (void) curPass;
-    return dvmCompilerTraceIsLoop (cUnit, curPass) && (gDvmJit.oldLoopDetection == true);
-}
-
-void dvmCompilerPrintPassNames (void)
-{
-    //Go through the different elements
-    Pass *curPass = gPasses;
-
-    ALOGI ("Loop Passes are:");
-    //As long as we have a pass and we haven't decided to quit the loop mode
-    while (curPass->getName () != "")
-    {
-        ALOGI ("\t-%s", curPass->getName ().c_str ());
-        curPass = curPass->getNext ();
-    }
-}
-
-void dvmCompilerPrintIgnorePasses (void)
-{
-    //Suppose the worse
-    bool ignoredSomething = false;
-
-    //Go through the different elements
-    Pass *curPass = gPasses;
-    ALOGI ("Ignoring Passes:");
-    //As long as we have a pass and we haven't decided to quit the loop mode
-    while (curPass->getName () != "")
-    {
-        if (gDvmJit.ignorePasses != 0 && strstr (gDvmJit.ignorePasses, curPass->getName ().c_str ()) != 0)
-        {
-            ALOGI ("\t-%s", curPass->getName ().c_str ());
-            //Set flag to true, we are going to ignore something
-            ignoredSomething = true;
-        }
-        curPass = curPass->getNext ();
-    }
-
-    //If nothing got ignored, print out information about it
-    if (ignoredSomething == false)
-    {
-        //Paranoid
-        if (gDvmJit.ignorePasses == 0)
-        {
-            ALOGI ("\tThe ignore pass information is missing, please use -Xjitignorepasses");
-        }
-        else
-        {
-            ALOGI ("\t- Nothing got ignored, you must put in the parameter of -Xjitignorepasses the exact spelling of one of the passes");
-            ALOGI ("\t- Here is what you provided %s", gDvmJit.ignorePasses);
-            ALOGI ("\t- Here are the loop passes for reference:");
-            dvmCompilerPrintPassNames ();
-        }
-    }
-}
-
-
-/**
- * @brief Helper function to dvmCompilerCheckLoops to check number of exits for each loop
- * @param info loop information to check
- * @param data required by interface, not used.
- */
-static bool exitLoopHelper (LoopInformation *info, void *data)
-{
-    return dvmCountSetBits (info->getExitLoops ()) <= 1;
-}
-
-bool dvmCompilerCheckLoops (const CompilationUnit *cUnit)
-{
-    // Build loop information
-    LoopInformation *loopInfo = LoopInformation::getLoopInformation (const_cast<CompilationUnit *>(cUnit), 0);
-    const_cast<CompilationUnit *>(cUnit)->loopInformation = loopInfo;
-
-    if (loopInfo != 0)
-    {
-        // we are rejecting sibling loops at top level
-        if (loopInfo->getNextSibling () !=0)
-        {
-            const_cast<CompilationUnit *>(cUnit)->quitLoopMode = true;
-            return false;
-        }
-
-        // Check that we have no more than one loop output
-        // Note we are working before loop formation, so exit block is real one
-        if (loopInfo->iterate (exitLoopHelper) == false)
-        {
-            const_cast<CompilationUnit *>(cUnit)->quitLoopMode = true;
-            return false;
-        }
-
-        //If it is nested and option says no, bail
-        if (gDvmJit.nestedLoops == false)
-        {
-            // We do not have sibling so it is enough to check first
-            if (loopInfo->getNested () != 0)
-            {
-                const_cast<CompilationUnit *>(cUnit)->quitLoopMode = true;
-                return false;
-            }
-
-            //Ok second possibility to reject is if we only want simple loops
-            if (gDvmJit.branchLoops == false)
-            {
-                //Now check if we have only one backward branch: to only enable "simple" loops
-                const BitVector *backwards = loopInfo->getBackwardBranches ();
-
-                if (backwards == 0)
-                {
-                    const_cast<CompilationUnit *>(cUnit)->quitLoopMode = true;
-                    return false;
-                }
-
-                if (dvmCountSetBits (backwards) != 1)
-                {
-                    const_cast<CompilationUnit *>(cUnit)->quitLoopMode = true;
-                    return false;
-                }
-
-                //Finally, get the basic block for the backward branch
-                int backwardIdx = dvmHighestBitSet (backwards);
-
-                if (backwardIdx < 0)
-                {
-                    const_cast<CompilationUnit *>(cUnit)->quitLoopMode = true;
-                    return false;
-                }
-
-                BasicBlock *backward = (BasicBlock *) dvmGrowableListGetElement (&cUnit->blockList, backwardIdx);
-
-                //If nil or no domination loopInformation, bail
-                if (backward == 0 || backward->dominators == 0)
-                {
-                    const_cast<CompilationUnit *>(cUnit)->quitLoopMode = true;
-                    return false;
-                }
-
-                //Now go through each BB and see if it dominates backward
-                BitVector *blocks = loopInfo->getBasicBlocks ();
-
-                BitVectorIterator bvIterator;
-                dvmBitVectorIteratorInit(blocks, &bvIterator);
-                for (BasicBlock *bb = dvmCompilerGetNextBasicBlockViaBitVector(bvIterator, cUnit->blockList); bb != 0;
-                        bb = dvmCompilerGetNextBasicBlockViaBitVector(bvIterator, cUnit->blockList))
-                {
-                    if (bb == backward)
-                    {
-                        continue;
-                    }
-
-                    //We bail if it doesn't dominate
-                    if (dvmIsBitSet (backward->dominators, bb->id) == 0)
-                    {
-                        const_cast<CompilationUnit *>(cUnit)->quitLoopMode = true;
-                        return false;
-                    }
-                }
-            }
-        }
-    }
-
-    return true;
-}
-
-/**
- * @brief Check if the loops are formed the way we want (nested / branches on / off)
- * @param cUnit the CompilationUnit
- * @param curPass the current Pass
- * @return Whether to continue as a loop or bail
- */
-bool checkLoopsGate (const CompilationUnit *cUnit, Pass *curPass)
-{
-    //Unused parameter
-    (void) curPass;
-
-    return dvmCompilerCheckLoops (cUnit);
-}
-
-bool dvmCompilerCheckReferences (CompilationUnit *cUnit, BasicBlock *bb)
-{
-    //Check all of the MIRs in this basic block
-    for (MIR *mir = bb->firstMIRInsn; mir != 0; mir = mir->next)
-    {
-        bool resolved = dvmCompilerCheckResolvedReferences (cUnit->method, &mir->dalvikInsn,
-                false /*tryToResolve*/);
-
-        if (resolved == false)
-        {
-            //We found an unresolved reference
-            cUnit->quitLoopMode = true;
-
-            //We have not changed the BB
-            return false;
-        }
-    }
-
-    //All references checked are resolved but we have not updated the BB
-    return false;
-}
-
-//Get a given pass
-Pass *dvmCompilerGetPass (const char *name)
-{
-    //Go through the different elements
-    Pass *curPass = gDvmJit.jitFramework.firstPass;
-
-    //Find the pass we care about
-    while (curPass->getName () != "" && curPass->getName () != name)
-    {
-        //Next pass
-        curPass = curPass->getNext ();
-    }
-
-    //If not found
-    if (curPass->getName () == "")
-    {
-        return 0;
-    }
-
-    //Otherwise return the pass
-    return curPass;
-}
-
-//Remove a given pass
-bool dvmCompilerRemovePass (const char *name)
-{
-    //Find the pass
-    Pass *curPass = dvmCompilerGetPass (name);
-
-    //Paranoid: didn't find the name
-    if (curPass == 0)
-    {
-        ALOGI ("\tRemoving a pass could not find the reference pass name, here is what you provided %s", name);
-        ALOGI ("\t- Here are the loop passes for reference:");
-        dvmCompilerPrintPassNames ();
-        return false;
-    }
-
-    Pass *previous = curPass->getPrevious ();
-    Pass *next = curPass->getNext ();
-
-    //Update previous
-    if (previous != 0)
-    {
-        previous->setNext (next);
-    }
-    else
-    {
-        //Update global list otherwise
-        gDvmJit.jitFramework.firstPass = next;
-    }
-
-    //Update next
-    if (next != 0)
-    {
-        next->setPrevious (previous);
-    }
-
-    //Report success
-    return true;
-}
-
-//Insert a user pass
-bool dvmCompilerInsertUserPass (Pass *newPass, const char *name, enum PassInstrumentation mode)
-{
-    //Find the pass
-    Pass *curPass = dvmCompilerGetPass (name);
-
-    //Paranoid: didn't find the name
-    if (curPass == 0)
-    {
-        ALOGI ("Pass Modification could not find the reference pass name, here is what you provided %s", name);
-        ALOGI ("\t- Here are the loop passes for reference:");
-        dvmCompilerPrintPassNames ();
-        return false;
-    }
-
-    //We have the pass reference, what we do now depends on the mode
-    switch (mode)
-    {
-        case kPassInstrumentationReplace:
-            {
-                Pass *previous = curPass->getPrevious ();
-                Pass *next = curPass->getNext ();
-
-                //Update links
-                if (previous != 0)
-                {
-                    previous->setNext (newPass);
-                }
-                else
-                {
-                    gDvmJit.jitFramework.firstPass = curPass;
-                }
-
-                if (next != 0)
-                {
-                    next->setPrevious (newPass);
-                }
-
-                newPass->setNext (next);
-                newPass->setPrevious (previous);
-            }
-            break;
-        case kPassInstrumentationInsertBefore:
-            {
-                Pass *previous = curPass->getPrevious ();
-
-                //Update links
-                newPass->setPrevious (previous);
-                newPass->setNext (curPass);
-
-                //If curPass was the first pass
-                if (previous == 0)
-                {
-                    //Update it now
-                    gDvmJit.jitFramework.firstPass = newPass;
-                }
-                else
-                {
-                    previous->setNext (curPass);
-                }
-
-                curPass->setPrevious (newPass);
-            }
-            break;
-        case kPassInstrumentationInsertAfter:
-            {
-                Pass *next = curPass->getNext ();
-
-                //Update links
-                newPass->setNext (next);
-                newPass->setPrevious (curPass);
-                curPass->setNext (newPass);
-
-                //Handle next
-                if (next != 0)
-                {
-                    next->setPrevious (newPass);
-                }
-            }
-            break;
-        default:
-            break;
-    }
-
-    //Report success
-    return true;
-}
-
-void dvmCompilerSetGeneralGate (bool (*general) (const CompilationUnit *, Pass*))
-{
-    gDvmJit.jitFramework.generalGate = general;
-}
-
-//Replace a given pass gate
-bool dvmCompilerReplaceGate (const char *name, bool (*gate) (const CompilationUnit *, Pass*))
-{
-    //Find the pass
-    Pass *curPass = dvmCompilerGetPass (name);
-
-    //Paranoid: didn't find the name
-    if (curPass == 0)
-    {
-        ALOGI ("Pass Modification could not find the reference pass name, here is what you provided %s", name);
-        ALOGI ("\t- Here are the loop passes for reference:");
-        dvmCompilerPrintPassNames ();
-        return false;
-    }
-
-    //Set the gate
-    curPass->setGate (gate);
-
-    //Report success
-    return true;
-}
-
-bool dvmCompilerReplaceEnd (const char *name, void (*endWork) (CompilationUnit *, Pass*))
-{
-    //Find the pass
-    Pass *curPass = dvmCompilerGetPass (name);
-
-    //Paranoid: didn't find the name
-    if (curPass == 0)
-    {
-        ALOGI ("Pass Modification could not find the reference pass name, here is what you provided %s", name);
-        ALOGI ("\t- Here are the loop passes for reference:");
-        dvmCompilerPrintPassNames ();
-        return false;
-    }
-
-    //Set the end work function
-    curPass->setEndWork (endWork);
-
-    //Report success
-    return true;
-}
-
-//Handle a user plugin
-void dvmCompilerHandleUserPlugin (const char *fileName)
-{
-    //Let us be optimistic
-    bool failure = false;
-
-    //Open the file
-    void *userHandle = dlopen (fileName, RTLD_NOW);
-
-    if (userHandle != 0)
-    {
-        //Open now the init function
-        void *tmp = dlsym (userHandle, "dalvikPluginInit");
-
-        if (tmp == 0)
-        {
-            ALOGD ("Problem with %s, cannot find dalvikPluginInit function\n", fileName);
-
-            //Set failure flag
-            failure = true;
-        }
-        else
-        {
-            //Transform it into a function pointer
-            bool (*pluginInitialization) (void) = (bool (*) (void)) (tmp);
-
-            //Call it
-            failure = (pluginInitialization () == false);
-        }
-    }
-    else
-    {
-        ALOGD ("Problem opening user plugin file %s", fileName);
-        ALOGD ("dlerror() reports %s", dlerror());
-
-        //Set failure flag
-        failure = true;
-    }
-
-    //If the failure flag is on
-    if (failure == true)
-    {
-        //Is the failure on the user plugin fatal?
-        if (gDvmJit.userpluginfatal == true)
-        {
-            dvmAbort ();
-        }
-
-        //Signal we failed loading a plugin
-        gDvmJit.userpluginfailed = true;
-    }
-}
diff --git a/vm/compiler/LoopOpt.h b/vm/compiler/LoopOpt.h
deleted file mode 100644
index d7b3cbd..0000000
--- a/vm/compiler/LoopOpt.h
+++ /dev/null
@@ -1,165 +0,0 @@
-/*
-* Copyright (C) 2012 Intel Corporation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-*      http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
-
-#ifndef DALVIK_VM_LOOPOPT_H_
-#define DALVIK_VM_LOOPOPT_H_
-
-/**
- * @brief PassInstrumentation allows the user to modify existing passes and add new ones
- */
-enum PassInstrumentation
-{
-    kPassInstrumentationInsertBefore,   /**< @brief Insert before the Pass */
-    kPassInstrumentationInsertAfter,    /**< @brief Insert after the Pass */
-    kPassInstrumentationReplace,        /**< @brief Replace a Pass */
-};
-
-//Forward Declaration
-struct CompilationUnit;
-class Pass;
-
-/**
- * @brief Run the pass on the cUnit
- * @details The pass is run completely, including the gate, pre and post functions
- * @param cUnit The CompilationUnit to run the pass on
- * @param pass The Pass which needs to be run
- * @return Whether the pass could be successfully applied
- */
-bool dvmCompilerRunPass (CompilationUnit *cUnit, Pass *pass);
-
-/**
- * @brief Find the pass with the passName and run it with the cUnit
- * @param cUnit The CompilationUnit to run the pass on
- * @param passName The name of the pass which should be run
- * @return Whether the pass could be successfully applied
- */
-bool dvmCompilerRunPass (CompilationUnit *cUnit, const char *passName);
-
-/**
-  * @brief The loop optimization driver: calls each pass from the gPasses array
-  * @param cUnit the Compilation Unit
-  */
-void dvmCompilerLoopOptimizationDriver (CompilationUnit *cUnit);
-
-/**
-  * @brief Is the trace a loop?
-  * @param cUnit the CompilationUnit
-  * @param curPass the Pass
-  * @return whether or not the cUnit represents a loop
-  */
-bool dvmCompilerTraceIsLoop (const CompilationUnit *cUnit, Pass *curPass);
-
-/**
-  * @brief Is the trace a loop formed by the new system?
-  * @param cUnit the CompilationUnit
-  * @param curPass the Pass
-  * @return whether or not the cUnit represents a loop
-  */
-bool dvmCompilerTraceIsLoopNewSystem (const CompilationUnit *cUnit, Pass *curPass);
-
-/**
-  * @brief Is the trace a loop formed by the old system?
-  * @param cUnit the CompilationUnit
-  * @param curPass the Pass
-  * @return whether or not the cUnit represents a loop
-  */
-bool dvmCompilerTraceIsLoopOldSystem (const CompilationUnit *cUnit, Pass *curPass);
-
-/**
- * @brief Print the pass names
- */
-void dvmCompilerPrintPassNames (void);
-
-/**
- * @brief Print the pass names we are going to ignore
- */
-void dvmCompilerPrintIgnorePasses (void);
-
-/**
- * @brief Check if the loops are formed the way we want (nested / branches on / off)
- * @param cUnit the CompilationUnit
- * @return Whether to continue as a loop or bail
- */
-bool dvmCompilerCheckLoops (const CompilationUnit *cUnit);
-
-/**
- * @brief Used to check whether instructions in basic block have resolved references.
- * @details If unresolved references have been found then cUnit->quitLoopMode is set to true.
- * @param cUnit The compilation unit
- * @param bb The basic block whose instructions to check
- * @return Always returns false because the CFG is not updated
- */
-bool dvmCompilerCheckReferences (CompilationUnit *cUnit, BasicBlock *bb);
-
-/**
- * @brief Verify that hoisted checks optimization is applicable
- * @param cUnit the CompilationUnit
- * @param curPass the Pass
- * @return Whether to generate hoisted checks for the loop
- */
-bool dvmCompilerHoistedChecksGate (const CompilationUnit *cUnit, Pass *curPass);
-
-/**
- * @brief Remove an optimization Pass
- * @param name the name of the Pass
- * @return whether removal was successful
- */
-bool dvmCompilerRemovePass (const char *name);
-
-/**
- * @brief Get an optimization pass
- * @param name the name of the Pass
- * @return pointer to the Pass, 0 if not found
- */
-Pass *dvmCompilerGetPass (const char *name);
-
-/**
- * @brief Used to replace the gate of an optimization pass
- * @param name the name of the Pass
- * @param gate the new gate
- * @return whether the gate replacement was successful
- */
-bool dvmCompilerReplaceGate (const char *name, bool (*gate) (const CompilationUnit *, Pass*));
-
-/**
- * @brief Used to replace the end work function of a pass
- * @param name The name of the Pass to update
- * @param endWork The new end work function to use
- * @return Returns true if replacement was successful
- */
-bool dvmCompilerReplaceEnd (const char *name, void (*endWork) (CompilationUnit *, Pass*));
-
-/**
- * @brief Insert the user pass
- * @param newPass the Pass information we want to add/modify
- * @param name the name of the current pass we want to be adding/modifying
- * @param mode what we want to do/change
- * @return whether we succeeded or not
- */
-bool dvmCompilerInsertUserPass (Pass *newPass, const char *name, enum PassInstrumentation mode);
-
-/**
- * @brief Handle User Plugin Library
- * @param fileName the name of the library
- */
-void dvmCompilerHandleUserPlugin (const char *fileName);
-
-/**
- * @brief Create the Pass list
- */
-void dvmCompilerBuildPassList (void);
-
-#endif
diff --git a/vm/compiler/PassDriver.cpp b/vm/compiler/PassDriver.cpp
new file mode 100644
index 0000000..c7372aa
--- /dev/null
+++ b/vm/compiler/PassDriver.cpp
@@ -0,0 +1,783 @@
+/*
+* Copyright (C) 2012 Intel Corporation
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+*      http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+#include <dlfcn.h>
+
+#include "AccumulationSinking.h"
+#include "BBOptimization.h"
+#include "Checks.h"
+#include "Dalvik.h"
+#include "Dataflow.h"
+#include "InvariantRemoval.h"
+#include "Loop.h"
+#include "PassDriver.h"
+#include "SinkCastOpt.h"
+#include "LoopRegisterUsage.h"
+#include "Pass.h"
+#include "RegisterizationME.h"
+#include "Vectorization.h"
+#include "Utility.h"
+
+/**
+ * @brief Static functions defined below
+ */
+static void handlePassFlag (CompilationUnit *cUnit, Pass *pass);
+static bool checkLoopsGate (const CompilationUnit *cUnit, Pass *pass);
+
+/**
+ * @brief Three macros to help pass definitions
+ */
+#define START_PASSES \
+    static Pass gPasses[] = {
+
+#define NEW_PASS(NAME,TYPE,DATA,GATE,START,END,WORK,FREE,FLAG) \
+        Pass ( \
+            NAME, TYPE, DATA, GATE, START, END, WORK, FREE, FLAG \
+        )
+
+#define END_PASSES \
+    };
+
+START_PASSES
+    //Check if the loops are like we want right now (nested or not, branches or not)
+    NEW_PASS ("Reject_Loops", kAllNodes, 0, checkLoopsGate, 0, 0, 0, 0, 0),
+    //This loop formation is used when the new loop filtering is active
+    NEW_PASS ("Form_Loop", kAllNodes, 0, dvmCompilerTraceIsLoopNewSystem,
+                dvmCompilerFormLoop, 0, 0, 0, kOptimizationBasicBlockChange | kLoopStructureChange),
+    NEW_PASS ("Test_Loop", kAllNodes, 0, dvmCompilerTraceIsLoopNewSystem,
+                dvmCompilerTestLoop, 0, 0, 0, 0),
+    //This loop formation is used when the old loop filtering is active
+    NEW_PASS ("Old_Loop_Formation", kAllNodesAndNew, 0, dvmCompilerTraceIsLoopOldSystem,
+                dvmCompilerFormOldLoop, 0, 0, 0, kOptimizationBasicBlockChange | kLoopStructureChange),
+    //Now check that bytecodes reference fully resolved classes, methods, and fields.
+    //We only do this check for loops because we can bring in parts that are not so hot.
+    NEW_PASS ("Check_References", kAllNodes, 0, dvmCompilerTraceIsLoopNewSystem,
+            0, 0, dvmCompilerCheckReferences, 0, 0),
+    //At this point, we finish with the loops, so to increase optimization scope we start inlining
+    NEW_PASS ("Method_Inlining", kAllNodesAndNew, 0, 0,
+                0, 0, dvmCompilerMethodInlining, 0, kOptimizationBasicBlockChange | kLoopStructureChange),
+    NEW_PASS ("Check_Removal", kPredecessorsFirstTraversal, 0, 0,
+                dvmCompilerStartCheckRemoval, dvmCompilerEndCheckRemoval, dvmCompilerCheckRemoval, 0, kOptimizationDefUsesChange),
+    //The 2addr pass should come before any pass that need register rewriting.
+    NEW_PASS ("Convert_2addr_to_normal", kAllNodes, 0, 0,
+                0, 0, dvmCompilerConvert2addr, 0, kOptimizationBasicBlockChange),
+    //Memory Aliasing only works on one basic block so let's try to merge first
+    //For the moment, no pass will create new blocks, etc. so this is fine up here
+    //Otherwise, we might want to duplicate the merge or make the gate for memory aliasing smarter
+    NEW_PASS ("Remove_Gotos", kAllNodes, 0, 0, 0, NULL, dvmCompilerRemoveGoto, 0, kOptimizationBasicBlockChange),
+    NEW_PASS ("Merge_Blocks", kAllNodes, 0, 0,
+                0, 0, dvmCompilerMergeBasicBlocks, 0,
+                kOptimizationBasicBlockChange | kLoopStructureChange | kOptimizationNeedIterative),
+    NEW_PASS ("Memory_Aliasing", kAllNodes, 0, dvmCompilerVerySimpleLoopGate,
+              0, 0, dvmCompilerMemoryAliasing, 0, 0),
+    NEW_PASS ("Local_Value_Numbering", kAllNodes, 0, dvmCompilerVerySimpleLoopGate,
+              0, 0, dvmCompilerLocalValueNumbering, 0, 0),
+    NEW_PASS ("Variant", kAllNodes, 0, dvmCompilerVerySimpleLoopGate,
+              0, dvmCompilerVariant, 0, 0, 0),
+    NEW_PASS ("Invariant_Removal", kAllNodes, 0, dvmCompilerInvariantRemovalGate,
+              dvmCompilerInvariantRemoval, 0, 0, 0, kOptimizationBasicBlockChange),
+    NEW_PASS ("Variant", kAllNodes, 0, dvmCompilerVerySimpleLoopGate,
+              0, dvmCompilerVariant, 0, 0, 0),
+    NEW_PASS ("Iget_Iput_Removal", kAllNodes, 0, dvmCompilerInvariantRemovalGate,
+              dvmCompilerIgetIputRemoval, 0, 0, 0, kOptimizationBasicBlockChange),
+    NEW_PASS ("Sink_Casts", kAllNodes, 0, dvmCompilerTraceIsLoopNewSystem,
+               dvmCompilerSinkCasts, 0, 0, 0, kOptimizationBasicBlockChange),
+    NEW_PASS ("Accumulation_Sinking", kAllNodes, 0, dvmCompilerSinkAccumulationsGate,
+            0, dvmCompilerAccumulationSinking, 0, 0, kOptimizationBasicBlockChange),
+    NEW_PASS ("Vectorization", kAllNodes, 0, dvmCompilerTraceIsLoopNewSystem,
+            dvmCompilerVectorize, 0, 0, 0, kOptimizationBasicBlockChange | kLoopStructureChange),
+    NEW_PASS ("Invariant_sinking", kAllNodes, 0, dvmCompilerInvariantSinkingGate,
+            dvmCompilerInvariantSinking, 0, 0, 0, kOptimizationBasicBlockChange),
+    //This should be after the last optimization that changes instruction sequence or BB logic
+    //Note: reorder is safe and should be after
+    //We do registerization for all traces to provide spill information to the BE
+    NEW_PASS ("Write_Back_Registers", kAllNodes, 0, 0, 0, 0, dvmCompilerWriteBackAll, 0, 0),
+    NEW_PASS ("Registerization_ME", kAllNodes, 0, dvmCompilerTraceIsLoopNewSystem,
+                0, dvmCompilerRegisterize, 0, 0, 0),
+    //From here we start preparing the CFG for the backend
+    NEW_PASS ("Fix_Chaining_Cells", kAllNodesAndNew, 0, 0,
+                0, 0, dvmCompilerFixChainingCellPredecessors, 0, kOptimizationBasicBlockChange | kLoopStructureChange),
+    NEW_PASS ("Add_Invoke_ChainingCells", kAllNodesAndNew, 0, 0,
+                0, 0, dvmCompilerAddInvokeSupportBlocks, 0, kOptimizationBasicBlockChange),
+    NEW_PASS ("Insert_LoopHelper_Blocks", kAllNodesAndNew, 0, 0,
+                    0, dvmCompilerInsertLoopHelperBlocks, 0, 0, kOptimizationBasicBlockChange | kLoopStructureChange),
+    NEW_PASS ("Reorder_Blocks", kBreadthFirstTraversal, 0, 0,
+                dvmCompilerReorder, 0, 0, 0, kOptimizationBasicBlockChange | kLoopStructureChange),
+
+    /* Last element must have and be the only one to have a NULL name, it's our ending check */
+    NEW_PASS ("",       /** Pass name */
+         kAllNodes,     /** Type of traversal */
+         0,             /** Data */
+         0,             /** Gate function */
+         0,             /** Start function */
+         0,             /** End function */
+         0,             /** Work function */
+         0,             /** Free function */
+         0              /** Flags */
+         ),
+END_PASSES
+
+void dvmCompilerBuildPassList (void)
+{
+    //Our pass system above is a table and is easy to create as it is, but our plugin system might want to reorder things,
+    //So let's make it a pass list
+    unsigned int max = sizeof (gPasses) / sizeof (gPasses[0]);
+
+    //If at least one, we have work to do
+    if (max > 0)
+    {
+        //Attach first
+        gDvmJit.jitFramework.firstPass = gPasses;
+
+        //Set last
+        Pass *last = gPasses;
+
+        for (unsigned int i = 1; i < max; i++)
+        {
+            //Get local version
+            Pass *ptr = gPasses + i;
+
+            //Paranoid
+            assert (ptr != 0);
+
+            //Attach it to last
+            last->setNext (ptr);
+            ptr->setPrevious (last);
+
+            //Update last
+            last = ptr;
+        }
+    }
+}
+
+/**
+  * @brief Handle any pass flag that requires clean-up
+  * @param cUnit the CompilationUnit
+  * @param pass the Pass
+  */
+void handlePassFlag (CompilationUnit *cUnit, Pass *pass)
+{
+    if ((pass->getFlag (kOptimizationBasicBlockChange) == true) ||
+            (pass->getFlag (kOptimizationDefUsesChange) == true))
+    {
+        bool buildLoopInfo = pass->getFlag (kLoopStructureChange) == true;
+        dvmCompilerCalculateBasicBlockInformation (cUnit, false, buildLoopInfo);
+    }
+}
+
+bool dvmCompilerRunPass (CompilationUnit *cUnit, Pass *curPass)
+{
+    //Paranoid
+    if (cUnit == 0 || curPass == 0 || curPass->getName() == "")
+    {
+        return false;
+    }
+
+    //Check the pass gate first
+    bool applyPass = curPass->gate (cUnit, curPass);
+
+    //If the pass gate said ok
+    if (applyPass == true)
+    {
+        //Applying the pass: first start, doWork, and end calls
+        curPass->start (cUnit, curPass);
+
+        //Get work function
+        bool (*doWork) (CompilationUnit *, BasicBlock *) = curPass->getWork ();
+
+        if (doWork != 0)
+        {
+            //Set the data in cUnit
+            cUnit->passData = curPass->getData ();
+
+            //Determine if pass is iterative
+            bool isIterative = curPass->getFlag (kOptimizationNeedIterative);
+
+            dvmCompilerDataFlowAnalysisDispatcher (cUnit, doWork, curPass->getTraversal (), isIterative);
+            cUnit->passData = 0;
+        }
+
+        curPass->end (cUnit, curPass);
+
+        //Do we need any clean up?
+        handlePassFlag (cUnit, curPass);
+
+        //Let's clean up any data we used during the pass
+        curPass->freePassData ();
+    }
+
+    //If the pass gate passed, we can declare success
+    return applyPass;
+}
+
+bool dvmCompilerRunPass (CompilationUnit *cUnit, const char *passName)
+{
+    //Paranoid
+    if (cUnit == 0 || passName == 0)
+    {
+        return false;
+    }
+
+    //Go through all the passes and find the requested pass
+    Pass *pass = gDvmJit.jitFramework.firstPass;
+
+    //To record successful application of a pass
+    bool success = false;
+
+    //Now loop and check the name
+    while (pass != 0 && pass->getName() != "")
+    {
+        //See if the name matches
+        if (strcmp(pass->getName().c_str(), passName) == 0)
+        {
+            success = dvmCompilerRunPass (cUnit, pass);
+
+            //There will be only one matching pass
+            break;
+        }
+
+        //Go to the next pass
+        pass = pass->getNext ();
+    }
+
+    return success;
+}
+
+ /**
+  * @brief The loop
+  * @param cUnit the CompilationUnit
+  */
+void dvmCompilerLaunchPassDriver (CompilationUnit *cUnit)
+{
+    //Go through the different elements
+    Pass *curPass = gDvmJit.jitFramework.firstPass;
+
+    //As long as we have a pass and we haven't decided to quit the loop mode
+    while (curPass->getName () != "" && cUnit->quitLoopMode == false)
+    {
+        //First, did someone want us to skip this pass?
+        //If they did, they used the option -Xjitignorepass:"Pass name"
+        //So if strstr returns something, someone wanted to ignore that pass
+        if (gDvmJit.ignorePasses != 0 && strstr (gDvmJit.ignorePasses, curPass->getName ().c_str ()) != 0)
+        {
+            curPass = curPass->getNext ();
+            continue;
+        }
+
+        //Save the print pass flag because we may be updating it.
+        //At end of pass, we always restore the printPass flag because it is a compilation unit property and we
+        //don't want to leave it permanently changed. For example, someone may enable verbosity by creating a plugin
+        //that changes the printPass flag for just a single trace and not globally.
+        bool oldPrintPass = cUnit->printPass;
+
+        //Now check if this pass is requested for debug. First we check if all passes should be debugged.
+        //Then we check whether just this particular pass should be debugged.
+        if (gDvmJit.debugAllPasses == true
+                || (gDvmJit.debugPasses != 0 && strstr (gDvmJit.debugPasses, curPass->getName ().c_str ()) != 0))
+        {
+            cUnit->printPass = true;
+        }
+
+        //Do we have a general gate defined?
+        bool (*generalGate) (const CompilationUnit *, Pass *) = gDvmJit.jitFramework.generalGate;
+
+        //We suppose we can apply the pass
+        bool applyPass = true;
+
+        //Apply the general gate
+        if (generalGate != 0)
+        {
+            applyPass = generalGate (cUnit, curPass);
+        }
+
+        //If the general gate did not invalidate the pass, continue
+        if (applyPass == true)
+        {
+            //Apply the pass (Ignore the return value of this call)
+            dvmCompilerRunPass (cUnit, curPass);
+        }
+
+        //Now restore the printPass flag. For explanation why we restore it, please see description of when we save.
+        cUnit->printPass = oldPrintPass;
+
+        //Go to next pass
+        curPass = curPass->getNext ();
+    }
+}
+
+bool dvmCompilerTraceIsLoop (const CompilationUnit *cUnit, Pass *curPass)
+{
+    (void) curPass;
+    return cUnit->jitMode == kJitLoop;
+}
+
+bool dvmCompilerTraceIsLoopNewSystem (const CompilationUnit *cUnit, Pass *curPass)
+{
+    (void) curPass;
+    return dvmCompilerTraceIsLoop (cUnit, curPass) && (gDvmJit.oldLoopDetection == false);
+}
+
+bool dvmCompilerTraceIsLoopOldSystem (const CompilationUnit *cUnit, Pass *curPass)
+{
+    (void) curPass;
+    return dvmCompilerTraceIsLoop (cUnit, curPass) && (gDvmJit.oldLoopDetection == true);
+}
+
+void dvmCompilerPrintPassNames (void)
+{
+    //Go through the different elements
+    Pass *curPass = gPasses;
+
+    ALOGI ("Loop Passes are:");
+    //As long as we have a pass and we haven't decided to quit the loop mode
+    while (curPass->getName () != "")
+    {
+        ALOGI ("\t-%s", curPass->getName ().c_str ());
+        curPass = curPass->getNext ();
+    }
+}
+
+void dvmCompilerPrintIgnorePasses (void)
+{
+    //Suppose the worse
+    bool ignoredSomething = false;
+
+    //Go through the different elements
+    Pass *curPass = gPasses;
+    ALOGI ("Ignoring Passes:");
+    //As long as we have a pass and we haven't decided to quit the loop mode
+    while (curPass->getName () != "")
+    {
+        if (gDvmJit.ignorePasses != 0 && strstr (gDvmJit.ignorePasses, curPass->getName ().c_str ()) != 0)
+        {
+            ALOGI ("\t-%s", curPass->getName ().c_str ());
+            //Set flag to true, we are going to ignore something
+            ignoredSomething = true;
+        }
+        curPass = curPass->getNext ();
+    }
+
+    //If nothing got ignored, print out information about it
+    if (ignoredSomething == false)
+    {
+        //Paranoid
+        if (gDvmJit.ignorePasses == 0)
+        {
+            ALOGI ("\tThe ignore pass information is missing, please use -Xjitignorepasses");
+        }
+        else
+        {
+            ALOGI ("\t- Nothing got ignored, you must put in the parameter of -Xjitignorepasses the exact spelling of one of the passes");
+            ALOGI ("\t- Here is what you provided %s", gDvmJit.ignorePasses);
+            ALOGI ("\t- Here are the loop passes for reference:");
+            dvmCompilerPrintPassNames ();
+        }
+    }
+}
+
+
+/**
+ * @brief Helper function to dvmCompilerCheckLoops to check number of exits for each loop
+ * @param info loop information to check
+ * @param data required by interface, not used.
+ */
+static bool exitLoopHelper (LoopInformation *info, void *data)
+{
+    return dvmCountSetBits (info->getExitLoops ()) <= 1;
+}
+
+bool dvmCompilerCheckLoops (const CompilationUnit *cUnit)
+{
+    // Build loop information
+    LoopInformation *loopInfo = LoopInformation::getLoopInformation (const_cast<CompilationUnit *>(cUnit), 0);
+    const_cast<CompilationUnit *>(cUnit)->loopInformation = loopInfo;
+
+    if (loopInfo != 0)
+    {
+        // we are rejecting sibling loops at top level
+        if (loopInfo->getNextSibling () !=0)
+        {
+            const_cast<CompilationUnit *>(cUnit)->quitLoopMode = true;
+            return false;
+        }
+
+        // Check that we have no more than one loop output
+        // Note we are working before loop formation, so exit block is real one
+        if (loopInfo->iterate (exitLoopHelper) == false)
+        {
+            const_cast<CompilationUnit *>(cUnit)->quitLoopMode = true;
+            return false;
+        }
+
+        //If it is nested and option says no, bail
+        if (gDvmJit.nestedLoops == false)
+        {
+            // We do not have sibling so it is enough to check first
+            if (loopInfo->getNested () != 0)
+            {
+                const_cast<CompilationUnit *>(cUnit)->quitLoopMode = true;
+                return false;
+            }
+
+            //Ok second possibility to reject is if we only want simple loops
+            if (gDvmJit.branchLoops == false)
+            {
+                //Now check if we have only one backward branch: to only enable "simple" loops
+                const BitVector *backwards = loopInfo->getBackwardBranches ();
+
+                if (backwards == 0)
+                {
+                    const_cast<CompilationUnit *>(cUnit)->quitLoopMode = true;
+                    return false;
+                }
+
+                if (dvmCountSetBits (backwards) != 1)
+                {
+                    const_cast<CompilationUnit *>(cUnit)->quitLoopMode = true;
+                    return false;
+                }
+
+                //Finally, get the basic block for the backward branch
+                int backwardIdx = dvmHighestBitSet (backwards);
+
+                if (backwardIdx < 0)
+                {
+                    const_cast<CompilationUnit *>(cUnit)->quitLoopMode = true;
+                    return false;
+                }
+
+                BasicBlock *backward = (BasicBlock *) dvmGrowableListGetElement (&cUnit->blockList, backwardIdx);
+
+                //If nil or no domination loopInformation, bail
+                if (backward == 0 || backward->dominators == 0)
+                {
+                    const_cast<CompilationUnit *>(cUnit)->quitLoopMode = true;
+                    return false;
+                }
+
+                //Now go through each BB and see if it dominates backward
+                BitVector *blocks = loopInfo->getBasicBlocks ();
+
+                BitVectorIterator bvIterator;
+                dvmBitVectorIteratorInit(blocks, &bvIterator);
+                for (BasicBlock *bb = dvmCompilerGetNextBasicBlockViaBitVector(bvIterator, cUnit->blockList); bb != 0;
+                        bb = dvmCompilerGetNextBasicBlockViaBitVector(bvIterator, cUnit->blockList))
+                {
+                    if (bb == backward)
+                    {
+                        continue;
+                    }
+
+                    //We bail if it doesn't dominate
+                    if (dvmIsBitSet (backward->dominators, bb->id) == 0)
+                    {
+                        const_cast<CompilationUnit *>(cUnit)->quitLoopMode = true;
+                        return false;
+                    }
+                }
+            }
+        }
+    }
+
+    return true;
+}
+
+/**
+ * @brief Check if the loops are formed the way we want (nested / branches on / off)
+ * @param cUnit the CompilationUnit
+ * @param curPass the current Pass
+ * @return Whether to continue as a loop or bail
+ */
+bool checkLoopsGate (const CompilationUnit *cUnit, Pass *curPass)
+{
+    //Unused parameter
+    (void) curPass;
+
+    return dvmCompilerCheckLoops (cUnit);
+}
+
+bool dvmCompilerCheckReferences (CompilationUnit *cUnit, BasicBlock *bb)
+{
+    //Check all of the MIRs in this basic block
+    for (MIR *mir = bb->firstMIRInsn; mir != 0; mir = mir->next)
+    {
+        bool resolved = dvmCompilerCheckResolvedReferences (cUnit->method, &mir->dalvikInsn,
+                false /*tryToResolve*/);
+
+        if (resolved == false)
+        {
+            //We found an unresolved reference
+            cUnit->quitLoopMode = true;
+
+            //We have not changed the BB
+            return false;
+        }
+    }
+
+    //All references checked are resolved but we have not updated the BB
+    return false;
+}
+
+//Get a given pass
+Pass *dvmCompilerGetPass (const char *name)
+{
+    //Go through the different elements
+    Pass *curPass = gDvmJit.jitFramework.firstPass;
+
+    //Find the pass we care about
+    while (curPass->getName () != "" && curPass->getName () != name)
+    {
+        //Next pass
+        curPass = curPass->getNext ();
+    }
+
+    //If not found
+    if (curPass->getName () == "")
+    {
+        return 0;
+    }
+
+    //Otherwise return the pass
+    return curPass;
+}
+
+//Remove a given pass
+bool dvmCompilerRemovePass (const char *name)
+{
+    //Find the pass
+    Pass *curPass = dvmCompilerGetPass (name);
+
+    //Paranoid: didn't find the name
+    if (curPass == 0)
+    {
+        ALOGI ("\tRemoving a pass could not find the reference pass name, here is what you provided %s", name);
+        ALOGI ("\t- Here are the loop passes for reference:");
+        dvmCompilerPrintPassNames ();
+        return false;
+    }
+
+    Pass *previous = curPass->getPrevious ();
+    Pass *next = curPass->getNext ();
+
+    //Update previous
+    if (previous != 0)
+    {
+        previous->setNext (next);
+    }
+    else
+    {
+        //Update global list otherwise
+        gDvmJit.jitFramework.firstPass = next;
+    }
+
+    //Update next
+    if (next != 0)
+    {
+        next->setPrevious (previous);
+    }
+
+    //Report success
+    return true;
+}
+
+//Insert a user pass
+bool dvmCompilerInsertUserPass (Pass *newPass, const char *name, enum PassInstrumentation mode)
+{
+    //Find the pass
+    Pass *curPass = dvmCompilerGetPass (name);
+
+    //Paranoid: didn't find the name
+    if (curPass == 0)
+    {
+        ALOGI ("Pass Modification could not find the reference pass name, here is what you provided %s", name);
+        ALOGI ("\t- Here are the loop passes for reference:");
+        dvmCompilerPrintPassNames ();
+        return false;
+    }
+
+    //We have the pass reference, what we do now depends on the mode
+    switch (mode)
+    {
+        case kPassInstrumentationReplace:
+            {
+                Pass *previous = curPass->getPrevious ();
+                Pass *next = curPass->getNext ();
+
+                //Update links
+                if (previous != 0)
+                {
+                    previous->setNext (newPass);
+                }
+                else
+                {
+                    gDvmJit.jitFramework.firstPass = curPass;
+                }
+
+                if (next != 0)
+                {
+                    next->setPrevious (newPass);
+                }
+
+                newPass->setNext (next);
+                newPass->setPrevious (previous);
+            }
+            break;
+        case kPassInstrumentationInsertBefore:
+            {
+                Pass *previous = curPass->getPrevious ();
+
+                //Update links
+                newPass->setPrevious (previous);
+                newPass->setNext (curPass);
+
+                //If curPass was the first pass
+                if (previous == 0)
+                {
+                    //Update it now
+                    gDvmJit.jitFramework.firstPass = newPass;
+                }
+                else
+                {
+                    previous->setNext (curPass);
+                }
+
+                curPass->setPrevious (newPass);
+            }
+            break;
+        case kPassInstrumentationInsertAfter:
+            {
+                Pass *next = curPass->getNext ();
+
+                //Update links
+                newPass->setNext (next);
+                newPass->setPrevious (curPass);
+                curPass->setNext (newPass);
+
+                //Handle next
+                if (next != 0)
+                {
+                    next->setPrevious (newPass);
+                }
+            }
+            break;
+        default:
+            break;
+    }
+
+    //Report success
+    return true;
+}
+
+void dvmCompilerSetGeneralGate (bool (*general) (const CompilationUnit *, Pass*))
+{
+    gDvmJit.jitFramework.generalGate = general;
+}
+
+//Replace a given pass gate
+bool dvmCompilerReplaceGate (const char *name, bool (*gate) (const CompilationUnit *, Pass*))
+{
+    //Find the pass
+    Pass *curPass = dvmCompilerGetPass (name);
+
+    //Paranoid: didn't find the name
+    if (curPass == 0)
+    {
+        ALOGI ("Pass Modification could not find the reference pass name, here is what you provided %s", name);
+        ALOGI ("\t- Here are the loop passes for reference:");
+        dvmCompilerPrintPassNames ();
+        return false;
+    }
+
+    //Set the gate
+    curPass->setGate (gate);
+
+    //Report success
+    return true;
+}
+
+bool dvmCompilerReplaceEnd (const char *name, void (*endWork) (CompilationUnit *, Pass*))
+{
+    //Find the pass
+    Pass *curPass = dvmCompilerGetPass (name);
+
+    //Paranoid: didn't find the name
+    if (curPass == 0)
+    {
+        ALOGI ("Pass Modification could not find the reference pass name, here is what you provided %s", name);
+        ALOGI ("\t- Here are the loop passes for reference:");
+        dvmCompilerPrintPassNames ();
+        return false;
+    }
+
+    //Set the end work function
+    curPass->setEndWork (endWork);
+
+    //Report success
+    return true;
+}
+
+//Handle a user plugin
+void dvmCompilerHandleUserPlugin (const char *fileName)
+{
+    //Let us be optimistic
+    bool failure = false;
+
+    //Open the file
+    void *userHandle = dlopen (fileName, RTLD_NOW);
+
+    if (userHandle != 0)
+    {
+        //Open now the init function
+        void *tmp = dlsym (userHandle, "dalvikPluginInit");
+
+        if (tmp == 0)
+        {
+            ALOGD ("Problem with %s, cannot find dalvikPluginInit function\n", fileName);
+
+            //Set failure flag
+            failure = true;
+        }
+        else
+        {
+            //Transform it into a function pointer
+            bool (*pluginInitialization) (void) = (bool (*) (void)) (tmp);
+
+            //Call it
+            failure = (pluginInitialization () == false);
+        }
+    }
+    else
+    {
+        ALOGD ("Problem opening user plugin file %s", fileName);
+        ALOGD ("dlerror() reports %s", dlerror());
+
+        //Set failure flag
+        failure = true;
+    }
+
+    //If the failure flag is on
+    if (failure == true)
+    {
+        //Is the failure on the user plugin fatal?
+        if (gDvmJit.userpluginfatal == true)
+        {
+            dvmAbort ();
+        }
+
+        //Signal we failed loading a plugin
+        gDvmJit.userpluginfailed = true;
+    }
+}
diff --git a/vm/compiler/PassDriver.h b/vm/compiler/PassDriver.h
new file mode 100644
index 0000000..cd0d519
--- /dev/null
+++ b/vm/compiler/PassDriver.h
@@ -0,0 +1,166 @@
+/*
+* Copyright (C) 2012 Intel Corporation
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+*      http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+#ifndef DALVIK_VM_PASSDRIVER_H_
+#define DALVIK_VM_PASSDRIVER_H_
+
+/**
+ * @brief PassInstrumentation allows the user to modify existing passes and add new ones
+ */
+enum PassInstrumentation
+{
+    kPassInstrumentationInsertBefore,   /**< @brief Insert before the Pass */
+    kPassInstrumentationInsertAfter,    /**< @brief Insert after the Pass */
+    kPassInstrumentationReplace,        /**< @brief Replace a Pass */
+};
+
+//Forward Declaration
+struct CompilationUnit;
+class Pass;
+
+/**
+ * @brief Run the pass on the cUnit
+ * @details The pass is run completely, including the gate, pre and post functions
+ * @param cUnit The CompilationUnit to run the pass on
+ * @param pass The Pass which needs to be run
+ * @return Whether the pass could be successfully applied
+ */
+bool dvmCompilerRunPass (CompilationUnit *cUnit, Pass *pass);
+
+/**
+ * @brief Find the pass with the passName and run it with the cUnit
+ * @param cUnit The CompilationUnit to run the pass on
+ * @param passName The name of the pass which should be run
+ * @return Whether the pass could be successfully applied
+ */
+bool dvmCompilerRunPass (CompilationUnit *cUnit, const char *passName);
+
+/**
+  * @brief The loop optimization driver: calls each pass from the gPasses array
+  * @brief The pass driver: calls each pass from the gPasses array
+  * @param cUnit the Compilation Unit
+  */
+void dvmCompilerLaunchPassDriver (CompilationUnit *cUnit);
+
+/**
+  * @brief Is the trace a loop?
+  * @param cUnit the CompilationUnit
+  * @param curPass the Pass
+  * @return whether or not the cUnit represents a loop
+  */
+bool dvmCompilerTraceIsLoop (const CompilationUnit *cUnit, Pass *curPass);
+
+/**
+  * @brief Is the trace a loop formed by the new system?
+  * @param cUnit the CompilationUnit
+  * @param curPass the Pass
+  * @return whether or not the cUnit represents a loop
+  */
+bool dvmCompilerTraceIsLoopNewSystem (const CompilationUnit *cUnit, Pass *curPass);
+
+/**
+  * @brief Is the trace a loop formed by the old system?
+  * @param cUnit the CompilationUnit
+  * @param curPass the Pass
+  * @return whether or not the cUnit represents a loop
+  */
+bool dvmCompilerTraceIsLoopOldSystem (const CompilationUnit *cUnit, Pass *curPass);
+
+/**
+ * @brief Print the pass names
+ */
+void dvmCompilerPrintPassNames (void);
+
+/**
+ * @brief Print the pass names we are going to ignore
+ */
+void dvmCompilerPrintIgnorePasses (void);
+
+/**
+ * @brief Check if the loops are formed the way we want (nested / branches on / off)
+ * @param cUnit the CompilationUnit
+ * @return Whether to continue as a loop or bail
+ */
+bool dvmCompilerCheckLoops (const CompilationUnit *cUnit);
+
+/**
+ * @brief Used to check whether instructions in basic block have resolved references.
+ * @details If unresolved references have been found then cUnit->quitLoopMode is set to true.
+ * @param cUnit The compilation unit
+ * @param bb The basic block whose instructions to check
+ * @return Always returns false because the CFG is not updated
+ */
+bool dvmCompilerCheckReferences (CompilationUnit *cUnit, BasicBlock *bb);
+
+/**
+ * @brief Verify that hoisted checks optimization is applicable
+ * @param cUnit the CompilationUnit
+ * @param curPass the Pass
+ * @return Whether to generate hoisted checks for the loop
+ */
+bool dvmCompilerHoistedChecksGate (const CompilationUnit *cUnit, Pass *curPass);
+
+/**
+ * @brief Remove an optimization Pass
+ * @param name the name of the Pass
+ * @return whether removal was successful
+ */
+bool dvmCompilerRemovePass (const char *name);
+
+/**
+ * @brief Get an optimization pass
+ * @param name the name of the Pass
+ * @return pointer to the Pass, 0 if not found
+ */
+Pass *dvmCompilerGetPass (const char *name);
+
+/**
+ * @brief Used to replace the gate of an optimization pass
+ * @param name the name of the Pass
+ * @param gate the new gate
+ * @return whether the gate replacement was successful
+ */
+bool dvmCompilerReplaceGate (const char *name, bool (*gate) (const CompilationUnit *, Pass*));
+
+/**
+ * @brief Used to replace the end work function of a pass
+ * @param name The name of the Pass to update
+ * @param endWork The new end work function to use
+ * @return Returns true if replacement was successful
+ */
+bool dvmCompilerReplaceEnd (const char *name, void (*endWork) (CompilationUnit *, Pass*));
+
+/**
+ * @brief Insert the user pass
+ * @param newPass the Pass information we want to add/modify
+ * @param name the name of the current pass we want to be adding/modifying
+ * @param mode what we want to do/change
+ * @return whether we succeeded or not
+ */
+bool dvmCompilerInsertUserPass (Pass *newPass, const char *name, enum PassInstrumentation mode);
+
+/**
+ * @brief Handle User Plugin Library
+ * @param fileName the name of the library
+ */
+void dvmCompilerHandleUserPlugin (const char *fileName);
+
+/**
+ * @brief Create the Pass list
+ */
+void dvmCompilerBuildPassList (void);
+
+#endif
diff --git a/vm/compiler/RegisterizationME.cpp b/vm/compiler/RegisterizationME.cpp
index 1cea93a..f705ecc 100644
--- a/vm/compiler/RegisterizationME.cpp
+++ b/vm/compiler/RegisterizationME.cpp
@@ -18,7 +18,7 @@
 #include "Dataflow.h"
 #include "CompilerIR.h"
 #include "LoopInformation.h"
-#include "LoopOpt.h"
+#include "PassDriver.h"
 #include "RegisterizationME.h"
 
 #include <algorithm>
diff --git a/vm/compiler/SinkCastOpt.cpp b/vm/compiler/SinkCastOpt.cpp
index 51c632e..7c69517 100644
--- a/vm/compiler/SinkCastOpt.cpp
+++ b/vm/compiler/SinkCastOpt.cpp
@@ -17,13 +17,13 @@
 #include <set>
 #include <map>
 
+#include "BBOptimization.h"
 #include "Dalvik.h"
 #include "Dataflow.h"
 #include "Loop.h"
 #include "LoopInformation.h"
-#include "LoopOpt.h"
-#include "BBOptimization.h"
 #include "Pass.h"
+#include "PassDriver.h"
 #include "Utility.h"
 #include <set>
 
diff --git a/vm/compiler/Vectorization.cpp b/vm/compiler/Vectorization.cpp
index 1414620..805e3e0 100644
--- a/vm/compiler/Vectorization.cpp
+++ b/vm/compiler/Vectorization.cpp
@@ -22,8 +22,8 @@
 #include "Compiler.h"
 #include "CompilerIR.h"
 #include "Dataflow.h"
-#include "LoopOpt.h"
 #include "Pass.h"
+#include "PassDriver.h"
 #include "Vectorization.h"
 #include "Utility.h"
 
diff --git a/vm/compiler/codegen/x86/pcg/PcgInterface.cpp b/vm/compiler/codegen/x86/pcg/PcgInterface.cpp
index 3b72aff..83cfef4 100644
--- a/vm/compiler/codegen/x86/pcg/PcgInterface.cpp
+++ b/vm/compiler/codegen/x86/pcg/PcgInterface.cpp
@@ -26,10 +26,10 @@
 #include "Lower.h"
 #include "LowerCall.h"
 #include "NcgHelper.h"
+#include "PassDriver.h"
 #include "PersistentInfo.h"
 #include "Singleton.h"
 #include "UtilityPCG.h"
-#include "LoopOpt.h"
 
 /**
  * @brief Return an appropriate ISA string based on gDvmJit configuration
diff --git a/vm/compiler/codegen/x86/pcg/UtilityPCG.cpp b/vm/compiler/codegen/x86/pcg/UtilityPCG.cpp
index d7959f2..6d155b0 100644
--- a/vm/compiler/codegen/x86/pcg/UtilityPCG.cpp
+++ b/vm/compiler/codegen/x86/pcg/UtilityPCG.cpp
@@ -21,8 +21,8 @@
 #include "Dataflow.h"
 #include "Labels.h"
 #include "LowerMemory.h"
-#include "LoopOpt.h"
 #include "LowerOther.h"
+#include "PassDriver.h"
 #include "PersistentInfo.h"
 #include "Singleton.h"
 #include "UtilityPCG.h"
-- 
1.7.4.1

