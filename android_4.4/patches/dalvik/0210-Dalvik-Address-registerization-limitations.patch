From 5802489d92adda814c7177fdf7e3817a1014bfd8 Mon Sep 17 00:00:00 2001
From: Razvan A Lupusoru <razvan.a.lupusoru@intel.com>
Date: Tue, 4 Jun 2013 16:16:03 -0700
Subject: Dalvik: Address registerization limitations

BZ: 104880

- Compile table has been updated into a class in order to eliminate global
array accesses. Having it as a class allows it to manage its own size and
easily provide accessor methods and iterators.
- Usage of DVMDEX entry in compile table was deprecated code but it was still
being tracked. This prevented registerization from resetting compile table
when it no longer needed the entries.
- Imm to register moves are now supported for handling state transition.
- Whenever parent must satisfy a child associations but doesn't have an
entry in compile table one is created now. This allows correct passing of
information.
- Registerization requests are no longer satisfied when there are no more free
registers. The registerization priority from middle-end is respected.
- Registerized VRs are used as def at entry into BB in order to correctly
determine type transfers.

Category: device-enablement
Domain: AOSP-Dalvik-Compiler-CG; AOSP-Dalvik-Runtime
Origin: internal
Upstream-Candidate: no, needs rework

Change-Id: I4096209422c94fdc2d1546120e953de3b55c5100
Orig-MCG-Change-Id: Ia517ccc7e02b5e3d637b86dc9307c2a5144f3c97
Signed-off-by: Razvan A Lupusoru <razvan.a.lupusoru@intel.com>
Signed-off-by: Qiming Shi <qiming.shi@intel.com>
Signed-off-by: Serguei Katkov <serguei.i.katkov@intel.com>
---
 vm/Dvm.mk                                         |    1 +
 vm/compiler/codegen/x86/AnalysisO1.cpp            | 1365 +++++++++------------
 vm/compiler/codegen/x86/AnalysisO1.h              |  324 +----
 vm/compiler/codegen/x86/BytecodeVisitor.cpp       |  784 +++++++------
 vm/compiler/codegen/x86/CodegenErrors.cpp         |    1 +
 vm/compiler/codegen/x86/CodegenErrors.h           |    2 +
 vm/compiler/codegen/x86/CodegenInterface.cpp      |   67 +-
 vm/compiler/codegen/x86/CompileTable.cpp          |   99 ++
 vm/compiler/codegen/x86/CompileTable.h            |  502 ++++++++
 vm/compiler/codegen/x86/InstructionGeneration.cpp |  154 ++-
 vm/compiler/codegen/x86/InstructionGeneration.h   |   27 +-
 vm/compiler/codegen/x86/Lower.cpp                 |   56 +-
 vm/compiler/codegen/x86/Lower.h                   |   31 +-
 vm/compiler/codegen/x86/LowerHelper.cpp           |  108 +--
 vm/compiler/codegen/x86/LowerJump.cpp             |   41 +-
 vm/compiler/codegen/x86/RegisterizationBE.cpp     |  415 ++++---
 vm/compiler/codegen/x86/libenc/enc_wrapper.cpp    |    7 -
 vm/compiler/codegen/x86/libenc/enc_wrapper.h      |   39 +-
 18 files changed, 2254 insertions(+), 1769 deletions(-)
 create mode 100644 vm/compiler/codegen/x86/CompileTable.cpp
 create mode 100644 vm/compiler/codegen/x86/CompileTable.h

diff --git a/vm/Dvm.mk b/vm/Dvm.mk
index 4bc2286..0e9fec1 100644
--- a/vm/Dvm.mk
+++ b/vm/Dvm.mk
@@ -358,6 +358,7 @@ ifeq ($(dvm_arch),x86)
               compiler/codegen/$(dvm_arch_variant)/CodegenErrors.cpp \
               compiler/codegen/$(dvm_arch_variant)/RegisterizationBE.cpp \
               compiler/codegen/$(dvm_arch_variant)/StackExtensionX86.cpp \
+              compiler/codegen/$(dvm_arch_variant)/CompileTable.cpp \
               compiler/codegen/$(dvm_arch_variant)/x86Specific.cpp \
               compiler/codegen/$(dvm_arch_variant)/Profile.cpp \
               compiler/LoopOpt.cpp \
diff --git a/vm/compiler/codegen/x86/AnalysisO1.cpp b/vm/compiler/codegen/x86/AnalysisO1.cpp
index 7ca48d6..21386bf 100644
--- a/vm/compiler/codegen/x86/AnalysisO1.cpp
+++ b/vm/compiler/codegen/x86/AnalysisO1.cpp
@@ -55,26 +55,41 @@
 #define DEBUG_SPILL(X)
 
 #include "AnalysisO1.h"
+#include "CompileTable.h"
 
 void dumpCompileTable();
 
-/* There are 3 kinds of variables that are handled in this file:
-   1> virtual register (isVirtualReg())
-   2> temporary (!isVirtualReg() && regNum < PhysicalReg_GLUE_DVMDEX)
-   3> glue variables: regNum >= PhysicalReg_GLUE_DVMDEX
-*/
-
 /**
  * @brief Check whether a type is a virtual register type
- * @param type the type of the register
+ * @param type the logical type of the register
  * @return whether type is a virtual register or not
  */
 bool isVirtualReg(int type) {
     return ((type & LowOpndRegType_virtual) != 0);
 }
 
-bool isTemporary(int type, int regNum) {
-    return (!isVirtualReg(type) && regNum < PhysicalReg_GLUE_DVMDEX);
+/**
+ * @brief Check whether the logical type represents a temporary
+ * @param type the logical type of the register
+ * @return Returns true if we are looking at a temporary, scratch, or hardcoded register.
+ */
+bool isTemporary (int type, int regNum)
+{
+    return (isVirtualReg (type) == false);
+}
+
+/**
+ * @brief Given a physical register it determines if it is scratch type.
+ * @param reg The physical register.
+ * @return Returns whether the register is scratch
+ */
+static bool isScratchReg (int reg)
+{
+    //A register is a scratch register if its physical type is one of the scratch ones
+    bool isScratch = (reg >= static_cast<int> (PhysicalReg_SCRATCH_1)
+            && reg <= static_cast<int> (PhysicalReg_SCRATCH_10));
+
+    return isScratch;
 }
 
 /** convert type defined in lowering module to type defined in register allocator
@@ -87,8 +102,10 @@ int convertType(int type, int reg, bool isPhysical) {
     if(isVirtualReg(type)) newType |= LowOpndRegType_virtual;
     else {
         /* reg number for a VR can exceed PhysicalReg_SCRATCH_1 */
-        if(reg >= PhysicalReg_SCRATCH_1 && reg < PhysicalReg_GLUE_DVMDEX)
+        if(isScratchReg (reg) == true)
+        {
             newType |= LowOpndRegType_scratch;
+        }
     }
     return newType;
 }
@@ -187,21 +204,13 @@ bool isAFullyCoverB(int regA, LowOpndRegType tA, int regB, LowOpndRegType tB) {
 //! one entry for each variable used
 
 //! a variable can be virtual register, or a temporary (can be hard-coded)
-CompileTableEntry compileTable[COMPILE_TABLE_SIZE];
-int num_compile_entries;
+CompileTable compileTable;
 //! tables to save the states of register allocation
-regAllocStateEntry1 stateTable1_1[COMPILE_TABLE_SIZE];
-regAllocStateEntry1 stateTable1_2[COMPILE_TABLE_SIZE];
-regAllocStateEntry1 stateTable1_3[COMPILE_TABLE_SIZE];
-regAllocStateEntry1 stateTable1_4[COMPILE_TABLE_SIZE];
-regAllocStateEntry2 stateTable2_1[COMPILE_TABLE_SIZE];
-regAllocStateEntry2 stateTable2_2[COMPILE_TABLE_SIZE];
-regAllocStateEntry2 stateTable2_3[COMPILE_TABLE_SIZE];
-regAllocStateEntry2 stateTable2_4[COMPILE_TABLE_SIZE];
-
-//! array of VirtualRegInfo to store VRs accessed by a single bytecode
-VirtualRegInfo infoByteCode[MAX_REG_PER_BYTECODE];
-int num_regs_per_bytecode;
+regAllocStateEntry2 stateTable2_1[NUM_MEM_VR_ENTRY];
+regAllocStateEntry2 stateTable2_2[NUM_MEM_VR_ENTRY];
+regAllocStateEntry2 stateTable2_3[NUM_MEM_VR_ENTRY];
+regAllocStateEntry2 stateTable2_4[NUM_MEM_VR_ENTRY];
+
 //! array of TempRegInfo to store temporaries accessed by a single bytecode
 TempRegInfo infoByteCodeTemp[MAX_TEMP_REG_PER_BYTECODE];
 int num_temp_regs_per_bytecode;
@@ -214,18 +223,10 @@ CompilationUnit* currentUnit = NULL;
 //! the current basic block
 BasicBlock_O1* currentBB = NULL;
 //! array of RegisterInfo for all the physical registers
-RegisterInfo allRegs[PhysicalReg_GLUE+1]; //initialized in codeGen
-
-VirtualRegInfo currentInfo;
-VirtualRegInfo tmpInfo;
+RegisterInfo allRegs[PhysicalReg_Last]; //initialized in codeGen
 
 //! this array says whether a spill location is used (0 means not used, 1 means used)
 int spillIndexUsed[MAX_SPILL_JIT_IA];
-int indexForGlue = -1;
-
-int num_bbs_for_method;
-//! array of basic blocks in a method in program order
-BasicBlock_O1* method_bbs_sorted[MAX_NUM_BBS_PER_METHOD];
 
 int inGetVR_num = -1;
 int inGetVR_type;
@@ -235,24 +236,25 @@ int inGetVR_type;
 void addExceptionHandler(s4 tmp);
 
 int createCFG(Method* method);
-int collectInfoOfBasicBlock(Method* method, BasicBlock_O1* bb);
 void dumpVirtualInfoOfBasicBlock(BasicBlock_O1* bb);
 void setTypeOfVR();
-void insertGlueReg();
 void dumpVirtualInfoOfMethod();
 int codeGenBasicBlock(const Method* method, BasicBlock_O1* bb);
 
 //used in collectInfoOfBasicBlock: getVirtualRegInfo
-int mergeEntry2(BasicBlock_O1* bb);
+int mergeEntry2 (BasicBlock_O1* bb, VirtualRegInfo &currentInfo);
 int sortAllocConstraint(RegAllocConstraint* allocConstraints,
                         RegAllocConstraint* allocConstraintsSorted, bool fromHighToLow);
 
 //Updates compile table with information about virtual register usage
-static int insertFromVirtualInfo (VirtualRegInfo &regInfo);
+static void insertFromVirtualInfo (const VirtualRegInfo &regInfo);
 
-int insertFromTempInfo(int k); //update compileTable
-int updateXferPoints(void);
-static int updateLiveTable();
+//Updates compile table with information about temporary usage
+static void insertFromTempInfo (const TempRegInfo &tempRegInfo);
+
+static int updateXferPoints (BasicBlock_O1 *bb);
+static int updateLiveTable (BasicBlock_O1 *bb);
+static void handleStartOfBBXferPoints (BasicBlock_O1 *bb);
 void printDefUseTable();
 bool isFirstOfHandler(BasicBlock_O1* bb);
 
@@ -263,18 +265,18 @@ RegAccessType updateAccess1(RegAccessType A, OverlapCase isAPartiallyOverlapB);
 RegAccessType updateAccess2(RegAccessType C1, RegAccessType C2);
 RegAccessType updateAccess3(RegAccessType C, RegAccessType B);
 
-void updateDefUseTable();
-static int updateReachingDefA(int indexToA, OverlapCase isBPartiallyOverlapA);
-static int updateReachingDefB1(int indexToA);
-static int updateReachingDefB2();
-void updateReachingDefB3();
+void updateDefUseTable (VirtualRegInfo &currentInfo);
+static int updateReachingDefA (VirtualRegInfo &currentInfo, int indexToA, OverlapCase isBPartiallyOverlapA);
+static int updateReachingDefB1 (VirtualRegInfo &currentInfo, VirtualRegInfo &tmpInfo, int indexToA);
+static int updateReachingDefB2 (VirtualRegInfo &currentInfo, VirtualRegInfo &tmpInfo);
+void updateReachingDefB3 (VirtualRegInfo &currentInfo);
 
 RegAccessType insertAUse(DefUsePair* ptr, int offsetPC, int regNum, LowOpndRegType physicalType);
-DefUsePair* insertADef(int offsetPC, int regNum, LowOpndRegType pType, RegAccessType rType);
-RegAccessType insertDefUsePair(int reachingDefIndex);
+DefUsePair* insertADef(BasicBlock_O1 *bb, int offsetPC, int regNum, LowOpndRegType pType, RegAccessType rType);
+RegAccessType insertDefUsePair (VirtualRegInfo &currentInfo, int reachingDefIndex);
 
 //used in updateXferPoints
-int fakeUsageAtEndOfBB(BasicBlock_O1* bb);
+int fakeUsageAtEndOfBB (BasicBlock_O1* bb, int vR, int physicalAndLogicalType);
 static int insertLoadXfer(int offset, int regNum, LowOpndRegType pType);
 int searchMemTable(int regNum);
 static int mergeLiveRange(int tableIndex, int rangeStart, int rangeEnd);
@@ -339,7 +341,7 @@ void syncAllRegs() {
             continue;
         //check whether the physical register is used by any logical register
         bool stillUsed = false;
-        for(k2 = 0; k2 < num_compile_entries; k2++) {
+        for(k2 = 0; k2 < compileTable.size (); k2++) {
             if(compileTable[k2].physicalReg == k) {
                 stillUsed = true;
                 break;
@@ -361,26 +363,33 @@ void syncAllRegs() {
 /**
  * @brief Looks through all physical registers and determines what is used
  * @param outFreeRegisters is a set that is updated with the unused physical registers
+ * @param includeGPs Whether or not to include general purpose registers
+ * @param includeXMMs Whether or not to include XMM registers
  */
-void findFreeRegisters(std::set<PhysicalReg> & outFreeRegisters) {
-    // Go through all GPs
-    for (int reg = PhysicalReg_StartOfGPMarker;
-            reg <= PhysicalReg_EndOfGPMarker; reg++) {
-        // If it is one of the unusable registers, continue
-        if (reg == PhysicalReg_EDI || reg == PhysicalReg_ESP
-                || reg == PhysicalReg_EBP)
-            continue;
-
-        if (allRegs[reg].isUsed == false) {
-            outFreeRegisters.insert(static_cast<PhysicalReg>(reg));
+void findFreeRegisters (std::set<PhysicalReg> &outFreeRegisters, bool includeGPs, bool includeXMMs)
+{
+    if (includeGPs == true)
+    {
+        // Go through all GPs
+        for (int reg = PhysicalReg_StartOfGPMarker; reg <= PhysicalReg_EndOfGPMarker; reg++)
+        {
+            //If it is not used, then we can add it to the list of free registers
+            if (allRegs[reg].isUsed == false)
+            {
+                outFreeRegisters.insert (static_cast<PhysicalReg> (reg));
+            }
         }
     }
 
-    // Go through all XMMs
-    for (int reg = PhysicalReg_StartOfXmmMarker;
-            reg <= PhysicalReg_EndOfXmmMarker; reg++) {
-        if (allRegs[reg].isUsed == false) {
-            outFreeRegisters.insert(static_cast<PhysicalReg>(reg));
+    if (includeXMMs == true)
+    {
+        // Go through all XMMs
+        for (int reg = PhysicalReg_StartOfXmmMarker; reg <= PhysicalReg_EndOfXmmMarker; reg++)
+        {
+            if (allRegs[reg].isUsed == false)
+            {
+                outFreeRegisters.insert (static_cast<PhysicalReg> (reg));
+            }
         }
     }
 }
@@ -392,8 +401,7 @@ void findFreeRegisters(std::set<PhysicalReg> & outFreeRegisters) {
  * @param type xmm or gp
  * @return physical register which can be used as scratch
  */
-PhysicalReg getScratch(std::set<PhysicalReg> & scratchCandidates,
-        LowOpndRegType type) {
+PhysicalReg getScratch(const std::set<PhysicalReg> &scratchCandidates, LowOpndRegType type) {
     if (type != LowOpndRegType_gp && type != LowOpndRegType_xmm) {
         return PhysicalReg_Null;
     }
@@ -453,7 +461,7 @@ static int updateSpillIndexUsed(void) {
     }
 
     /* Second: go through each compile entry */
-    for(k = 0; k < num_compile_entries; k++) {
+    for(k = 0; k < compileTable.size (); k++) {
         /** If it is a virtual register, we skip it, we don't need a special spill region for VRs */
         if(isVirtualReg(compileTable[k].physicalType)) {
             continue;
@@ -477,15 +485,6 @@ static int updateSpillIndexUsed(void) {
     return 0;
 }
 
-/* free memory used in all basic blocks */
-void freeCFG(void) {
-    int k;
-    for(k = 0; k < num_bbs_for_method; k++) {
-        //Call the BasicBlock_O1 clear function
-        method_bbs_sorted[k]->freeIt ();
-    }
-}
-
 /**
  * @brief Inserts high VR entries into compile table.
  * @details Looks through compile table and for all wide VRs it finds, it ensures that an entry exists for the
@@ -494,7 +493,7 @@ void freeCFG(void) {
  */
 static bool addHighOfWideVRToCompileTable (void)
 {
-    for (int entry = 0; entry < num_compile_entries; entry++)
+    for (int entry = 0; entry < compileTable.size (); entry++)
     {
         //We only need to do the correction for wide VRs
         if (compileTable[entry].isVirtualReg () == false)
@@ -514,22 +513,11 @@ static bool addHighOfWideVRToCompileTable (void)
             //If we don't have an entry for the high bits, we insert it now.
             if (indexHigh < 0)
             {
-                //If we exceed size of table, we must throw an error
-                if (num_compile_entries >= COMPILE_TABLE_SIZE)
-                {
-                    ALOGI("JIT_INFO: compileTable overflow at addHighOfWideVRToCompileTable");
-                    SET_JIT_ERROR(kJitErrorRegAllocFailed);
-                    return false;
-                }
-
-                //Let's insert at end of table
-                indexHigh = num_compile_entries++;
-
                 //Create a new entry for the high VR. Since we just care about 32-bits we make it GP type
                 CompileTableEntry newEntry (highVR, LowOpndRegType_virtual | LowOpndRegType_gp);
 
                 //We now copy it to the table
-                compileTable[indexHigh] = newEntry;
+                compileTable.insert (newEntry);
             }
         }
     }
@@ -566,6 +554,62 @@ void MemoryVRInfo::reset (void)
 }
 
 /**
+ * @brief Updates the table that keeps the in memory state of VRs to contain new VR.
+ * @param vR The virtual register
+ * @param inMemory The initial inMemory state
+ * @return Returns whether the VR's addition was successful.
+ */
+bool addToMemVRTable (int vR, bool inMemory)
+{
+    //We want to keep track of index in memory table
+    int index = 0;
+
+    //Search mem table for the virtual register we are interested in adding
+    for (; index < num_memory_vr; index++)
+    {
+        if (memVRTable[index].regNum == vR)
+        {
+            break;
+        }
+    }
+
+    //If the index is not the size of table, then it means we have found an entry
+    if (index != num_memory_vr)
+    {
+        //We already have entry for this VR so simply update its memory state
+        memVRTable[index].setInMemoryState (inMemory);
+    }
+    else
+    {
+        //Let's make sure we won't overflow the table if we make this insertion
+        if (num_memory_vr >= NUM_MEM_VR_ENTRY)
+        {
+            ALOGI("JIT_INFO: Index %d exceeds size of memVRTable during addToMemVRTable\n", num_memory_vr);
+            SET_JIT_ERROR(kJitErrorRegAllocFailed);
+            return false;
+        }
+
+        //Create the new entry
+        MemoryVRInfo memInfo (vR);
+
+        //Now set the in memory state for our new entry
+        memInfo.setInMemoryState (inMemory);
+
+        //We access the index at end of the table
+        index = num_memory_vr;
+
+        //We are adding an entry so increment the number of entries
+        num_memory_vr++;
+
+        //Finally add it to the table
+        memVRTable[index] = memInfo;
+    }
+
+    //If we made it here everything went well
+    return true;
+}
+
+/**
  * @brief Initializes the in memory tracking table for virtual registers.
  * @param bb The basic block which we are looking at for initialization.
  * @return Returns true if all initialization completed successfully. Otherwise it returns false.
@@ -577,7 +621,7 @@ static bool initializeMemVRTable (BasicBlock_O1 *bb)
 
     //Now walk through compile entries so we can track in memory state for every VR.
     //For wide VRs, the compile table must guarantee an entry for both the low and high VR.
-    for(int entry = 0; entry < num_compile_entries; entry++)
+    for(int entry = 0; entry < compileTable.size (); entry++)
     {
         //We can skip any entry that is not a virtual register
         if (compileTable[entry].isVirtualReg () == false)
@@ -588,52 +632,18 @@ static bool initializeMemVRTable (BasicBlock_O1 *bb)
         //Make it easier to refer to the VR number
         int vR = compileTable[entry].getRegisterNumber ();
 
-        //Now we want to figure out if we need to make an entry for the VR to keep
-        //track of its inMemory state.
-        bool alreadyInserted = false;
-        for (int memEntry = 0; memEntry < num_memory_vr; memEntry++)
-        {
-            //If we find an entry, we must have already inserted since we reset table at
-            //the beginning of this function
-            if (memVRTable[memEntry].getVirtualRegister () == vR)
-            {
-                alreadyInserted = true;
-                break;
-            }
-        }
+        //Determine if parent said that the VR was in memory
+        bool setToInMemory = bb->associationTable.wasVRInMemory (vR);
 
-        //If we have already inserted this, we can continue
-        if (alreadyInserted == true)
-        {
-            continue;
-        }
+        //Now let's add it to the table
+        bool result = addToMemVRTable (vR, setToInMemory);
 
-        //Let's make sure we won't overflow the table if we make this insertion
-        if (num_memory_vr >= NUM_MEM_VR_ENTRY)
+        if (result == false)
         {
-            ALOGI("JIT_INFO: Index %d exceeds size of memVRTable\n", num_memory_vr);
-            SET_JIT_ERROR(kJitErrorRegAllocFailed);
+            //We simply pass along failure since addToMemVRTable has already set error code
             return false;
         }
 
-        //We know we have an entry in the table by the time we get here so simply get a reference to it
-        MemoryVRInfo &memInfo = memVRTable[num_memory_vr];
-
-        //We are adding an entry so increment the number of entries
-        num_memory_vr++;
-
-        //Initialize fields for this entry
-        memInfo.reset ();
-
-        //Set the virtual register for this entry
-        memInfo.setVirtualRegister (vR);
-
-        //Determine if parent said that the VR was in memory
-        bool setToInMemory = bb->associationTable.wasVRInMemory (vR);
-
-        //Now set the in memory state for our new entry
-        memInfo.setInMemoryState (setToInMemory);
-
         DEBUG_MEMORYVR(ALOGD("Initializing state of v%d %sin memory",
                 vR, (setToInMemory ? "" : "NOT ")));
     }
@@ -654,7 +664,7 @@ static bool initializeConstVRTable (BasicBlock_O1 *bb)
 
     //Now walk through compile entries so we can track the constantness for every VR.
     //For wide VRs, the compile table must guarantee an entry for both the low and high VR.
-    for (int entry = 0; entry < num_compile_entries; entry++)
+    for (int entry = 0; entry < compileTable.size (); entry++)
     {
         //We can skip any entry that is not a virtual register
         if (compileTable[entry].isVirtualReg () == false)
@@ -693,21 +703,93 @@ static bool initializeConstVRTable (BasicBlock_O1 *bb)
 }
 
 /**
+ * @brief Used to add registerized virtual registers as defined at entry into basic block
+ */
+static bool initializeRegisterizeDefs (BasicBlock_O1* bb)
+{
+    //Walk through the compile entries
+    for (CompileTable::const_iterator it = compileTable.begin (); it != compileTable.end (); it++)
+    {
+        const CompileTableEntry &compileEntry = *it;
+
+        //Did we find a virtual register that is in physical register? If yes then we must add a def for it
+        if (compileEntry.isVirtualReg () == true && compileEntry.inPhysicalRegister() == true)
+        {
+            //Add a def for this virtual register coming into the BB
+            VirtualRegInfo regDefineInfo;
+            regDefineInfo.regNum = compileEntry.getRegisterNumber ();
+            regDefineInfo.physicalType = compileEntry.getPhysicalType ();
+            regDefineInfo.accessType = REGACCESS_D;
+            offsetPC = PC_FOR_START_OF_BB;
+
+            //Now add it to the defuse tables
+            int res = mergeEntry2 (bb, regDefineInfo);
+
+            if (res < 0)
+            {
+                //We just pass along the error information
+                return false;
+            }
+        }
+    }
+
+    //If we made it here everything went okay
+    return true;
+}
+
+/**
  * @brief Initializes entries in the compile table at start of BB.
  * @details It ensures that it updates compile table based on the given associations from its parent.
  * @param bb The basic block whose virtual register state should be initialized.
  * @return Returns true if all initialization completed successfully. Otherwise it returns false.
  */
-static bool initializeRegStateOfBB(BasicBlock_O1* bb)
+static bool initializeRegStateOfBB (BasicBlock_O1* bb)
 {
     assert (bb != 0);
 
+    //First we clear the compile table
+    compileTable.clear ();
+
     //Load associations into compile table
     if (AssociationTable::syncCompileTableWithAssociations (bb->associationTable) == false)
     {
         return false;
     }
 
+    //Since we loaded associations into compile table now we may have virtual registers that are
+    //in physical registers. Thus we set up defines of all those VRs at entry to the BB.
+    if (initializeRegisterizeDefs (bb) == false)
+    {
+        //Just pass along error information
+        return false;
+    }
+
+    //Collect information about the virtual registers in current BB
+    collectInfoOfBasicBlock (bb);
+
+    //Update compileTable with virtual register information from current BB
+    for (std::vector<VirtualRegInfo>::const_iterator vrInfoIter = bb->infoBasicBlock.begin ();
+            vrInfoIter != bb->infoBasicBlock.end (); vrInfoIter++)
+    {
+        insertFromVirtualInfo (*vrInfoIter);
+    }
+
+    //For each virtual register, we insert fake usage at end of basic block to keep it live
+    for (CompileTable::const_iterator tableIter = compileTable.begin (); tableIter != compileTable.end (); tableIter++)
+    {
+        //Get the compile entry
+        const CompileTableEntry &compileEntry = *tableIter;
+
+        if (compileEntry.isVirtualReg ())
+        {
+            //Calling fakeUsageAtEndOfBB uses offsetPC so we switch it to point to end of basic block
+            offsetPC = PC_FOR_END_OF_BB;
+
+            //Update the defUseTable by assuming a fake usage at end of basic block
+            fakeUsageAtEndOfBB (bb, compileEntry.getRegisterNumber (), compileEntry.getLogicalAndPhysicalTypes ());
+        }
+    }
+
     //Ensure that we also have an entry in compile table for high bits of a VR
     if (addHighOfWideVRToCompileTable () == false)
     {
@@ -726,15 +808,8 @@ static bool initializeRegStateOfBB(BasicBlock_O1* bb)
         return false;
     }
 
-    for (int k = 0; k < num_compile_entries; k++)
-    {
-        if(compileTable[k].regNum != PhysicalReg_GLUE &&
-           compileTable[k].regNum >= PhysicalReg_GLUE_DVMDEX) {
-            /* glue related registers */
-            compileTable[k].setPhysicalReg (PhysicalReg_Null);
-            compileTable[k].spill_loc_index = -1;
-        }
-    }
+    //Now let's make sure we synchronize all registers being used
+    syncAllRegs ();
 
     return true;
 }
@@ -785,9 +860,6 @@ void BasicBlock_O1::clear (bool allocateLabel)
     streamStart = 0;
     defUseTable = 0;
     defUseTail = 0;
-    num_defs = 0;
-    endsWithReturn = 0;
-    hasAccessToGlue = 0;
     defUseTail = 0;
 
     //Clear the vectors
@@ -1081,100 +1153,17 @@ static void parseBlock (CompilationUnit *cUnit, BasicBlock *bb)
 
 /**
  * @brief Pre-process BasicBlocks
- * @details The function registers the BasicBlock in the method_bbs_sorted
- *  It checks the number of BasicBlocks can be handled by the back-end
- *  It then also collects information about the BasicBlock such as virtual register usage
- *  Finally, it parses the block to perform some pre-code generation tasks
- * @param cUnit the BasicBlock
+ * @details This parses the block to perform some pre-code generation tasks
+ * @param cUnit the Compilation Unit
  * @param bb the BasicBlock
  * @return -1 if error happened, 0 otherwise
  */
-int preprocessingBB(CompilationUnit *cUnit, BasicBlock* bb) {
-    // We should have already created the x86 specific BB
-    currentBB = reinterpret_cast<BasicBlock_O1 *> (bb);
-
-    if (currentBB == NULL) {
-        ALOGI("JIT_INFO: BB null at preprocessingBB");
-        SET_JIT_ERROR(kJitErrorTraceFormation);
-        return -1;
-    }
-
-    // Keep track of this newly created BB_O1
-    method_bbs_sorted[num_bbs_for_method] = currentBB;
-    num_bbs_for_method++;
-
-    if (num_bbs_for_method >= MAX_NUM_BBS_PER_METHOD) {
-        ALOGI("JIT_INFO: Exceeded maximum number of basic blocks\n");
-        SET_JIT_ERROR(kJitErrorTraceFormation);
-        return -1;
-    }
-
-    // If BB does not have any bytecode we do not need to collect
-    // any information about it
-    if (bb->firstMIRInsn == NULL)
-    {
-        return 0;
-    }
-
-    int retCode = collectInfoOfBasicBlock(currentMethod, currentBB);
-    if (retCode < 0) {
-        return retCode;
-    }
-
-#ifdef DEBUG_COMPILE_TABLE
-    dumpVirtualInfoOfBasicBlock(currentBB);
-#endif
-
+int preprocessingBB (CompilationUnit *cUnit, BasicBlock* bb)
+{
     //Parse the BasicBlock, we might have some pre work to do
     parseBlock (cUnit, bb);
 
-    currentBB = NULL;
-    return 0;
-}
-
-/**
- * @brief Perform some preprocessing when getting a trace
- * @return -1 on error, 0 on success
- */
-int preprocessingTrace(void) {
-    int k, k2;
-    int retCode = 0;
-
-    /* insert a glue-related register GLUE_DVMDEX to compileTable */
-    insertGlueReg();
-
-    int compile_entries_old = num_compile_entries;
-    for(k2 = 0; k2 < num_bbs_for_method; k2++) {
-        currentBB = method_bbs_sorted[k2];
-        unsigned int max = method_bbs_sorted[k2]->infoBasicBlock.size ();
-        /* update compileTable with virtual register from currentBB */
-        for(unsigned int k3 = 0; k3 < max; k3++) {
-            retCode = insertFromVirtualInfo (currentBB->infoBasicBlock[k3]);
-            if (retCode < 0)
-                return retCode;
-        }
-
-        /* for each GL|GG type VR, insert fake usage at end of basic block to keep it live */
-        int offsetPC_back = offsetPC;
-        offsetPC = PC_FOR_END_OF_BB;
-        for(k = 0; k < num_compile_entries; k++) {
-            currentInfo.regNum = compileTable[k].regNum;
-            currentInfo.physicalType = (LowOpndRegType)compileTable[k].physicalType;
-            if(isVirtualReg(compileTable[k].physicalType)) {
-                /* update defUseTable by assuming a fake usage at END of a basic block for variable @ currentInfo */
-                fakeUsageAtEndOfBB(currentBB);
-            }
-        }
-        offsetPC = offsetPC_back;
-        num_compile_entries = compile_entries_old;
-    }
-    /* initialize data structure allRegs */
-    initializeAllRegs();
-#ifdef DEBUG_COMPILE_TABLE
-    dumpCompileTable();
-#endif
-
-    currentBB = NULL;
+    //Everything went well
     return 0;
 }
 
@@ -1183,12 +1172,14 @@ void printJitTraceInfoAtRunTime(const Method* method, int offset) {
 }
 
 void startOfTraceO1(const Method* method, int exceptionBlockId, CompilationUnit *cUnit) {
-    num_compile_entries = 0;
+    compileTable.clear ();
     currentBB = NULL;
-    num_bbs_for_method = 0;
     currentUnit = cUnit;
     lowOpTimeStamp = 0;
 
+    /* initialize data structure allRegs */
+    initializeAllRegs();
+
 // dumpDebuggingInfo is gone in CompilationUnit struct
 #if 0
     /* add code to dump debugging information */
@@ -1214,56 +1205,38 @@ void startOfTraceO1(const Method* method, int exceptionBlockId, CompilationUnit
        BasicBlock_O1 defined in o1 */
 int codeGenBasicBlockJit(const Method* method, BasicBlock* bb) {
     lowOpTimeStamp = 0; //reset time stamp at start of a basic block
-    int cg_ret = 0;
 
     // For x86, the BasicBlock should be the specialized one
-    currentBB = reinterpret_cast<BasicBlock_O1 *>(bb);
+    currentBB = reinterpret_cast<BasicBlock_O1 *> (bb);
 
     // Basic block here also means new native basic block
     if (gDvmJit.scheduling)
-        singletonPtr<Scheduler>()->signalEndOfNativeBasicBlock();
+    {
+        singletonPtr<Scheduler> ()->signalEndOfNativeBasicBlock ();
+    }
 
     // Finalize this block's association table because we are generating
     // it and thus any parent of it that hasn't been generated yet must
     // be aware of this fact.
     currentBB->associationTable.finalize ();
 
-    // If basic block does not have any MIRs, we do not need to generate
-    // code for the MIRs. However, let's make sure to update its association
-    // table. Also, it might need to update register/memory state before it
-    // it goes into the next BB.
-    if (currentBB->firstMIRInsn == NULL) {
-        // Sync compile table with associations
-        if (initializeRegStateOfBB(currentBB) == false)
-            return -1;
-
-        // Assert because a BB with no MIRs has no way to branch to two BBs
-        assert (currentBB->taken == NULL);
-
-        if (AssociationTable::createOrSyncTable(currentBB, true) == false)
-            return -1;
-
-        // FIXME This is a workaround to reset compile table after processing
-        // an empty BB. This leaves the GLUE_DVMDEX entry still in table.
-        num_compile_entries = 1;
-    } else {
-        cg_ret = codeGenBasicBlock(method, currentBB);
-    }
+    // Generate code for this basic block
+    int result = codeGenBasicBlock (method, currentBB);
 
     // End of managed basic block means end of native basic block
     if (gDvmJit.scheduling)
-        singletonPtr<Scheduler>()->signalEndOfNativeBasicBlock();
+    {
+        singletonPtr<Scheduler> ()->signalEndOfNativeBasicBlock ();
+    }
 
     currentBB = NULL;
-    return cg_ret;
+
+    return result;
 }
 void endOfBasicBlock(BasicBlock* bb) {
     isScratchPhysical = true;
     currentBB = NULL;
 }
-void endOfTraceO1() {
-     freeCFG();
-}
 
 /**
  * @brief decide if skip the extended Op whose implementation uses NcgO0 mode
@@ -1271,7 +1244,9 @@ void endOfTraceO1() {
  * @return return false if the opcode doesn't use NcgO0, otherwise return true
  */
 bool skipExtendedMir(Opcode opc) {
-    switch (opc) {
+    ExtendedMIROpcode extendedOpCode = static_cast<ExtendedMIROpcode> (opc);
+
+    switch (extendedOpCode) {
         case kMirOpRegisterize:
         case kMirOpDualDoubleDivide:
             return false;
@@ -1286,7 +1261,8 @@ bool skipExtendedMir(Opcode opc) {
 
     Global variables accessed: offsetPC, rPC
 */
-int collectInfoOfBasicBlock(Method* method, BasicBlock_O1* bb) {
+int collectInfoOfBasicBlock (BasicBlock_O1* bb)
+{
     int seqNum = 0;
     /* traverse the MIR in basic block
        sequence number is used to make sure next bytecode will have a larger sequence number */
@@ -1300,33 +1276,18 @@ int collectInfoOfBasicBlock(Method* method, BasicBlock_O1* bb) {
             continue;
         }
 
-        Opcode inst_op = mir->dalvikInsn.opcode;
-        /* update bb->hasAccessToGlue */
-        if((inst_op >= OP_MOVE_RESULT && inst_op <= OP_RETURN_OBJECT) ||
-           (inst_op >= OP_MONITOR_ENTER && inst_op <= OP_INSTANCE_OF) ||
-           (inst_op == OP_FILLED_NEW_ARRAY) ||
-           (inst_op == OP_FILLED_NEW_ARRAY_RANGE) ||
-           (inst_op == OP_THROW) ||
-           (inst_op >= OP_INVOKE_VIRTUAL && inst_op <= OP_INVOKE_INTERFACE_RANGE) ||
-           (inst_op >= OP_THROW_VERIFICATION_ERROR &&
-            inst_op <= OP_EXECUTE_INLINE_RANGE) ||
-           (inst_op >= OP_INVOKE_VIRTUAL_QUICK && inst_op <= OP_INVOKE_SUPER_QUICK_RANGE))
-            bb->hasAccessToGlue = true;
-        /* update bb->endsWithReturn */
-        if(inst_op == OP_RETURN_VOID || inst_op == OP_RETURN || inst_op == OP_RETURN_VOID_BARRIER ||
-           inst_op == OP_RETURN_OBJECT || inst_op == OP_RETURN_WIDE)
-            bb->endsWithReturn = true;
-
-        /* get virtual register usage in current bytecode */
-        getVirtualRegInfo(infoByteCode, mir);
-        int num_regs = num_regs_per_bytecode;
-        for(int kk = 0; kk < num_regs; kk++) {
-            currentInfo = infoByteCode[kk];
+        //Get information about the VRs in current bytecode
+        VirtualRegInfo infoByteCode[MAX_REG_PER_BYTECODE];
+        int numVRs = getVirtualRegInfo (infoByteCode, mir, true);
+
+        for(int kk = 0; kk < numVRs; kk++) {
+            //Make a copy of current bytecode
+            VirtualRegInfo currentInfo = infoByteCode[kk];
 #ifdef DEBUG_MERGE_ENTRY
             ALOGI("Call mergeEntry2 at offsetPC %x kk %d VR %d %d\n", offsetPC, kk,
                   currentInfo.regNum, currentInfo.physicalType);
 #endif
-            int retCode = mergeEntry2(bb); //update defUseTable of the basic block
+            int retCode = mergeEntry2(bb, currentInfo); //update defUseTable of the basic block
             if (retCode < 0)
                 return retCode;
         }
@@ -1396,8 +1357,9 @@ static bool shouldRejectBasicBlock(BasicBlock_O1* bb) {
             continue;
         }
 
-        // Get VR usage for bytecode
-        int numVRs = getVirtualRegInfo(infoByteCode, mir);
+        //Get information about the VRs in current bytecode
+        VirtualRegInfo infoByteCode[MAX_REG_PER_BYTECODE];
+        int numVRs = getVirtualRegInfo (infoByteCode, mir);
 
         // Go through each VR of the MIR
         for (int vrIter = 0; vrIter < numVRs; vrIter++) {
@@ -1446,57 +1408,75 @@ static bool shouldRejectBasicBlock(BasicBlock_O1* bb) {
 */
 int codeGenBasicBlock(const Method* method, BasicBlock_O1* bb)
 {
-    //Eagerly set retCode to 0 since most likely everythign will be okay
+    //Eagerly set retCode to 0 since most likely everything will be okay
     int retCode = 0;
 
-    /* update compileTable with entries in bb->infoBasicBlock */
-    int k, max;
-    max = bb->infoBasicBlock.size ();
-    for(k = 0; k < max; k++) {
-        retCode = insertFromVirtualInfo (bb->infoBasicBlock[k]);
-        if (retCode < 0)
-            return retCode;
-    }
-    retCode = updateXferPoints(); //call fakeUsageAtEndOfBB
-    if (retCode < 0)
-        return retCode;
+    //We have no MIRs if first MIR pointer is null
+    bool noMirs = (currentBB->firstMIRInsn == NULL);
 
     // If we should reject the BB, return that it has not been handled
-    if (shouldRejectBasicBlock(bb) == true)
+    if (shouldRejectBasicBlock (bb) == true)
+    {
+        //If rejected, an error message will have been set so we just pass along the error
         return -1;
-
-#ifdef DEBUG_REACHING_DEF
-    printDefUseTable();
-#endif
-#ifdef DEBUG_COMPILE_TABLE
-    ALOGI("At start of basic block %d (num of VRs %d) -------", bb->bb_index, bb->infoBasicBlock.size ());
-    dumpCompileTable();
-#endif
+    }
 
     //We have already loaded the information about VR from each bytecode in this basic block.
     //Thus we are now ready to finish initializing virtual register state.
-    if (initializeRegStateOfBB(bb) == false)
+    if (initializeRegStateOfBB (bb) == false)
     {
         return -1;
     }
 
-    retCode = updateLiveTable();
-    if (retCode < 0)
-        return retCode;
-    freeReg(false);  //before code gen of a basic block, also called at end of a basic block?
+    //If we do have MIRs, we must update the transfer points and the live table
+    if (noMirs == false)
+    {
+        //Now we update any transfer points between virtual registers that are represented by different types
+        //throughout this same BB
+        retCode = updateXferPoints (bb);
+
+        if (retCode < 0)
+        {
+            //Someone else has set the error so we just pass it along
+            return retCode;
+        }
+
+        //Since we have set up the transfer points, check to see if there are any points at the start of the BB
+        //so that we can handle them right now.
+        handleStartOfBBXferPoints (bb);
+
+        retCode = updateLiveTable (bb);
+
+        if (retCode < 0)
+        {
+            //Someone else has set the error so we just pass it along
+            return retCode;
+        }
+    }
+
+#ifdef DEBUG_REACHING_DEF
+    printDefUseTable();
+#endif
+
 #ifdef DEBUG_COMPILE_TABLE
     ALOGI("At start of basic block %d (num of VRs %d) -------", bb->bb_index, bb->infoBasicBlock.size ());
+    dumpCompileTable();
 #endif
 
+    //Assume that the last bytecode in this block is not a jump unless proven otherwise
     bool lastByteCodeIsJump = false;
-    for(MIR * mir = bb->firstMIRInsn; mir; mir = mir->next) {
+
+    //Now walk through the bytecodes to generate code for each
+    for (MIR * mir = bb->firstMIRInsn; mir; mir = mir->next)
+    {
+        int k;
         offsetPC = mir->seqNum;
         rPC = const_cast<u2 *>(method->insns) + mir->offset;
 
         // Handle extended MIRs whose implementation uses NcgO0 mode
         if ( isExtendedMir(mir->dalvikInsn.opcode) == true &&
              skipExtendedMir(mir->dalvikInsn.opcode) == true) {
-            handleExtendedMIR(currentUnit, mir);
+            handleExtendedMIR (currentUnit, bb, mir);
             // The rest of logic is for handling mirs that use NCG01 so
             // we can safely skip
             continue;
@@ -1506,19 +1486,11 @@ int codeGenBasicBlock(const Method* method, BasicBlock_O1* bb)
         num_temp_regs_per_bytecode = getTempRegInfo(infoByteCodeTemp, mir);
         for(k = 0; k < num_temp_regs_per_bytecode; k++) {
             if(infoByteCodeTemp[k].versionNum > 0) continue;
-            retCode = insertFromTempInfo(k);
-            if (retCode < 0)
-                return retCode;
+            insertFromTempInfo (infoByteCodeTemp[k]);
         }
         startNativeCode(-1, -1);
         for(k = 0; k <= MAX_SPILL_JIT_IA - 1; k++) spillIndexUsed[k] = 0;
-        //update spillIndexUsed if a glue variable was spilled
-        for(k = 0; k < num_compile_entries; k++) {
-            if(compileTable[k].regNum >= PhysicalReg_GLUE_DVMDEX) {
-                if(compileTable[k].spill_loc_index >= 0)
-                    spillIndexUsed[compileTable[k].spill_loc_index >> 2] = 1;
-            }
-        }
+
 #ifdef DEBUG_COMPILE_TABLE
         ALOGI("compile table size after importing temporary info %d", num_compile_entries);
         ALOGI("before one bytecode %d (num of VRs %d) -------", bb->bb_index, bb->infoBasicBlock.size ());
@@ -1535,16 +1507,19 @@ int codeGenBasicBlock(const Method* method, BasicBlock_O1* bb)
             return retCode;
         //otherwise, bytecode does not generate a constant
 
-        getVirtualRegInfo(infoByteCode, mir);
+        //Get information about the VRs in current bytecode
+        VirtualRegInfo infoByteCode[MAX_REG_PER_BYTECODE];
+        int numVRs = getVirtualRegInfo (infoByteCode, mir);
+
         //call something similar to mergeEntry2, but only update refCount
         //clear refCount
-        for(k = 0; k < num_regs_per_bytecode; k++) {
+        for(k = 0; k < numVRs; k++) {
             int indexT = searchCompileTable(LowOpndRegType_virtual | infoByteCode[k].physicalType,
                                             infoByteCode[k].regNum);
             if(indexT >= 0)
                 compileTable[indexT].refCount = 0;
         }
-        for(k = 0; k < num_regs_per_bytecode; k++) {
+        for(k = 0; k < numVRs; k++) {
             int indexT = searchCompileTable(LowOpndRegType_virtual | infoByteCode[k].physicalType,
                                             infoByteCode[k].regNum);
             if(indexT >= 0)
@@ -1560,11 +1535,17 @@ int codeGenBasicBlock(const Method* method, BasicBlock_O1* bb)
             if (isCurrentByteCodeJump(mir->dalvikInsn.opcode))
                 lastByteCodeIsJump = true;
 
-            bool notHandled = false;
+            //We eagerly assume we don't handle unless proven otherwise.
+            bool notHandled = true;
+
             if ((int) mir->dalvikInsn.opcode >= (int) kMirOpFirst)
-                handleExtendedMIR(currentUnit, mir);
+            {
+                notHandled = (handleExtendedMIR (currentUnit, bb, mir) == false);
+            }
             else
+            {
                 notHandled = lowerByteCodeJit(method, mir, rPC);
+            }
 
             if(gDvmJit.codeCacheByteUsed + (stream - streamStart) +
                  CODE_CACHE_PADDING > gDvmJit.codeCacheSize) {
@@ -1590,8 +1571,8 @@ int codeGenBasicBlock(const Method* method, BasicBlock_O1* bb)
             freeReg(false); //may dump GL VR to memory (this is necessary)
 
             //after each bytecode, make sure non-VRs have refCount of zero
-            for(k = 0; k < num_compile_entries; k++) {
-                if(isTemporary(compileTable[k].physicalType, compileTable[k].regNum)) {
+            for(k = 0; k < compileTable.size (); k++) {
+                if(compileTable[k].isTemporary ()) {
 #ifdef PRINT_WARNING
                     if(compileTable[k].refCount > 0) {
                         ALOGW("refCount for a temporary reg %d %d is %d after a bytecode", compileTable[k].regNum, compileTable[k].physicalType, compileTable[k].refCount);
@@ -1613,53 +1594,38 @@ int codeGenBasicBlock(const Method* method, BasicBlock_O1* bb)
         ALOGI("After one bytecode BB %d (num of VRs %d)", bb->bb_index, bb->infoBasicBlock.size ());
 #endif
     }//for each bytecode
+
 #ifdef DEBUG_COMPILE_TABLE
     dumpCompileTable();
 #endif
 
-    //at end of a basic block, get spilled GG VR & dump GL VR
-    retCode = handleVRsEndOfBB(lastByteCodeIsJump);
-    if (retCode < 0) {
+    //At the end of a basic block we want to handle VR information. If the BB ended with
+    //jump or switch, then we have nothing to handle because it has already been handled
+    //in the corresponding jumping bytecode.
+    retCode = handleRegistersEndOfBB (lastByteCodeIsJump == false);
+
+    if (retCode < 0)
+    {
+        //Just pass along error information
         return retCode;
     }
 
-    //remove entries for temporary registers, L VR and GL VR
-    for(k = 0; k < num_compile_entries; ) {
-        bool removeEntry = false;
-        if(isVirtualReg(compileTable[k].physicalType)) {
-            removeEntry = true;
-        }
-        if(isTemporary(compileTable[k].physicalType, compileTable[k].regNum))
-            removeEntry = true;
-        if(removeEntry) {
-#ifdef PRINT_WARNING
-            if(compileTable[k].refCount > 0)
-                ALOGW("refCount for REG %d %d is %d at end of a basic block", compileTable[k].regNum, compileTable[k].physicalType, compileTable[k].refCount);
-#endif
-            compileTable[k].refCount = 0;
-            for(int jj = k+1; jj < num_compile_entries; jj++) {
-                compileTable[jj-1] = compileTable[jj];
-            }
-            num_compile_entries--;
-        } else {
-            k++;
-        }
-    }
-    freeReg(false);
-    //free LIVE TABLE
-    for(k = 0; k < num_memory_vr; k++) {
+    // We are done with compile table so clear it now
+    compileTable.clear ();
+
+    //Free live table
+    for (int k = 0; k < num_memory_vr; k++)
+    {
         LiveRange* ptr2 = memVRTable[k].ranges;
-        while(ptr2 != NULL) {
+        while (ptr2 != NULL)
+        {
             LiveRange* tmpP = ptr2->next;
-            free(ptr2->accessPC);
-            free(ptr2);
+            free (ptr2->accessPC);
+            free (ptr2);
             ptr2 = tmpP;
         }
     }
-#ifdef DEBUG_COMPILE_TABLE
-    ALOGI("At end of basic block -------");
-    dumpCompileTable();
-#endif
+
     return 0;
 }
 
@@ -1674,7 +1640,8 @@ int codeGenBasicBlock(const Method* method, BasicBlock_O1* bb)
     if accessType of B is U or UD, we call updateReachingDefB to update currentInfo.reachingDefs
         in order to correctly insert the usage to defUseTable
 */
-int mergeEntry2(BasicBlock_O1* bb) {
+int mergeEntry2 (BasicBlock_O1* bb, VirtualRegInfo &currentInfo)
+{
     LowOpndRegType typeB = currentInfo.physicalType;
     int regB = currentInfo.regNum;
     int jj, k;
@@ -1700,8 +1667,8 @@ int mergeEntry2(BasicBlock_O1* bb) {
             currentInfo.num_reaching_defs = bb->infoBasicBlock[jj].num_reaching_defs;
             for(k = 0; k < currentInfo.num_reaching_defs; k++)
                 currentInfo.reachingDefs[k] = bb->infoBasicBlock[jj].reachingDefs[k];
-            updateDefUseTable(); //use currentInfo to update defUseTable
-            int retCode = updateReachingDefA(jj, OVERLAP_B_COVER_A); //update reachingDefs of A
+            updateDefUseTable (currentInfo); //use currentInfo to update defUseTable
+            int retCode = updateReachingDefA (currentInfo, jj, OVERLAP_B_COVER_A); //update reachingDefs of A
             if (retCode < 0)
                 return -1;
             isMerged = true;
@@ -1722,15 +1689,17 @@ int mergeEntry2(BasicBlock_O1* bb) {
 #endif
             hasAlias = true;
             if(currentInfo.accessType == REGACCESS_U || currentInfo.accessType == REGACCESS_UD) {
+                VirtualRegInfo tmpInfo;
+
                 /* update currentInfo.reachingDefs */
-                int retCode = updateReachingDefB1(jj);
+                int retCode = updateReachingDefB1 (currentInfo, tmpInfo, jj);
                 if (retCode < 0)
                     return retCode;
-                retCode = updateReachingDefB2();
+                retCode = updateReachingDefB2 (currentInfo, tmpInfo);
                 if (retCode < 0)
                     return retCode;
             }
-            int retCode = updateReachingDefA(jj, isBPartiallyOverlapA);
+            int retCode = updateReachingDefA (currentInfo, jj, isBPartiallyOverlapA);
             if (retCode < 0)
                 return retCode;
         }
@@ -1738,7 +1707,7 @@ int mergeEntry2(BasicBlock_O1* bb) {
             //even if B does not overlap with A, B can affect the reaching defs of A
             //for example, B is a def of "v0", A is "v1"
             //  B can kill some reaching defs of A or affect the accessType of a reaching def
-            int retCode = updateReachingDefA(jj, OVERLAP_NO); //update reachingDefs of A
+            int retCode = updateReachingDefA (currentInfo, jj, OVERLAP_NO); //update reachingDefs of A
             if (retCode < 0)
                 return -1;
         }
@@ -1761,8 +1730,8 @@ int mergeEntry2(BasicBlock_O1* bb) {
 #ifdef DEBUG_MERGE_ENTRY
         ALOGI("isMerged is false, call updateDefUseTable");
 #endif
-        updateDefUseTable(); //use currentInfo to update defUseTable
-        updateReachingDefB3(); //update currentInfo.reachingDefs if currentInfo defines variable B
+        updateDefUseTable (currentInfo); //use currentInfo to update defUseTable
+        updateReachingDefB3 (currentInfo); //update currentInfo.reachingDefs if currentInfo defines variable B
 
         //copy from currentInfo.reachingDefs to info
         info.num_reaching_defs = currentInfo.num_reaching_defs;
@@ -1792,7 +1761,8 @@ int mergeEntry2(BasicBlock_O1* bb) {
 //! \param indexToA Index of variable A
 //! \param isBPartiallyOverlapA the type of overlap
 //! \return -1 if error, 0 otherwise
-static int updateReachingDefA(int indexToA, OverlapCase isBPartiallyOverlapA) {
+static int updateReachingDefA (VirtualRegInfo &currentInfo, int indexToA, OverlapCase isBPartiallyOverlapA)
+{
     if(indexToA < 0) return 0;
     int k, k2;
     OverlapCase isBPartiallyOverlapDef;
@@ -1908,7 +1878,8 @@ static int updateReachingDefA(int indexToA, OverlapCase isBPartiallyOverlapA) {
 //! The result is stored in tmpInfo.reachingDefs
 //! \param indexToA Index of variable A
 //! \return -1 if error, 0 otherwise
-static int updateReachingDefB1(int indexToA) {
+static int updateReachingDefB1 (VirtualRegInfo &currentInfo, VirtualRegInfo &tmpInfo, int indexToA)
+{
     if(indexToA < 0) return 0;
     int k;
     tmpInfo.num_reaching_defs = 0;
@@ -1965,7 +1936,8 @@ static int updateReachingDefB1(int indexToA) {
 //! \details update currentInfo.reachingDefs by merging
 //! currentInfo.reachingDefs with tmpInfo.reachingDefs
 //! \return -1 if error, 0 otherwise
-static int updateReachingDefB2(void) {
+static int updateReachingDefB2 (VirtualRegInfo &currentInfo, VirtualRegInfo &tmpInfo)
+{
     int k, k2;
     for(k2 = 0; k2 < tmpInfo.num_reaching_defs; k2++ ) {
         bool merged = false;
@@ -2006,7 +1978,8 @@ static int updateReachingDefB2(void) {
 //!update currentInfo.reachingDefs with currentInfo if variable is defined in currentInfo
 
 //!
-void updateReachingDefB3() {
+void updateReachingDefB3 (VirtualRegInfo &currentInfo)
+{
     if(currentInfo.accessType == REGACCESS_U) {
         return; //no need to update currentInfo.reachingDefs
     }
@@ -2019,13 +1992,14 @@ void updateReachingDefB3() {
 
 /** update defUseTable by checking currentInfo
 */
-void updateDefUseTable() {
+void updateDefUseTable (VirtualRegInfo &currentInfo)
+{
     /* no access */
     if(currentInfo.accessType == REGACCESS_N) return;
     /* define then use, or define only */
     if(currentInfo.accessType == REGACCESS_DU || currentInfo.accessType == REGACCESS_D) {
         /* insert a definition at offsetPC to variable @ currentInfo */
-        DefUsePair* ptr = insertADef(offsetPC, currentInfo.regNum, currentInfo.physicalType, REGACCESS_D);
+        DefUsePair* ptr = insertADef(currentBB, offsetPC, currentInfo.regNum, currentInfo.physicalType, REGACCESS_D);
         if(currentInfo.accessType != REGACCESS_D) {
              /* if access is define then use, insert a use at offsetPC */
             insertAUse(ptr, offsetPC, currentInfo.regNum, currentInfo.physicalType);
@@ -2038,7 +2012,7 @@ void updateDefUseTable() {
     bool isLCovered = false, isHCovered = false, isDCovered = false;
     for(k = 0; k < currentInfo.num_reaching_defs; k++) {
         /* insert a def currentInfo.reachingDefs[k] and a use of variable at offsetPC */
-        RegAccessType useType = insertDefUsePair(k);
+        RegAccessType useType = insertDefUsePair (currentInfo, k);
         if(useType == REGACCESS_D) isDCovered = true;
         if(useType == REGACCESS_L) isLCovered = true;
         if(useType == REGACCESS_H) isHCovered = true;
@@ -2047,16 +2021,16 @@ void updateDefUseTable() {
     if((!isDCovered) && (!isLCovered)) {
         /* the low half of variable is not defined in the basic block
            so insert a def to the low half at START of the basic block */
-        insertDefUsePair(-1);
+        insertDefUsePair(currentInfo, -1);
     }
     if(useSize == OpndSize_64 && (!isDCovered) && (!isHCovered)) {
         /* the high half of variable is not defined in the basic block
            so insert a def to the high half at START of the basic block */
-        insertDefUsePair(-2);
+        insertDefUsePair(currentInfo, -2);
     }
     if(currentInfo.accessType == REGACCESS_UD) {
         /* insert a def at offsetPC to variable @ currentInfo */
-        insertADef(offsetPC, currentInfo.regNum, currentInfo.physicalType, REGACCESS_D);
+        insertADef(currentBB, offsetPC, currentInfo.regNum, currentInfo.physicalType, REGACCESS_D);
         return;
     }
 }
@@ -2103,13 +2077,16 @@ RegAccessType insertAUse(DefUsePair* ptr, int offsetPC, int regNum, LowOpndRegTy
 //! \param pType Physical type
 //! \param rType Register access type
 //! \return DefUsePair
-DefUsePair* insertADef(int offsetPC, int regNum, LowOpndRegType pType, RegAccessType rType) {
+DefUsePair* insertADef (BasicBlock_O1 *bb, int offsetPC, int regNum, LowOpndRegType pType, RegAccessType rType)
+{
     DefUsePair* ptr = (DefUsePair*)malloc(sizeof(DefUsePair));
     if(ptr == NULL) {
         ALOGI("JIT_INFO: Memory allocation failed at insertADef");
         SET_JIT_ERROR(kJitErrorMallocFailed);
         return NULL;
     }
+
+    //First initialize the information we keep for defuse
     ptr->next = NULL;
     ptr->def.offsetPC = offsetPC;
     ptr->def.regNum = regNum;
@@ -2118,13 +2095,21 @@ DefUsePair* insertADef(int offsetPC, int regNum, LowOpndRegType pType, RegAccess
     ptr->num_uses = 0;
     ptr->useTail = NULL;
     ptr->uses = NULL;
-    if(currentBB->defUseTail != NULL) {
-        currentBB->defUseTail->next = ptr;
+
+    //Now add this to the end of our defUse chain
+    if (bb->defUseTail != NULL)
+    {
+        bb->defUseTail->next = ptr;
     }
-    currentBB->defUseTail = ptr;
-    if(currentBB->defUseTable == NULL)
-        currentBB->defUseTable = ptr;
-    currentBB->num_defs++;
+
+    bb->defUseTail = ptr;
+
+    //If this is the first entry, we must make the start point to it
+    if (bb->defUseTable == NULL)
+    {
+        bb->defUseTable = ptr;
+    }
+
 #ifdef DEBUG_REACHING_DEF
     ALOGI("Insert a def at %d to defUseTable for VR %d %d", offsetPC,
           regNum, pType);
@@ -2137,7 +2122,8 @@ DefUsePair* insertADef(int offsetPC, int regNum, LowOpndRegType pType, RegAccess
     if reachingDefIndex is -1, the low half is defined at START of the basic block
     if reachingDefIndex is -2, the high half is defined at START of the basic block
 */
-RegAccessType insertDefUsePair(int reachingDefIndex) {
+RegAccessType insertDefUsePair (VirtualRegInfo &currentInfo, int reachingDefIndex)
+{
     int k = reachingDefIndex;
     DefUsePair* tableIndex = NULL;
     DefOrUse theDef;
@@ -2157,7 +2143,7 @@ RegAccessType insertDefUsePair(int reachingDefIndex) {
     }
     tableIndex = searchDefUseTable(theDef.offsetPC, theDef.regNum, theDef.physicalType);
     if(tableIndex == NULL) //insert an entry
-        tableIndex = insertADef(theDef.offsetPC, theDef.regNum, theDef.physicalType, theDef.accessType);
+        tableIndex = insertADef(currentBB, theDef.offsetPC, theDef.regNum, theDef.physicalType, theDef.accessType);
     else
         tableIndex->def.accessType = theDef.accessType;
     RegAccessType useType = insertAUse(tableIndex, offsetPC, currentInfo.regNum, currentInfo.physicalType);
@@ -2213,7 +2199,17 @@ static int insertLoadXfer(int offset, int regNum, LowOpndRegType pType) {
             update reaching defs of B by checking reaching defs of variable A
     update defUseTable
 */
-int fakeUsageAtEndOfBB(BasicBlock_O1* bb) {
+int fakeUsageAtEndOfBB (BasicBlock_O1* bb, int vR, int physicalAndLogicalType)
+{
+    VirtualRegInfo currentInfo;
+
+    //Get the register number
+    currentInfo.regNum = vR;
+
+    //TODO The cast here is invalid because it creates an invalid LowOpndRegType.
+    //However, this invalidity seems to be required for properly creating usedef chains.
+    currentInfo.physicalType = static_cast<LowOpndRegType> (physicalAndLogicalType);
+
     currentInfo.accessType = REGACCESS_U;
     LowOpndRegType typeB = currentInfo.physicalType;
     int regB = currentInfo.regNum;
@@ -2233,18 +2229,20 @@ int fakeUsageAtEndOfBB(BasicBlock_O1* bb) {
             break;
         }
         else if(isBPartiallyOverlapA != OVERLAP_NO) {
+            VirtualRegInfo tmpInfo;
+
             /* B overlaps with A */
             /* update reaching defs of variable B by checking reaching defs of bb->infoBasicBlock[jj] */
-            int retCode = updateReachingDefB1(jj);
+            int retCode = updateReachingDefB1 (currentInfo, tmpInfo, jj);
             if (retCode < 0)
                 return retCode;
-            retCode = updateReachingDefB2(); //merge currentInfo with tmpInfo
+            retCode = updateReachingDefB2 (currentInfo, tmpInfo); //merge currentInfo with tmpInfo
             if (retCode < 0)
                 return retCode;
         }
     }
     /* update defUseTable by checking currentInfo */
-    updateDefUseTable();
+    updateDefUseTable (currentInfo);
     return 0;
 }
 
@@ -2252,12 +2250,13 @@ int fakeUsageAtEndOfBB(BasicBlock_O1* bb) {
  * @brief Update xferPoints of currentBB
  * @return -1 on error, 0 otherwise
 */
-int updateXferPoints(void) {
+int updateXferPoints (BasicBlock_O1 *bb)
+{
     //First clear the XferPoints
-    currentBB->xferPoints.clear ();
+    bb->xferPoints.clear ();
 
     //Get a local version of defUseTable
-    DefUsePair* ptr = currentBB->defUseTable;
+    DefUsePair* ptr = bb->defUseTable;
 
     /* Traverse the def-use chain of the basic block */
     while(ptr != NULL) {
@@ -2317,14 +2316,14 @@ int updateXferPoints(void) {
                 }
                 point.tableIndex = 0;
 #ifdef DEBUG_XFER_POINTS
-                ALOGI("Insert XFER %d at def %d: V%d %d", currentBB->xferPoints.size (), ptr->def.offsetPC, ptr->def.regNum, defType);
+                ALOGI("Insert XFER %d at def %d: V%d %d", bb->xferPoints.size (), ptr->def.offsetPC, ptr->def.regNum, defType);
 #endif
 
                 //Push new point
-                currentBB->xferPoints.push_back (point);
+                bb->xferPoints.push_back (point);
 
-                if(currentBB->xferPoints.size () >= MAX_XFER_PER_BB) {
-                    ALOGI("JIT_INFO: Number of transfer points (%d) exceed maximum (%d)", currentBB->xferPoints.size (), MAX_XFER_PER_BB);
+                if(bb->xferPoints.size () >= MAX_XFER_PER_BB) {
+                    ALOGI("JIT_INFO: Number of transfer points (%d) exceed maximum (%d)", bb->xferPoints.size (), MAX_XFER_PER_BB);
                     SET_JIT_ERROR(kJitErrorMaxXferPoints);
                     return -1;
                 }
@@ -2419,13 +2418,13 @@ int updateXferPoints(void) {
             }
             point.tableIndex = 0;
 #ifdef DEBUG_XFER_POINTS
-            ALOGI("Insert XFER %d at def %d: V%d %d", currentBB->xferPoints.size (), ptr->def.offsetPC, ptr->def.regNum, defType);
+            ALOGI("Insert XFER %d at def %d: V%d %d", bb->xferPoints.size (), ptr->def.offsetPC, ptr->def.regNum, defType);
 #endif
             //Push new point
-            currentBB->xferPoints.push_back (point);
+            bb->xferPoints.push_back (point);
 
-            if(currentBB->xferPoints.size () >= MAX_XFER_PER_BB) {
-                ALOGI("JIT_INFO: Number of transfer points (%d) exceed maximum (%d)", currentBB->xferPoints.size (), MAX_XFER_PER_BB);
+            if(bb->xferPoints.size () >= MAX_XFER_PER_BB) {
+                ALOGI("JIT_INFO: Number of transfer points (%d) exceed maximum (%d)", bb->xferPoints.size (), MAX_XFER_PER_BB);
                 SET_JIT_ERROR(kJitErrorMaxXferPoints);
                 return -1;
             }
@@ -2437,13 +2436,13 @@ int updateXferPoints(void) {
 
 #ifdef DEBUG_XFER_POINTS
     ALOGI("XFER points for current basic block ------");
-    unsigned int max = currentBB->xferPoints.size ();
+    unsigned int max = bb->xferPoints.size ();
     for(unsigned int k = 0; k < max; k++) {
         ALOGI("  at offset %x, VR %d %d: type %d, vr_gpl %d, vr_gph %d, dumpToMem %d, dumpToXmm %d",
-              currentBB->xferPoints[k].offsetPC, currentBB->xferPoints[k].regNum,
-              currentBB->xferPoints[k].physicalType, currentBB->xferPoints[k].xtype,
-              currentBB->xferPoints[k].vr_gpl, currentBB->xferPoints[k].vr_gph,
-              currentBB->xferPoints[k].dumpToMem, currentBB->xferPoints[k].dumpToXmm);
+              bb->xferPoints[k].offsetPC, bb->xferPoints[k].regNum,
+              bb->xferPoints[k].physicalType, bb->xferPoints[k].xtype,
+              bb->xferPoints[k].vr_gpl, bb->xferPoints[k].vr_gph,
+              bb->xferPoints[k].dumpToMem, bb->xferPoints[k].dumpToXmm);
     }
 #endif
 
@@ -2451,6 +2450,46 @@ int updateXferPoints(void) {
     return 0;
 }
 
+/**
+ * @brief Used to handle type transfer points at the start of the BB
+ * @param bb The current basic block
+ */
+void handleStartOfBBXferPoints (BasicBlock_O1 *bb)
+{
+    //Walk through the BB's transfer points
+    for (std::vector<XferPoint>::const_iterator xferIter = bb->xferPoints.begin (); xferIter != bb->xferPoints.end ();
+            xferIter++)
+    {
+        const XferPoint &transfer = *xferIter;
+
+        //If we have a transfer of VR defined at start of BB and the transfer involves storing back to memory
+        //then we handle it right now.
+        if (transfer.offsetPC == PC_FOR_START_OF_BB
+                && (transfer.xtype == XFER_DEF_TO_MEM
+                        || transfer.xtype == XFER_DEF_TO_GP_MEM
+                        || transfer.xtype == XFER_DEF_IS_XMM))
+        {
+            int vR = transfer.regNum;
+
+            //Look through compile table to find the physical register for this VR
+            for (CompileTable::iterator compileIter = compileTable.begin (); compileIter != compileTable.end ();
+                    compileIter++)
+            {
+                CompileTableEntry &compileEntry = *compileIter;
+
+                //We found what we're looking for when we find the VR we care about in a physical register
+                if (compileEntry.isVirtualReg () == true
+                        && compileEntry.getRegisterNumber () == vR
+                        && compileEntry.inPhysicalRegister( ) == true)
+                {
+                    //Write back the VR to memory
+                    writeBackVR (vR, compileEntry.getPhysicalType (), compileEntry.getPhysicalReg ());
+                }
+            }
+        }
+    }
+}
+
 /* @brief update memVRTable[].ranges by browsing the defUseTable
  *
  * @details each virtual register has a list of live ranges, and
@@ -2458,9 +2497,10 @@ int updateXferPoints(void) {
  *
  * @return -1 if error happened, 0 otherwise
  */
-static int updateLiveTable(void) {
+int updateLiveTable (BasicBlock_O1 *bb)
+{
     int retCode = 0;
-    DefUsePair* ptr = currentBB->defUseTable;
+    DefUsePair* ptr = bb->defUseTable;
     while(ptr != NULL) {
         bool updateUse = false;
         if(ptr->num_uses == 0) {
@@ -2745,9 +2785,8 @@ void insertAccess(int tableIndex, LiveRange* startP, int rangeStart) {
 }
 
 /////////////////////////////////////////////////////////////////////
-void setVRToMemory(int regNum, OpndSize size);
 bool isVRLive(int vA);
-int getSpillIndex(bool isGLUE, OpndSize size);
+int getSpillIndex (OpndSize size);
 void clearVRToMemory(int regNum, OpndSize size);
 void clearVRNullCheck(int regNum, OpndSize size);
 
@@ -2829,7 +2868,7 @@ void writeBackConstVR(int vR, int value) {
     set_VR_to_imm_noalloc(vR, OpndSize_32, value);
 
     // Mark the VR as in memory now
-    setVRToMemory(vR, OpndSize_32);
+    setVRMemoryState(vR, OpndSize_32, true);
 }
 
 /**
@@ -2863,7 +2902,7 @@ void writeBackVR(int vR, LowOpndRegType type, int physicalReg) {
                 true, MemoryAccess_VR, vR);
 
     // Mark it in memory because we have written it back
-    setVRToMemory(vR, getRegSize(physicalType));
+    setVRMemoryState (vR, getRegSize (physicalType), true);
 }
 //! dump part of a 64-bit VR to memory and update inMemory
 
@@ -2892,7 +2931,7 @@ void dumpPartToMem(int reg /*xmm physical reg*/, int vA, bool isLow) {
         move_ss_reg_to_mem_noalloc(reg, true,
                                    4*vA, PhysicalReg_FP, true, MemoryAccess_VR, vA);
     } else {
-        int k = getSpillIndex(false, OpndSize_64);
+        int k = getSpillIndex (OpndSize_64);
         //H, L in 4*k+4 & 4*k
 #ifdef SPILL_IN_THREAD
         get_self_pointer(PhysicalReg_SCRATCH_1, isScratchPhysical);
@@ -2912,10 +2951,15 @@ void dumpPartToMem(int reg /*xmm physical reg*/, int vA, bool isLow) {
         //move low 32 bits of xmm reg to vA+1
         move_ss_reg_to_mem_noalloc(reg, true, 4*(vA+1), PhysicalReg_FP, true, MemoryAccess_VR, vA+1);
     }
-    if(isLow)
-        setVRToMemory(vA, OpndSize_32);
+
+    if (isLow)
+    {
+        setVRMemoryState (vA, OpndSize_32, true);
+    }
     else
-        setVRToMemory(vA+1, OpndSize_32);
+    {
+        setVRMemoryState (vA + 1, OpndSize_32, true);
+    }
 }
 void clearVRBoundCheck(int regNum, OpndSize size);
 //! the content of a VR is no longer in memory or in physical register if the latest content of a VR is constant
@@ -3095,10 +3139,13 @@ int updateVirtualReg(int reg, LowOpndRegType pType) {
     invalidateVR(reg, pType);
     clearVRNullCheck(reg, size);
     clearVRBoundCheck(reg, size);
-    if(pType == LowOpndRegType_fs || pType == LowOpndRegType_fs_s)
-        setVRToMemory(reg, size);
-    else {
-        clearVRToMemory(reg, size);
+    if (pType == LowOpndRegType_fs || pType == LowOpndRegType_fs_s)
+    {
+        setVRMemoryState (reg, size, true);
+    }
+    else
+    {
+        clearVRToMemory (reg, size);
     }
 
     unsigned int max = currentBB->xferPoints.size ();
@@ -3368,13 +3415,13 @@ int getFreeReg(int type, int reg, int indexToCompileTable) {
         if(index1 >= 0) return currentBB->allocConstraintsSorted[index1].physicalReg;
         return -1;
     }
-    /* handle request from a temporary variable or a glue variable */
+    /* handle request from a temporary variable */
     else {
         bool is8Bit = isTemp8Bit(type, reg);
 
         /* if the temporary variable is linked to a VR and
               the VR is not yet allocated to any physical register */
-        int vr_num = compileTable[indexToCompileTable].linkageToVR;
+        int vr_num = compileTable[indexToCompileTable].getLinkedVR ();
         if(vr_num >= 0) {
             int index3 = searchCompileTable(LowOpndRegType_gp | LowOpndRegType_virtual, vr_num);
             if(index3 < 0) {
@@ -3506,7 +3553,7 @@ PhysicalReg spillForLogicalReg(int type, int reg, int indexToCompileTable) {
     int numOfUses[PhysicalReg_Null];
     for(k = PhysicalReg_EAX; k < PhysicalReg_Null; k++)
         numOfUses[k] = 0;
-    for(k = 0; k < num_compile_entries; k++) {
+    for(k = 0; k < compileTable.size (); k++) {
         if((compileTable[k].physicalReg != PhysicalReg_Null) &&
            matchType(type, compileTable[k].physicalType) &&
            (compileTable[k].physicalType & LowOpndRegType_hard) == 0) {
@@ -3517,9 +3564,9 @@ PhysicalReg spillForLogicalReg(int type, int reg, int indexToCompileTable) {
     /* candidates: all non-hardcode entries that are mapped to
            a physical register that is used by only one entry*/
     bool is8Bit = isTemp8Bit(type, reg);
-    int candidates[COMPILE_TABLE_SIZE];
+    int candidates[compileTable.size ()];
     int num_cand = 0;
-    for(k = 0; k < num_compile_entries; k++) {
+    for(k = 0; k < compileTable.size (); k++) {
         if(matchType(type, compileTable[k].physicalType) && compileTable[k].physicalReg != PhysicalReg_Null) {
             //If we care about 8 bits, we can't have a register over EDX
             if(is8Bit == true && compileTable[k].physicalReg > PhysicalReg_EDX)
@@ -3540,23 +3587,7 @@ PhysicalReg spillForLogicalReg(int type, int reg, int indexToCompileTable) {
         }
     }
 
-    /* go through all candidates:
-       first check GLUE-related entries */
     int spill_index = -1;
-    for(k2 = 0; k2 < num_cand; k2++) {
-        k = candidates[k2];
-        if((compileTable[k].physicalReg != PhysicalReg_Null) &&
-           matchType(type, compileTable[k].physicalType) &&
-           (compileTable[k].regNum >= PhysicalReg_GLUE_DVMDEX &&
-            compileTable[k].regNum != PhysicalReg_GLUE)) {
-            allocR = (PhysicalReg)spillLogicalReg(k, true);
-#ifdef DEBUG_REGALLOC
-            ALOGI("SPILL register used by num %d type %d it is a GLUE register with refCount %d",
-                  compileTable[k].regNum, compileTable[k].physicalType, compileTable[k].refCount);
-#endif
-            return allocR;
-        }
-    }
 
     /* out of the candates, find a VR that has the furthest next use */
     int furthestUse = offsetPC;
@@ -3584,8 +3615,7 @@ PhysicalReg spillForLogicalReg(int type, int reg, int indexToCompileTable) {
     int index = -1;
     for(k2 = 0; k2 < num_cand; k2++) {
         k = candidates[k2];
-        if(k != indexForGlue &&
-           (compileTable[k].physicalReg != PhysicalReg_Null) &&
+        if((compileTable[k].physicalReg != PhysicalReg_Null) &&
            (compileTable[k].physicalType & LowOpndRegType_hard) == 0 && //not hard-coded
            matchType(type, compileTable[k].physicalType)) {
             if((index < 0) || (compileTable[k].refCount < baseLeftOver)) {
@@ -3637,11 +3667,11 @@ int spillLogicalReg(int spill_index, bool updateTable) {
     }
 #endif
 
-    if(isVirtualReg(compileTable[spill_index].physicalType)) {
-        //spill back to memory
-        writeBackVR(compileTable[spill_index].regNum,
-                  (LowOpndRegType)(compileTable[spill_index].physicalType & MASK_FOR_TYPE),
-                  compileTable[spill_index].physicalReg);
+    if (compileTable[spill_index].isVirtualReg ())
+    {
+        //Write VR back to memory
+        writeBackVR (compileTable[spill_index].getRegisterNumber (), compileTable[spill_index].getPhysicalType (),
+                compileTable[spill_index].getPhysicalReg ());
     }
     else {
         //If the gCompilationUnit has maximumRegisterization set
@@ -3651,8 +3681,7 @@ int spillLogicalReg(int spill_index, bool updateTable) {
             SET_JIT_ERROR (kJitErrorSpill);
         }
         //update spill_loc_index
-        int k = getSpillIndex(spill_index == indexForGlue,
-                    getRegSize(compileTable[spill_index].physicalType));
+        int k = getSpillIndex (compileTable[spill_index].getSize ());
         compileTable[spill_index].spill_loc_index = 4*k;
         if(k >= 0)
             spillIndexUsed[k] = 1;
@@ -3762,9 +3791,8 @@ int spillForHardReg(int regNum, int type) {
     //find an entry that uses the physical register
     int spill_index = -1;
     int k;
-    for(k = 0; k < num_compile_entries; k++) {
-        if(k != indexForGlue &&
-           compileTable[k].physicalReg == regNum &&
+    for(k = 0; k < compileTable.size (); k++) {
+        if(compileTable[k].physicalReg == regNum &&
            matchType(type, compileTable[k].physicalType)) {
             spill_index = k;
             if(compileTable[k].regNum == regNum && compileTable[k].physicalType == type)
@@ -3777,7 +3805,7 @@ int spillForHardReg(int regNum, int type) {
                    regNum, type);
             if(compileTable[spill_index].physicalType & LowOpndRegType_hard) dumpCompileTable();
 #endif
-            assert(spill_index < COMPILE_TABLE_SIZE);
+            assert(spill_index < compileTable.size ());
             spillLogicalReg(spill_index, true);
         }
     }
@@ -4250,34 +4278,55 @@ bool isInMemory(int regNum, OpndSize size) {
     if(size == OpndSize_64 && (!memVRTable[indexH].inMemory)) return false;
     return true;
 }
-//!set field inMemory of memVRTable to true
 
-//!
-void setVRToMemory(int regNum, OpndSize size) {
-    int indexL = searchMemTable(regNum);
+/**
+ * @brief Used to update the in memory state of a virtual register
+ * @param vR The virtual register
+ * @param size The size of the virtual register
+ * @param inMemory The new in memory state of the virtual register
+ */
+void setVRMemoryState (int vR, OpndSize size, bool inMemory)
+{
+    //Look for the index in the mem table for the virtual register
+    int indexL = searchMemTable (vR);
+
+    //If virtual register is wide, we want to find the index for the high part as well
     int indexH = -1;
-    if(size == OpndSize_64) indexH = searchMemTable(regNum+1);
-    if(indexL < 0) {
-        ALOGI("JIT_INFO: VR %d not in memVRTable at setVRToMemory", regNum);
-        SET_JIT_ERROR(kJitErrorRegAllocFailed);
+    if (size == OpndSize_64)
+    {
+        indexH = searchMemTable (vR + 1);
+    }
+
+    if (indexL < 0)
+    {
+        ALOGI ("JIT_INFO: VR %d not in memVRTable at setVRToMemory", vR);
+        SET_JIT_ERROR (kJitErrorRegAllocFailed);
         return;
     }
-    memVRTable[indexL].inMemory = true;
-    DEBUG_MEMORYVR(ALOGD("Setting state of v%d %sin memory",
-            memVRTable[indexL].regNum,
+
+    //Update the in memory state of the VR
+    memVRTable[indexL].setInMemoryState (inMemory);
+
+    DEBUG_MEMORYVR (ALOGD ("Setting state of v%d %sin memory", memVRTable[indexL].vR,
             (memVRTable[indexL].inMemory ? "" : "NOT ")));
-    if(size == OpndSize_64) {
-        if(indexH < 0) {
-            ALOGI("JIT_INFO: VR %d not in memVRTable at setVRToMemory for upper 64-bits", regNum+1);
-            SET_JIT_ERROR(kJitErrorRegAllocFailed);
+
+    if (size == OpndSize_64)
+    {
+        if (indexH < 0)
+        {
+            ALOGI ("JIT_INFO: VR %d not in memVRTable at setVRToMemory for upper 64-bits", vR+1);
+            SET_JIT_ERROR (kJitErrorRegAllocFailed);
             return;
         }
-        memVRTable[indexH].inMemory = true;
-        DEBUG_MEMORYVR(ALOGD("Setting state of v%d %sin memory",
-                memVRTable[indexH].regNum,
+
+        //Update the in memory state of the upper 64-bits of the VR
+        memVRTable[indexH].setInMemoryState (inMemory);
+
+        DEBUG_MEMORYVR (ALOGD ("Setting state of v%d %sin memory", memVRTable[indexH].vR,
                 (memVRTable[indexH].inMemory ? "" : "NOT ")));
     }
 }
+
 //! check whether null check for a VR is performed previously
 
 //!
@@ -4397,7 +4446,7 @@ void clearVRNullCheck(int regNum, OpndSize size) {
 bool requestVRFreeDelayAll(u4 reason) {
     bool state_changed = false;
     // Delay only VRs, which could be freed by freeReg
-    for(int k = 0; k < num_compile_entries; k++) {
+    for(int k = 0; k < compileTable.size (); k++) {
 
         if(compileTable[k].physicalReg != PhysicalReg_Null) {
 
@@ -4431,7 +4480,7 @@ bool requestVRFreeDelayAll(u4 reason) {
 bool cancelVRFreeDelayRequestAll(u4 reason) {
     bool state_changed = false;
     // Cancel delay for VRs only
-    for(int k = 0; k < num_compile_entries; k++) {
+    for(int k = 0; k < compileTable.size (); k++) {
         if(isVirtualReg(compileTable[k].physicalType) == true) {
             bool freeCrit = isLastByteCodeOfLiveRange(k);
 
@@ -4605,7 +4654,7 @@ int searchVirtualInfoOfBB(LowOpndRegType type, int regNum, BasicBlock_O1* bb) {
 //! return -1 if not found
 int searchCompileTable(int type, int regNum) { //returns the index
     int k;
-    for(k = 0; k < num_compile_entries; k++) {
+    for(k = 0; k < compileTable.size (); k++) {
         if(compileTable[k].physicalType == type && compileTable[k].regNum == regNum)
             return k;
     }
@@ -4623,7 +4672,7 @@ int searchCompileTable(int type, int regNum) { //returns the index
  */
 bool updatePhysicalRegForVR(int vR, PhysicalReg oldReg, PhysicalReg newReg) {
     //Go through the entries in the compile table
-    for (int entry = 0; entry < num_compile_entries; entry++) {
+    for (int entry = 0; entry < compileTable.size (); entry++) {
 
         //If it is a virtual register, the vR we are looking for, and is associated to the old register
         if (isVirtualReg(compileTable[entry].physicalType)
@@ -4678,8 +4727,7 @@ bool hasExposedUsage2(BasicBlock_O1* bb, int index) {
 //! return the spill location that is not used
 
 //!
-int getSpillIndex(bool isGLUE, OpndSize size) {
-    if(isGLUE) return 0;
+int getSpillIndex (OpndSize size) {
     int k;
     for(k = 1; k <= MAX_SPILL_JIT_IA - 1; k++) {
         if(size == OpndSize_64) {
@@ -4905,14 +4953,10 @@ int beforeCall(const char* target) { //spill all live registers
 #ifdef DEBUG_REGALLOC
     ALOGI("enter beforeCall");
 #endif
-    if(!strncmp(target, ".invokeArgsDone", 15)) resetGlue(PhysicalReg_GLUE_DVMDEX);
 
     freeReg(true); //to avoid spilling dead logical registers
     int k;
-    for(k = 0; k < num_compile_entries; k++) {
-        /* before throwing an exception, if GLUE is spilled, load to %ebp
-           this should happen at last */
-        if(k == indexForGlue) continue;
+    for(k = 0; k < compileTable.size (); k++) {
         if(compileTable[k].physicalReg != PhysicalReg_Null &&
            (compileTable[k].physicalType & LowOpndRegType_hard) == 0) {
             /* handles non hardcoded variables that are in physical registers */
@@ -4960,10 +5004,6 @@ int beforeCall(const char* target) { //spill all live registers
             spillLogicalReg(k, true);
         }
     }
-    if(indexForGlue >= 0 && !strcmp(target, "exception") &&
-       compileTable[indexForGlue].physicalReg == PhysicalReg_Null) {
-        unspillLogicalReg(indexForGlue, PhysicalReg_EBP); //load %ebp
-    }
 
     cancelVRFreeDelayRequestAll(VRDELAY_CAN_THROW);
 
@@ -5379,7 +5419,7 @@ int freeReg(bool writeBackAllVRs) {
         }
     }
 
-    for(int k = 0; k < num_compile_entries; k++) {
+    for(int k = 0; k < compileTable.size (); k++) {
         if (writeBackAllVRs && isVirtualReg(compileTable[k].physicalType)
                 && compileTable[k].inPhysicalRegister () == true) {
 #ifdef DEBUG_REGALLOC
@@ -5466,89 +5506,6 @@ int updateRefCount2(int reg, int type, bool isPhysical) {
     decreaseRefCount(index);
     return 0;
 }
-//! check whether a glue variable is in physical register or spilled
-
-//!
-bool isGlueHandled(int glue_reg) {
-    if(currentBB == NULL) return false;
-    int index = searchCompileTable(LowOpndRegType_gp, glue_reg);
-    if(index < 0) {
-        ALOGI("JIT_INFO: glue reg %d not found in isGlueHandled\n", glue_reg);
-        SET_JIT_ERROR(kJitErrorRegAllocFailed);
-        return -1;
-    }
-    if(compileTable[index].spill_loc_index >= 0 ||
-       compileTable[index].physicalReg != PhysicalReg_Null) {
-#ifdef DEBUG_GLUE
-        ALOGI("GLUE isGlueHandled for %d returns true", glue_reg);
-#endif
-        return true;
-    }
-#ifdef DEBUG_GLUE
-    ALOGI("GLUE isGlueHandled for %d returns false", glue_reg);
-#endif
-    return false;
-}
-
-//! \brief reset the state of a glue variable to not existent
-//!
-//! \details reset the state of a glue variable to not existent
-//!  (not in physical register nor spilled)
-//! \param glue_reg the register to reset
-//!
-//! \return -1 if error happened, 0 otherwise
-int resetGlue(int glue_reg) {
-    if(currentBB == NULL)
-        return 0;
-    int index = searchCompileTable(LowOpndRegType_gp, glue_reg);
-    if(index < 0) {
-        ALOGI("JIT_INFO: glue reg %d not found in resetGlue\n", glue_reg);
-        SET_JIT_ERROR(kJitErrorRegAllocFailed);
-        return -1;
-    }
-#ifdef DEBUG_GLUE
-    ALOGI("GLUE reset for %d", glue_reg);
-#endif
-    compileTable[index].setPhysicalReg (PhysicalReg_Null);
-    if(compileTable[index].spill_loc_index >= 0)
-        spillIndexUsed[compileTable[index].spill_loc_index >> 2] = 0;
-    compileTable[index].spill_loc_index = -1;
-    return 0;
-}
-
-//! \brief set a glue variable in a physical register allocated for a variable
-//!
-//! \details Variable is using lowering module's naming convention
-//! \param reg
-//! \param isPhysical whether reg is physical
-//! \param glue_reg
-//!
-//! \return -1 if error happened, 0 otherwise
-int updateGlue(int reg, bool isPhysical, int glue_reg) {
-    if(currentBB == NULL)
-        return 0;
-    int index = searchCompileTable(LowOpndRegType_gp, glue_reg);
-    if(index < 0) {
-        ALOGI("JIT_INFO: updateGlue reg %d type %d\n", reg, glue_reg);
-        SET_JIT_ERROR(kJitErrorRegAllocFailed);
-        return -1;
-    }
-    /* find the compileTable entry for variable <reg, isPhysical> */
-    int newType = convertType(LowOpndRegType_gp, reg, isPhysical);
-    if(newType & LowOpndRegType_scratch) reg = reg - PhysicalReg_SCRATCH_1 + 1;
-    int index2 = searchCompileTable(newType, reg);
-    if(index2 < 0 || compileTable[index2].physicalReg == PhysicalReg_Null) {
-        ALOGI("JIT_INFO: updateGlue reg %d type %d for index2", reg, newType);
-        SET_JIT_ERROR(kJitErrorRegAllocFailed);
-        return -1;
-    }
-#ifdef DEBUG_GLUE
-    ALOGI("physical register for GLUE %d set to %d", glue_reg, compileTable[index2].physicalReg);
-#endif
-    compileTable[index].setPhysicalReg (compileTable[index2].getPhysicalReg ());
-    compileTable[index].spill_loc_index = -1;
-    return 0;
-}
 
 //! check whether a virtual register is in a physical register
 
@@ -5637,7 +5594,7 @@ int checkTempReg(int reg, int type, bool isPhysical, int vrNum) {
     //FIX: if this temp reg shares a physical reg with another reg
     if(compileTable[index].physicalReg != PhysicalReg_Null) {
         int k;
-        for(k = 0; k < num_compile_entries; k++) {
+        for(k = 0; k < compileTable.size (); k++) {
             if(k == index) continue;
             if(compileTable[k].physicalReg == compileTable[index].physicalReg) {
                 return PhysicalReg_Null; //will allocate a register for VR
@@ -5669,40 +5626,40 @@ bool hasExposedUsage(LowOpndRegType type, int regNum, BasicBlock_O1* bb) {
 }
 
 /**
- * @brief Handle the spilling of registers at the end of a BasicBlock
- * @param lastByteCodeIsJump is the last bytecode is a jump
+ * @brief Handle the spilling of registers at the end of a BasicBlock.
+ * @param syncChildren If sync children is set to true, then we create or sync association table for child.
  * @return -1 if error, 0 otherwise
  */
-int handleVRsEndOfBB(bool lastByteCodeIsJump) {
-    // Call freeReg to free temporaries. However, we only spill VRs depending on
-    // association tables.
-    freeReg(false);
-
-    //If it's a jump, then we don't update the association tables
-    if (lastByteCodeIsJump == false)
+int handleRegistersEndOfBB (bool syncChildren)
+{
+    //First we call freeReg to get rid of any temporaries that might be using physical registers.
+    //Since we are at the end of the BB, we don't need to spill the temporaries because we
+    //are done using them.
+    freeReg (false);
+
+    //If it's a jump, then we don't update the association tables. The reason is
+    //that the implementation of jumping bytecode (for example "if" bytecode) will
+    //create association tables for children
+    if (syncChildren == true)
     {
-        // Update association tables of children
+        //Update association tables of child. There should technically be just one child
+        //but we generically try to pass our information to all children.
+
         if (AssociationTable::createOrSyncTable(currentBB, true) == false)
+        {
+            //If syncing failed, the error code will be already set so we just pass along error information
             return -1;
+        }
+
         if (AssociationTable::createOrSyncTable(currentBB, false) == false)
+        {
+            //If syncing failed, the error code will be already set so we just pass along error information
             return -1;
-    }
-
-    //spill GG VR first if it is not mapped to the specific reg
-    //release GLUE regs
-    for(int k = 0; k < num_compile_entries; k++) {
-        if(compileTable[k].regNum >= PhysicalReg_GLUE_DVMDEX &&
-           compileTable[k].regNum != PhysicalReg_GLUE) {
-            compileTable[k].setPhysicalReg (PhysicalReg_Null);
-            compileTable[k].spill_loc_index = -1;
         }
     }
+
     syncAllRegs();
 
-    if(indexForGlue >= 0 &&
-        compileTable[indexForGlue].physicalReg == PhysicalReg_Null) {
-        unspillLogicalReg(indexForGlue, PhysicalReg_EBP); //load %ebp
-    }
     return 0;
 }
 
@@ -5729,9 +5686,8 @@ int nextVersionOfHardReg(PhysicalReg pReg, int refCount) {
  * @details If compile table already contains information about virtual register, only the
  * reference counts are updated. Otherwise a new entry is created in the compile table.
  * @param regInfo Information about the virtual register.
- * @return Returns 0 on success and -1 on failure.
  */
-int insertFromVirtualInfo (VirtualRegInfo &regInfo)
+void insertFromVirtualInfo (const VirtualRegInfo &regInfo)
 {
     int vR = regInfo.regNum;
 
@@ -5744,79 +5700,48 @@ int insertFromVirtualInfo (VirtualRegInfo &regInfo)
     {
         //If we get here it means that the VR is not in the compile table
 
-        //If we exceed size of table, we must throw an error
-        if (num_compile_entries >= COMPILE_TABLE_SIZE)
-        {
-            ALOGI("JIT_INFO: compileTable overflow at insertFromVirtualInfo");
-            SET_JIT_ERROR(kJitErrorRegAllocFailed);
-            return -1;
-        }
-
-        //Let's insert at end of table
-        index = num_compile_entries;
+        //Create the new entry
+        CompileTableEntry newEntry (regInfo);
 
         //Create the new entry and then copy it to the table
-        compileTable[index] = CompileTableEntry (regInfo);
-
-        //We have added an entry so increment the count
-        num_compile_entries++;
+        compileTable.insert (newEntry);
     }
     else
     {
         //Just update the ref count when we already have an entry
         compileTable[index].updateRefCount (regInfo.refCount);
     }
-
-    //If we make it here, return 0 for success
-    return 0;
 }
 
-//! \brief update compileTable with infoByteCodeTemp[k]
-//!
-//! \param k index
-//!
-//! \return -1 on error, 0 otherwise
-int insertFromTempInfo(int k) {
-    int index = searchCompileTable(infoByteCodeTemp[k].physicalType, infoByteCodeTemp[k].regNum);
-    if(index < 0) {
-        if(num_compile_entries >= COMPILE_TABLE_SIZE) {
-            ALOGI("JIT_INFO: compileTable overflow at insertFromTempInfo");
-            SET_JIT_ERROR(kJitErrorRegAllocFailed);
-            return -1;
-        }
+/**
+ * @brief Updates compile table with temporary information.
+ * @param regInfo Information about the temporary.
+ */
+static void insertFromTempInfo (const TempRegInfo &tempRegInfo)
+{
+    int index = searchCompileTable(tempRegInfo.physicalType, tempRegInfo.regNum);
 
-        /* the temporary is not in compileTable, insert it */
-        index = num_compile_entries;
-        compileTable[num_compile_entries].physicalType = infoByteCodeTemp[k].physicalType;
-        compileTable[num_compile_entries].regNum = infoByteCodeTemp[k].regNum;
-        compileTable[num_compile_entries].size = getRegSize (compileTable[num_compile_entries].physicalType);
+    //If we did not find it in compile table simply insert it.
+    if (index < 0)
+    {
+        CompileTableEntry newEntry (tempRegInfo);
 
-        num_compile_entries++;
+        compileTable.insert (newEntry);
     }
-    compileTable[index].setPhysicalReg (PhysicalReg_Null);
-    compileTable[index].refCount = infoByteCodeTemp[k].refCount;
-    compileTable[index].linkageToVR = infoByteCodeTemp[k].linkageToVR;
-    compileTable[index].spill_loc_index = -1;
-    return 0;
-}
+    else
+    {
+        //Set the physical register
+        compileTable[index].setPhysicalReg (PhysicalReg_Null);
 
-/* insert a glue-related register GLUE_DVMDEX to compileTable */
-void insertGlueReg() {
-    if(num_compile_entries >= COMPILE_TABLE_SIZE) {
-        ALOGI("JIT_INFO: compileTable overflow at insertGlueReg");
-        SET_JIT_ERROR(kJitErrorRegAllocFailed);
-        return;
-    }
+        //Update the reference count for this temporary
+        compileTable[index].updateRefCount (tempRegInfo.refCount);
 
-    compileTable[num_compile_entries].physicalType = LowOpndRegType_gp;
-    compileTable[num_compile_entries].regNum = PhysicalReg_GLUE_DVMDEX;
-    compileTable[num_compile_entries].size = getRegSize (compileTable[num_compile_entries].physicalType);
-    compileTable[num_compile_entries].refCount = 2;
-    compileTable[num_compile_entries].setPhysicalReg (PhysicalReg_Null);
-    compileTable[num_compile_entries].spill_loc_index = -1;
-    compileTable[num_compile_entries].linkageToVR = -1;
+        //Create link with the corresponding VR if needed
+        compileTable[index].linkToVR (tempRegInfo.linkageToVR);
 
-    num_compile_entries++;
+        //Reset spill location because this is a new temp which has not been spilled
+        compileTable[index].resetSpillLocation ();
+    }
 }
 
 /** print infoBasicBlock of the given basic block
@@ -5842,9 +5767,9 @@ void dumpVirtualInfoOfBasicBlock(BasicBlock_O1* bb) {
 */
 void dumpCompileTable() {
     ALOGD("+++++++++++++++++++++ Compile Table +++++++++++++++++++++");
-    ALOGD("%d entries\t%d memory_vr\t%d const_vr", num_compile_entries,
+    ALOGD("%d entries\t%d memory_vr\t%d const_vr", compileTable.size (),
             num_memory_vr, num_const_vr);
-    for(int entry = 0; entry < num_compile_entries; entry++) {
+    for(int entry = 0; entry < compileTable.size (); entry++) {
         ALOGD("regNum %d physicalType %d refCount %d physicalReg %s",
                compileTable[entry].regNum, compileTable[entry].physicalType,
                compileTable[entry].refCount, physicalRegToString(
@@ -5872,28 +5797,8 @@ void rememberState(int stateNum) {
     ALOGI("STATE: remember state %d", stateNum);
 #endif
     int k;
-    for(k = 0; k < num_compile_entries; k++) {
-        if(stateNum == 1) {
-            stateTable1_1[k].physicalReg = compileTable[k].physicalReg;
-            stateTable1_1[k].spill_loc_index = compileTable[k].spill_loc_index;
-        }
-        else if(stateNum == 2) {
-            stateTable1_2[k].physicalReg = compileTable[k].physicalReg;
-            stateTable1_2[k].spill_loc_index = compileTable[k].spill_loc_index;
-        }
-        else if(stateNum == 3) {
-            stateTable1_3[k].physicalReg = compileTable[k].physicalReg;
-            stateTable1_3[k].spill_loc_index = compileTable[k].spill_loc_index;
-        }
-        else if(stateNum == 4) {
-            stateTable1_4[k].physicalReg = compileTable[k].physicalReg;
-            stateTable1_4[k].spill_loc_index = compileTable[k].spill_loc_index;
-        }
-        else {
-            ALOGI("JIT_INFO: state table overflow at rememberState for compileTable");
-            SET_JIT_ERROR(kJitErrorRegAllocFailed);
-            return;
-        }
+    for(k = 0; k < compileTable.size (); k++) {
+        compileTable[k].rememberState (stateNum);
 #ifdef DEBUG_STATE
         ALOGI("logical reg %d %d mapped to physical reg %d with spill index %d refCount %d",
                compileTable[k].regNum, compileTable[k].physicalType, compileTable[k].physicalReg,
@@ -5936,28 +5841,8 @@ void goToState(int stateNum) {
 #ifdef DEBUG_STATE
     ALOGI("STATE: go to state %d", stateNum);
 #endif
-    for(k = 0; k < num_compile_entries; k++) {
-        if(stateNum == 1) {
-            compileTable[k].setPhysicalReg (stateTable1_1[k].physicalReg);
-            compileTable[k].spill_loc_index = stateTable1_1[k].spill_loc_index;
-        }
-        else if(stateNum == 2) {
-            compileTable[k].setPhysicalReg (stateTable1_2[k].physicalReg);
-            compileTable[k].spill_loc_index = stateTable1_2[k].spill_loc_index;
-        }
-        else if(stateNum == 3) {
-            compileTable[k].setPhysicalReg (stateTable1_3[k].physicalReg);
-            compileTable[k].spill_loc_index = stateTable1_3[k].spill_loc_index;
-        }
-        else if(stateNum == 4) {
-            compileTable[k].setPhysicalReg (stateTable1_4[k].physicalReg);
-            compileTable[k].spill_loc_index = stateTable1_4[k].spill_loc_index;
-        }
-        else {
-            ALOGI("JIT_INFO: State table overflow at goToState");
-            SET_JIT_ERROR(kJitErrorStateTransfer);
-            return;
-        }
+    for(k = 0; k < compileTable.size (); k++) {
+        compileTable[k].goToState (stateNum);
     }
     int retCode = updateSpillIndexUsed();
     if (retCode < 0)
@@ -6067,30 +5952,7 @@ bool dstStillInUse(int dstReg) {
     if(handledSrc[index]) return false; //not in use
     return true;
 }
-//! reset the state of glue variables in a state table
 
-//!
-void resetStateOfGlue(int stateNum, int k) {
-#ifdef DEBUG_STATE
-    ALOGI("resetStateOfGlue state %d regNum %d", stateNum, compileTable[k].regNum);
-#endif
-    if(stateNum == 1) {
-        stateTable1_1[k].physicalReg = PhysicalReg_Null;
-        stateTable1_1[k].spill_loc_index = -1;
-    }
-    else if(stateNum == 2) {
-        stateTable1_2[k].physicalReg = PhysicalReg_Null;
-        stateTable1_2[k].spill_loc_index = -1;
-    }
-    else if(stateNum == 3) {
-        stateTable1_3[k].physicalReg = PhysicalReg_Null;
-        stateTable1_3[k].spill_loc_index = -1;
-    }
-    else if(stateNum == 4) {
-        stateTable1_4[k].physicalReg = PhysicalReg_Null;
-        stateTable1_4[k].spill_loc_index = -1;
-    }
-}
 //! construct a legal order of the source registers in this transfer
 
 //!
@@ -6101,7 +5963,7 @@ void constructSrcRegs(int stateNum) {
     ALOGI("IN constructSrcRegs");
 #endif
 
-    for(k = 0; k < num_compile_entries; k++) {
+    for(k = 0; k < compileTable.size (); k++) {
 #ifdef DEBUG_STATE
         ALOGI("logical reg %d %d mapped to physical reg %d with spill index %d refCount %d",
                compileTable[k].regNum, compileTable[k].physicalType, compileTable[k].physicalReg,
@@ -6120,33 +5982,9 @@ void constructSrcRegs(int stateNum) {
         //GG VR refCount is zero, can't ignore
         //temporary refCount is zero, ignore
 
-        //for GLUE variables, if they do not exist, reset the entries in state table
-        if(compileTable[k].physicalReg == PhysicalReg_Null &&
-           compileTable[k].regNum >= PhysicalReg_GLUE_DVMDEX &&
-           compileTable[k].regNum != PhysicalReg_GLUE &&
-           compileTable[k].spill_loc_index < 0) {
-            resetStateOfGlue(stateNum, k);
-        }
-
         /* get the target state */
-        int targetReg = PhysicalReg_Null;
-        int targetSpill = -1;
-        if(stateNum == 1) {
-            targetReg = stateTable1_1[k].physicalReg;
-            targetSpill = stateTable1_1[k].spill_loc_index;
-        }
-        else if(stateNum == 2) {
-            targetReg = stateTable1_2[k].physicalReg;
-            targetSpill = stateTable1_2[k].spill_loc_index;
-        }
-        else if(stateNum == 3) {
-            targetReg = stateTable1_3[k].physicalReg;
-            targetSpill = stateTable1_3[k].spill_loc_index;
-        }
-        else if(stateNum == 4) {
-            targetReg = stateTable1_4[k].physicalReg;
-            targetSpill = stateTable1_4[k].spill_loc_index;
-        }
+        int targetReg = compileTable[k].getStatePhysicalRegister (stateNum);
+        int targetSpill = compileTable[k].getStateSpillLocation (stateNum);
 
         /* there exists an ordering problem
            for example:
@@ -6158,7 +5996,6 @@ void constructSrcRegs(int stateNum) {
              II: a variable is currently in a register and its target is in memory
              III: a variable is currently in a different register
              IV: a variable is currently in a different memory location (for non-VRs)
-           for GLUE, since it can only be allocated to %ebp, we don't have case III
            For now, case IV is not handled since it didn't show
         */
         if(compileTable[k].physicalReg != targetReg &&
diff --git a/vm/compiler/codegen/x86/AnalysisO1.h b/vm/compiler/codegen/x86/AnalysisO1.h
index a50b8e7..93e20ee 100644
--- a/vm/compiler/codegen/x86/AnalysisO1.h
+++ b/vm/compiler/codegen/x86/AnalysisO1.h
@@ -32,8 +32,6 @@
 
 //! maximal number of edges per basic block
 #define MAX_NUM_EDGE_PER_BB 300
-//! maximal number of basic blocks per method
-#define MAX_NUM_BBS_PER_METHOD 1000
 //! maximal number of virtual registers per basic block
 #define MAX_REG_PER_BASICBLOCK 140
 //! maximal number of virtual registers per bytecode
@@ -49,8 +47,7 @@
 #define MASK_FOR_TYPE 7 //last 3 bits 111
 
 #define LOOP_COUNT 10
-//! maximal number of entries in compileTable
-#define COMPILE_TABLE_SIZE 230
+
 //! maximal number of transfer points per basic block
 #define MAX_XFER_PER_BB 1000  //on Jan 4
 #define PC_FOR_END_OF_BB -999
@@ -159,12 +156,28 @@ typedef struct DefUsePair {
 //!information associated with a virtual register
 //!the pair <regNum, physicalType> uniquely determines a variable
 typedef struct VirtualRegInfo {
+   VirtualRegInfo () : regNum (-1), physicalType (LowOpndRegType_invalid), refCount (0),
+           accessType (REGACCESS_UNKNOWN), num_reaching_defs (0)
+  {
+        //Set up allocation constraints for hardcoded registers
+        for (int reg = PhysicalReg_StartOfGPMarker; reg <= PhysicalReg_EndOfGPMarker; reg++)
+        {
+            PhysicalReg pReg = static_cast<PhysicalReg> (reg);
+
+            //For now we know of no constraints for each reg so we set count to zero
+            allocConstraints[reg].physicalReg = pReg;
+            allocConstraints[reg].count = 0;
+            allocConstraintsSorted[reg].physicalReg = pReg;
+            allocConstraintsSorted[reg].count = 0;
+        }
+  }
+
   int regNum;
   LowOpndRegType physicalType;
   int refCount;
   RegAccessType accessType;
-  RegAllocConstraint allocConstraints[8];
-  RegAllocConstraint allocConstraintsSorted[8];
+  RegAllocConstraint allocConstraints[PhysicalReg_EndOfGPMarker + 1];
+  RegAllocConstraint allocConstraintsSorted[PhysicalReg_EndOfGPMarker + 1];
 
   DefOrUse reachingDefs[3]; //!reaching defs to the virtual register
   int num_reaching_defs;
@@ -209,6 +222,14 @@ typedef struct BoundCheckIndex {
 } BoundCheckIndex;
 
 /**
+ * @brief Used to keep track of virtual register's in-memory state.
+ */
+typedef struct regAllocStateEntry2 {
+  int regNum;    //!< The virtual register
+  bool inMemory; //!< Whether 4-byte virtual register is in memory
+} regAllocStateEntry2;
+
+/**
  * @class MemoryVRInfo
  * @brief information for a virtual register such as live ranges, in memory
  */
@@ -222,6 +243,23 @@ typedef struct MemoryVRInfo {
     int delayFreeCounters[VRDELAY_COUNT]; /**< @brief Used with indexes defined by VRDelayFreeCounters enum to delay freeing */
 
     /**
+     * @brief Default constructor which initializes all fields but sets an invalid virtual register.
+     */
+    MemoryVRInfo (void)
+    {
+        reset ();
+    }
+
+    /**
+     * @brief Initializes all fields and sets a virtual register associated with this information.
+     */
+    MemoryVRInfo (int vR)
+    {
+        reset ();
+        regNum = vR;
+    }
+
+    /**
      * @brief Used to reset information about the VR to default values.
      * @details Creates a logically invalid entry.
      */
@@ -266,217 +304,6 @@ typedef struct TempRegInfo {
   bool is8Bit;
 } TempRegInfo;
 struct BasicBlock_O1;
-//!all variables accessed
-
-/**
- * @brief Provides a mapping between physical type and the size represented.
- * @param type The physical type represented by LowOpndRegType.
- * @return Returns size represented by the physical type.
- */
-OpndSize getRegSize (int type);
-
-/**
- * @brief Represents an entry to the compilation table, helping the compiler follow what register is where.
- * @details The pair <regNum, physicalType> uniquely determines a variable
- */
-class CompileTableEntry {
-public:
-    /**
-     * @brief Empty constructor.
-     */
-    CompileTableEntry (void) :
-            regNum (-1), physicalType (LowOpndRegType_invalid), physicalReg (PhysicalReg_Null),
-            size (OpndSize_Null), isConst (false), refCount(0), linkageToVR (-1), spill_loc_index (-1),
-            isWritten (false)
-    {
-    }
-
-    /**
-     * @brief Constructor which initializes an entry with its register number and type.
-     * @param regNum The register number: vr number, temp number, or hardcoded register number.
-     * @param physicalType the LowOpndRegType for this register. Should reflect both its physical
-     * type and its logical type.
-     */
-    CompileTableEntry (int regNum, int physicalType) :
-            regNum (regNum), physicalType (physicalType), physicalReg (PhysicalReg_Null),
-            isConst (false), refCount(0), linkageToVR (0), spill_loc_index (-1), isWritten (false)
-    {
-        size = getRegSize (physicalType);
-    }
-
-    /**
-     * @brief Constructs a compile table entry which represents a virtual register.
-     * @param vrInfo The virtual register info to use for initialization.
-     */
-    CompileTableEntry (const VirtualRegInfo &vrInfo) :
-            regNum (vrInfo.regNum), physicalType (LowOpndRegType_virtual | vrInfo.physicalType),
-            physicalReg (PhysicalReg_Null), isConst (false), refCount(vrInfo.refCount),
-            linkageToVR (0), spill_loc_index (-1), isWritten (false)
-    {
-        size = getRegSize (vrInfo.physicalType);
-    }
-
-    /**
-     * @brief Returns the register number.
-     */
-    int getRegisterNumber (void) const
-    {
-        return regNum;
-    }
-
-    /**
-     * @brief Returns the physical type for this entry. This returns only type of physical register
-     * usable for this entry.
-     */
-    LowOpndRegType getPhysicalType (void) const
-    {
-        return static_cast<LowOpndRegType> (physicalType & MASK_FOR_TYPE);
-    }
-
-    /**
-     * @brief Returns the physical register used for this entry.
-     */
-    PhysicalReg getPhysicalReg (void) const
-    {
-        return static_cast<PhysicalReg> (physicalReg);
-    }
-
-    /**
-     * @brief Returns the size of the physical type for this entry.
-     */
-    OpndSize getSize (void) const
-    {
-        return size;
-    }
-
-    /**
-     * @brief Sets a new physical register for this entry.
-     * @param newReg The new physical register.
-     */
-    void setPhysicalReg (PhysicalReg newReg)
-    {
-        setPhysicalReg (static_cast<int> (newReg));
-    }
-
-    /**
-     * @brief Sets a new physical register for this entry.
-     * @param newReg The new physical register.
-     */
-    void setPhysicalReg (int newReg)
-    {
-        // It doesn't make sense to set physical register to a non-existent register.
-        // Thus we have this check here for sanity.
-        assert (newReg <= PhysicalReg_Null);
-        physicalReg = newReg;
-    }
-
-    /**
-     * @brief Updates the reference count for this entry.
-     * @param newCount The reference count to set.
-     */
-    void updateRefCount (int newCount)
-    {
-        refCount = newCount;
-    }
-
-    /**
-     * @brief Returns whether this entry is in a physical register.
-     */
-    bool inPhysicalRegister (void) const
-    {
-        return physicalReg != PhysicalReg_Null;
-    }
-
-    /**
-     * @brief Returns whether this entry is in a general purpose register.
-     */
-    bool inGeneralPurposeRegister (void) const
-    {
-        return (physicalReg >= PhysicalReg_StartOfGPMarker && physicalReg <= PhysicalReg_EndOfGPMarker);
-    }
-
-    /**
-     * @brief Returns whether this entry is in an xmm register.
-     */
-    bool inXMMRegister (void) const
-    {
-        return (physicalReg >= PhysicalReg_StartOfXmmMarker && physicalReg <= PhysicalReg_EndOfXmmMarker);
-    }
-
-    /**
-     * @brief Returns whether this entry represent a virtual register.
-     */
-    bool isVirtualReg (void) const
-    {
-        return ((physicalType & LowOpndRegType_virtual) != 0);
-    }
-
-    /**
-     * @brief Returns whether this entry represent a backend temporary.
-     */
-    bool isTemporary (void) const
-    {
-        return (isVirtualReg () == false && regNum < PhysicalReg_GLUE_DVMDEX);
-    }
-
-    /**
-     * @brief Resets properties of compile entry to default values. Does not reset the type and register represented
-     * by this compile entry.
-     */
-    void reset (void)
-    {
-        //We do not reset regNum and physicalType because those uniquely represent an entry
-        //Because of that, we also do not reset size because it is calculated based on physical type.
-
-        //Reset physical register to null
-        physicalReg = PhysicalReg_Null;
-
-        //Not a constant
-        isConst = false;
-        value[0] = 0, value[1] = 0;
-
-        //Unknown number of references
-        refCount = 0;
-
-        //If temporary, we don't know the VR it represents
-        linkageToVR = -1;
-
-        //We have not spilled this entry so no spill index
-        spill_loc_index = -1;
-
-        //We have not written to this
-        isWritten = false;
-    }
-
-    int regNum;               /**< @brief The register number */
-    int physicalType;         /**< @brief The physical type: gp, xmm or scratch, virtual */
-    int physicalReg;          /**< @brief Which physical register was chosen */
-    OpndSize size;            /**< @brief Used to keep track of size of entry */
-
-    bool isConst;             /**< @brief Is the entry a constant */
-    int value[2];             /**< @brief The value: [0]: lower [1]: higher */
-    int refCount;             /**< @brief Number of reference counts for the entry */
-
-    int linkageToVR;          /**< @brief Linked to which VR, for temporary registers only */
-
-    int spill_loc_index;      /**< @brief what is the spill location index (for temporary registers only) */
-    bool isWritten;           /**< @brief is the entry written */
-};
-
-//!to save the state of register allocator
-typedef struct regAllocStateEntry1 {
-  int spill_loc_index;
-  int physicalReg;
-} regAllocStateEntry1;
-typedef struct regAllocStateEntry2 {
-  int regNum; //
-  bool inMemory; //whether 4-byte virtual reg is in memory
-} regAllocStateEntry2;
-//!edge in control flow graph
-typedef struct Edge_O1 {
-  struct BasicBlock_O1* src;
-  struct BasicBlock_O1* dst;
-} Edge_O1;
 
 //Forward declaration
 struct LowOpBlockLabel;
@@ -495,13 +322,9 @@ struct BasicBlock_O1 : BasicBlock {
 
   DefUsePair* defUseTable;
   DefUsePair* defUseTail;
-  int num_defs;
 
   std::vector <XferPoint> xferPoints; //program points where the transfer is required
 
-  bool endsWithReturn;
-  bool hasAccessToGlue;
-
   AssociationTable associationTable;    //Association table to keep track of physical registers beyond a BasicBlock
 
   LowOpBlockLabel *label;               //Label for the BasicBlock
@@ -514,54 +337,30 @@ struct BasicBlock_O1 : BasicBlock {
   //Clear and free everything
   void freeIt (void);
 };
-typedef struct CFG_O1 {
-  BasicBlock_O1* head;
-} CFG_O1;
-//!worklist to create a control flow graph
-typedef struct CFGWork {
-  BasicBlock_O1* bb_prev;
-  int targetOff;
-  struct CFGWork* nextItem;
-} CFGWork;
-
-/////////////////////////////////////////
-//! array of MemoryVRInfo to store whether a VR is in memory
 
 extern MemoryVRInfo memVRTable[NUM_MEM_VR_ENTRY];
 extern int num_memory_vr;
-extern CompileTableEntry compileTable[COMPILE_TABLE_SIZE];
-extern int num_compile_entries;
-extern VirtualRegInfo infoByteCode[MAX_REG_PER_BYTECODE];
-extern int num_regs_per_bytecode;
 extern TempRegInfo infoByteCodeTemp[MAX_TEMP_REG_PER_BYTECODE];
 extern int num_temp_regs_per_bytecode;
 extern VirtualRegInfo infoMethod[MAX_REG_PER_METHOD];
 extern int num_regs_per_method;
 extern BasicBlock_O1* currentBB;
 
-// TODO The usage of method_bbs_sorted should be eliminated since
-// we automatically get all of the BasicBlock_O1 as part of the cUnit
-extern int num_bbs_for_method;
-extern BasicBlock_O1* method_bbs_sorted[MAX_NUM_BBS_PER_METHOD];
-
 extern int num_const_vr;
 extern ConstVRInfo constVRTable[MAX_CONST_REG];
 
-typedef enum GlueVarType {
-  RES_CLASS = 0,
-  RES_METHOD,
-  RES_FIELD,
-  RES_STRING,
-  GLUE_DVMDEX,
-  GLUE_METHOD_CLASS,
-  GLUE_METHOD
-} GlueVarType;
+/**
+ * @brief Provides a mapping between physical type and the size represented.
+ * @param type The physical type represented by LowOpndRegType.
+ * @return Returns size represented by the physical type.
+ */
+OpndSize getRegSize (int type);
 
 void forwardAnalysis(int type);
 
 //functions in bc_visitor.c
 int getConstInfo(BasicBlock_O1* bb, const MIR * currentMIR);
-int getVirtualRegInfo(VirtualRegInfo* infoArray, const MIR * currentMIR);
+int getVirtualRegInfo(VirtualRegInfo* infoArray, const MIR * currentMIR, bool updateBBConstraints = false);
 int getTempRegInfo(TempRegInfo* infoArray, const MIR * currentMIR);
 int createCFGHandler(Method* method);
 
@@ -571,7 +370,8 @@ void handleJump(BasicBlock_O1* bb_prev, int relOff);
 void connectBasicBlock(BasicBlock_O1* src, BasicBlock_O1* dst);
 int insertWorklist(BasicBlock_O1* bb_prev, int targetOff);
 
-int collectInfoOfBasicBlock(Method* method, BasicBlock_O1* bb); //update bb->infoBasicBlock
+//Collects virtual register usage for BB and sets up defuse tables
+int collectInfoOfBasicBlock (BasicBlock_O1* bb);
 
 void updateCurrentBBWithConstraints(PhysicalReg reg);
 void updateConstInfo(BasicBlock_O1*);
@@ -595,7 +395,7 @@ enum VirtualRegConstantness
 };
 
 //Checks if VR is constant
-VirtualRegConstantness isVirtualRegConstant (int regNum, int opndRegType, int *valuePtr, bool updateRef);
+VirtualRegConstantness isVirtualRegConstant (int regNum, int opndRegType, int *valuePtr, bool updateRef = false);
 
 //If VR is dirty, it writes the constant value to the VR on stack
 void writeBackConstVR (int vR, int value);
@@ -603,15 +403,20 @@ void writeBackConstVR (int vR, int value);
 //Writes virtual register back to memory if it holds a constant value
 bool writeBackVRIfConstant (int vR, LowOpndRegType type);
 
+//Write back virtual register to memory when it is in given physical register
+void writeBackVR (int vR, LowOpndRegType type, int physicalReg);
+
 //Check if VR is in memory
 bool isInMemory(int regNum, OpndSize size);
 
+//Update the in memory state of the virtual register
+void setVRMemoryState (int vR, OpndSize size, bool inMemory);
+
 //Find free registers and update the set
-void findFreeRegisters(std::set<PhysicalReg> & outFreeRegisters);
+void findFreeRegisters (std::set<PhysicalReg> &outFreeRegisters, bool includeGPs = true, bool includeXMMs = true);
 
 //Get a scratch register of a given type
-PhysicalReg getScratch(std::set<PhysicalReg> & scratchCandidates,
-        LowOpndRegType type);
+PhysicalReg getScratch(const std::set<PhysicalReg> &scratchCandidates, LowOpndRegType type);
 
 //Synchronize all registers in the compileTable
 void syncAllRegs(void);
@@ -628,9 +433,12 @@ bool isVirtualReg(int type);
 //Spill a logical register using a index in the compileTable
 int spillLogicalReg(int spill_index, bool updateTable);
 
-// Search in the memory table for a register
+//Search in the memory table for a register
 int searchMemTable(int regNum);
 
+//Adds a virtual register to the memory table
+bool addToMemVRTable (int vR, bool inMemory);
+
 //! check whether the current bytecode is the last access to a VR within a live
 bool isLastByteCodeOfLiveRange(int compileIndex);
 #endif
diff --git a/vm/compiler/codegen/x86/BytecodeVisitor.cpp b/vm/compiler/codegen/x86/BytecodeVisitor.cpp
index a36cfa8..6d40c34 100644
--- a/vm/compiler/codegen/x86/BytecodeVisitor.cpp
+++ b/vm/compiler/codegen/x86/BytecodeVisitor.cpp
@@ -601,7 +601,6 @@ int getConstInfo(BasicBlock_O1* bb, const MIR * currentMIR) {
     int retCode = 0;
     bool success = false;
 
-    CompileTableEntry* infoArray = compileTable;
     Opcode inst_op = currentMIR->dalvikInsn.opcode;
     int vA = 0, vB = 0, v1, v2;
     u2 BBBB;
@@ -610,7 +609,7 @@ int getConstInfo(BasicBlock_O1* bb, const MIR * currentMIR) {
     u4 tmp_u4;
     int entry, tmpValue[2], tmpValue2[2];
 
-    num_const_worklist = 0;
+    clearConstKills ();
 
 #ifdef WITH_JIT_INLINING
     /* A bytecode with the MIR_INLINED op will be treated as
@@ -661,8 +660,6 @@ int getConstInfo(BasicBlock_O1* bb, const MIR * currentMIR) {
                 return -1;
             }
 
-            infoArray[entry].isConst = true;
-            infoArray[entry].value[0] = tmpValue[0];
             compileTable[entry].refCount--;
             retCode = touchOneVR(vB, LowOpndRegType_gp);
             if (retCode < 0)
@@ -821,21 +818,35 @@ int getConstInfo(BasicBlock_O1* bb, const MIR * currentMIR) {
         if(isVirtualRegConstant(vB, LowOpndRegType_gp, tmpValue, false) == 3) {
             entry = findVirtualRegInTable(vA, LowOpndRegType_gp);
             if (entry < 0)
+            {
                 return -1;
-            infoArray[entry].isConst = true;
-            if(inst_op == OP_NEG_INT)
-                infoArray[entry].value[0] = -tmpValue[0];
-            if(inst_op == OP_NOT_INT)
-                infoArray[entry].value[0] = ~tmpValue[0]; //CHECK
-            if(inst_op == OP_LONG_TO_INT)
-                infoArray[entry].value[0] = tmpValue[0];
-            if(inst_op == OP_INT_TO_BYTE)// sar
-                infoArray[entry].value[0] = (tmpValue[0] << 24) >> 24;
-            if(inst_op == OP_INT_TO_CHAR) //shr
-                infoArray[entry].value[0] = ((unsigned int)(tmpValue[0] << 16)) >> 16;
-            if(inst_op == OP_INT_TO_SHORT) //sar
-                infoArray[entry].value[0] = (tmpValue[0] << 16) >> 16;
-            tmpValue[0] = infoArray[entry].value[0];
+            }
+
+            switch (inst_op)
+            {
+                case OP_NEG_INT:
+                    tmpValue[0] = -tmpValue[0];
+                    break;
+                case OP_NOT_INT:
+                    tmpValue[0] = ~tmpValue[0]; //CHECK
+                    break;
+                case OP_LONG_TO_INT:
+                    //Nothing to do for long to int to convert value
+                    break;
+                case OP_INT_TO_BYTE: // sar
+                    tmpValue[0] = (tmpValue[0] << 24) >> 24;
+                    break;
+                case OP_INT_TO_CHAR: //shr
+                    tmpValue[0] = ((unsigned int) (tmpValue[0] << 16)) >> 16;
+                    break;
+                case OP_INT_TO_SHORT: //sar
+                    tmpValue[0] = (tmpValue[0] << 16) >> 16;
+                    break;
+                default:
+                    ALOGI ("JIT_INFO: Unsupported constant folding for %d\n", inst_op);
+                    SET_JIT_ERROR (kJitErrorConstantFolding);
+                    return -1;
+            }
 
             success = setVRToConst(vA, OpndSize_32, tmpValue);
             if (success == false)
@@ -890,31 +901,50 @@ int getConstInfo(BasicBlock_O1* bb, const MIR * currentMIR) {
            isVirtualRegConstant(v2, LowOpndRegType_gp, tmpValue2, false) == 3) {
             entry = findVirtualRegInTable(vA, LowOpndRegType_gp);
             if (entry < 0)
+            {
                 return -1;
-            infoArray[entry].isConst = true;
-            if(inst_op == OP_ADD_INT_2ADDR)
-                infoArray[entry].value[0] = tmpValue[0] + tmpValue2[0];
-            if(inst_op == OP_SUB_INT_2ADDR)
-                infoArray[entry].value[0] = tmpValue[0] - tmpValue2[0];
-            if(inst_op == OP_MUL_INT_2ADDR)
-                infoArray[entry].value[0] = tmpValue[0] * tmpValue2[0];
-            if(inst_op == OP_DIV_INT_2ADDR)
-                infoArray[entry].value[0] = tmpValue[0] / tmpValue2[0];
-            if(inst_op == OP_REM_INT_2ADDR)
-                infoArray[entry].value[0] = tmpValue[0] % tmpValue2[0];
-            if(inst_op == OP_AND_INT_2ADDR)
-                infoArray[entry].value[0] = tmpValue[0] & tmpValue2[0];
-            if(inst_op == OP_OR_INT_2ADDR)
-                infoArray[entry].value[0] = tmpValue[0] | tmpValue2[0];
-            if(inst_op == OP_XOR_INT_2ADDR)
-                infoArray[entry].value[0] = tmpValue[0] ^ tmpValue2[0];
-            if(inst_op == OP_SHL_INT_2ADDR)
-                infoArray[entry].value[0] = tmpValue[0] << tmpValue2[0];
-            if(inst_op == OP_SHR_INT_2ADDR)
-                infoArray[entry].value[0] = tmpValue[0] >> tmpValue2[0];
-            if(inst_op == OP_USHR_INT_2ADDR)
-                infoArray[entry].value[0] = (unsigned int)tmpValue[0] >> tmpValue2[0];
-            tmpValue[0] = infoArray[entry].value[0];
+            }
+
+            switch (inst_op)
+            {
+                case OP_ADD_INT_2ADDR:
+                    tmpValue[0] = tmpValue[0] + tmpValue2[0];
+                    break;
+                case OP_SUB_INT_2ADDR:
+                    tmpValue[0] = tmpValue[0] - tmpValue2[0];
+                    break;
+                case OP_MUL_INT_2ADDR:
+                    tmpValue[0] = tmpValue[0] * tmpValue2[0];
+                    break;
+                case OP_DIV_INT_2ADDR:
+                    tmpValue[0] = tmpValue[0] / tmpValue2[0];
+                    break;
+                case OP_REM_INT_2ADDR:
+                    tmpValue[0] = tmpValue[0] % tmpValue2[0];
+                    break;
+                case OP_AND_INT_2ADDR:
+                    tmpValue[0] = tmpValue[0] & tmpValue2[0];
+                    break;
+                case OP_OR_INT_2ADDR:
+                    tmpValue[0] = tmpValue[0] | tmpValue2[0];
+                    break;
+                case OP_XOR_INT_2ADDR:
+                    tmpValue[0] = tmpValue[0] ^ tmpValue2[0];
+                    break;
+                case OP_SHL_INT_2ADDR:
+                    tmpValue[0] = tmpValue[0] << tmpValue2[0];
+                    break;
+                case OP_SHR_INT_2ADDR:
+                    tmpValue[0] = tmpValue[0] >> tmpValue2[0];
+                    break;
+                case OP_USHR_INT_2ADDR:
+                    tmpValue[0] = (unsigned int) tmpValue[0] >> tmpValue2[0];
+                    break;
+                default:
+                    ALOGI ("JIT_INFO: Unsupported constant folding for %d\n", inst_op);
+                    SET_JIT_ERROR (kJitErrorConstantFolding);
+                    return -1;
+            }
 
             success = setVRToConst(vA, OpndSize_32, tmpValue);
             if (success == false)
@@ -948,25 +978,41 @@ int getConstInfo(BasicBlock_O1* bb, const MIR * currentMIR) {
         if(isVirtualRegConstant(vB, LowOpndRegType_gp, tmpValue, false) == 3) {
             entry = findVirtualRegInTable(vA, LowOpndRegType_gp);
             if (entry < 0)
+            {
                 return -1;
-            infoArray[entry].isConst = true;
-            if(inst_op == OP_ADD_INT_LIT16)
-                infoArray[entry].value[0] = tmpValue[0] + tmp_s4;
-            if(inst_op == OP_RSUB_INT)
-                infoArray[entry].value[0] = tmp_s4 - tmpValue[0];
-            if(inst_op == OP_MUL_INT_LIT16)
-                infoArray[entry].value[0] = tmpValue[0] * tmp_s4;
-            if(inst_op == OP_DIV_INT_LIT16)
-                infoArray[entry].value[0] = tmpValue[0] / tmp_s4;
-            if(inst_op == OP_REM_INT_LIT16)
-                infoArray[entry].value[0] = tmpValue[0] % tmp_s4;
-            if(inst_op == OP_AND_INT_LIT16)
-                infoArray[entry].value[0] = tmpValue[0] & tmp_s4;
-            if(inst_op == OP_OR_INT_LIT16)
-                infoArray[entry].value[0] = tmpValue[0] | tmp_s4;
-            if(inst_op == OP_XOR_INT_LIT16)
-                infoArray[entry].value[0] = tmpValue[0] ^ tmp_s4;
-            tmpValue[0] = infoArray[entry].value[0];
+            }
+
+            switch (inst_op)
+            {
+                case OP_ADD_INT_LIT16:
+                    tmpValue[0] = tmpValue[0] + tmp_s4;
+                    break;
+                case OP_RSUB_INT:
+                    tmpValue[0] = tmp_s4 - tmpValue[0];
+                    break;
+                case OP_MUL_INT_LIT16:
+                    tmpValue[0] = tmpValue[0] * tmp_s4;
+                    break;
+                case OP_DIV_INT_LIT16:
+                    tmpValue[0] = tmpValue[0] / tmp_s4;
+                    break;
+                case OP_REM_INT_LIT16:
+                    tmpValue[0] = tmpValue[0] % tmp_s4;
+                    break;
+                case OP_AND_INT_LIT16:
+                    tmpValue[0] = tmpValue[0] & tmp_s4;
+                    break;
+                case OP_OR_INT_LIT16:
+                    tmpValue[0] = tmpValue[0] | tmp_s4;
+                    break;
+                case OP_XOR_INT_LIT16:
+                    tmpValue[0] = tmpValue[0] ^ tmp_s4;
+                    break;
+                default:
+                    ALOGI ("JIT_INFO: Unsupported constant folding for %d\n", inst_op);
+                    SET_JIT_ERROR (kJitErrorConstantFolding);
+                    return -1;
+            }
 
             success = setVRToConst(vA, OpndSize_32, tmpValue);
             if (success == false)
@@ -1004,31 +1050,50 @@ int getConstInfo(BasicBlock_O1* bb, const MIR * currentMIR) {
            isVirtualRegConstant(v2, LowOpndRegType_gp, tmpValue2, false) == 3) {
             entry = findVirtualRegInTable(vA, LowOpndRegType_gp);
             if (entry < 0)
+            {
                 return -1;
-            infoArray[entry].isConst = true;
-            if(inst_op == OP_ADD_INT)
-                infoArray[entry].value[0] = tmpValue[0] + tmpValue2[0];
-            if(inst_op == OP_SUB_INT)
-                infoArray[entry].value[0] = tmpValue[0] - tmpValue2[0];
-            if(inst_op == OP_MUL_INT)
-                infoArray[entry].value[0] = tmpValue[0] * tmpValue2[0];
-            if(inst_op == OP_DIV_INT)
-                infoArray[entry].value[0] = tmpValue[0] / tmpValue2[0];
-            if(inst_op == OP_REM_INT)
-                infoArray[entry].value[0] = tmpValue[0] % tmpValue2[0];
-            if(inst_op == OP_AND_INT)
-                infoArray[entry].value[0] = tmpValue[0] & tmpValue2[0];
-            if(inst_op == OP_OR_INT)
-                infoArray[entry].value[0] = tmpValue[0] | tmpValue2[0];
-            if(inst_op == OP_XOR_INT)
-                infoArray[entry].value[0] = tmpValue[0] ^ tmpValue2[0];
-            if(inst_op == OP_SHL_INT)
-                infoArray[entry].value[0] = tmpValue[0] << tmpValue2[0];
-            if(inst_op == OP_SHR_INT)
-                infoArray[entry].value[0] = tmpValue[0] >> tmpValue2[0];
-            if(inst_op == OP_USHR_INT)
-                infoArray[entry].value[0] = (unsigned int)tmpValue[0] >> tmpValue2[0];
-            tmpValue[0] = infoArray[entry].value[0];
+            }
+
+            switch (inst_op)
+            {
+                case OP_ADD_INT:
+                    tmpValue[0] = tmpValue[0] + tmpValue2[0];
+                    break;
+                case OP_SUB_INT:
+                    tmpValue[0] = tmpValue[0] - tmpValue2[0];
+                    break;
+                case OP_MUL_INT:
+                    tmpValue[0] = tmpValue[0] * tmpValue2[0];
+                    break;
+                case OP_DIV_INT:
+                    tmpValue[0] = tmpValue[0] / tmpValue2[0];
+                    break;
+                case OP_REM_INT:
+                    tmpValue[0] = tmpValue[0] % tmpValue2[0];
+                    break;
+                case OP_AND_INT:
+                    tmpValue[0] = tmpValue[0] & tmpValue2[0];
+                    break;
+                case OP_OR_INT:
+                    tmpValue[0] = tmpValue[0] | tmpValue2[0];
+                    break;
+                case OP_XOR_INT:
+                    tmpValue[0] = tmpValue[0] ^ tmpValue2[0];
+                    break;
+                case OP_SHL_INT:
+                    tmpValue[0] = tmpValue[0] << tmpValue2[0];
+                    break;
+                case OP_SHR_INT:
+                    tmpValue[0] = tmpValue[0] >> tmpValue2[0];
+                    break;
+                case OP_USHR_INT:
+                    tmpValue[0] = (unsigned int) tmpValue[0] >> tmpValue2[0];
+                    break;
+                default:
+                    ALOGI ("JIT_INFO: Unsupported constant folding for %d\n", inst_op);
+                    SET_JIT_ERROR (kJitErrorConstantFolding);
+                    return -1;
+            }
 
             success = setVRToConst(vA, OpndSize_32, tmpValue);
             if (success == false)
@@ -1068,31 +1133,50 @@ int getConstInfo(BasicBlock_O1* bb, const MIR * currentMIR) {
         if(isVirtualRegConstant(vB, LowOpndRegType_gp, tmpValue, false) == 3) {
             entry = findVirtualRegInTable(vA, LowOpndRegType_gp);
             if (entry < 0)
+            {
                 return -1;
-            infoArray[entry].isConst = true;
-            if(inst_op == OP_ADD_INT_LIT8)
-                infoArray[entry].value[0] = tmpValue[0] + tmp_s4;
-            if(inst_op == OP_RSUB_INT_LIT8)
-                infoArray[entry].value[0] = tmp_s4 - tmpValue[0];
-            if(inst_op == OP_MUL_INT_LIT8)
-                infoArray[entry].value[0] = tmpValue[0] * tmp_s4;
-            if(inst_op == OP_DIV_INT_LIT8)
-                infoArray[entry].value[0] = tmpValue[0] / tmp_s4;
-            if(inst_op == OP_REM_INT_LIT8)
-                infoArray[entry].value[0] = tmpValue[0] % tmp_s4;
-            if(inst_op == OP_AND_INT_LIT8)
-                infoArray[entry].value[0] = tmpValue[0] & tmp_s4;
-            if(inst_op == OP_OR_INT_LIT8)
-                infoArray[entry].value[0] = tmpValue[0] | tmp_s4;
-            if(inst_op == OP_XOR_INT_LIT8)
-                infoArray[entry].value[0] = tmpValue[0] ^ tmp_s4;
-            if(inst_op == OP_SHL_INT_LIT8)
-                infoArray[entry].value[0] = tmpValue[0] << tmp_s4;
-            if(inst_op == OP_SHR_INT_LIT8)
-                infoArray[entry].value[0] = tmpValue[0] >> tmp_s4;
-            if(inst_op == OP_USHR_INT_LIT8)
-                infoArray[entry].value[0] = (unsigned int)tmpValue[0] >> tmp_s4;
-            tmpValue[0] = infoArray[entry].value[0];
+            }
+
+            switch (inst_op)
+            {
+                case OP_ADD_INT_LIT8:
+                    tmpValue[0] = tmpValue[0] + tmp_s4;
+                    break;
+                case OP_RSUB_INT_LIT8:
+                    tmpValue[0] = tmp_s4 - tmpValue[0];
+                    break;
+                case OP_MUL_INT_LIT8:
+                    tmpValue[0] = tmpValue[0] * tmp_s4;
+                    break;
+                case OP_DIV_INT_LIT8:
+                    tmpValue[0] = tmpValue[0] / tmp_s4;
+                    break;
+                case OP_REM_INT_LIT8:
+                    tmpValue[0] = tmpValue[0] % tmp_s4;
+                    break;
+                case OP_AND_INT_LIT8:
+                    tmpValue[0] = tmpValue[0] & tmp_s4;
+                    break;
+                case OP_OR_INT_LIT8:
+                    tmpValue[0] = tmpValue[0] | tmp_s4;
+                    break;
+                case OP_XOR_INT_LIT8:
+                    tmpValue[0] = tmpValue[0] ^ tmp_s4;
+                    break;
+                case OP_SHL_INT_LIT8:
+                    tmpValue[0] = tmpValue[0] << tmp_s4;
+                    break;
+                case OP_SHR_INT_LIT8:
+                    tmpValue[0] = tmpValue[0] >> tmp_s4;
+                    break;
+                case OP_USHR_INT_LIT8:
+                    tmpValue[0] = (unsigned int) tmpValue[0] >> tmp_s4;
+                    break;
+                default:
+                    ALOGI ("JIT_INFO: Unsupported constant folding for %d\n", inst_op);
+                    SET_JIT_ERROR (kJitErrorConstantFolding);
+                    return -1;
+            }
 
             success = setVRToConst(vA, OpndSize_32, tmpValue);
             if (success == false)
@@ -1156,9 +1240,7 @@ int getConstInfo(BasicBlock_O1* bb, const MIR * currentMIR) {
         entry = findVirtualRegInTable(vA, LowOpndRegType_gp);
         if (entry < 0)
             return -1;
-        infoArray[entry].isConst = true;
-        infoArray[entry].value[0] = tmp_s4;
-        tmpValue[0] = infoArray[entry].value[0];
+        tmpValue[0] = tmp_s4;
 
         success = setVRToConst(vA, OpndSize_32, tmpValue);
         if (success == false)
@@ -1178,9 +1260,7 @@ int getConstInfo(BasicBlock_O1* bb, const MIR * currentMIR) {
         entry = findVirtualRegInTable(vA, LowOpndRegType_gp);
         if (entry < 0)
             return -1;
-        infoArray[entry].isConst = true;
-        infoArray[entry].value[0] = (s2)BBBB;
-        tmpValue[0] = infoArray[entry].value[0];
+        tmpValue[0] = (s2)BBBB;
 
         success = setVRToConst(vA, OpndSize_32, tmpValue);
         if (success == false)
@@ -1200,9 +1280,7 @@ int getConstInfo(BasicBlock_O1* bb, const MIR * currentMIR) {
         entry = findVirtualRegInTable(vA, LowOpndRegType_gp);
         if (entry < 0)
             return -1;
-        infoArray[entry].isConst = true;
-        infoArray[entry].value[0] = (s4)tmp_u4;
-        tmpValue[0] = infoArray[entry].value[0];
+        tmpValue[0] = (s4)tmp_u4;
 
         success = setVRToConst(vA, OpndSize_32, tmpValue);
         if (success == false)
@@ -1222,9 +1300,7 @@ int getConstInfo(BasicBlock_O1* bb, const MIR * currentMIR) {
         entry = findVirtualRegInTable(vA, LowOpndRegType_gp);
         if (entry < 0)
             return -1;
-        infoArray[entry].isConst = true;
-        infoArray[entry].value[0] = ((s4)tmp_u2)<<16;
-        tmpValue[0] = infoArray[entry].value[0];
+        tmpValue[0] = ((s4)tmp_u2)<<16;
 
         success = setVRToConst(vA, OpndSize_32, tmpValue);
         if (success == false)
@@ -1244,9 +1320,8 @@ int getConstInfo(BasicBlock_O1* bb, const MIR * currentMIR) {
         entry = findVirtualRegInTable(vA, LowOpndRegType_gp);
         if (entry < 0)
             return -1;
-        infoArray[entry].isConst = true;
-        infoArray[entry].value[0] = (s2)tmp_u2;
-        tmpValue[0] = infoArray[entry].value[0];
+        tmpValue[0] = (s2)tmp_u2;
+
         compileTable[entry].refCount--;
 #ifdef DEBUG_CONST
         ALOGD("getConstInfo: set VR %d to %x", vA, infoArray[entry].value[0]);
@@ -1255,9 +1330,7 @@ int getConstInfo(BasicBlock_O1* bb, const MIR * currentMIR) {
         entry = findVirtualRegInTable(vA+1, LowOpndRegType_gp);
         if (entry < 0)
             return -1;
-        infoArray[entry].isConst = true;
-        infoArray[entry].value[0] = ((s2)tmp_u2)>>31;
-        tmpValue[1] = infoArray[entry].value[0];
+        tmpValue[1] = ((s2)tmp_u2)>>31;
 
         success = setVRToConst(vA, OpndSize_64, tmpValue);
         if (success == false)
@@ -1277,9 +1350,7 @@ int getConstInfo(BasicBlock_O1* bb, const MIR * currentMIR) {
         entry = findVirtualRegInTable(vA, LowOpndRegType_gp);
         if (entry < 0)
             return -1;
-        infoArray[entry].isConst = true;
-        infoArray[entry].value[0] = (s4)tmp_u4;
-        tmpValue[0] = infoArray[entry].value[0];
+        tmpValue[0] = (s4)tmp_u4;
         compileTable[entry].refCount--;
 #ifdef DEBUG_CONST
         ALOGD("getConstInfo: set VR %d to %x", vA, infoArray[entry].value[0]);
@@ -1288,9 +1359,7 @@ int getConstInfo(BasicBlock_O1* bb, const MIR * currentMIR) {
         entry = findVirtualRegInTable(vA+1, LowOpndRegType_gp);
         if (entry < 0)
             return -1;
-        infoArray[entry].isConst = true;
-        infoArray[entry].value[0] = ((s4)tmp_u4)>>31;
-        tmpValue[1] = infoArray[entry].value[0];
+        tmpValue[1] = ((s4)tmp_u4)>>31;
 
         success = setVRToConst(vA, OpndSize_64, tmpValue);
         if (success == false)
@@ -1310,9 +1379,8 @@ int getConstInfo(BasicBlock_O1* bb, const MIR * currentMIR) {
         entry = findVirtualRegInTable(vA, LowOpndRegType_gp);
         if (entry < 0)
             return -1;
-        infoArray[entry].isConst = true;
-        infoArray[entry].value[0] = (s4)tmp_u4;
-        tmpValue[0] = infoArray[entry].value[0];
+        tmpValue[0] = (s4)tmp_u4;
+
         compileTable[entry].refCount--;
 #ifdef DEBUG_CONST
         ALOGD("getConstInfo: set VR %d to %x", vA, infoArray[entry].value[0]);
@@ -1322,9 +1390,7 @@ int getConstInfo(BasicBlock_O1* bb, const MIR * currentMIR) {
         entry = findVirtualRegInTable(vA+1, LowOpndRegType_gp);
         if (entry < 0)
             return -1;
-        infoArray[entry].isConst = true;
-        infoArray[entry].value[0] = (s4)tmp_u4;
-        tmpValue[1] = infoArray[entry].value[0];
+        tmpValue[1] = (s4)tmp_u4;
 
         success = setVRToConst(vA, OpndSize_64, tmpValue);
         if (success == false)
@@ -1344,9 +1410,8 @@ int getConstInfo(BasicBlock_O1* bb, const MIR * currentMIR) {
         entry = findVirtualRegInTable(vA, LowOpndRegType_gp);
         if (entry < 0)
             return -1;
-        infoArray[entry].isConst = true;
-        infoArray[entry].value[0] = 0;
-        tmpValue[0] = infoArray[entry].value[0];
+        tmpValue[0] = 0;
+
         compileTable[entry].refCount--;
 #ifdef DEBUG_CONST
         ALOGD("getConstInfo: set VR %d to %x", vA, infoArray[entry].value[0]);
@@ -1355,9 +1420,7 @@ int getConstInfo(BasicBlock_O1* bb, const MIR * currentMIR) {
         entry = findVirtualRegInTable(vA+1, LowOpndRegType_gp);
         if (entry < 0)
             return -1;
-        infoArray[entry].isConst = true;
-        infoArray[entry].value[0] = ((s4)tmp_u2)<<16;
-        tmpValue[1] = infoArray[entry].value[0];
+        tmpValue[1] = ((s4)tmp_u2)<<16;
 
         success = setVRToConst(vA, OpndSize_64, tmpValue);
         if (success == false)
@@ -1408,18 +1471,21 @@ int getConstInfo(BasicBlock_O1* bb, const MIR * currentMIR) {
     return 0;
 }
 
-//! This function updates infoArray with virtual registers accessed when lowering the bytecode, and returns size of the bytecode in unit of u2
-
-//! uses of virtual registers are added to infoArray first
-int getVirtualRegInfo(VirtualRegInfo* infoArray, const MIR * currentMIR) {
+/**
+ * @brief Updates infoArray with virtual registers accessed when lowering the bytecode.
+ * @param infoArray Must be an array of size MAX_REG_PER_BYTECODE. This is updated by function.
+ * @param currentMIR The MIR to examine.
+ * @return Returns the number of registers for the bytecode. Returns -1 in case of error.
+ */
+int getVirtualRegInfo (VirtualRegInfo* infoArray, const MIR * currentMIR, bool updateBBConstraints)
+{
     u2 inst_op = currentMIR->dalvikInsn.opcode;
     int vA = 0, vB = 0, vref, vindex;
     int v1, v2, vD, vE, vF;
     u2 length, count;
     int kk, num, num_entry;
     s2 tmp_s2;
-    int codeSize = 0;
-    num_regs_per_bytecode = 0;
+    int num_regs_per_bytecode = 0;
     //update infoArray[xx].allocConstraints
     for(num = 0; num < MAX_REG_PER_BYTECODE; num++) {
         for(kk = 0; kk < 8; kk++) {
@@ -1429,46 +1495,49 @@ int getVirtualRegInfo(VirtualRegInfo* infoArray, const MIR * currentMIR) {
     }
 
 #ifdef WITH_JIT_INLINING
-    /* A bytecode with the MIR_INLINED op will be treated as
-     * no-op during codegen */
+    //A bytecode with the inlined flag is treated as a nop so therefore simply return
+    //that we have 0 regs for this bytecode
     if (currentMIR->OptimizationFlags & MIR_INLINED)
-        return currentMIR->width;
+    {
+        return 0;
+    }
 #endif
 
+    bool isExtended = false;
+
     // Check if we need to handle an extended MIR
     if (currentMIR->dalvikInsn.opcode >= static_cast<Opcode> (kMirOpFirst)) {
+        //We have an extended MIR
+        isExtended = true;
+
         switch (static_cast<ExtendedMIROpcode>(currentMIR->dalvikInsn.opcode)) {
             case kMirOpRegisterize:
+                infoArray[0].regNum = currentMIR->dalvikInsn.vA;
+                infoArray[0].refCount = 2;
+
+                //The access type is use and then def because we use the VR when loading it into temporary
+                //and then we alias virtual register to that temporary thus "defining" it.
+                infoArray[0].accessType = REGACCESS_UD;
+
+                //Decide the type depending on the register class
+                switch (static_cast<RegisterClass> (currentMIR->dalvikInsn.vB))
                 {
-                    infoArray[0].regNum = currentMIR->dalvikInsn.vA;
-                    infoArray[0].refCount = 2;
-
-                    //The access type is use and then def because we use the VR when loading it into temporary
-                    //and then we alias virtual register to that temporary thus "defining" it.
-                    infoArray[0].accessType = REGACCESS_UD;
-
-                    //Ok the type really depends on vB
-                    RegisterClass regClass = static_cast<RegisterClass> (currentMIR->dalvikInsn.vB);
-
-                    //Decide the type depending on the register class
-                    switch (regClass) {
-                        case kCoreReg:
-                            infoArray[0].physicalType = LowOpndRegType_gp;
-                            break;
-                        case kSFPReg:
-                            infoArray[0].physicalType = LowOpndRegType_ss;
-                            break;
-                        case kDFPReg:
-                            infoArray[0].physicalType = LowOpndRegType_xmm;
-                            break;
-                        default:
-                            ALOGI("JIT_INFO: kMirOpRegisterize does not support regClass %d", regClass);
-                            SET_JIT_ERROR(kJitErrorUnsupportedBytecode);
-                            break;
-                    }
-                    num_regs_per_bytecode = 1;
+                    case kCoreReg:
+                        infoArray[0].physicalType = LowOpndRegType_gp;
+                        break;
+                    case kSFPReg:
+                        infoArray[0].physicalType = LowOpndRegType_ss;
+                        break;
+                    case kDFPReg:
+                        infoArray[0].physicalType = LowOpndRegType_xmm;
+                        break;
+                    default:
+                        ALOGI("JIT_INFO: kMirOpRegisterize does not support regClass %d", currentMIR->dalvikInsn.vB);
+                        SET_JIT_ERROR(kJitErrorUnsupportedBytecode);
+                        break;
                 }
-                return currentMIR->width;
+                num_regs_per_bytecode = 1;
+                break;
             case kMirOpDualDoubleDivide:
                 // (int-to-double arg[0], vC), (int-to-double arg[4], arg[3])
                 // (div-double vA, vB, vC), (div-double arg[1], arg[2], arg[3])
@@ -1513,7 +1582,7 @@ int getVirtualRegInfo(VirtualRegInfo* infoArray, const MIR * currentMIR) {
                 infoArray[0].physicalType = LowOpndRegType_gp;
 
                 num_regs_per_bytecode = 8;
-                return currentMIR->width;
+                break;
             default:
                 ALOGI("JIT_INFO: Extended MIR not supported in getVirtualRegInfo");
                 SET_JIT_ERROR(kJitErrorUnsupportedBytecode);
@@ -1521,9 +1590,14 @@ int getVirtualRegInfo(VirtualRegInfo* infoArray, const MIR * currentMIR) {
         }
     }
 
+    //If we have an extended bytecode, we have nothing else to do
+    if (isExtended == true)
+    {
+        return num_regs_per_bytecode;
+    }
+
     switch (inst_op) {
     case OP_NOP:
-        codeSize = 1;
         break;
     case OP_MOVE:
     case OP_MOVE_OBJECT:
@@ -1534,17 +1608,14 @@ int getVirtualRegInfo(VirtualRegInfo* infoArray, const MIR * currentMIR) {
         if(inst_op == OP_MOVE || inst_op == OP_MOVE_OBJECT) {
             vA = currentMIR->dalvikInsn.vA;
             vB = currentMIR->dalvikInsn.vB;
-            codeSize = 1;
         }
         else if(inst_op == OP_MOVE_FROM16 || inst_op == OP_MOVE_OBJECT_FROM16) {
             vA = currentMIR->dalvikInsn.vA;
             vB = currentMIR->dalvikInsn.vB;
-            codeSize = 2;
         }
         else if(inst_op == OP_MOVE_16 || inst_op == OP_MOVE_OBJECT_16) {
             vA = currentMIR->dalvikInsn.vA;
             vB = currentMIR->dalvikInsn.vB;
-            codeSize = 3;
         }
         infoArray[1].regNum = vA; //dst
         infoArray[1].refCount = 1;
@@ -1562,17 +1633,14 @@ int getVirtualRegInfo(VirtualRegInfo* infoArray, const MIR * currentMIR) {
         if(inst_op == OP_MOVE_WIDE) {
             vA = currentMIR->dalvikInsn.vA;
             vB = currentMIR->dalvikInsn.vB;
-            codeSize = 1;
         }
         else if(inst_op == OP_MOVE_WIDE_FROM16) {
             vA = currentMIR->dalvikInsn.vA;
             vB = currentMIR->dalvikInsn.vB;
-            codeSize = 2;
         }
         else if(inst_op == OP_MOVE_WIDE_16) {
             vA = currentMIR->dalvikInsn.vA;
             vB = currentMIR->dalvikInsn.vB;
-            codeSize = 3;
         }
         infoArray[1].regNum = vA; //dst
         infoArray[1].refCount = 1;
@@ -1591,7 +1659,6 @@ int getVirtualRegInfo(VirtualRegInfo* infoArray, const MIR * currentMIR) {
         infoArray[0].refCount = 1;
         infoArray[0].accessType = REGACCESS_D;
         infoArray[0].physicalType = LowOpndRegType_gp;
-        codeSize = 1;
         num_regs_per_bytecode = 1;
         break;
     case OP_MOVE_RESULT_WIDE: //note: 2 destinations
@@ -1600,7 +1667,6 @@ int getVirtualRegInfo(VirtualRegInfo* infoArray, const MIR * currentMIR) {
         infoArray[0].refCount = 1;
         infoArray[0].accessType = REGACCESS_D;
         infoArray[0].physicalType = LowOpndRegType_xmm;
-        codeSize = 1;
         num_regs_per_bytecode = 1;
         break;
     case OP_MOVE_EXCEPTION: //access memory
@@ -1609,24 +1675,27 @@ int getVirtualRegInfo(VirtualRegInfo* infoArray, const MIR * currentMIR) {
         infoArray[0].refCount = 1;
         infoArray[0].accessType = REGACCESS_D;
         infoArray[0].physicalType = LowOpndRegType_gp;
-        codeSize = 1;
         num_regs_per_bytecode = 1;
         break;
     case OP_RETURN_VOID:
     case OP_RETURN_VOID_BARRIER:
-        codeSize = 1;
-        updateCurrentBBWithConstraints(PhysicalReg_EAX);
+        if (updateBBConstraints == true)
+        {
+            updateCurrentBBWithConstraints (PhysicalReg_EAX);
+        }
         num_regs_per_bytecode = 0;
         break;
     case OP_RETURN:
     case OP_RETURN_OBJECT:
         vA = currentMIR->dalvikInsn.vA;
-        codeSize = 1;
         infoArray[0].regNum = vA; //src
         infoArray[0].refCount = 1;
         infoArray[0].accessType = REGACCESS_U;
         infoArray[0].physicalType = LowOpndRegType_gp;
-        updateCurrentBBWithConstraints(PhysicalReg_EAX);
+        if (updateBBConstraints == true)
+        {
+            updateCurrentBBWithConstraints (PhysicalReg_EAX);
+        }
         num_regs_per_bytecode = 1;
         break;
     case OP_RETURN_WIDE:
@@ -1636,7 +1705,6 @@ int getVirtualRegInfo(VirtualRegInfo* infoArray, const MIR * currentMIR) {
         infoArray[0].accessType = REGACCESS_U;
         infoArray[0].physicalType = LowOpndRegType_xmm;
         num_regs_per_bytecode = 1;
-        codeSize = 1;
         break;
     case OP_CONST_4:
         vA = currentMIR->dalvikInsn.vA;
@@ -1645,7 +1713,6 @@ int getVirtualRegInfo(VirtualRegInfo* infoArray, const MIR * currentMIR) {
         infoArray[0].accessType = REGACCESS_D;
         infoArray[0].physicalType = LowOpndRegType_gp;
         num_regs_per_bytecode = 1;
-        codeSize = 1;
         break;
     case OP_CONST_16:
         vA = currentMIR->dalvikInsn.vA;
@@ -1654,7 +1721,6 @@ int getVirtualRegInfo(VirtualRegInfo* infoArray, const MIR * currentMIR) {
         infoArray[0].accessType = REGACCESS_D;
         infoArray[0].physicalType = LowOpndRegType_gp;
         num_regs_per_bytecode = 1;
-        codeSize = 2;
         break;
     case OP_CONST:
         vA = currentMIR->dalvikInsn.vA;
@@ -1663,7 +1729,6 @@ int getVirtualRegInfo(VirtualRegInfo* infoArray, const MIR * currentMIR) {
         infoArray[0].accessType = REGACCESS_D;
         infoArray[0].physicalType = LowOpndRegType_gp;
         num_regs_per_bytecode = 1;
-        codeSize = 3;
         break;
     case OP_CONST_HIGH16:
         vA = currentMIR->dalvikInsn.vA;
@@ -1672,7 +1737,6 @@ int getVirtualRegInfo(VirtualRegInfo* infoArray, const MIR * currentMIR) {
         infoArray[0].accessType = REGACCESS_D;
         infoArray[0].physicalType = LowOpndRegType_gp;
         num_regs_per_bytecode = 1;
-        codeSize = 2;
         break;
     case OP_CONST_WIDE_16:
         vA = currentMIR->dalvikInsn.vA;
@@ -1684,7 +1748,6 @@ int getVirtualRegInfo(VirtualRegInfo* infoArray, const MIR * currentMIR) {
         infoArray[1].refCount = 1;
         infoArray[1].accessType = REGACCESS_D;
         infoArray[1].physicalType = LowOpndRegType_gp;
-        codeSize = 2;
         num_regs_per_bytecode = 2;
         break;
     case OP_CONST_WIDE_32:
@@ -1698,7 +1761,6 @@ int getVirtualRegInfo(VirtualRegInfo* infoArray, const MIR * currentMIR) {
         infoArray[1].accessType = REGACCESS_D;
         infoArray[1].physicalType = LowOpndRegType_gp;
         num_regs_per_bytecode = 2;
-        codeSize = 3;
         break;
     case OP_CONST_WIDE:
         vA = currentMIR->dalvikInsn.vA;
@@ -1710,7 +1772,6 @@ int getVirtualRegInfo(VirtualRegInfo* infoArray, const MIR * currentMIR) {
         infoArray[1].refCount = 1;
         infoArray[1].accessType = REGACCESS_D;
         infoArray[1].physicalType = LowOpndRegType_gp;
-        codeSize = 5;
         num_regs_per_bytecode = 2;
         break;
     case OP_CONST_WIDE_HIGH16:
@@ -1724,27 +1785,24 @@ int getVirtualRegInfo(VirtualRegInfo* infoArray, const MIR * currentMIR) {
         infoArray[1].accessType = REGACCESS_D;
         infoArray[1].physicalType = LowOpndRegType_gp;
         num_regs_per_bytecode = 2;
-        codeSize = 2;
         break;
     case OP_CONST_STRING:
     case OP_CONST_STRING_JUMBO:
     case OP_CONST_CLASS:
         vA = currentMIR->dalvikInsn.vA;
-        if(inst_op == OP_CONST_STRING || inst_op == OP_CONST_CLASS)
-            codeSize = 2;
-        else if(inst_op == OP_CONST_STRING_JUMBO)
-            codeSize = 3;
         infoArray[0].regNum = vA; //dst
         infoArray[0].refCount = 1;
         infoArray[0].accessType = REGACCESS_D;
         infoArray[0].physicalType = LowOpndRegType_gp;
         infoArray[0].allocConstraints[PhysicalReg_EAX].count = 1;
-        updateCurrentBBWithConstraints(PhysicalReg_EAX);
+        if (updateBBConstraints == true)
+        {
+            updateCurrentBBWithConstraints (PhysicalReg_EAX);
+        }
         num_regs_per_bytecode = 1;
         break;
     case OP_MONITOR_ENTER:
         vA = currentMIR->dalvikInsn.vA;
-        codeSize = 1;
         infoArray[0].regNum = vA; //src
         infoArray[0].refCount = 1;
         infoArray[0].accessType = REGACCESS_U;
@@ -1753,29 +1811,32 @@ int getVirtualRegInfo(VirtualRegInfo* infoArray, const MIR * currentMIR) {
         break;
     case OP_MONITOR_EXIT:
         vA = currentMIR->dalvikInsn.vA;
-        codeSize = 1;
         infoArray[0].regNum = vA; //src
         infoArray[0].refCount = 1;
         infoArray[0].accessType = REGACCESS_U;
         infoArray[0].physicalType = LowOpndRegType_gp;
-        updateCurrentBBWithConstraints(PhysicalReg_EAX); //eax is used as return value from c function
-        updateCurrentBBWithConstraints(PhysicalReg_EDX);
+        if (updateBBConstraints == true)
+        {
+            updateCurrentBBWithConstraints (PhysicalReg_EAX); //eax is used as return value from c function
+            updateCurrentBBWithConstraints (PhysicalReg_EDX);
+        }
         num_regs_per_bytecode = 1;
         break;
     case OP_CHECK_CAST:
-        codeSize = 2;
         vA = currentMIR->dalvikInsn.vA;
         infoArray[0].regNum = vA; //src
         infoArray[0].refCount = 1;
         infoArray[0].accessType = REGACCESS_U;
         infoArray[0].physicalType = LowOpndRegType_gp;
-        updateCurrentBBWithConstraints(PhysicalReg_EAX);
-        updateCurrentBBWithConstraints(PhysicalReg_ECX);
-        updateCurrentBBWithConstraints(PhysicalReg_EDX);
+        if (updateBBConstraints == true)
+        {
+            updateCurrentBBWithConstraints (PhysicalReg_EAX);
+            updateCurrentBBWithConstraints (PhysicalReg_ECX);
+            updateCurrentBBWithConstraints (PhysicalReg_EDX);
+        }
         num_regs_per_bytecode = 1;
         break;
     case OP_INSTANCE_OF:
-        codeSize = 2;
         vA = currentMIR->dalvikInsn.vA;
         vB = currentMIR->dalvikInsn.vB;
         infoArray[0].regNum = vB; //src
@@ -1786,13 +1847,15 @@ int getVirtualRegInfo(VirtualRegInfo* infoArray, const MIR * currentMIR) {
         infoArray[1].refCount = 1;
         infoArray[1].accessType = REGACCESS_D;
         infoArray[1].physicalType = LowOpndRegType_gp;
-        updateCurrentBBWithConstraints(PhysicalReg_EAX);
+        if (updateBBConstraints == true)
+        {
+            updateCurrentBBWithConstraints (PhysicalReg_EAX);
+        }
         num_regs_per_bytecode = 2;
         break;
     case OP_ARRAY_LENGTH:
         vA = currentMIR->dalvikInsn.vA;
         vB = currentMIR->dalvikInsn.vB;
-        codeSize = 1;
         infoArray[0].regNum = vB; //src
         infoArray[0].refCount = 1;
         infoArray[0].accessType = REGACCESS_U;
@@ -1802,7 +1865,10 @@ int getVirtualRegInfo(VirtualRegInfo* infoArray, const MIR * currentMIR) {
         infoArray[1].accessType = REGACCESS_D;
         infoArray[1].physicalType = LowOpndRegType_gp;
         //%edx is used in this bytecode, update currentBB->allocConstraints
-        updateCurrentBBWithConstraints(PhysicalReg_EDX);
+        if (updateBBConstraints == true)
+        {
+            updateCurrentBBWithConstraints (PhysicalReg_EDX);
+        }
         num_regs_per_bytecode = 2;
         break;
     case OP_NEW_INSTANCE:
@@ -1812,11 +1878,13 @@ int getVirtualRegInfo(VirtualRegInfo* infoArray, const MIR * currentMIR) {
         infoArray[0].accessType = REGACCESS_D;
         infoArray[0].physicalType = LowOpndRegType_gp;
         infoArray[0].allocConstraints[PhysicalReg_EAX].count = 1;
-        updateCurrentBBWithConstraints(PhysicalReg_EAX);
-        updateCurrentBBWithConstraints(PhysicalReg_ECX);
-        updateCurrentBBWithConstraints(PhysicalReg_EDX);
+        if (updateBBConstraints == true)
+        {
+            updateCurrentBBWithConstraints (PhysicalReg_EAX);
+            updateCurrentBBWithConstraints (PhysicalReg_ECX);
+            updateCurrentBBWithConstraints (PhysicalReg_EDX);
+        }
         num_regs_per_bytecode = 1;
-        codeSize = 2;
         break;
     case OP_NEW_ARRAY:
         vA = currentMIR->dalvikInsn.vA; //destination
@@ -1830,10 +1898,12 @@ int getVirtualRegInfo(VirtualRegInfo* infoArray, const MIR * currentMIR) {
         infoArray[1].accessType = REGACCESS_D;
         infoArray[1].physicalType = LowOpndRegType_gp;
         infoArray[1].allocConstraints[PhysicalReg_EAX].count = 1;
-        updateCurrentBBWithConstraints(PhysicalReg_EAX);
-        updateCurrentBBWithConstraints(PhysicalReg_EDX);
+        if (updateBBConstraints == true)
+        {
+            updateCurrentBBWithConstraints (PhysicalReg_EAX);
+            updateCurrentBBWithConstraints (PhysicalReg_EDX);
+        }
         num_regs_per_bytecode = 2;
-        codeSize = 2;
         break;
     case OP_FILLED_NEW_ARRAY: {//update return value
         //can use up to 5 registers to fill the content of array
@@ -1873,10 +1943,12 @@ int getVirtualRegInfo(VirtualRegInfo* infoArray, const MIR * currentMIR) {
             infoArray[4].accessType = REGACCESS_U;
             infoArray[4].physicalType = LowOpndRegType_gp;
         }
-        updateCurrentBBWithConstraints(PhysicalReg_EAX);
-        updateCurrentBBWithConstraints(PhysicalReg_EDX);
+        if (updateBBConstraints == true)
+        {
+            updateCurrentBBWithConstraints (PhysicalReg_EAX);
+            updateCurrentBBWithConstraints (PhysicalReg_EDX);
+        }
         num_regs_per_bytecode = length;
-        codeSize = 3;
         break;
     }
     case OP_FILLED_NEW_ARRAY_RANGE: {//use "length" virtual registers
@@ -1888,10 +1960,12 @@ int getVirtualRegInfo(VirtualRegInfo* infoArray, const MIR * currentMIR) {
             infoArray[kk].accessType = REGACCESS_U;
             infoArray[kk].physicalType = LowOpndRegType_gp;
         }
-        updateCurrentBBWithConstraints(PhysicalReg_EAX);
-        updateCurrentBBWithConstraints(PhysicalReg_EDX);
+        if (updateBBConstraints == true)
+        {
+            updateCurrentBBWithConstraints (PhysicalReg_EAX);
+            updateCurrentBBWithConstraints (PhysicalReg_EDX);
+        }
         num_regs_per_bytecode = length;
-        codeSize = 3;
         break;
     }
     case OP_FILL_ARRAY_DATA: //update content of array, read memory
@@ -1900,10 +1974,12 @@ int getVirtualRegInfo(VirtualRegInfo* infoArray, const MIR * currentMIR) {
         infoArray[0].refCount = 1;
         infoArray[0].accessType = REGACCESS_U;
         infoArray[0].physicalType = LowOpndRegType_gp;
-        updateCurrentBBWithConstraints(PhysicalReg_EAX);
-        updateCurrentBBWithConstraints(PhysicalReg_EDX);
+        if (updateBBConstraints == true)
+        {
+            updateCurrentBBWithConstraints (PhysicalReg_EAX);
+            updateCurrentBBWithConstraints (PhysicalReg_EDX);
+        }
         num_regs_per_bytecode = 1;
-        codeSize = 3;
         break;
     case OP_THROW: //update glue->exception
         vA = currentMIR->dalvikInsn.vA;
@@ -1911,42 +1987,35 @@ int getVirtualRegInfo(VirtualRegInfo* infoArray, const MIR * currentMIR) {
         infoArray[0].refCount = 1;
         infoArray[0].accessType = REGACCESS_U;
         infoArray[0].physicalType = LowOpndRegType_gp;
-        updateCurrentBBWithConstraints(PhysicalReg_EDX);
+        if (updateBBConstraints == true)
+        {
+            updateCurrentBBWithConstraints (PhysicalReg_EDX);
+        }
         num_regs_per_bytecode = 1;
-        codeSize = 1;
         break;
     case OP_THROW_VERIFICATION_ERROR:
-        num_regs_per_bytecode = 0;
-        codeSize = 2;
-        break;
     case OP_GOTO:
-        codeSize = 1;
-        num_regs_per_bytecode = 0;
-        break;
     case OP_GOTO_16:
-        codeSize = 2;
-        num_regs_per_bytecode = 0;
-        break;
     case OP_GOTO_32:
-        codeSize = 3;
         num_regs_per_bytecode = 0;
         break;
     case OP_PACKED_SWITCH:
     case OP_SPARSE_SWITCH:
         vA = currentMIR->dalvikInsn.vA;
-        codeSize = 3;
         infoArray[0].regNum = vA; //use
         infoArray[0].refCount = 1;
         infoArray[0].accessType = REGACCESS_U;
         infoArray[0].physicalType = LowOpndRegType_gp;
-        updateCurrentBBWithConstraints(PhysicalReg_EAX);
-        updateCurrentBBWithConstraints(PhysicalReg_EDX);
+        if (updateBBConstraints == true)
+        {
+            updateCurrentBBWithConstraints (PhysicalReg_EAX);
+            updateCurrentBBWithConstraints (PhysicalReg_EDX);
+        }
         num_regs_per_bytecode = 1;
         break;
 
     case OP_CMPL_FLOAT: //move 32 bits from memory to lower part of XMM register
     case OP_CMPG_FLOAT:
-        codeSize = 2;
         vA = currentMIR->dalvikInsn.vA;
         v1 = currentMIR->dalvikInsn.vB;
         v2 = currentMIR->dalvikInsn.vC;
@@ -1969,7 +2038,6 @@ int getVirtualRegInfo(VirtualRegInfo* infoArray, const MIR * currentMIR) {
     case OP_CMPL_DOUBLE: //move 64 bits from memory to lower part of XMM register
     case OP_CMPG_DOUBLE:
     case OP_CMP_LONG: //load v1, v1+1, v2, v2+1 to gpr
-        codeSize = 2;
         vA = currentMIR->dalvikInsn.vA;
         v1 = currentMIR->dalvikInsn.vB;
         v2 = currentMIR->dalvikInsn.vC;
@@ -2032,7 +2100,6 @@ int getVirtualRegInfo(VirtualRegInfo* infoArray, const MIR * currentMIR) {
         infoArray[1].accessType = REGACCESS_U;
         infoArray[1].physicalType = LowOpndRegType_gp;
         num_regs_per_bytecode = 2;
-        codeSize =12;
         break;
     case OP_IF_EQZ:
     case OP_IF_NEZ:
@@ -2046,7 +2113,6 @@ int getVirtualRegInfo(VirtualRegInfo* infoArray, const MIR * currentMIR) {
         infoArray[0].accessType = REGACCESS_U;
         infoArray[0].physicalType = LowOpndRegType_gp;
         num_regs_per_bytecode = 1;
-        codeSize = 2;
         break;
     case OP_AGET:
     case OP_AGET_WIDE:
@@ -2055,7 +2121,6 @@ int getVirtualRegInfo(VirtualRegInfo* infoArray, const MIR * currentMIR) {
     case OP_AGET_BYTE: //moves 8
     case OP_AGET_CHAR: //movez 16
     case OP_AGET_SHORT: //moves 16
-        codeSize = 2;
         vA = currentMIR->dalvikInsn.vA;
         vref = currentMIR->dalvikInsn.vB;
         vindex = currentMIR->dalvikInsn.vC;
@@ -2090,7 +2155,6 @@ int getVirtualRegInfo(VirtualRegInfo* infoArray, const MIR * currentMIR) {
         vA = currentMIR->dalvikInsn.vA;
         vref = currentMIR->dalvikInsn.vB;
         vindex = currentMIR->dalvikInsn.vC;
-        codeSize = 2;
         if(inst_op == OP_APUT_WIDE) {
             infoArray[0].regNum = vA;
             infoArray[0].refCount = 1;
@@ -2110,9 +2174,10 @@ int getVirtualRegInfo(VirtualRegInfo* infoArray, const MIR * currentMIR) {
         infoArray[2].refCount = 1;
         infoArray[2].accessType = REGACCESS_U;
         infoArray[2].physicalType = LowOpndRegType_gp;
-        if(inst_op == OP_APUT_OBJECT) {
-            updateCurrentBBWithConstraints(PhysicalReg_EAX);
-            updateCurrentBBWithConstraints(PhysicalReg_EDX);
+        if (inst_op == OP_APUT_OBJECT && updateBBConstraints == true)
+        {
+            updateCurrentBBWithConstraints (PhysicalReg_EAX);
+            updateCurrentBBWithConstraints (PhysicalReg_EDX);
         }
         num_regs_per_bytecode = 3;
         break;
@@ -2132,7 +2197,6 @@ int getVirtualRegInfo(VirtualRegInfo* infoArray, const MIR * currentMIR) {
     case OP_IGET_OBJECT_QUICK:
         vA = currentMIR->dalvikInsn.vA;
         vB = currentMIR->dalvikInsn.vB;
-        codeSize = 2;
         infoArray[0].regNum = vB; //object instance
         infoArray[0].refCount = 1;
         infoArray[0].accessType = REGACCESS_U;
@@ -2175,8 +2239,11 @@ int getVirtualRegInfo(VirtualRegInfo* infoArray, const MIR * currentMIR) {
             infoArray[1].physicalType = LowOpndRegType_gp;
         }
 #endif
-        updateCurrentBBWithConstraints(PhysicalReg_EAX);
-        updateCurrentBBWithConstraints(PhysicalReg_EDX);
+        if (updateBBConstraints == true)
+        {
+            updateCurrentBBWithConstraints (PhysicalReg_EAX);
+            updateCurrentBBWithConstraints (PhysicalReg_EDX);
+        }
         break;
     case OP_IPUT:
     case OP_IPUT_WIDE:
@@ -2193,7 +2260,6 @@ int getVirtualRegInfo(VirtualRegInfo* infoArray, const MIR * currentMIR) {
     case OP_IPUT_OBJECT_QUICK:
         vA = currentMIR->dalvikInsn.vA;
         vB = currentMIR->dalvikInsn.vB;
-        codeSize = 2;
         if(inst_op == OP_IPUT_WIDE || inst_op == OP_IPUT_WIDE_QUICK || inst_op == OP_IPUT_WIDE_VOLATILE) {
             infoArray[0].regNum = vA;
             infoArray[0].refCount = 1;
@@ -2209,8 +2275,11 @@ int getVirtualRegInfo(VirtualRegInfo* infoArray, const MIR * currentMIR) {
         infoArray[1].refCount = 1;
         infoArray[1].accessType = REGACCESS_U;
         infoArray[1].physicalType = LowOpndRegType_gp;
-        updateCurrentBBWithConstraints(PhysicalReg_EAX);
-        updateCurrentBBWithConstraints(PhysicalReg_EDX);
+        if (updateBBConstraints == true)
+        {
+            updateCurrentBBWithConstraints (PhysicalReg_EAX);
+            updateCurrentBBWithConstraints (PhysicalReg_EDX);
+        }
         num_regs_per_bytecode = 2;
         break;
     case OP_SGET:
@@ -2224,7 +2293,6 @@ int getVirtualRegInfo(VirtualRegInfo* infoArray, const MIR * currentMIR) {
     case OP_SGET_CHAR:
     case OP_SGET_SHORT:
         vA = currentMIR->dalvikInsn.vA;
-        codeSize = 2;
 #ifndef WITH_SELF_VERIFICATION
         if(inst_op == OP_SGET_WIDE) {
             infoArray[0].regNum = vA;
@@ -2250,7 +2318,10 @@ int getVirtualRegInfo(VirtualRegInfo* infoArray, const MIR * currentMIR) {
             num_regs_per_bytecode = 2;
         else
             num_regs_per_bytecode = 1;
-        updateCurrentBBWithConstraints(PhysicalReg_EAX);
+        if (updateBBConstraints == true)
+        {
+            updateCurrentBBWithConstraints (PhysicalReg_EAX);
+        }
         break;
 #else
         if(inst_op == OP_SGET_WIDE || inst_op == OP_SGET_WIDE_VOLATILE) {
@@ -2279,7 +2350,6 @@ int getVirtualRegInfo(VirtualRegInfo* infoArray, const MIR * currentMIR) {
     case OP_SPUT_CHAR:
     case OP_SPUT_SHORT:
         vA = currentMIR->dalvikInsn.vA;
-        codeSize = 2;
         if(inst_op == OP_SPUT_WIDE || inst_op == OP_SPUT_WIDE_VOLATILE) {
             infoArray[0].regNum = vA;
             infoArray[0].refCount = 1;
@@ -2291,7 +2361,10 @@ int getVirtualRegInfo(VirtualRegInfo* infoArray, const MIR * currentMIR) {
             infoArray[0].accessType = REGACCESS_U;
             infoArray[0].physicalType = LowOpndRegType_gp;
         }
-        updateCurrentBBWithConstraints(PhysicalReg_EAX);
+        if (updateBBConstraints == true)
+        {
+            updateCurrentBBWithConstraints (PhysicalReg_EAX);
+        }
         num_regs_per_bytecode = 1;
         break;
     case OP_INVOKE_VIRTUAL:
@@ -2301,7 +2374,6 @@ int getVirtualRegInfo(VirtualRegInfo* infoArray, const MIR * currentMIR) {
     case OP_INVOKE_INTERFACE:
     case OP_INVOKE_VIRTUAL_QUICK:
     case OP_INVOKE_SUPER_QUICK:
-        codeSize = 3;
         vD = currentMIR->dalvikInsn.arg[0]; //object for virtual,direct & interface
         count = currentMIR->dalvikInsn.vA;
         vE = currentMIR->dalvikInsn.arg[1];
@@ -2339,10 +2411,15 @@ int getVirtualRegInfo(VirtualRegInfo* infoArray, const MIR * currentMIR) {
             }
         }
 
-        if(inst_op != OP_INVOKE_VIRTUAL_QUICK && inst_op != OP_INVOKE_SUPER_QUICK)
-            updateCurrentBBWithConstraints(PhysicalReg_EAX);
-        updateCurrentBBWithConstraints(PhysicalReg_ECX);
-        updateCurrentBBWithConstraints(PhysicalReg_EDX);
+        if (updateBBConstraints == true)
+        {
+            if (inst_op != OP_INVOKE_VIRTUAL_QUICK && inst_op != OP_INVOKE_SUPER_QUICK)
+            {
+                updateCurrentBBWithConstraints (PhysicalReg_EAX);
+            }
+            updateCurrentBBWithConstraints (PhysicalReg_ECX);
+            updateCurrentBBWithConstraints (PhysicalReg_EDX);
+        }
         break;
     case OP_INVOKE_VIRTUAL_RANGE:
     case OP_INVOKE_SUPER_RANGE:
@@ -2351,7 +2428,6 @@ int getVirtualRegInfo(VirtualRegInfo* infoArray, const MIR * currentMIR) {
     case OP_INVOKE_INTERFACE_RANGE:
     case OP_INVOKE_VIRTUAL_QUICK_RANGE:
     case OP_INVOKE_SUPER_QUICK_RANGE:
-        codeSize = 3;
         vD = currentMIR->dalvikInsn.vC;
         count = currentMIR->dalvikInsn.vA;
         if(count == 0) {
@@ -2380,10 +2456,15 @@ int getVirtualRegInfo(VirtualRegInfo* infoArray, const MIR * currentMIR) {
                 infoArray[kk].physicalType = LowOpndRegType_gp;
             }
         }
-        if(inst_op != OP_INVOKE_VIRTUAL_QUICK_RANGE && inst_op != OP_INVOKE_SUPER_QUICK_RANGE)
-            updateCurrentBBWithConstraints(PhysicalReg_EAX);
-        updateCurrentBBWithConstraints(PhysicalReg_ECX);
-        updateCurrentBBWithConstraints(PhysicalReg_EDX);
+        if (updateBBConstraints == true)
+        {
+            if (inst_op != OP_INVOKE_VIRTUAL_QUICK_RANGE && inst_op != OP_INVOKE_SUPER_QUICK_RANGE)
+            {
+                updateCurrentBBWithConstraints (PhysicalReg_EAX);
+            }
+            updateCurrentBBWithConstraints (PhysicalReg_ECX);
+            updateCurrentBBWithConstraints (PhysicalReg_EDX);
+        }
         num_regs_per_bytecode = count;
         break;
     case OP_NEG_INT:
@@ -2400,14 +2481,12 @@ int getVirtualRegInfo(VirtualRegInfo* infoArray, const MIR * currentMIR) {
         infoArray[0].accessType = REGACCESS_U;
         infoArray[0].physicalType = LowOpndRegType_gp;
         num_regs_per_bytecode = 2;
-        codeSize = 1;
         break;
     case OP_NEG_LONG:
     case OP_NOT_LONG:
     case OP_NEG_DOUBLE:
         vA = currentMIR->dalvikInsn.vA; //destination
         vB = currentMIR->dalvikInsn.vB;
-        codeSize = 1;
         infoArray[1].regNum = vA;
         infoArray[1].refCount = 1;
         infoArray[1].accessType = REGACCESS_D;
@@ -2421,7 +2500,6 @@ int getVirtualRegInfo(VirtualRegInfo* infoArray, const MIR * currentMIR) {
     case OP_INT_TO_LONG: //hard-coded registers
         vA = currentMIR->dalvikInsn.vA; //destination
         vB = currentMIR->dalvikInsn.vB;
-        codeSize = 1;
         infoArray[1].regNum = vA;
         infoArray[1].refCount = 1;
         infoArray[1].accessType = REGACCESS_D;
@@ -2437,8 +2515,11 @@ int getVirtualRegInfo(VirtualRegInfo* infoArray, const MIR * currentMIR) {
         infoArray[0].accessType = REGACCESS_U;
         infoArray[0].physicalType = LowOpndRegType_gp;
         infoArray[0].allocConstraints[PhysicalReg_EAX].count = 1;
-        updateCurrentBBWithConstraints(PhysicalReg_EAX);
-        updateCurrentBBWithConstraints(PhysicalReg_EDX);
+        if (updateBBConstraints == true)
+        {
+            updateCurrentBBWithConstraints (PhysicalReg_EAX);
+            updateCurrentBBWithConstraints (PhysicalReg_EDX);
+        }
         num_regs_per_bytecode = 3;
         break;
     case OP_INT_TO_FLOAT: //32 to 32
@@ -2449,7 +2530,6 @@ int getVirtualRegInfo(VirtualRegInfo* infoArray, const MIR * currentMIR) {
     case OP_DOUBLE_TO_FLOAT: //64 to 32
         vA = currentMIR->dalvikInsn.vA; //destination
         vB = currentMIR->dalvikInsn.vB;
-        codeSize = 1;
         infoArray[1].regNum = vA;
         infoArray[1].refCount = 1;
         infoArray[1].accessType = REGACCESS_D;
@@ -2482,13 +2562,11 @@ int getVirtualRegInfo(VirtualRegInfo* infoArray, const MIR * currentMIR) {
         infoArray[0].accessType = REGACCESS_U;
         infoArray[0].physicalType = LowOpndRegType_gp;
         num_regs_per_bytecode = 2;
-        codeSize = 1;
         break;
     case OP_FLOAT_TO_INT:
     case OP_DOUBLE_TO_INT: //for reaching-def analysis
         vA = currentMIR->dalvikInsn.vA; //destination
         vB = currentMIR->dalvikInsn.vB;
-        codeSize = 1;
         infoArray[2].regNum = vA;
         infoArray[2].refCount = 3;
         infoArray[2].accessType = REGACCESS_D;
@@ -2510,7 +2588,6 @@ int getVirtualRegInfo(VirtualRegInfo* infoArray, const MIR * currentMIR) {
     case OP_DOUBLE_TO_LONG:
         vA = currentMIR->dalvikInsn.vA; //destination
         vB = currentMIR->dalvikInsn.vB;
-        codeSize = 1;
         infoArray[2].regNum = vA;
         infoArray[2].refCount = 3;
         infoArray[2].accessType = REGACCESS_D;
@@ -2533,7 +2610,6 @@ int getVirtualRegInfo(VirtualRegInfo* infoArray, const MIR * currentMIR) {
     case OP_INT_TO_SHORT:
         vA = currentMIR->dalvikInsn.vA; //destination
         vB = currentMIR->dalvikInsn.vB;
-        codeSize = 1;
         infoArray[1].regNum = vA;
         infoArray[1].refCount = 1;
         infoArray[1].accessType = REGACCESS_D;
@@ -2554,7 +2630,6 @@ int getVirtualRegInfo(VirtualRegInfo* infoArray, const MIR * currentMIR) {
         vA = currentMIR->dalvikInsn.vA;
         v1 = currentMIR->dalvikInsn.vB;
         v2 = currentMIR->dalvikInsn.vC;
-        codeSize = 2;
         infoArray[2].regNum = vA;
         infoArray[2].refCount = 1;
         infoArray[2].accessType = REGACCESS_D;
@@ -2574,7 +2649,6 @@ int getVirtualRegInfo(VirtualRegInfo* infoArray, const MIR * currentMIR) {
         vA = currentMIR->dalvikInsn.vA;
         v1 = currentMIR->dalvikInsn.vB;
         v2 = currentMIR->dalvikInsn.vC;
-        codeSize = 2;
         infoArray[2].regNum = vA;
         infoArray[2].refCount = 1;
         infoArray[2].accessType = REGACCESS_D;
@@ -2592,8 +2666,11 @@ int getVirtualRegInfo(VirtualRegInfo* infoArray, const MIR * currentMIR) {
             infoArray[2].allocConstraints[PhysicalReg_EDX].count = 1;//vA
         else
             infoArray[2].allocConstraints[PhysicalReg_EAX].count = 1;//vA
-        updateCurrentBBWithConstraints(PhysicalReg_EAX);
-        updateCurrentBBWithConstraints(PhysicalReg_EDX);
+        if (updateBBConstraints == true)
+        {
+            updateCurrentBBWithConstraints (PhysicalReg_EAX);
+            updateCurrentBBWithConstraints (PhysicalReg_EDX);
+        }
         num_regs_per_bytecode = 3;
         break;
     case OP_SHL_INT:
@@ -2602,7 +2679,6 @@ int getVirtualRegInfo(VirtualRegInfo* infoArray, const MIR * currentMIR) {
         vA = currentMIR->dalvikInsn.vA;
         v1 = currentMIR->dalvikInsn.vB;
         v2 = currentMIR->dalvikInsn.vC;
-        codeSize = 2;
         infoArray[2].regNum = vA;
         infoArray[2].refCount = 1;
         infoArray[2].accessType = REGACCESS_D;
@@ -2616,14 +2692,16 @@ int getVirtualRegInfo(VirtualRegInfo* infoArray, const MIR * currentMIR) {
         infoArray[1].accessType = REGACCESS_U;
         infoArray[1].physicalType = LowOpndRegType_gp;
         infoArray[1].allocConstraints[PhysicalReg_ECX].count = 1;
-        updateCurrentBBWithConstraints(PhysicalReg_ECX);
+        if (updateBBConstraints == true)
+        {
+            updateCurrentBBWithConstraints (PhysicalReg_ECX);
+        }
         num_regs_per_bytecode = 3;
         break;
     case OP_ADD_LONG:
         vA = currentMIR->dalvikInsn.vA;
         v1 = currentMIR->dalvikInsn.vB;
         v2 = currentMIR->dalvikInsn.vC;
-        codeSize = 2;
         infoArray[0].regNum = v1;
         infoArray[0].refCount = 1;
         infoArray[0].accessType = REGACCESS_U;
@@ -2657,7 +2735,6 @@ int getVirtualRegInfo(VirtualRegInfo* infoArray, const MIR * currentMIR) {
         vA = currentMIR->dalvikInsn.vA;
         v1 = currentMIR->dalvikInsn.vB;
         v2 = currentMIR->dalvikInsn.vC;
-        codeSize = 2;
         infoArray[2].regNum = vA;
         infoArray[2].refCount = 1;
         infoArray[2].accessType = REGACCESS_D;
@@ -2700,10 +2777,12 @@ int getVirtualRegInfo(VirtualRegInfo* infoArray, const MIR * currentMIR) {
         infoArray[5].refCount = 1;
         infoArray[5].accessType = REGACCESS_D;
         infoArray[5].physicalType = LowOpndRegType_gp;
-        updateCurrentBBWithConstraints(PhysicalReg_ECX);
-        updateCurrentBBWithConstraints(PhysicalReg_EAX);
+        if (updateBBConstraints == true)
+        {
+            updateCurrentBBWithConstraints (PhysicalReg_ECX);
+            updateCurrentBBWithConstraints (PhysicalReg_EAX);
+        }
         num_regs_per_bytecode = 6;
-        codeSize = 2;
         break;
     case OP_DIV_LONG: //v1: xmm v2,vA:
     case OP_REM_LONG:
@@ -2731,7 +2810,6 @@ int getVirtualRegInfo(VirtualRegInfo* infoArray, const MIR * currentMIR) {
         infoArray[4].accessType = REGACCESS_D;
         infoArray[4].physicalType = LowOpndRegType_gp;
         num_regs_per_bytecode = 5;
-        codeSize = 2;
         break;
     case OP_SHL_LONG: //v2: 32, move_ss; v1,vA: xmm CHECK
         vA = currentMIR->dalvikInsn.vA;
@@ -2750,7 +2828,6 @@ int getVirtualRegInfo(VirtualRegInfo* infoArray, const MIR * currentMIR) {
         infoArray[2].accessType = REGACCESS_D;
         infoArray[2].physicalType = LowOpndRegType_xmm;
         num_regs_per_bytecode = 3;
-        codeSize = 2;
         break;
     case OP_SHR_LONG: //v2: 32, move_ss; v1,vA: xmm CHECK
         vA = currentMIR->dalvikInsn.vA;
@@ -2773,7 +2850,6 @@ int getVirtualRegInfo(VirtualRegInfo* infoArray, const MIR * currentMIR) {
         infoArray[3].accessType = REGACCESS_D;
         infoArray[3].physicalType = LowOpndRegType_xmm;
         num_regs_per_bytecode = 4;
-        codeSize = 2;
         break;
     case OP_USHR_LONG: //v2: move_ss; v1,vA: move_sd
         vA = currentMIR->dalvikInsn.vA;
@@ -2792,7 +2868,6 @@ int getVirtualRegInfo(VirtualRegInfo* infoArray, const MIR * currentMIR) {
         infoArray[2].accessType = REGACCESS_D;
         infoArray[2].physicalType = LowOpndRegType_xmm; //sd
         num_regs_per_bytecode = 3;
-        codeSize = 2;
         break;
     case OP_ADD_FLOAT: //move_ss
     case OP_SUB_FLOAT:
@@ -2801,7 +2876,6 @@ int getVirtualRegInfo(VirtualRegInfo* infoArray, const MIR * currentMIR) {
         vA = currentMIR->dalvikInsn.vA;
         v1 = currentMIR->dalvikInsn.vB;
         v2 = currentMIR->dalvikInsn.vC;
-        codeSize = 2;
         infoArray[2].regNum = vA;
         infoArray[2].refCount = 1;
         infoArray[2].accessType = REGACCESS_D;
@@ -2820,7 +2894,6 @@ int getVirtualRegInfo(VirtualRegInfo* infoArray, const MIR * currentMIR) {
         vA = currentMIR->dalvikInsn.vA;
         v1 = currentMIR->dalvikInsn.vB;
         v2 = currentMIR->dalvikInsn.vC;
-        codeSize = 2;
         infoArray[2].regNum = vA;
         infoArray[2].refCount = 1;
         infoArray[2].accessType = REGACCESS_D;
@@ -2842,7 +2915,6 @@ int getVirtualRegInfo(VirtualRegInfo* infoArray, const MIR * currentMIR) {
         vA = currentMIR->dalvikInsn.vA;
         v1 = currentMIR->dalvikInsn.vB;
         v2 = currentMIR->dalvikInsn.vC;
-        codeSize = 2;
         infoArray[2].regNum = vA;
         infoArray[2].refCount = 1;
         infoArray[2].accessType = REGACCESS_D;
@@ -2861,7 +2933,6 @@ int getVirtualRegInfo(VirtualRegInfo* infoArray, const MIR * currentMIR) {
         vA = currentMIR->dalvikInsn.vA;
         v1 = currentMIR->dalvikInsn.vB;
         v2 = currentMIR->dalvikInsn.vC;
-        codeSize = 2;
         infoArray[2].regNum = vA;
         infoArray[2].refCount = 1;
         infoArray[2].accessType = REGACCESS_D;
@@ -2885,7 +2956,6 @@ int getVirtualRegInfo(VirtualRegInfo* infoArray, const MIR * currentMIR) {
     case OP_XOR_INT_2ADDR:
         vA = currentMIR->dalvikInsn.vA;
         v2 = currentMIR->dalvikInsn.vB;
-        codeSize = 1;
         infoArray[1].regNum = vA;
         infoArray[1].refCount = 2;
         infoArray[1].accessType = REGACCESS_UD; //use then define
@@ -2900,7 +2970,6 @@ int getVirtualRegInfo(VirtualRegInfo* infoArray, const MIR * currentMIR) {
     case OP_REM_INT_2ADDR:
         vA = currentMIR->dalvikInsn.vA;
         v2 = currentMIR->dalvikInsn.vB;
-        codeSize = 1;
         infoArray[1].regNum = vA;
         infoArray[1].refCount = 3;
         infoArray[1].accessType = REGACCESS_UD; //use then define
@@ -2914,8 +2983,11 @@ int getVirtualRegInfo(VirtualRegInfo* infoArray, const MIR * currentMIR) {
             infoArray[1].allocConstraints[PhysicalReg_EDX].count = 1;//vA
         else
             infoArray[1].allocConstraints[PhysicalReg_EAX].count = 1;//vA
-        updateCurrentBBWithConstraints(PhysicalReg_EAX);
-        updateCurrentBBWithConstraints(PhysicalReg_EDX);
+        if (updateBBConstraints == true)
+        {
+            updateCurrentBBWithConstraints (PhysicalReg_EAX);
+            updateCurrentBBWithConstraints (PhysicalReg_EDX);
+        }
         num_regs_per_bytecode = 2;
         break;
     case OP_SHL_INT_2ADDR:
@@ -2923,7 +2995,6 @@ int getVirtualRegInfo(VirtualRegInfo* infoArray, const MIR * currentMIR) {
     case OP_USHR_INT_2ADDR:
         vA = currentMIR->dalvikInsn.vA;
         v2 = currentMIR->dalvikInsn.vB;
-        codeSize = 1;
         infoArray[1].regNum = vA;
         infoArray[1].refCount = 2;
         infoArray[1].accessType = REGACCESS_UD; //use then define
@@ -2933,13 +3004,15 @@ int getVirtualRegInfo(VirtualRegInfo* infoArray, const MIR * currentMIR) {
         infoArray[0].accessType = REGACCESS_U;
         infoArray[0].physicalType = LowOpndRegType_gp;
         infoArray[0].allocConstraints[PhysicalReg_ECX].count = 1; //v2
-        updateCurrentBBWithConstraints(PhysicalReg_ECX);
+        if (updateBBConstraints == true)
+        {
+            updateCurrentBBWithConstraints (PhysicalReg_ECX);
+        }
         num_regs_per_bytecode = 2;
         break;
     case OP_ADD_LONG_2ADDR:
         vA = currentMIR->dalvikInsn.vA;
         v2 = currentMIR->dalvikInsn.vB;
-        codeSize = 1;
         infoArray[1].regNum = vA;
         infoArray[1].refCount = 2;
         infoArray[1].accessType = REGACCESS_UD;
@@ -2964,7 +3037,6 @@ int getVirtualRegInfo(VirtualRegInfo* infoArray, const MIR * currentMIR) {
     case OP_XOR_LONG_2ADDR:
         vA = currentMIR->dalvikInsn.vA;
         v2 = currentMIR->dalvikInsn.vB;
-        codeSize = 1;
         infoArray[1].regNum = vA;
         infoArray[1].refCount = 2;
         infoArray[1].accessType = REGACCESS_UD;
@@ -2978,7 +3050,6 @@ int getVirtualRegInfo(VirtualRegInfo* infoArray, const MIR * currentMIR) {
     case OP_MUL_LONG_2ADDR:
         vA = currentMIR->dalvikInsn.vA;
         v2 = currentMIR->dalvikInsn.vB;
-        codeSize = 1;
         num_regs_per_bytecode = 4;
         infoArray[0].regNum = v2;
         infoArray[0].refCount = 1;
@@ -2996,15 +3067,17 @@ int getVirtualRegInfo(VirtualRegInfo* infoArray, const MIR * currentMIR) {
         infoArray[3].refCount = 2;
         infoArray[3].accessType = REGACCESS_UD;
         infoArray[3].physicalType = LowOpndRegType_gp;
-        updateCurrentBBWithConstraints(PhysicalReg_ECX);
-        updateCurrentBBWithConstraints(PhysicalReg_EAX);
+        if (updateBBConstraints == true)
+        {
+            updateCurrentBBWithConstraints (PhysicalReg_ECX);
+            updateCurrentBBWithConstraints (PhysicalReg_EAX);
+        }
         break;
     case OP_DIV_LONG_2ADDR: //vA used as xmm, then updated as gps
     case OP_REM_LONG_2ADDR:
         vA = currentMIR->dalvikInsn.vA;
         v2 = currentMIR->dalvikInsn.vB;
         num_regs_per_bytecode = 5;
-        codeSize = 1;
         infoArray[0].regNum = vA;
         infoArray[0].refCount = 1;
         infoArray[0].accessType = REGACCESS_U;
@@ -3030,7 +3103,6 @@ int getVirtualRegInfo(VirtualRegInfo* infoArray, const MIR * currentMIR) {
         vA = currentMIR->dalvikInsn.vA;
         v2 = currentMIR->dalvikInsn.vB;
         num_regs_per_bytecode = 2;
-        codeSize = 1;
         infoArray[0].regNum = v2; //ss
         infoArray[0].refCount = 1;
         infoArray[0].accessType = REGACCESS_U;
@@ -3044,7 +3116,6 @@ int getVirtualRegInfo(VirtualRegInfo* infoArray, const MIR * currentMIR) {
         vA = currentMIR->dalvikInsn.vA;
         v2 = currentMIR->dalvikInsn.vB;
         num_regs_per_bytecode = 3;
-        codeSize = 1;
         infoArray[0].regNum = v2; //ss
         infoArray[0].refCount = 1;
         infoArray[0].accessType = REGACCESS_U;
@@ -3062,7 +3133,6 @@ int getVirtualRegInfo(VirtualRegInfo* infoArray, const MIR * currentMIR) {
         vA = currentMIR->dalvikInsn.vA;
         v2 = currentMIR->dalvikInsn.vB;
         num_regs_per_bytecode = 2;
-        codeSize = 1;
         infoArray[0].regNum = v2;
         infoArray[0].refCount = 1;
         infoArray[0].accessType = REGACCESS_U;
@@ -3078,7 +3148,6 @@ int getVirtualRegInfo(VirtualRegInfo* infoArray, const MIR * currentMIR) {
     case OP_DIV_FLOAT_2ADDR:
         vA = currentMIR->dalvikInsn.vA;
         v2 = currentMIR->dalvikInsn.vB;
-        codeSize = 1;
         infoArray[1].regNum = vA;
         infoArray[1].refCount = 2;
         infoArray[1].accessType = REGACCESS_UD;
@@ -3092,7 +3161,6 @@ int getVirtualRegInfo(VirtualRegInfo* infoArray, const MIR * currentMIR) {
     case OP_REM_FLOAT_2ADDR: //load vA as GPR, store from fs
         vA = currentMIR->dalvikInsn.vA;
         v2 = currentMIR->dalvikInsn.vB;
-        codeSize = 1;
         infoArray[1].regNum = vA;
         infoArray[1].refCount = 2;
         infoArray[1].accessType = REGACCESS_UD;
@@ -3109,7 +3177,6 @@ int getVirtualRegInfo(VirtualRegInfo* infoArray, const MIR * currentMIR) {
     case OP_DIV_DOUBLE_2ADDR:
         vA = currentMIR->dalvikInsn.vA;
         v2 = currentMIR->dalvikInsn.vB;
-        codeSize = 1;
         infoArray[1].regNum = vA;
         infoArray[1].refCount = 2;
         infoArray[1].accessType = REGACCESS_UD;
@@ -3123,7 +3190,6 @@ int getVirtualRegInfo(VirtualRegInfo* infoArray, const MIR * currentMIR) {
     case OP_REM_DOUBLE_2ADDR: //load to xmm, store from fs
         vA = currentMIR->dalvikInsn.vA;
         v2 = currentMIR->dalvikInsn.vB;
-        codeSize = 1;
         infoArray[1].regNum = vA;
         infoArray[1].refCount = 2;
         infoArray[1].accessType = REGACCESS_UD;
@@ -3143,7 +3209,6 @@ int getVirtualRegInfo(VirtualRegInfo* infoArray, const MIR * currentMIR) {
     case OP_XOR_INT_LIT16:
         vA = currentMIR->dalvikInsn.vA;
         vB = currentMIR->dalvikInsn.vB;
-        codeSize = 2;
         infoArray[1].regNum = vA;
         infoArray[1].refCount = 1;
         infoArray[1].accessType = REGACCESS_D;
@@ -3158,7 +3223,6 @@ int getVirtualRegInfo(VirtualRegInfo* infoArray, const MIR * currentMIR) {
     case OP_REM_INT_LIT16:
         vA = currentMIR->dalvikInsn.vA;
         vB = currentMIR->dalvikInsn.vB;
-        codeSize = 2;
         tmp_s2 = currentMIR->dalvikInsn.vC;
         if(tmp_s2 == 0) {
             num_regs_per_bytecode = 0;
@@ -3188,8 +3252,11 @@ int getVirtualRegInfo(VirtualRegInfo* infoArray, const MIR * currentMIR) {
         else
             infoArray[1].allocConstraints[PhysicalReg_EAX].count = 1;
         infoArray[0].allocConstraints[PhysicalReg_EAX].count = 1;
-        updateCurrentBBWithConstraints(PhysicalReg_EAX);
-        updateCurrentBBWithConstraints(PhysicalReg_EDX);
+        if (updateBBConstraints == true)
+        {
+            updateCurrentBBWithConstraints (PhysicalReg_EAX);
+            updateCurrentBBWithConstraints (PhysicalReg_EDX);
+        }
         break;
     case OP_ADD_INT_LIT8:
     case OP_RSUB_INT_LIT8:
@@ -3200,7 +3267,6 @@ int getVirtualRegInfo(VirtualRegInfo* infoArray, const MIR * currentMIR) {
     case OP_SHL_INT_LIT8:
     case OP_SHR_INT_LIT8:
     case OP_USHR_INT_LIT8:
-        codeSize = 2;
         vA = currentMIR->dalvikInsn.vA;
         vB = currentMIR->dalvikInsn.vB;
         infoArray[1].regNum = vA;
@@ -3215,7 +3281,6 @@ int getVirtualRegInfo(VirtualRegInfo* infoArray, const MIR * currentMIR) {
         break;
     case OP_DIV_INT_LIT8:
     case OP_REM_INT_LIT8:
-        codeSize = 2;
         vA = currentMIR->dalvikInsn.vA;
         vB = currentMIR->dalvikInsn.vB;
         tmp_s2 = currentMIR->dalvikInsn.vC;
@@ -3249,8 +3314,11 @@ int getVirtualRegInfo(VirtualRegInfo* infoArray, const MIR * currentMIR) {
         else
             infoArray[1].allocConstraints[PhysicalReg_EAX].count = 1;
         infoArray[0].allocConstraints[PhysicalReg_EAX].count = 1;
-        updateCurrentBBWithConstraints(PhysicalReg_EAX);
-        updateCurrentBBWithConstraints(PhysicalReg_EDX);
+        if (updateBBConstraints == true)
+        {
+            updateCurrentBBWithConstraints (PhysicalReg_EAX);
+            updateCurrentBBWithConstraints (PhysicalReg_EDX);
+        }
         break;
     case OP_EXECUTE_INLINE: //update glue->retval
     case OP_EXECUTE_INLINE_RANGE:
@@ -3270,7 +3338,6 @@ int getVirtualRegInfo(VirtualRegInfo* infoArray, const MIR * currentMIR) {
             vE = vC + 2;
             vF = vC + 3;
         }
-        codeSize = 3;
         if(num >= 1) {
             infoArray[0].regNum = vC;
             infoArray[0].refCount = 1;
@@ -3295,8 +3362,11 @@ int getVirtualRegInfo(VirtualRegInfo* infoArray, const MIR * currentMIR) {
             infoArray[3].accessType = REGACCESS_U;
             infoArray[3].physicalType = LowOpndRegType_gp;
         }
-        updateCurrentBBWithConstraints(PhysicalReg_EAX);
-        updateCurrentBBWithConstraints(PhysicalReg_EDX);
+        if (updateBBConstraints == true)
+        {
+            updateCurrentBBWithConstraints (PhysicalReg_EAX);
+            updateCurrentBBWithConstraints (PhysicalReg_EDX);
+        }
         num_regs_per_bytecode = num;
         break;
 #if FIXME
@@ -3306,13 +3376,12 @@ int getVirtualRegInfo(VirtualRegInfo* infoArray, const MIR * currentMIR) {
         break;
 #endif
     default:
-        ALOGI("JIT_INFO: JIT does not support bytecode 0x%hx when updating\n"
-                "VR accesses\n", currentMIR->dalvikInsn.opcode);
+        ALOGI("JIT_INFO: JIT does not support bytecode 0x%hx when updating VR accesses", currentMIR->dalvikInsn.opcode);
         SET_JIT_ERROR(kJitErrorUnsupportedBytecode);
         assert(false && "All opcodes should be supported.");
         break;
     }
-    return codeSize;
+    return num_regs_per_bytecode;
 }
 
 /**
@@ -3604,14 +3673,23 @@ int getTempRegInfo(TempRegInfo* infoArray, const MIR * currentMIR) { //returns a
             case kMirOpRegisterize:
                 infoArray[0].regNum = 1;
                 infoArray[0].refCount = 2; //UD
-                //Ok the type really depends on vB
-                if (currentMIR->dalvikInsn.vB == static_cast<int> (kCoreReg))
-                {
-                    infoArray[0].physicalType = LowOpndRegType_gp;
-                }
-                else
+
+                //Decide the type depending on the register class
+                switch (static_cast<RegisterClass> (currentMIR->dalvikInsn.vB))
                 {
-                    infoArray[0].physicalType = LowOpndRegType_xmm;
+                    case kCoreReg:
+                        infoArray[0].physicalType = LowOpndRegType_gp;
+                        break;
+                    case kSFPReg:
+                    case kDFPReg:
+                        //Temps don't have concept of SS type so the physical type of both
+                        //Single FP and Double FP must be xmm.
+                        infoArray[0].physicalType = LowOpndRegType_xmm;
+                        break;
+                    default:
+                        ALOGI("JIT_INFO: kMirOpRegisterize does not support regClass %d", currentMIR->dalvikInsn.vB);
+                        SET_JIT_ERROR(kJitErrorUnsupportedBytecode);
+                        break;
                 }
                 return 1;
             case kMirOpDualDoubleDivide:
@@ -6343,8 +6421,8 @@ int getTempRegInfo(TempRegInfo* infoArray, const MIR * currentMIR) { //returns a
     }
 #endif
     default:
-        ALOGI("JIT_INFO: JIT does not support bytecode 0x%hx when updating\n"
-                "temp accesses\n", currentMIR->dalvikInsn.opcode);
+        ALOGI("JIT_INFO: JIT does not support bytecode 0x%hx when updating temp accesses",
+                currentMIR->dalvikInsn.opcode);
         SET_JIT_ERROR(kJitErrorUnsupportedBytecode);
         assert(false && "All opcodes should be supported.");
         break;
diff --git a/vm/compiler/codegen/x86/CodegenErrors.cpp b/vm/compiler/codegen/x86/CodegenErrors.cpp
index 1abde1d..e976257 100644
--- a/vm/compiler/codegen/x86/CodegenErrors.cpp
+++ b/vm/compiler/codegen/x86/CodegenErrors.cpp
@@ -45,6 +45,7 @@ static const char* jitErrorMessages[kJitErrorMaxDefined] = {
     "An issue was encountered while generating chaining cell",
     "Invalid Operand Size was encountered",
     "Problem with the plugin system",
+    "Constant folding failed due to unhandled case",
     //Add error messages here when adding error codes
 };
 
diff --git a/vm/compiler/codegen/x86/CodegenErrors.h b/vm/compiler/codegen/x86/CodegenErrors.h
index c27a082..5fac860 100644
--- a/vm/compiler/codegen/x86/CodegenErrors.h
+++ b/vm/compiler/codegen/x86/CodegenErrors.h
@@ -87,6 +87,8 @@ enum JitCompilationErrors {
     kJitErrorInvalidOperandSize,
     /** @brief Problem with the plugin system */
     kJitErrorPlugin,
+    /** @brief Unhandled case during constant folding */
+    kJitErrorConstantFolding,
 
     /* ----- Add more errors above ---------------------------*/
     /* ----- Don't add new errors beyond this point ----------*/
diff --git a/vm/compiler/codegen/x86/CodegenInterface.cpp b/vm/compiler/codegen/x86/CodegenInterface.cpp
index 4aa5c28..4f347e3 100644
--- a/vm/compiler/codegen/x86/CodegenInterface.cpp
+++ b/vm/compiler/codegen/x86/CodegenInterface.cpp
@@ -1315,15 +1315,25 @@ static bool handleInvokePredictedChainingCell (CompilationUnit *cUnit,
     return true;
 }
 
-/* Extended MIR instructions like PHI */
-void handleExtendedMIR(CompilationUnit *cUnit, MIR *mir)
+/**
+ * @brief Used to handle semantics of extended MIRs, including possibly generating native code.
+ * @param cUnit The compilation unit
+ * @param bb The basic block containing the MIR
+ * @param mir The extended instruction
+ * @return Returns whether or not it successfully handled the extended MIR
+ */
+bool handleExtendedMIR (CompilationUnit *cUnit, BasicBlock_O1 *bb, MIR *mir)
 {
-    if (dump_x86_inst) {
+    if (cUnit->printMe == true)
+    {
         char * decodedString = dvmCompilerGetDalvikDisassembly(&mir->dalvikInsn,
                 NULL);
         ALOGI("LOWER %s @%p\n", decodedString, stream);
     }
 
+    //Eagerly assume that we will be able to handle it
+    bool result = true;
+
     ExecutionMode origMode = gDvm.executionMode;
     gDvm.executionMode = kExecutionModeNcgO0;
     switch ((ExtendedMIROpcode)mir->dalvikInsn.opcode) {
@@ -1355,7 +1365,7 @@ void handleExtendedMIR(CompilationUnit *cUnit, MIR *mir)
         }
         case kMirOpRegisterize: {
             gDvm.executionMode = origMode;
-            genRegisterize (cUnit, mir);
+            result = genRegisterize (cUnit, bb, mir);
             break;
         }
 #ifdef WITH_JIT_INLINING_PHASE2
@@ -1371,9 +1381,16 @@ void handleExtendedMIR(CompilationUnit *cUnit, MIR *mir)
             break;
         }
         default:
+        {
+            char * decodedString = dvmCompilerGetDalvikDisassembly(&mir->dalvikInsn, NULL);
+            ALOGD ("JIT_INFO: No logic to handle extended MIR %s", decodedString);
+            result = false;
             break;
+        }
     }
     gDvm.executionMode = origMode;
+
+    return result;
 }
 
 #define PRINT_BUFFER_LEN 1024
@@ -1809,7 +1826,7 @@ static bool generateCode (CompilationUnit *cUnit, BasicBlock *bb, BasicBlock **n
                     cUnit->method->clazz->descriptor, cUnit->method->name,
                     cUnit->traceDesc->trace[0].info.frag.startOffset);
             SET_JIT_ERROR(kJitErrorCodegen);
-            endOfTrace(true/*freeOnly*/);
+            endOfTrace (cUnit);
             PROTECT_CODE_CACHE(stream, unprotected_code_cache_bytes);
             return false;
         }
@@ -1826,7 +1843,7 @@ static bool generateCode (CompilationUnit *cUnit, BasicBlock *bb, BasicBlock **n
 
             //If extended, send it off and go to the next instruction
             if((int)dalvikOpCode >= (int)kMirOpFirst) {
-                handleExtendedMIR(cUnit, mir);
+                handleExtendedMIR (cUnit, bbO1, mir);
                 continue;
             }
 
@@ -1868,7 +1885,7 @@ static bool generateCode (CompilationUnit *cUnit, BasicBlock *bb, BasicBlock **n
                     ALOGI("JIT_INFO: Code cache full after lowerByteCodeJit (trace uses %uB)", (stream - streamStart));
                     SET_JIT_ERROR(kJitErrorCodeCacheFull);
                     gDvmJit.codeCacheFull = true;
-                    endOfTrace(true/*freeOnly*/);
+                    endOfTrace (cUnit);
                     PROTECT_CODE_CACHE(stream, unprotected_code_cache_bytes);
                     return false;
                 }
@@ -1881,7 +1898,7 @@ static bool generateCode (CompilationUnit *cUnit, BasicBlock *bb, BasicBlock **n
                 //Lowering could have failed due to various reasons.
                 //Set a generic error flag
                 SET_JIT_ERROR(kJitErrorCodegen);
-                endOfTrace(true); /* need to free structures */
+                endOfTrace (cUnit);
                 return false;
             }
         } // end for
@@ -1982,20 +1999,14 @@ static void compilerMIR2LIRJit(CompilationUnit_O1 *cUnit, JitTranslationInfo *in
                 bb != NULL;
                 bb = (BasicBlock *) (dvmGrowableListIteratorNext(&iterator))) {
 
-            int retCode = preprocessingBB(cUnit, bb);
+            int retCode = preprocessingBB (cUnit, bb);
 
             if (retCode < 0) {
-                endOfTrace(true/*freeOnly*/);
+                endOfTrace (cUnit);
                 SET_JIT_ERROR(kJitErrorCodegen);
                 return;
             }
         }
-
-        if (preprocessingTrace() == -1) {
-            endOfTrace(true/*freeOnly*/);
-            SET_JIT_ERROR(kJitErrorCodegen);
-            return;
-        }
     }
 
     dvmGrowableListIteratorInit(&cUnit->blockList, &iterator);
@@ -2180,7 +2191,7 @@ static void compilerMIR2LIRJit(CompilationUnit_O1 *cUnit, JitTranslationInfo *in
                 default:
                     ALOGI("JIT_INFO: Bad blocktype %d", chainingBlock->blockType);
                     SET_JIT_ERROR(kJitErrorTraceFormation);
-                    endOfTrace(true); /* need to free structures */
+                    endOfTrace (cUnit);
                     code_block_table.clear();
                     return;
             }
@@ -2188,7 +2199,7 @@ static void compilerMIR2LIRJit(CompilationUnit_O1 *cUnit, JitTranslationInfo *in
             if (success == false)
             {
                 SET_JIT_ERROR(kJitErrorChainingCell);
-                endOfTrace (true/*freeOnly*/);
+                endOfTrace (cUnit);
                 return;
             }
 
@@ -2203,7 +2214,7 @@ static void compilerMIR2LIRJit(CompilationUnit_O1 *cUnit, JitTranslationInfo *in
                 ALOGI("JIT_INFO: Code cache full after ChainingCell (trace uses %uB)", (stream - streamStart));
                 SET_JIT_ERROR(kJitErrorCodeCacheFull);
                 gDvmJit.codeCacheFull = true;
-                endOfTrace(true); /* need to free structures */
+                endOfTrace (cUnit);
                 PROTECT_CODE_CACHE(stream, unprotected_code_cache_bytes);
                 code_block_table.clear();
                 return;
@@ -2218,7 +2229,11 @@ static void compilerMIR2LIRJit(CompilationUnit_O1 *cUnit, JitTranslationInfo *in
     //In case, handle fallthrough branch
     handleFallThroughBranch (cUnit, 0, &nextFallThrough);
 
-    endOfTrace(false);
+    //Since we are at end of trace, we need to finish all work in the worklists
+    performWorklistWork ();
+
+    //We finished generating code for trace so we can signal end of trace now
+    endOfTrace (cUnit);
 
     if (cUnit->printMe) {
         // record exception VR restores as block type kExceptionHandling
@@ -2548,23 +2563,25 @@ void dvmCompilerCacheFlush(long start, long end, long flags) {
 
 bool dvmCompilerFindRegClass (MIR *mir, int vR, RegisterClass &regClass)
 {
-    int res = getVirtualRegInfo (infoByteCode, mir);
+    //Get information about the VRs in current bytecode
+    VirtualRegInfo infoByteCode[MAX_REG_PER_BYTECODE];
+    int numVRs = getVirtualRegInfo (infoByteCode, mir);
 
-    //If that failed, we failed
-    if (res == 0)
+    //If we get a negative return value, there was an error.
+    if (numVRs < 0)
     {
         return false;
     }
 
     int entry;
-    for (entry = 0; entry < num_regs_per_bytecode; entry++) {
+    for (entry = 0; entry < numVRs; entry++) {
         if (infoByteCode[entry].regNum == vR) {
             break;
         }
     }
 
     // If we cannot find this VR, we failed
-    if (entry == num_regs_per_bytecode)
+    if (entry == numVRs)
     {
         return false;
     }
diff --git a/vm/compiler/codegen/x86/CompileTable.cpp b/vm/compiler/codegen/x86/CompileTable.cpp
new file mode 100644
index 0000000..341f670
--- /dev/null
+++ b/vm/compiler/codegen/x86/CompileTable.cpp
@@ -0,0 +1,99 @@
+/*
+ * Copyright (C) 2013 Intel Corporation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "CompileTable.h"
+#include <algorithm>
+
+void CompileTableEntry::reset (void)
+{
+    //We do not reset regNum and physicalType because those uniquely represent an entry.
+    //If we reset those we would be creating an invalid CompileTableEntry so we do not.
+
+    //Initialize size based on physical type
+    size = getRegSize (physicalType);
+
+    //Reset physical register to null
+    physicalReg = PhysicalReg_Null;
+
+    //Unknown number of references
+    refCount = 0;
+
+    //If temporary, we don't know the VR it represents
+    linkageToVR = -1;
+
+    //We have not spilled this entry so no spill index
+    spill_loc_index = -1;
+
+    //We have not written to this
+    isWritten = false;
+}
+
+bool CompileTableEntry::rememberState (int stateNum)
+{
+    RegisterState newState;
+
+    newState.physicalReg = physicalReg;
+    newState.spill_loc_index = spill_loc_index;
+
+    state[stateNum] = newState;
+    return true;
+}
+
+bool CompileTableEntry::goToState (int stateNum)
+{
+    //Look to see if we have the state requested
+    std::map<int, RegisterState>::const_iterator stateIter = state.find (stateNum);
+
+    if (stateIter == state.end ())
+    {
+        //We do not have the state and therefore we cannot go to it. Fail now.
+        return false;
+    }
+
+    //Now load data from state
+    physicalReg = state[stateNum].physicalReg;
+    spill_loc_index = state[stateNum].spill_loc_index;
+
+    return true;
+}
+
+CompileTable::iterator CompileTable::find (int regNum, int physicalType)
+{
+    CompileTableEntry lookupEntry (regNum, physicalType);
+
+    return std::find (compileTable.begin (), compileTable.end (), lookupEntry);
+}
+
+CompileTable::const_iterator CompileTable::find (int regNum, int physicalType) const
+{
+    CompileTableEntry lookupEntry (regNum, physicalType);
+
+    return std::find (compileTable.begin (), compileTable.end (), lookupEntry);
+}
+
+CompileTable::iterator CompileTable::findVirtualRegister (int regNum, LowOpndRegType physicalType)
+{
+    CompileTableEntry lookupEntry (regNum, LowOpndRegType_virtual | physicalType);
+
+    return std::find (compileTable.begin (), compileTable.end (), lookupEntry);
+}
+
+CompileTable::const_iterator CompileTable::findVirtualRegister (int regNum, LowOpndRegType physicalType) const
+{
+    CompileTableEntry lookupEntry (regNum, LowOpndRegType_virtual | physicalType);
+
+    return std::find (compileTable.begin (), compileTable.end (), lookupEntry);
+}
diff --git a/vm/compiler/codegen/x86/CompileTable.h b/vm/compiler/codegen/x86/CompileTable.h
new file mode 100644
index 0000000..62b8eb1
--- /dev/null
+++ b/vm/compiler/codegen/x86/CompileTable.h
@@ -0,0 +1,502 @@
+/*
+ * Copyright (C) 2013 Intel Corporation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef COMPILETABLE_H_
+#define COMPILETABLE_H_
+
+#include <vector>
+#include <map>
+#include "AnalysisO1.h"
+
+/**
+ * @brief Represents an entry to the compilation table, helping the compiler follow what register is where.
+ * @details The pair <regNum, physicalType> uniquely determines a variable
+ */
+class CompileTableEntry {
+public:
+    /**
+     * @brief Constructor which initializes an entry with its register number and type.
+     * @param regNum The register number: vr number, temp number, or hardcoded register number.
+     * @param physicalType the LowOpndRegType for this register. Should reflect both its physical
+     * type and its logical type.
+     */
+    CompileTableEntry (int regNum, int physicalType) :
+            regNum (regNum), physicalType (physicalType), physicalReg (PhysicalReg_Null),
+            refCount(0), spill_loc_index (-1), isWritten (false), linkageToVR (0)
+    {
+        logicalType = static_cast<LogicalRegType> (physicalType & ~MASK_FOR_TYPE);
+        size = getRegSize (physicalType);
+    }
+
+    /**
+     * @brief Constructor which initializes an entry with its register number, its logical type, and
+     * its physical type.
+     * @param regNum The register number: vr number, temp number, or hardcoded register number.
+     * @param physicalType The physical type for this register.
+     * @param logicalType The logical type for this register.
+     */
+    CompileTableEntry (int regNum, LowOpndRegType physicalType, LogicalRegType logicalType) :
+            regNum (regNum), physicalReg (PhysicalReg_Null), refCount(0), spill_loc_index (-1),
+            isWritten (false), logicalType (logicalType), linkageToVR (0)
+    {
+        this->physicalType = logicalType | physicalType;
+        size = getRegSize (physicalType);
+    }
+
+    /**
+     * @brief Constructs a compile table entry which represents a virtual register.
+     * @param vrInfo The virtual register info to use for initialization.
+     */
+    CompileTableEntry (const VirtualRegInfo &vrInfo) :
+            regNum (vrInfo.regNum), physicalType (LowOpndRegType_virtual | vrInfo.physicalType),
+            physicalReg (PhysicalReg_Null), refCount(vrInfo.refCount), spill_loc_index (-1),
+            isWritten (false), logicalType (LowOpndRegType_virtual), linkageToVR (0)
+    {
+        size = getRegSize (vrInfo.physicalType);
+    }
+
+    /**
+     * @brief Constructs a compile table entry which represents a temporary.
+     * @param vrInfo The temporary info to use for initialization.
+     */
+    CompileTableEntry (const TempRegInfo &tempInfo) :
+            regNum (tempInfo.regNum), physicalType (tempInfo.physicalType),
+            physicalReg (PhysicalReg_Null), refCount(tempInfo.refCount),
+            spill_loc_index (-1), isWritten (false), linkageToVR (tempInfo.linkageToVR)
+    {
+        logicalType = static_cast<LogicalRegType> (physicalType & ~MASK_FOR_TYPE);
+        size = getRegSize (tempInfo.physicalType);
+    }
+
+    /**
+     * @brief Destructor.
+     */
+    ~CompileTableEntry (void)
+    {
+        reset ();
+    }
+
+    /**
+     * @brief Get the register number.
+     * @return Returns the register number for this entry.
+     */
+    int getRegisterNumber (void) const
+    {
+        return regNum;
+    }
+
+    /**
+     * @brief Used to get the physical type for this entry.
+     * @details This returns only type of physical register usable for this entry.
+     * @return Returns the physical type for this entry
+     */
+    LowOpndRegType getPhysicalType (void) const
+    {
+        return static_cast<LowOpndRegType> (physicalType & MASK_FOR_TYPE);
+    }
+
+    /**
+     * @brief Used to get the logical type.
+     * @return Returns the logical type for the entry.
+     */
+    LogicalRegType getLogicalType (void) const
+    {
+        return logicalType;
+    }
+
+    /**
+     * @brief Used to get an integer whose low 3 bits represent the physical type and the high bits
+     * represent the logical type.
+     * @return Returns the representation of logical and physical types.
+     */
+    int getLogicalAndPhysicalTypes (void) const
+    {
+        //For now the physical type field holds both the logical and physical types so we return that
+        return physicalType;
+    }
+
+    /**
+     * @brief Used to get the physical register.
+     * @return Returns the physical register used for this entry. If no register is used, it returns
+     * PhysicalReg_Null.
+     */
+    PhysicalReg getPhysicalReg (void) const
+    {
+        return static_cast<PhysicalReg> (physicalReg);
+    }
+
+    /**
+     * @brief Used to get the size of this entry which depends on the physical type.
+     * @return Returns the size of the physical type for this entry.
+     */
+    OpndSize getSize (void) const
+    {
+        return size;
+    }
+
+    /**
+     * @brief Sets a new physical register for this entry.
+     * @param newReg The new physical register.
+     */
+    void setPhysicalReg (PhysicalReg newReg)
+    {
+        setPhysicalReg (static_cast<int> (newReg));
+    }
+
+    /**
+     * @brief Sets a new physical register for this entry.
+     * @param newReg The new physical register.
+     */
+    void setPhysicalReg (int newReg)
+    {
+        // It doesn't make sense to set physical register to a non-existent register.
+        // Thus we have this check here for sanity.
+        assert (newReg <= PhysicalReg_Null);
+        physicalReg = newReg;
+    }
+
+    /**
+     * @brief Updates the reference count for this entry.
+     * @param newCount The reference count to set.
+     */
+    void updateRefCount (int newCount)
+    {
+        refCount = newCount;
+    }
+
+    /**
+     * @brief Used to reset the spilled location of temporary thus marking it as non-spilled.
+     */
+    void resetSpillLocation ()
+    {
+        spill_loc_index = -1;
+    }
+
+    /**
+     * @brief Checks if entry is in a physical register.
+     * @return Returns whether this entry is in a physical register.
+     */
+    bool inPhysicalRegister (void) const
+    {
+        return physicalReg != PhysicalReg_Null;
+    }
+
+    /**
+     * @brief Checks if entry is in a general purpose register.
+     * @return Returns whether this entry is in a general purpose register.
+     */
+    bool inGeneralPurposeRegister (void) const
+    {
+        return (physicalReg >= PhysicalReg_StartOfGPMarker && physicalReg <= PhysicalReg_EndOfGPMarker);
+    }
+
+    /**
+     * @brief Checks if entry is in an xmm register.
+     * @return Returns whether this entry is in an xmm register.
+     */
+    bool inXMMRegister (void) const
+    {
+        return (physicalReg >= PhysicalReg_StartOfXmmMarker && physicalReg <= PhysicalReg_EndOfXmmMarker);
+    }
+
+    /**
+     * @brief Checks if entry is in an X87 register.
+     * @return Returns whether this entry is in an X87 register.
+     */
+    bool inX87Register (void) const
+    {
+        return (physicalReg >= PhysicalReg_StartOfX87Marker && physicalReg <= PhysicalReg_EndOfX87Marker);
+    }
+
+    /**
+     * @brief Checks whether logical type represents a virtual register.
+     * @return Returns whether this entry represent a virtual register.
+     */
+    bool isVirtualReg (void) const
+    {
+        return ((physicalType & LowOpndRegType_virtual) != 0);
+    }
+
+    /**
+     * @brief Checks if this is a backend temporary used during bytecode generation.
+     * @return Returns whether this entry represent a backend temporary.
+     */
+    bool isTemporary (void) const
+    {
+        return (isVirtualReg () == false);
+    }
+
+    /**
+     * @brief Links a temporary to a corresponding virtual register.
+     * @param vR The virtual register number.
+     */
+    void linkToVR (int vR)
+    {
+        assert (isTemporary () == true);
+        linkageToVR = vR;
+    }
+
+    /**
+     * @brief Given that the entry is a temporary, it returns the virtual register it is linked to.
+     * @return Returns corresponding virtual register.
+     */
+    int getLinkedVR (void) const
+    {
+        assert (isTemporary () == true);
+        return linkageToVR;
+    }
+
+    /**
+     * @brief Resets properties of compile entry to default values. Does not reset the type and register represented
+     * by this compile entry.
+     */
+    void reset (void);
+
+    /**
+     * @brief Equality operator for checking equivalence.
+     * @details The pair <regNum, physicalType> uniquely determines a variable.
+     * @param other The compile table entry to compare to
+     * @return Returns true if the two entries are equivalent.
+     */
+    bool operator== (const CompileTableEntry& other) const
+    {
+        if (regNum == other.regNum && physicalType == other.physicalType)
+        {
+            return true;
+        }
+        else
+        {
+            return false;
+        }
+    }
+
+    /**
+     * @brief For a given state number it remembers some properties about the compile entry.
+     * @param stateNum The state number to associate current state with.
+     * @return Returns true if it successfully remembered state.
+     */
+    bool rememberState (int stateNum);
+
+    /**
+     * @brief Updates the current state of the compile entry to match the state we are interested in.
+     * @param stateNum The state number to look at for updating self state.
+     * @return Returns true if it successfully changed to the other state.
+     */
+    bool goToState (int stateNum);
+
+    /**
+     * @brief Provides physical register for an entry for a specific state.
+     * @param stateNum The state to look at.
+     * @return Returns the physical register for that state.
+     */
+    int getStatePhysicalRegister (int stateNum)
+    {
+        return state[stateNum].physicalReg;
+    }
+
+    /**
+     * @brief Provides spill location for an entry for a specific state.
+     * @param stateNum The state to look at.
+     * @return Returns the spill location for that state.
+     */
+    int getStateSpillLocation (int stateNum)
+    {
+        return state[stateNum].spill_loc_index;
+    }
+
+    int regNum;               /**< @brief The register number */
+
+    /**
+     * @brief This field holds BOTH physical type (like XMM register) and the logical type (like virtual register)
+     * @details The low 7 bits hold LowOpndRegType and the rest of bits hold LogicalRegType
+     */
+    int physicalType;
+
+    int physicalReg;          /**< @brief Which physical register was chosen */
+
+    int refCount;             /**< @brief Number of reference counts for the entry */
+
+    int spill_loc_index;      /**< @brief what is the spill location index (for temporary registers only) */
+    bool isWritten;           /**< @brief is the entry written */
+
+private:
+    /**
+     * @brief Used to save the sate of register allocator.
+     */
+    struct RegisterState
+    {
+        int spill_loc_index;
+        int physicalReg;
+    };
+
+    /**
+     * @brief Keeps track of the register state for state number.
+     */
+    std::map<int, RegisterState> state;
+
+    LogicalRegType logicalType;  /**< @brief The logical type for this entry */
+    OpndSize size;               /**< @brief Used to keep track of size of entry */
+    int linkageToVR;             /**< @brief Linked to which VR, for temporary registers only */
+};
+
+class CompileTable
+{
+public:
+    /**
+     * @brief Used to access an element of the compile table.
+     * @details If index matches the key of an element in the container, the function returns a reference to its mapped
+     * value. If index does not match the key of any element in the container, the function inserts a new element with
+     * that key and returns a reference to its mapped value.
+     * @param index The index of the entry we want to access.
+     * @return Returns a reference to the mapped value of the element with a key value equivalent to index.
+     */
+    CompileTableEntry& operator[] (size_t index)
+    {
+        return compileTable[index];
+    }
+
+    /**
+     * @brief Used to access an element of the compile table in a constant fashion.
+     * @details If index matches the key of an element in the container, the function returns a reference to its mapped
+     * value. If index does not match the key of any element in the container, the function inserts a new element with
+     * that key and returns a reference to its mapped value.
+     * @param index The index of the entry we want to access.
+     * @return Returns a reference to the mapped value of the element with a key value equivalent to index.
+     */
+    const CompileTableEntry& operator[] (size_t index) const
+    {
+        return compileTable[index];
+    }
+
+    /**
+     * @brief Random access const iterator. This does not modify structure it is iterating.
+     */
+    typedef std::vector<CompileTableEntry>::const_iterator const_iterator;
+
+    /**
+     * @brief Random access iterator. This may modify structure it is iterating.
+     */
+    typedef std::vector<CompileTableEntry>::iterator iterator;
+
+    /**
+     * @brief Returns an iterator pointing to the first compile entry.
+     * @return iterator to beginning
+     */
+    iterator begin (void)
+    {
+        return compileTable.begin ();
+    }
+
+    /**
+     * @brief Returns a const iterator pointing to the first compile entry.
+     * @return iterator to beginning
+     */
+    const_iterator begin (void) const
+    {
+        return compileTable.begin ();
+    }
+
+    /**
+     * @brief Returns an iterator referring to the past-the-end compile entry.
+     * @return iterator past end
+     */
+    iterator end (void)
+    {
+        return compileTable.end ();
+    }
+
+    /**
+     * @brief Returns a const iterator referring to the past-the-end compile entry.
+     * @return iterator past end
+     */
+    const_iterator end (void) const
+    {
+        return compileTable.end ();
+    }
+
+    /**
+     * @brief Used to get an iterator pointing to the entry matching number and type.
+     * @param regNum The register number (can be temp, virtual, or hardcoded)
+     * @param physicalType The physical type and logical type representing the entry.
+     * @return Returns iterator pointing to the desired entry. If one is not found, it
+     * returns the past-the-end iterator.
+     */
+    iterator find (int regNum, int physicalType);
+
+    /**
+     * @brief Used to get a const iterator pointing to the entry matching number and type.
+     * @param regNum The register number (can be temp, virtual, or hardcoded)
+     * @param physicalType The physical type and logical type representing the entry.
+     * @return Returns const iterator pointing to the desired entry. If one is not found, it
+     * returns the past-the-end const iterator.
+     */
+    const_iterator find (int regNum, int physicalType) const;
+
+    /**
+     * @brief Used to get an iterator pointing to the virtual register whose physical type matches.
+     * @param regNum The virtual register number.
+     * @param physicalType The physical type of the virtual register.
+     * @return Returns iterator pointing to the desired entry. If one is not found, it
+     * returns the past-the-end iterator.
+     */
+    iterator findVirtualRegister (int regNum, LowOpndRegType physicalType);
+
+    /**
+     * @brief Used to get a const iterator pointing to the virtual register whose physical type matches.
+     * @param regNum The virtual register number.
+     * @param physicalType The physical type of the virtual register.
+     * @return Returns const iterator pointing to the desired entry. If one is not found, it
+     * returns the past-the-end const iterator.
+     */
+    const_iterator findVirtualRegister (int regNum, LowOpndRegType physicalType) const;
+
+    /**
+     * @brief Used to get size of compile table.
+     * @return Returns the size of the compile table.
+     */
+    int size (void) const
+    {
+        return compileTable.size ();
+    }
+
+    /**
+     * @brief Used to insert a new entry into the compile table.
+     * @param newEntry The compile table entry to insert into the table.
+     */
+    void insert (const CompileTableEntry &newEntry)
+    {
+        compileTable.push_back (newEntry);
+    }
+
+    /**
+     * @brief Used to clear the compile table.
+     */
+    void clear (void)
+    {
+        compileTable.clear ();
+    }
+
+private:
+    /**
+     * @brief Used to keep track of the entries in the compile table.
+     * @todo Ideally this should be a set or a map so that lookup is fast.
+     */
+    std::vector<CompileTableEntry> compileTable;
+};
+
+extern CompileTable compileTable;
+
+#endif /* COMPILETABLE_H_ */
diff --git a/vm/compiler/codegen/x86/InstructionGeneration.cpp b/vm/compiler/codegen/x86/InstructionGeneration.cpp
index 4820637..c8e4c89 100644
--- a/vm/compiler/codegen/x86/InstructionGeneration.cpp
+++ b/vm/compiler/codegen/x86/InstructionGeneration.cpp
@@ -205,36 +205,142 @@ void genValidationForPredictedInline(CompilationUnit *cUnit, MIR *mir)
 }
 #endif
 
-void genRegisterize (CompilationUnit *cUnit, MIR *mir)
+/**
+ * @brief Uses heuristics to determine whether a registerize request should be satisfied.
+ * @param physicalType The backend physical type for the registerize request
+ * @return Returns true if the registerize request should be satisfied.
+ */
+static bool shouldGenerateRegisterize (LowOpndRegType physicalType)
 {
-    int vA = mir->dalvikInsn.vA;
-    int vB = mir->dalvikInsn.vB;
+    std::set<PhysicalReg> freeGPs, freeXMMs;
+
+    //Get the free registers available
+    findFreeRegisters (freeGPs, true, false);
+    findFreeRegisters (freeXMMs, false, true);
+
+    //If we want to registerize into a GP and we have no more, then reject this request
+    if (freeGPs.size () == 0 && physicalType == LowOpndRegType_gp)
+    {
+        return false;
+    }
+
+    //If we want to registerize into an XMM and we have no more, then reject this request
+    if (freeXMMs.size () == 0 && (physicalType == LowOpndRegType_ss || physicalType == LowOpndRegType_xmm))
+    {
+        return false;
+    }
+
+    //We accept the registerize request if we get here
+    return true;
+}
+
+bool genRegisterize (CompilationUnit *cUnit, BasicBlock_O1 *bb, MIR *mir)
+{
+    //Get the virtual register which is vA
+    int vR = mir->dalvikInsn.vA;
 
     //Get the class from vB, it determines which instruction to use for the move
-    RegisterClass regClass = static_cast<RegisterClass> (vB);
+    RegisterClass regClass = static_cast<RegisterClass> (mir->dalvikInsn.vB);
 
-    switch (regClass)
+    LowOpndRegType physicalType = LowOpndRegType_invalid;
+
+    // We want to figure out the mapping between the register class and the backend physical type
+    if (regClass == kCoreReg)
+    {
+        physicalType = LowOpndRegType_gp;
+    }
+    else if (regClass == kSFPReg)
     {
-        case kCoreReg:
-            //We just want vA in a register
-            get_virtual_reg (vA, OpndSize_32, 1, false);
-            set_virtual_reg (vA, OpndSize_32, 1, false);
-            break;
-        case kSFPReg:
-            //We just want vA in a register
-            get_VR_ss (vA, 1, false);
-            set_VR_ss (vA, 1, false);
-            break;
-        case kDFPReg:
-            //We just want vA in a register
-            get_VR_sd (vA, 1, false);
-            set_VR_sd (vA, 1, false);
-            break;
-        default:
-            ALOGI("JIT_INFO: genRegisterize is requesting an unsupported regClass %d", regClass);
-            SET_JIT_ERROR(kJitErrorUnsupportedBytecode);
-            break;
+        physicalType = LowOpndRegType_ss;
     }
+    else if (regClass == kDFPReg)
+    {
+        physicalType = LowOpndRegType_xmm;
+    }
+
+    //If we haven't determined a proper backend type, we reject this case
+    if (physicalType == LowOpndRegType_invalid)
+    {
+        ALOGI ("JIT_INFO: genRegisterize is requesting an unsupported regClass %d", regClass);
+        SET_JIT_ERROR (kJitErrorUnsupportedBytecode);
+        return false;
+    }
+
+    //We haven't registerized yet so we mark it as false for now until we actually do it
+    bool registerized = false;
+
+    //Look for this virtual register in the compile table
+    CompileTable::const_iterator vrPtr = compileTable.findVirtualRegister (vR, physicalType);
+
+    //We should already have this virtual register in the compile table because it is part of
+    //uses of this extended MIR. However, if we don't, then simply ignore the registerize request.
+    if (vrPtr != compileTable.end())
+    {
+        //Get the compile entry reference
+        const CompileTableEntry &compileEntry = *vrPtr;
+
+        //We check if it is already in physical register so we don't reload if not needed.
+        if (compileEntry.inPhysicalRegister () == false)
+        {
+            //We might want to load it in physical register so check the heuristics
+            if (shouldGenerateRegisterize (physicalType) == true)
+            {
+                //What is the size of this virtual register?
+                OpndSize size = compileEntry.getSize ();
+
+                //Define the temporary we will load into
+                const int temp = 1;
+
+                //Now we want to do the actual loading of this virtual register. We do this by using a trick
+                //to load the virtual register into a temp. And then to make sure the load happens we alias
+                //the virtual register to that temp
+                if (physicalType == LowOpndRegType_gp)
+                {
+                    get_virtual_reg (vR, size, temp, false);
+                    set_virtual_reg (vR, size, temp, false);
+                    registerized = true;
+                }
+                else if (physicalType == LowOpndRegType_ss)
+                {
+                    get_VR_ss (vR, temp, false);
+                    set_VR_ss (vR, temp, false);
+                    registerized = true;
+                }
+                else if (physicalType == LowOpndRegType_xmm)
+                {
+                    get_VR_sd (vR, temp, false);
+                    set_VR_sd (vR, temp, false);
+                    registerized = true;
+                }
+            }
+        }
+        else
+        {
+            //This is already in physical register so we mark it as having been registerized
+            registerized = true;
+        }
+    }
+
+    //If we don't satisfy this registerize request then we should make this part of the writeback requests
+    if (registerized == false)
+    {
+        //We have a wide virtual register if its backend type is xmm
+        bool isWideVr = (physicalType == LowOpndRegType_xmm);
+
+        BitVector *writebacks = bb->requestWriteBack;
+
+        //Put this VR in this block's writeback requests
+        dvmSetBit (writebacks, vR);
+
+        //If it is wide, we make sure the high VR also makes it in the writeback requests
+        if (isWideVr == true)
+        {
+            dvmSetBit (writebacks, vR + 1);
+        }
+    }
+
+    //If we get here, everything was handled
+    return true;
 }
 
 /**
diff --git a/vm/compiler/codegen/x86/InstructionGeneration.h b/vm/compiler/codegen/x86/InstructionGeneration.h
index 9815fa4..a795d81 100644
--- a/vm/compiler/codegen/x86/InstructionGeneration.h
+++ b/vm/compiler/codegen/x86/InstructionGeneration.h
@@ -19,6 +19,9 @@
 
 #include "Dalvik.h"
 
+//Forward declarations
+class BasicBlock_O1;
+
 /**
  * @brief Generate a Null check
  * @param cUnit the CompilationUnit
@@ -39,7 +42,7 @@ void genHoistedNullCheck (CompilationUnit *cUnit, MIR *mir);
 void genHoistedBoundCheck (CompilationUnit *cUnit, MIR *mir);
 
 //use O0 code generator for hoisted checks outside of the loop
-/*
+/**
  * @brief Generate the null and upper bound check for a count up loop
  * vA = arrayReg;
  * vB = idxReg;
@@ -52,7 +55,7 @@ void genHoistedBoundCheck (CompilationUnit *cUnit, MIR *mir);
  */
 void genHoistedChecksForCountUpLoop(CompilationUnit *cUnit, MIR *mir);
 
-/*
+/**
  * @brief Generate the null and upper bound check for a count down loop
  * vA = arrayReg;
  * vB = idxReg;
@@ -65,7 +68,7 @@ void genHoistedChecksForCountUpLoop(CompilationUnit *cUnit, MIR *mir);
  */
 void genHoistedChecksForCountDownLoop(CompilationUnit *cUnit, MIR *mir);
 
-/*
+/**
  * @brief Generate the lower bound check
  * vA = arrayReg;
  * vB = minimum constant used for the array;
@@ -74,7 +77,7 @@ void genHoistedChecksForCountDownLoop(CompilationUnit *cUnit, MIR *mir);
  */
 void genHoistedLowerBoundCheck(CompilationUnit *cUnit, MIR *mir);
 
-/*
+/**
  * @brief Generate the validation for a predicted inline
  * vC actual class
  * @param cUnit the CompilationUnit
@@ -82,15 +85,17 @@ void genHoistedLowerBoundCheck(CompilationUnit *cUnit, MIR *mir);
  */
 void genValidationForPredictedInline(CompilationUnit *cUnit, MIR *mir);
 
-/*
- * @brief Generate the registerize instruction
- * vA = the register to set in a physical register
- * @param cUnit the CompilationUnit
- * @param mir the MIR instruction
+/**
+ * @brief Generate native code for the registerize extended instruction
+ * @details vA of the mir has the register to set in a physical register
+ * @param cUnit The Compilation Unit
+ * @param bb The basic block that contains the request
+ * @param mir the MIR instruction representing the registerization request
+ * @return Returns whether or not it successfully handled the request
  */
-void genRegisterize (CompilationUnit *cUnit, MIR *mir);
+bool genRegisterize (CompilationUnit *cUnit, BasicBlock_O1 *bb, MIR *mir);
 
-/*
+/**
  * @brief Generate code for MirOpDualDoubleDivide
  *   vA = Result of division 1
  *   vB = Numerator of division 1
diff --git a/vm/compiler/codegen/x86/Lower.cpp b/vm/compiler/codegen/x86/Lower.cpp
index a765efd..03cc0df 100644
--- a/vm/compiler/codegen/x86/Lower.cpp
+++ b/vm/compiler/codegen/x86/Lower.cpp
@@ -484,22 +484,48 @@ void startOfTrace(const Method* method, int exceptionBlockId,
         startOfTraceO1(method, exceptionBlockId, cUnit);
 }
 
-void endOfTrace(bool freeOnly) {
-    if(freeOnly) {
-        freeLabelWorklist();
-        freeNCGWorklist();
-        freeDataWorklist();
-        freeChainingWorklist();
-    }
-    else {
-        performLabelWorklist();
-        performNCGWorklist(); //handle forward jump (GOTO, IF)
-        performDataWorklist(); //handle SWITCH & FILL_ARRAY_DATA
-        performChainingWorklist();
-    }
-    if(gDvm.executionMode == kExecutionModeNcgO1) {
-        endOfTraceO1();
+/**
+ * @brief Used to free the data structures in basic blocks that were used by backend
+ * @param basicBlocks The list of all basic blocks in current cUnit
+ */
+static void freeCFG (GrowableList &basicBlocks)
+{
+    //Create and initialize the basic block iterator
+    GrowableListIterator iter;
+    dvmGrowableListIteratorInit (&basicBlocks, &iter);
+
+    //Get the first basic block provided by iterator
+    BasicBlock_O1 *bb = reinterpret_cast<BasicBlock_O1 *> (dvmGrowableListIteratorNext (&iter));
+
+    while (bb != 0)
+    {
+        //Call the BasicBlock_O1 clear function
+        bb->freeIt ();
+
+        //We want to move on to next basic block
+        bb = reinterpret_cast<BasicBlock_O1 *> (dvmGrowableListIteratorNext (&iter));
     }
+}
+
+void performWorklistWork (void)
+{
+    performLabelWorklist ();
+    performNCGWorklist (); //handle forward jump (GOTO, IF)
+    performDataWorklist (); //handle SWITCH & FILL_ARRAY_DATA
+    performChainingWorklist ();
+}
+
+void endOfTrace (CompilationUnit *cUnit) {
+    freeLabelWorklist ();
+    freeNCGWorklist ();
+    freeDataWorklist ();
+    freeChainingWorklist ();
+
+    //Now we want to free anything in BasicBlock that we used during backend but was not
+    //allocated using the arena
+    freeCFG (cUnit->blockList);
+
+    //Restore the execution mode as the ME expects it
     gDvm.executionMode = origMode;
 
     //Reset the global compilation unit
diff --git a/vm/compiler/codegen/x86/Lower.h b/vm/compiler/codegen/x86/Lower.h
index 2a77442..68c6354 100644
--- a/vm/compiler/codegen/x86/Lower.h
+++ b/vm/compiler/codegen/x86/Lower.h
@@ -44,8 +44,6 @@
 /*! remove redundant null check */
 #define NULLCHECK_OPT
 //#define BOUNDCHECK_OPT
-/*! optimize the access to glue structure */
-#define GLUE_OPT
 #define CALL_FIX
 #define NATIVE_FIX
 #define INVOKE_FIX //optimization
@@ -55,6 +53,7 @@
 #include "Dalvik.h"
 #include "enc_wrapper.h"
 #include "AnalysisO1.h"
+#include "CompileTable.h"
 #include "compiler/CompilerIR.h"
 
 //compilation flags for debugging
@@ -650,9 +649,6 @@ bool requestVRFreeDelayAll(u4 reason);
 bool cancelVRFreeDelayRequestAll(u4 reason);
 
 bool getVRFreeDelayRequested(int regNum);
-bool isGlueHandled(int glue_reg);
-int resetGlue(int glue_reg);
-int updateGlue(int reg, bool isPhysical, int glue_reg);
 
 //Update the virtual register use information
 void updateVRAtUse(int reg, LowOpndRegType pType, int regAll);
@@ -668,7 +664,7 @@ void goToState(int);
 void transferToState(int);
 
 //Handle virtual register writebacks
-int handleVRsEndOfBB(bool lastBytecodeIsJump);
+int handleRegistersEndOfBB(bool syncChildren);
 
 //Call to reset certain flags before generating native code
 void startNativeCode(int num, int type);
@@ -929,9 +925,6 @@ int get_res_fields(int reg, bool isPhysical);
 int get_res_methods(int reg, bool isPhysical);
 int get_glue_method_class(int reg, bool isPhysical);
 int get_glue_method(int reg, bool isPhysical);
-int set_glue_method(int reg, bool isPhysical);
-int get_glue_dvmdex(int reg, bool isPhysical);
-int set_glue_dvmdex(int reg, bool isPhysical);
 int get_suspendCount(int reg, bool isPhysical);
 int get_return_value(OpndSize size, int reg, bool isPhysical);
 int set_return_value(OpndSize size, int reg, bool isPhysical);
@@ -940,7 +933,6 @@ void set_return_value(OpndSize size, int sourceReg, bool isSourcePhysical,
 int clear_exception();
 int get_exception(int reg, bool isPhysical);
 int set_exception(int reg, bool isPhysical);
-int save_pc_fp_to_glue();
 int savearea_from_fp(int reg, bool isPhysical);
 
 int call_moddi3();
@@ -1354,22 +1346,30 @@ void startOfBasicBlock(struct BasicBlock* bb);
 extern struct BasicBlock* traceCurrentBB;
 extern JitMode traceMode;
 
-//Forward declaration
+//Forward declarations
 class CompilationUnit_O1;
+class BasicBlock_O1;
+
 //Start of a trace call to reset certain elements
 void startOfTrace(const Method* method, int, CompilationUnit_O1*);
+
 //End of a trace call to reset certain elements
-void endOfTrace(bool freeOnly);
+void endOfTrace (CompilationUnit *cUnit);
+
+//Initiates all worklists to do their work
+void performWorklistWork (void);
 
 LowOp* jumpToBasicBlock(char* instAddr, int targetId, bool targetIsChainingCell = false);
 LowOp* condJumpToBasicBlock(char* instAddr, ConditionCode cc, int targetId, bool immediateNeedsAligned = false);
 bool jumpToException(const char* target);
 int codeGenBasicBlockJit(const Method* method, BasicBlock* bb);
 void endOfBasicBlock(struct BasicBlock* bb);
-void handleExtendedMIR(CompilationUnit *cUnit, MIR *mir);
+
+//Used to generate native code the extended MIRs
+bool handleExtendedMIR (CompilationUnit *cUnit, BasicBlock_O1 *bb, MIR *mir);
+
 int insertChainingWorklist(int bbId, char * codeStart);
 void startOfTraceO1(const Method* method, int exceptionBlockId, CompilationUnit *cUnit);
-void endOfTraceO1();
 /** @brief search globalMap to find the entry for the given label */
 char* findCodeForLabel(const char* label);
 /* Find a label offset given a BasicBlock index */
@@ -1392,8 +1392,7 @@ void freeAtomMem();
 OpndSize estOpndSizeFromImm(int target);
 
 //Preprocess a BasicBlock before being lowered
-int preprocessingBB(CompilationUnit *cUnit, BasicBlock* bb);
-int preprocessingTrace();
+int preprocessingBB (CompilationUnit *cUnit, BasicBlock *bb);
 /** @brief align the relative offset of jmp/jcc and movl within 16B */
 void alignOffset(int cond);
 bool doesJumpToBBNeedAlignment(BasicBlock * bb);
diff --git a/vm/compiler/codegen/x86/LowerHelper.cpp b/vm/compiler/codegen/x86/LowerHelper.cpp
index 8086b7c..bd11e12 100644
--- a/vm/compiler/codegen/x86/LowerHelper.cpp
+++ b/vm/compiler/codegen/x86/LowerHelper.cpp
@@ -3109,66 +3109,17 @@ int get_self_pointer(int reg, bool isPhysical) {
     return 0;
 }
 
-int get_res_classes(int reg, bool isPhysical) {
-    int retCode = 0;
-    //if spill_loc_index > 0 || reg != NULL, use registerAlloc
-    if(isGlueHandled(PhysicalReg_GLUE_DVMDEX)) {
-        //if spill_loc_index > 0
-        //  load from spilled location, updte spill_loc_index & physicalReg
-        startNativeCode(-1, -1);
-        freeReg(true);
-        int regAll = registerAlloc(LowOpndRegType_gp, PhysicalReg_GLUE_DVMDEX, false, false/*updateRefCount*/, true);
-
-        //Do not spill regAll
-        gCompilationUnit->setCanSpillRegister (regAll, false);
-
-        dump_mem_reg_noalloc_mem(Mnemonic_MOV, ATOM_NORMAL, OpndSize_32, OFFSETOF_MEMBER(DvmDex, pResClasses), regAll, true, MemoryAccess_Unknown, -1, reg, isPhysical, LowOpndRegType_gp);
-        endNativeCode();
-    }
-    else
-        {
-            get_self_pointer(C_SCRATCH_1, isScratchPhysical);
-            move_mem_to_reg(OpndSize_32, offsetof(Thread, interpSave.methodClassDex), C_SCRATCH_1, isScratchPhysical, C_SCRATCH_2, isScratchPhysical);
-            //glue is not in a physical reg nor in a spilled location
-            retCode = updateGlue(C_SCRATCH_2, isScratchPhysical, PhysicalReg_GLUE_DVMDEX); //spill_loc_index is -1, set physicalReg
-            if (retCode < 0)
-                return retCode;
-            move_mem_to_reg(OpndSize_32, OFFSETOF_MEMBER(DvmDex, pResClasses), C_SCRATCH_2, isScratchPhysical, reg, isPhysical);
-        }
-    return 0;
-}
+int get_res_classes(int reg, bool isPhysical)
+{
+    get_self_pointer(C_SCRATCH_1, isScratchPhysical);
 
-//!generate native code to get ResMethods from glue
+    move_mem_to_reg(OpndSize_32, offsetof(Thread, interpSave.methodClassDex), C_SCRATCH_1, isScratchPhysical, C_SCRATCH_2, isScratchPhysical);
 
-//!It uses two scratch registers
-int get_res_methods(int reg, bool isPhysical) {
-    int retCode = 0;
-    //if spill_loc_index > 0 || reg != NULL, use registerAlloc
-    if(isGlueHandled(PhysicalReg_GLUE_DVMDEX)) {
-        //if spill_loc_index > 0
-        //  load from spilled location, updte spill_loc_index & physicalReg
-        startNativeCode(-1, -1);
-        freeReg(true);
-        int regAll = registerAlloc(LowOpndRegType_gp, PhysicalReg_GLUE_DVMDEX, false, false/*updateRefCount*/, true);
+    move_mem_to_reg(OpndSize_32, OFFSETOF_MEMBER(DvmDex, pResClasses), C_SCRATCH_2, isScratchPhysical, reg, isPhysical);
 
-        //Do not spill regAll
-        gCompilationUnit->setCanSpillRegister (regAll, false);
-
-        dump_mem_reg_noalloc_mem(Mnemonic_MOV, ATOM_NORMAL, OpndSize_32, OFFSETOF_MEMBER(DvmDex, pResMethods), regAll, true, MemoryAccess_Unknown, -1, reg, isPhysical, LowOpndRegType_gp);
-        endNativeCode();
-    }
-    else
-        {
-            get_self_pointer(C_SCRATCH_1, isScratchPhysical);
-            move_mem_to_reg(OpndSize_32, offsetof(Thread, interpSave.methodClassDex), C_SCRATCH_1, isScratchPhysical, C_SCRATCH_2, isScratchPhysical);
-            //glue is not in a physical reg nor in a spilled location
-            retCode = updateGlue(C_SCRATCH_2, isScratchPhysical, PhysicalReg_GLUE_DVMDEX); //spill_loc_index is -1, set physicalReg
-            if (retCode < 0)
-                return retCode;
-            move_mem_to_reg(OpndSize_32, OFFSETOF_MEMBER(DvmDex, pResMethods), C_SCRATCH_2, isScratchPhysical, reg, isPhysical);
-        }
     return 0;
 }
+
 //!generate native code to get the current class object from glue
 
 //!It uses two scratch registers
@@ -3186,54 +3137,7 @@ int get_glue_method(int reg, bool isPhysical) {
     move_mem_to_reg(OpndSize_32, offsetof(Thread, interpSave.method), C_SCRATCH_1, isScratchPhysical, reg, isPhysical);
     return 0;
 }
-//!generate native code to set the current method in glue
-
-//!It uses one scratch register
-int set_glue_method(int reg, bool isPhysical) {
-    get_self_pointer(C_SCRATCH_1, isScratchPhysical);
-    move_reg_to_mem(OpndSize_32, reg, isPhysical, offsetof(Thread, interpSave.method), C_SCRATCH_1, isScratchPhysical);
-    return 0;
-}
-
-//!generate native code to get DvmDex from glue
-
-//!It uses one scratch register
-int get_glue_dvmdex(int reg, bool isPhysical) {
-    int retCode = 0;
-    //if spill_loc_index > 0 || reg != NULL, use registerAlloc
-    if(isGlueHandled(PhysicalReg_GLUE_DVMDEX)) {
-        //if spill_loc_index > 0
-        //  load from spilled location, updte spill_loc_index & physicalReg
-        startNativeCode(-1, -1);
-        freeReg(true);
-        int regAll = registerAlloc(LowOpndRegType_gp, PhysicalReg_GLUE_DVMDEX, false, false/*updateRefCount*/, true);
-
-        //Do not spill regAll
-        gCompilationUnit->setCanSpillRegister (regAll, false);
-
-        dump_reg_reg_noalloc_src(Mnemonic_MOV, ATOM_NORMAL, OpndSize_32, regAll, true,
-                                          reg, isPhysical, LowOpndRegType_gp);
-        endNativeCode();
-    }
-    else
-        {
-            get_self_pointer(C_SCRATCH_1, isScratchPhysical);
-            move_mem_to_reg(OpndSize_32, offsetof(Thread, interpSave.methodClassDex), C_SCRATCH_1, isScratchPhysical, reg, isPhysical);
-            //glue is not in a physical reg nor in a spilled location
-            retCode = updateGlue(reg, isPhysical, PhysicalReg_GLUE_DVMDEX); //spill_loc_index is -1, set physicalReg
-            if (retCode < 0)
-                return retCode;
-        }
-    return 0;
-}
-//!generate native code to set DvmDex in glue
 
-//!It uses one scratch register
-int set_glue_dvmdex(int reg, bool isPhysical) {
-    get_self_pointer(C_SCRATCH_1, isScratchPhysical);
-    move_reg_to_mem(OpndSize_32, reg, isPhysical, offsetof(Thread, interpSave.methodClassDex), C_SCRATCH_1, isScratchPhysical);
-    return 0;
-}
 //!generate native code to get SuspendCount from glue
 
 //!It uses one scratch register
diff --git a/vm/compiler/codegen/x86/LowerJump.cpp b/vm/compiler/codegen/x86/LowerJump.cpp
index 39ed407..e458d71 100644
--- a/vm/compiler/codegen/x86/LowerJump.cpp
+++ b/vm/compiler/codegen/x86/LowerJump.cpp
@@ -1137,7 +1137,7 @@ int common_goto(s4 tmp) { //tmp: relativePC
         //potential garbage collection will work as designed
         call_helper_API("common_periodicChecks4");
     }
-    retCode = handleVRsEndOfBB(true);
+    retCode = handleRegistersEndOfBB(true);
     if (retCode < 0)
         return retCode;
     bool unknown;
@@ -1186,11 +1186,14 @@ int common_goto(s4 targetBlockId) {
     OpndSize size;
     bool needAlignment = doesJumpToBBNeedAlignment(traceCurrentBB->taken);
 
-    // We call it with false because we want to actually want to update
+    // We call it with true because we want to actually want to update
     // association tables of children and handle ME spill requests
-    retCode = handleVRsEndOfBB(false);
+    retCode = handleRegistersEndOfBB (true);
     if (retCode < 0)
+    {
+        //Just pass along error information
         return retCode;
+    }
 
     if(gDvmJit.scheduling) {
         // Assuming that gotos never go to chaining cells because they are not
@@ -1247,6 +1250,11 @@ int common_if(s4 tmp, ConditionCode cc_next, ConditionCode cc) {
         return -1;
     }
 
+    // Since we have reached the end of basic block, let's handle registers at
+    // end of BB without actually syncing the state. We sync the state below
+    // when we handle each child
+    handleRegistersEndOfBB (false);
+
     // So if we have a Prebackward block, we need to satisfy associations
     // of loop entry
     if (takenBB->blockType == kPreBackwardBlock)
@@ -1692,15 +1700,20 @@ int op_packed_switch(const MIR * mir, const u2 * dalvikPC) {
     move_imm_to_mem(OpndSize_32, (int)entries, 0, PhysicalReg_ESP, true);
     move_reg_to_mem(OpndSize_32, 1, false, 12, PhysicalReg_ESP, true);
 
+    //We are done using the VRs and it is end of BB, so we handle it right now
+    retCode = handleRegistersEndOfBB (true);
+    if (retCode < 0)
+    {
+        //Just pass along error information
+        return retCode;
+    }
+
     //if value out of range, fall through (no_op)
     //return targets[testVal - first_key]
     scratchRegs[0] = PhysicalReg_SCRATCH_1;
     call_dvmJitHandlePackedSwitch();
     load_effective_addr(16, PhysicalReg_ESP, true, PhysicalReg_ESP, true);
-    //TODO: eax should be absolute address, call handleVRsEndOfBB
-    retCode = handleVRsEndOfBB(true); //update GG VRs
-    if (retCode < 0)
-        return retCode;
+
     //get rPC, %eax has the relative PC offset
     alu_binary_imm_reg(OpndSize_32, add_opc, (int)dalvikPC, PhysicalReg_EAX, true);
     scratchRegs[0] = PhysicalReg_SCRATCH_2;
@@ -1759,15 +1772,20 @@ int op_sparse_switch(const MIR * mir, const u2 * dalvikPC) {
     move_imm_to_mem(OpndSize_32, (int)keys, 0, PhysicalReg_ESP, true);
     move_reg_to_mem(OpndSize_32, 1, false, 8, PhysicalReg_ESP, true);
 
+    //We are done using the VRs and it is end of BB, so we handle it right now
+    retCode = handleRegistersEndOfBB (true);
+    if (retCode < 0)
+    {
+        //Just pass along error information
+        return retCode;
+    }
+
     scratchRegs[0] = PhysicalReg_SCRATCH_1;
     //if testVal is in keys, return the corresponding target
     //otherwise, fall through (no_op)
     call_dvmJitHandleSparseSwitch();
     load_effective_addr(12, PhysicalReg_ESP, true, PhysicalReg_ESP, true);
-    //TODO: eax should be absolute address, call handleVRsEndOfBB
-    retCode = handleVRsEndOfBB(true);
-    if (retCode < 0)
-        return retCode;
+
     //get rPC, %eax has the relative PC offset
     alu_binary_imm_reg(OpndSize_32, add_opc, (int)dalvikPC, PhysicalReg_EAX, true);
     scratchRegs[0] = PhysicalReg_SCRATCH_2;
@@ -2099,7 +2117,6 @@ int common_gotoBail(void) {
 
     //scratchRegs[0] = PhysicalReg_EDX; scratchRegs[1] = PhysicalReg_ESI;
     //scratchRegs[2] = PhysicalReg_Null; scratchRegs[3] = PhysicalReg_Null;
-    //save_pc_fp_to_glue();
     get_self_pointer(PhysicalReg_EAX, true);
     move_reg_to_mem(OpndSize_32, PhysicalReg_FP, true, offsetof(Thread, interpSave.curFrame), PhysicalReg_EAX, true);
     move_reg_to_mem(OpndSize_32, PhysicalReg_EDX, true, offsetof(Thread, interpSave.pc), PhysicalReg_EAX, true);
diff --git a/vm/compiler/codegen/x86/RegisterizationBE.cpp b/vm/compiler/codegen/x86/RegisterizationBE.cpp
index 6a6eb1f..db99dd4 100644
--- a/vm/compiler/codegen/x86/RegisterizationBE.cpp
+++ b/vm/compiler/codegen/x86/RegisterizationBE.cpp
@@ -78,12 +78,13 @@ bool AssociationTable::copy(AssociationTable &source) {
     return true;
 }
 
-bool AssociationTable::associate(const CompileTableEntry & compileEntry) {
+bool AssociationTable::associate(const CompileTableEntry &compileEntry)
+{
     // We cannot update once the association table has been finalized
     assert (hasBeenFinalized() == false);
 
     // Paranoid: this must be a virtual register
-    assert(isVirtualReg(compileEntry.physicalType));
+    assert (compileEntry.isVirtualReg () == true);
 
     //Get local versions of the compileEntry
     int VR = compileEntry.regNum;
@@ -92,7 +93,7 @@ bool AssociationTable::associate(const CompileTableEntry & compileEntry) {
     bool safeToUpdate = true;
 
     // Check if we are overwriting an existing association
-    const_iterator assocEntry = associations.find(VR);
+    iterator assocEntry = associations.find(VR);
     if (assocEntry != associations.end())
     {
         int oldPhysicalReg = assocEntry->second.physicalReg;
@@ -122,10 +123,18 @@ bool AssociationTable::associate(const CompileTableEntry & compileEntry) {
     //We only do the update if it is safe
     if (safeToUpdate == true)
     {
-        // Make a copy of the compile table entry
-        associations[VR] = compileEntry;
+        if (assocEntry != associations.end())
+        {
+            //If we already have an entry for this VR then simply update its compile entry
+            assocEntry->second = compileEntry;
+        }
+        else
+        {
+            //Otherwise we insert it into our associations
+            associations.insert (std::make_pair (VR, compileEntry));
+        }
 
-        DEBUG_ASSOCIATION( ALOGD ("Associating v%d with %s\n", VR,
+        DEBUG_ASSOCIATION (ALOGD ("Associating v%d with %s\n", VR,
                 physicalRegToString(static_cast<PhysicalReg> (physicalReg))));
     }
 
@@ -264,7 +273,7 @@ bool AssociationTable::syncAssociationsWithCompileTable (AssociationTable & asso
     }
 
     // Go through each entry of the compile table
-    for (int entry = 0; entry < num_compile_entries; entry++)
+    for (int entry = 0; entry < compileTable.size (); entry++)
     {
         // Update associations for every VR entry we find
         if (compileTable[entry].isVirtualReg () == true && shouldSaveAssociation (compileTable[entry]) == true)
@@ -316,13 +325,13 @@ bool AssociationTable::syncCompileTableWithAssociations(AssociationTable & assoc
         bool foundCompileTableEntry = false;
 
         DEBUG_COMPILETABLE_UPDATE(ALOGD("Starting to search through compile "
-                "table that has %d entries", num_compile_entries));
+                "table that has %d entries", compileTable.size ()));
 
         int vR = assocIter->first;
         const CompileTableEntry &associationEntry = assocIter->second;
 
         // Now search the compile table for an appropriate entry
-        for (int entry = 0; entry < num_compile_entries; entry++)
+        for (int entry = 0; entry < compileTable.size (); entry++)
         {
             //If it is a virtual register and the right register
             if (compileTable[entry].isVirtualReg () == true
@@ -347,25 +356,16 @@ bool AssociationTable::syncCompileTableWithAssociations(AssociationTable & assoc
             DEBUG_COMPILETABLE_UPDATE(ALOGD("We have not found v%d in compile "
                         "table so we will make a new entry.", assocIter->first));
 
-            //Paranoid
-            if (num_compile_entries >= COMPILE_TABLE_SIZE)
-            {
-                ALOGI ("JIT_INFO: compileTable overflow at syncCompileTableWithAssociations");
-                SET_JIT_ERROR(kJitErrorRegAllocFailed);
-                return false;
-            }
-
-            //Add it to the global compileTable
-            compileTable[num_compile_entries] = assocIter->second;
+            CompileTableEntry newEntry = assocIter->second;
 
             //Since we added it ourselves and it wasn't there before, lets reset it
-            compileTable[num_compile_entries].reset ();
+            newEntry.reset ();
 
             //Now set its physical register correctly
-            compileTable[num_compile_entries].setPhysicalReg (assocIter->second.getPhysicalReg ());
+            newEntry.setPhysicalReg (assocIter->second.getPhysicalReg ());
 
-            //Augment number of entries
-            num_compile_entries++;
+            //Add it to the global compileTable
+            compileTable.insert (newEntry);
         }
     }
 
@@ -559,7 +559,7 @@ static bool determineVirtualRegisterState (const AssociationTable &associations,
 
         //If we make it here it means we have not figured out the state of the VR
         ALOGI ("JIT_INFO: We failed to satisfy BB associations because we couldn't figure "
-                "out state of virtual register.");
+                "out state of virtual register v%d.", vR);
         SET_JIT_ERROR(kJitErrorBERegisterization);
         return false;
     }
@@ -664,11 +664,8 @@ static bool decideOnMismatchAction (const std::map<int, VirtualRegisterState> &p
             {
                 DEBUG_ASSOCIATION_MERGE (ALOGD (">> We need to move immediate into GP for v%d", vR));
 
-                //Technically we need to add it to set for which we need to do imm to reg for
-                //but since that is not implemented let's add it to sets which we need to store
-                //back and then reload.
-                actions.virtualRegistersToStore.insert (vR);
-                actions.virtualRegistersToLoad.insert (vR);
+                //Add it to set to do imm to reg move
+                actions.virtualRegistersImmToReg.insert (vR);
             }
             else
             {
@@ -842,7 +839,7 @@ static void initAssociationHelperTables (const AssociationTable &associationsToU
 
     // Now go through current compile table to figure out what VRs are in
     // physical registers
-    for (int entry = 0; entry < num_compile_entries; entry++)
+    for (int entry = 0; entry < compileTable.size (); entry++)
     {
         if (isVirtualReg(compileTable[entry].physicalType)
                 && compileTable[entry].physicalReg != PhysicalReg_Null)
@@ -879,7 +876,7 @@ static bool writeBackVirtualRegistersToMemory (const std::set<int> &virtualRegis
         int vR = *setOpIter;
 
         //Now look through compile table to find the matching entry
-        for (int entry = 0; entry < num_compile_entries; entry++)
+        for (int entry = 0; entry < compileTable.size (); entry++)
         {
             CompileTableEntry &compileEntry = compileTable[entry];
 
@@ -1027,46 +1024,48 @@ static bool findRegistersToMove (const std::set<int> &virtualRegistersRegToReg,
  * @return whether or not the move registers succeeds
  */
 static bool moveRegisters (std::map<PhysicalReg, PhysicalReg> &regToRegMoves,
-                           std::set<PhysicalReg> &scratchRegs,
-                           std::map<int, PhysicalReg> &currentVRToPhysicalReg) {
-
+                           const std::set<PhysicalReg> &scratchRegs,
+                           const std::map<int, PhysicalReg> &currentVRToPhysicalReg)
+{
     std::map<PhysicalReg, PhysicalReg>::const_iterator regToRegIter;
-    //Go through each register to register request, inverse order
-    for (regToRegIter = regToRegMoves.begin();
-            regToRegIter != regToRegMoves.end(); regToRegIter++) {
 
+    //Go through each register to register request
+    for (regToRegIter = regToRegMoves.begin (); regToRegIter != regToRegMoves.end (); regToRegIter++)
+    {
         std::vector<PhysicalReg> toBeMoved;
         std::vector<PhysicalReg>::reverse_iterator moveIter;
-        bool cycleFound = false;
-        bool useMemoryForSwap = false;
         PhysicalReg source = regToRegIter->first;
         PhysicalReg dest = regToRegIter->second;
 
+        // Paranoid because we cannot move to null register
         if (dest == PhysicalReg_Null)
         {
             continue;
         }
 
-        if (regToRegMoves.count(source) > 1) {
+        if (regToRegMoves.count (source) > 1)
+        {
             ALOGI ("JIT_INFO: We have the same physical register as source "
                     "multiple times.");
             SET_JIT_ERROR(kJitErrorBERegisterization);
             return false;
         }
 
-        DEBUG_ASSOCIATION_MERGE(ALOGD("We want to move from %s to %s",
-                physicalRegToString(source), physicalRegToString(dest)));
+        DEBUG_ASSOCIATION_MERGE (ALOGD ("We want to move from %s to %s", physicalRegToString(source),
+                physicalRegToString(dest)));
 
-        toBeMoved.push_back(source);
-        toBeMoved.push_back(dest);
+        toBeMoved.push_back (source);
+        toBeMoved.push_back (dest);
+
+        // We eagerly assume that we won't find a cycle but we want to do something special if we do
+        bool cycleFound = false;
 
         // Now look through the rest of the moves to see if anyone
         // is going to replace source register
         std::map<PhysicalReg, PhysicalReg>::const_iterator regToRegFinder;
-        for (regToRegFinder = regToRegMoves.find(dest);
-                regToRegFinder != regToRegMoves.end(); regToRegFinder =
-                        regToRegMoves.find(regToRegFinder->second)) {
-
+        for (regToRegFinder = regToRegMoves.find (dest); regToRegFinder != regToRegMoves.end (); regToRegFinder =
+                regToRegMoves.find (regToRegFinder->second))
+        {
 
             // If we already have this register in the toBeMoved list,
             // it means we found a cycle. Instead of doing a find,
@@ -1074,48 +1073,58 @@ static bool moveRegisters (std::map<PhysicalReg, PhysicalReg> &regToRegMoves,
             // better. However, PhysicalReg enum contains invalid
             // physical registers so it is hard to decide which ones we
             // need to keep track of.
-            if (std::find(toBeMoved.begin(), toBeMoved.end(),
-                    regToRegFinder->second) != toBeMoved.end()) {
+            if (std::find (toBeMoved.begin (), toBeMoved.end (), regToRegFinder->second) != toBeMoved.end ())
+            {
                 cycleFound = true;
                 // Save this because we will need to move value into it
-                toBeMoved.push_back(regToRegFinder->second);
+                toBeMoved.push_back (regToRegFinder->second);
                 break;
             }
 
             // Save this because we will need to move value into it
-            toBeMoved.push_back(regToRegFinder->second);
+            toBeMoved.push_back (regToRegFinder->second);
         }
 
-        if (cycleFound) {
+        // If we have a cycle, we might need to use memory for doing the swap
+        bool useMemoryForSwap = false;
+
+        if (cycleFound == true)
+        {
             // If we find a cycle, the last value in the toBeMoved list
             // is the register that caused cycle. Lets pop it off
             // for now so we can use std::replace below but we will
             // reinsert it
-            PhysicalReg cycleCause = toBeMoved.back();
-            toBeMoved.pop_back();
+            PhysicalReg cycleCause = toBeMoved.back ();
+            toBeMoved.pop_back ();
 
             // Lets hope we have a scratch register to break the cycle
-            PhysicalReg scratch = getScratch(scratchRegs,
-                    getTypeOfRegister(source));
+            PhysicalReg scratch = getScratch (scratchRegs, getTypeOfRegister (source));
 
-            if (scratch != PhysicalReg_Null) {
-                // We found a scratch register
-                // If we had C->A B->C A->B
-                // Now we will have A->T C->A B->C T->B
+            if (scratch != PhysicalReg_Null)
+            {
+                // When we get here we found a scratch register
+
+                // Thus if we had C->A B->C A->B
+                // Now we want to have A->T C->A B->C T->B
 
-                // Which means that toBeMoved contained A B C and now we
+                // Which means that toBeMoved contains A B C when we get here and now we
                 // want it to have T B C A T
 
-                std::replace(toBeMoved.begin(), toBeMoved.end(), cycleCause,
-                        scratch);
-                toBeMoved.push_back(cycleCause);
-                toBeMoved.push_back(scratch);
-            } else {
+                // Replace A with T so we have T B C instead of A B C
+                std::replace (toBeMoved.begin (), toBeMoved.end (), cycleCause, scratch);
+
+                // Now add A so we have T B C A
+                toBeMoved.push_back (cycleCause);
+
+                // Now add T so we have T B C A T
+                toBeMoved.push_back (scratch);
+            }
+            else
+            {
                 useMemoryForSwap = true;
             }
         }
 
-        //TODO We should be able to swap without register
         if (useMemoryForSwap == true)
         {
             ALOGI ("JIT_INFO: We have no scratch registers so we must use memory for swap");
@@ -1125,9 +1134,8 @@ static bool moveRegisters (std::map<PhysicalReg, PhysicalReg> &regToRegMoves,
 
         // Now handle the actual reg to reg moves
         PhysicalReg tmpIter = PhysicalReg_Null;
-        for (moveIter = toBeMoved.rbegin();
-                moveIter != toBeMoved.rend()
-                        ; moveIter++) {
+        for (moveIter = toBeMoved.rbegin (); moveIter != toBeMoved.rend (); moveIter++)
+        {
             PhysicalReg dest = tmpIter;
             PhysicalReg source = *(moveIter);
 
@@ -1135,56 +1143,39 @@ static bool moveRegisters (std::map<PhysicalReg, PhysicalReg> &regToRegMoves,
             tmpIter = source;
 
             //If destination is null, next iteration
-            if (dest == PhysicalReg_Null) {
+            if (dest == PhysicalReg_Null)
+            {
                 continue;
             }
 
-            if ((getTypeOfRegister(source) != LowOpndRegType_gp
-                    && getTypeOfRegister(source) != LowOpndRegType_xmm)
-                    || (getTypeOfRegister(dest) != LowOpndRegType_gp
-                            && getTypeOfRegister(dest) != LowOpndRegType_xmm)) {
-                ALOGI ("JIT_INFO: We cannot handle association table merge for "
-                        "anything but xmm and gp registers");
-                SET_JIT_ERROR(kJitErrorBERegisterization);
-                return false;
-            }
-
-            if (getTypeOfRegister(source) != getTypeOfRegister(dest)) {
-                // They are different types of registers and we currently
-                // cannot handle moves between different types
-                ALOGI ("JIT_INFO: We cannot transfer from GP reg to XMM and "
-                        "vice versa");
-                SET_JIT_ERROR(kJitErrorBERegisterization);
-                return false;
-            }
-
-            DEBUG_ASSOCIATION_MERGE(ALOGD("Moving %s to %s",
-                    physicalRegToString(source),
-                    physicalRegToString(dest)));
+            DEBUG_ASSOCIATION_MERGE(ALOGD("Moving %s to %s", physicalRegToString(source), physicalRegToString(dest)));
 
             OpndSize regSize = OpndSize_32;
 
-            //If we have an xmm to xmm move, the operand size is 64-bits
+            //If we have an xmm to xmm move, then we set the operand size to 64-bits. The reason
+            //for this is because move_reg_to_reg function expects this size so it can use a MOVQ.
+            //We may be able to get away with doing a MOVD if we have a 32-bit FP loaded with a MOVSS,
+            //but we don't have the API for it and we would need additional logic here.
             if (source >= PhysicalReg_StartOfXmmMarker && source <= PhysicalReg_EndOfXmmMarker)
             {
                 regSize = OpndSize_64;
             }
 
             // Do the actual reg to reg move
-            move_reg_to_reg_noalloc(regSize, source, true, dest,
-                    true);
+            move_reg_to_reg_noalloc (regSize, source, true, dest, true);
 
             // We have moved from reg to reg, but we must also update the
             // entry in the compile table
             std::map<int, PhysicalReg>::const_iterator currentVRToRegIter;
-            for (currentVRToRegIter = currentVRToPhysicalReg.begin();
-                    currentVRToRegIter != currentVRToPhysicalReg.end();
-                    currentVRToRegIter++) {
+            for (currentVRToRegIter = currentVRToPhysicalReg.begin ();
+                    currentVRToRegIter != currentVRToPhysicalReg.end (); currentVRToRegIter++)
+            {
                 int VR = currentVRToRegIter->first;
                 int oldReg = currentVRToRegIter->second;
 
-                if (oldReg == source) {
-                    updatePhysicalRegForVR(VR, source, dest);
+                if (oldReg == source)
+                {
+                    updatePhysicalRegForVR (VR, source, dest);
                 }
             }
 
@@ -1193,8 +1184,7 @@ static bool moveRegisters (std::map<PhysicalReg, PhysicalReg> &regToRegMoves,
         }
     }
 
-    // Since we update the physical registers for some of the VRs
-    // lets sync up register usage with compile table
+    // Since we update the physical registers for some of the VRs lets sync up register usage with compile table
     syncAllRegs();
 
     //Report success
@@ -1203,13 +1193,13 @@ static bool moveRegisters (std::map<PhysicalReg, PhysicalReg> &regToRegMoves,
 
 /**
  * @brief Load virtual registers to child's physical registers requests
- * @param associationsToUse the association table for the child at code generation entrance
  * @param virtualRegistersToLoad Set of virtual registers we need to load into physical registers.
+ * @param associationsToUse the association table for the child at code generation entrance
  * @param childVRToPhysicalReg the child map of Virtual Register to physical register at start of code generation
  * @return whether or not the function succeeds
  */
-static bool loadVirtualRegistersForChild (const AssociationTable &associationsToUse,
-                                          const std::set<int> &virtualRegistersToLoad,
+static bool loadVirtualRegistersForChild (const std::set<int> &virtualRegistersToLoad,
+                                          const AssociationTable &associationsToUse,
                                           const std::map<int, PhysicalReg> &childVRToPhysicalReg)
 {
     std::set<int>::const_iterator setOpIter;
@@ -1244,8 +1234,7 @@ static bool loadVirtualRegistersForChild (const AssociationTable &associationsTo
             continue;
         }
 
-        LowOpndRegType type = LowOpndRegType_invalid;
-        OpndSize size = OpndSize_Null;
+        const CompileTableEntry *childCompileEntry = 0;
 
         // Look through child's association entries to find the type of the VR
         // so we can load it properly into the physical register
@@ -1256,58 +1245,59 @@ static bool loadVirtualRegistersForChild (const AssociationTable &associationsTo
 
             if (compileEntry.getPhysicalReg () == targetReg)
             {
-                type = compileEntry.getPhysicalType ();
-                size = compileEntry.getSize ();
+                //We found the proper entry so let's get some information from it
+                childCompileEntry = &compileEntry;
+                break;
             }
         }
 
-        assert (type != LowOpndRegType_invalid);
-        assert (size != OpndSize_Null);
-
-        // If we are loading wide VR, lets do a sanity check that high order
-        // bits are in memory
-        if (type == LowOpndRegType_xmm) {
-            // Lets look in the table for the high order VR. If we cannot
-            // find it, then lets assume it is in memory
-            if (searchMemTable(VR + 1) >= 0) {
-                // We only care about the 32-bit that is high order. It must be
-                // in memory before we load it in xmm
-                if (isInMemory(VR + 1, OpndSize_32) == false) {
-                    ALOGI ("JIT_INFO: We are loading wide v%d but high order "
-                            "bits are not in memory!", VR);
-                    SET_JIT_ERROR(kJitErrorBERegisterization);
-                    return false;
-                }
-            }
-        }
+        //Paranoid
+        assert (childCompileEntry != 0);
+        assert (childCompileEntry->isVirtualReg () == true);
+
+        //Get the physical type
+        LowOpndRegType type = childCompileEntry->getPhysicalType ();
 
-        DEBUG_ASSOCIATION_MERGE(ALOGD("Loading v%d to %s",
-                VR, physicalRegToString(targetReg)));
+        DEBUG_ASSOCIATION_MERGE (ALOGD ("Loading v%d to %s", VR, physicalRegToString(targetReg)));
 
         // Load VR into the target physical register
-        if (type == LowOpndRegType_ss) {
-            move_ss_mem_to_reg_noalloc(4 * VR, PhysicalReg_FP, true,
-                    MemoryAccess_VR, VR, targetReg, true);
-        } else {
-            get_virtual_reg_noalloc(VR, size, targetReg, true);
+        if (type == LowOpndRegType_ss)
+        {
+            move_ss_mem_to_reg_noalloc (4 * VR, PhysicalReg_FP, true, MemoryAccess_VR, VR, targetReg, true);
+        }
+        else
+        {
+            OpndSize size = childCompileEntry->getSize ();
+            get_virtual_reg_noalloc (VR, size, targetReg, true);
         }
 
-        int entry;
-        for (entry = 0; entry < num_compile_entries; entry++)
+        //Look for the entry to update in compile table
+        CompileTable::iterator entryToUpdate = compileTable.findVirtualRegister (VR, type);
+
+        if (entryToUpdate != compileTable.end ())
         {
-            if (compileTable[entry].isVirtualReg () == true && compileTable[entry].getRegisterNumber () == VR)
-            {
-                compileTable[entry].setPhysicalReg (targetReg);
-                break;
-            }
+            //We found a matching entry so simply update its physical register
+            entryToUpdate->setPhysicalReg (targetReg);
         }
+        else
+        {
+            //If we were not able to find an entry, then we can just copy it from child's association table
 
-        // TODO We must handle case when we don't have entry in the compile table
-        if (entry == num_compile_entries) {
-            ALOGI ("JIT_INFO: We are not handling properly when we don't have "
-                    "entry in compile table");
-            SET_JIT_ERROR(kJitErrorRegAllocFailed);
-            return false;
+            //Make a copy of new entry
+            CompileTableEntry newEntry = (*childCompileEntry);
+
+            //Since we copied it over, let's reset it
+            newEntry.reset ();
+
+            //Make sure that the physical register is set
+            newEntry.setPhysicalReg (targetReg);
+
+            //We now copy into the compile table
+            compileTable.insert (newEntry);
+
+            //Since we just loaded it from memory, we keep it marked as being in memory and add it to the
+            //memory table in order to keep track of it.
+            addToMemVRTable (newEntry.regNum, true);
         }
     }
 
@@ -1318,6 +1308,89 @@ static bool loadVirtualRegistersForChild (const AssociationTable &associationsTo
     return true;
 }
 
+/**
+ * @brief Moves constant virtual registers values into physical registers.
+ * @details The parent must believe VR is constant and child must want it in physical register.
+ * @param immToRegMoves The virtual registers whose constant value must be moved to physical register.
+ * @param childVRToPhysicalReg Mapping between child virtual register and the physical register they are in.
+ * @return Returns true if successfully moves all immediates into physical registers. Otherwise it sets
+ * error and returns false.
+ */
+static bool moveImmediates (const std::set<int> &immToRegMoves,
+                            const std::map<int, PhysicalReg> &childVRToPhysicalReg)
+{
+    std::set<int>::const_iterator setOpIter;
+
+    //Now walk through the constant VRs we need to move to physical registers
+    for (setOpIter = immToRegMoves.begin (); setOpIter != immToRegMoves.end (); setOpIter++)
+    {
+        int vR = *setOpIter;
+
+        //We can only handle immediate to GP moves so we can preset the type
+        LowOpndRegType type = LowOpndRegType_gp;
+        OpndSize size = getRegSize (static_cast<int> (LowOpndRegType_gp));
+
+        //Make space for constant value
+        int constantValue;
+
+        //We want to get the constant value so we check if virtual register is constant.
+        //Since we just care to do immediate to GP register move, we pass only enough space
+        //for non-wide VR.
+        if (isVirtualRegConstant (vR, type, &constantValue) == VR_IS_NOT_CONSTANT)
+        {
+            ALOGI ("JIT_INFO: We decided that we need to do an imm to reg move but now VR is no longer constant.");
+            SET_JIT_ERROR (kJitErrorBERegisterization);
+            return false;
+        }
+
+        //Look to see if we have a physical register for this VR
+        std::map<int, PhysicalReg>::const_iterator findRegIter;
+        findRegIter = childVRToPhysicalReg.find (vR);
+
+        //This should never happen
+        if (findRegIter == childVRToPhysicalReg.end ())
+        {
+            ALOGI ("JIT_INFO: We decided that we need to do an imm to reg move but we cannot find register.");
+            SET_JIT_ERROR (kJitErrorBERegisterization);
+            return false;
+        }
+
+        PhysicalReg targetReg = findRegIter->second;
+
+        //Paranoid because we only support GP moves
+        assert (targetReg >= PhysicalReg_StartOfGPMarker && targetReg <= PhysicalReg_EndOfGPMarker);
+
+        //Do the actual move now
+        move_imm_to_reg_noalloc (size, constantValue, targetReg, true);
+
+        //Since we have it in physical register, lets invalidate its constantness
+        setVRToNonConst (vR, size);
+
+        //Look for the entry to update in compile table
+        CompileTable::iterator entryToUpdate = compileTable.findVirtualRegister (vR, type);
+
+        if (entryToUpdate != compileTable.end ())
+        {
+            //We found a matching entry so simply update its physical register
+            entryToUpdate->setPhysicalReg (targetReg);
+        }
+        else
+        {
+            //Since we don't have an entry already we can make one right now
+            CompileTableEntry newEntry (vR, type, LowOpndRegType_virtual);
+
+            //We now copy into the compile table
+            compileTable.insert (newEntry);
+
+            //If the constant was already marked as being in memory, then our VR is still technically
+            //in memory and thus we don't need to update its in memory state right now
+        }
+    }
+
+    //Report success
+    return true;
+}
+
 bool AssociationTable::satisfyBBAssociations (BasicBlock_O1 * parent,
         BasicBlock_O1 * child, bool isBackward)
 {
@@ -1383,18 +1456,25 @@ bool AssociationTable::satisfyBBAssociations (BasicBlock_O1 * parent,
     }
 
     // 5) Load any VRs we believe is in memory because child wants it in physical register
-    if (loadVirtualRegistersForChild (childAssociations, actions.virtualRegistersToLoad, childVRToPhysicalReg) == false)
+    if (loadVirtualRegistersForChild (actions.virtualRegistersToLoad, childAssociations, childVRToPhysicalReg) == false)
     {
         //If moveToChildPhysical fails, we bail too
         return false;
     }
 
-    //TODO Add function to deal with moving immediate to register
+    // 6) Now handle any immediate to GP register moves
+    if (moveImmediates (actions.virtualRegistersImmToReg, childVRToPhysicalReg) == false)
+    {
+        //If move immediates fails it will set error message. We simply propagate it now.
+        return false;
+    }
 
+    //If we make it here, everything went okay so we report success
     return true;
 }
 
-bool AssociationTable::handleSpillRequestsFromME(BasicBlock_O1 * bb) {
+bool AssociationTable::handleSpillRequestsFromME (BasicBlock_O1 *bb)
+{
     //Initialize empty set of VRs to write back
     std::set<int> virtualRegisterToWriteBack;
 
@@ -1423,16 +1503,17 @@ bool AssociationTable::handleSpillRequestsFromME(BasicBlock_O1 * bb) {
  * we spill everything because those BBs are handled specially and are exit
  * points.
  */
-bool AssociationTable::createOrSyncTable(BasicBlock_O1 * bb, bool forFallthrough) {
+bool AssociationTable::createOrSyncTable (BasicBlock_O1 * bb, bool forFallthrough)
+{
     // Before we pass association tables, lets handle spill requests from ME
     // so we don't pass anything useless for associations
-    if (handleSpillRequestsFromME(bb) == false) {
+    if (handleSpillRequestsFromME (bb) == false)
+    {
         return false;
     }
 
     //Get child depending on the forFallthrough boolean
-    BasicBlock_O1 * child = reinterpret_cast<BasicBlock_O1 *>(
-            forFallthrough ? bb->fallThrough : bb->taken);
+    BasicBlock_O1 * child = reinterpret_cast<BasicBlock_O1 *> (forFallthrough ? bb->fallThrough : bb->taken);
 
     //If there is a child
     if (child != NULL) {
@@ -1440,24 +1521,28 @@ bool AssociationTable::createOrSyncTable(BasicBlock_O1 * bb, bool forFallthrough
         //If it is not a dalvik code and it's not prebackward block,
         //then write back and free all registers because we might
         //be exiting to interpreter.
-        if (child->blockType != kDalvikByteCode
-                && child->blockType != kPreBackwardBlock) {
+        if (child->blockType != kDalvikByteCode && child->blockType != kPreBackwardBlock)
+        {
             freeReg (true);
         }
-        else {
-            if (child->associationTable.hasBeenFinalized() == false) {
+        else
+        {
+            if (child->associationTable.hasBeenFinalized () == false)
+            {
                 // If the child's association table has not been finalized then we can
                 // update it now. However, if we don't have any MIRs in this BB,
                 // it means the compile table has not been updated and thus we can
                 // just copy associations
-                if (syncAssociationsWithCompileTable(
-                            child->associationTable) == false) {
+                if (syncAssociationsWithCompileTable (child->associationTable) == false)
+                {
                     return false;
                 }
             }
-            else {
+            else
+            {
                 //Otherwise, let's satisfy the associations for the child
-                if (satisfyBBAssociations(bb, child) == false) {
+                if (satisfyBBAssociations (bb, child) == false)
+                {
                     return false;
                 }
             }
diff --git a/vm/compiler/codegen/x86/libenc/enc_wrapper.cpp b/vm/compiler/codegen/x86/libenc/enc_wrapper.cpp
index a537bc6..aa3d882 100644
--- a/vm/compiler/codegen/x86/libenc/enc_wrapper.cpp
+++ b/vm/compiler/codegen/x86/libenc/enc_wrapper.cpp
@@ -683,11 +683,6 @@ static const char * ScratchRegString[] = { "scratch1", "scratch2", "scratch3",
         "scratch4", "scratch5", "scratch6", "scratch7", "scratch8", "scratch9",
         "scratch10" };
 
-/**
- * @brief Glue register char* counterparts
- */
-static const char * GlueRegString[] = { "glue-dvmdex", "glue" };
-
 extern "C" ENCODER_DECLARE_EXPORT
 /**
  * @brief Transform a physical register into its char* counterpart
@@ -700,8 +695,6 @@ const char * physicalRegToString(PhysicalReg reg)
         return PhysicalRegString[reg];
     } else if (reg >= PhysicalReg_SCRATCH_1 && reg <= PhysicalReg_SCRATCH_10) {
         return ScratchRegString[reg - PhysicalReg_SCRATCH_1];
-    } else if (reg >= PhysicalReg_GLUE_DVMDEX && reg <= PhysicalReg_GLUE) {
-        return GlueRegString[reg - PhysicalReg_GLUE_DVMDEX];
     } else if (reg == PhysicalReg_Null) {
         return "null";
     } else {
diff --git a/vm/compiler/codegen/x86/libenc/enc_wrapper.h b/vm/compiler/codegen/x86/libenc/enc_wrapper.h
index 47d6117..ba50c13 100644
--- a/vm/compiler/codegen/x86/libenc/enc_wrapper.h
+++ b/vm/compiler/codegen/x86/libenc/enc_wrapper.h
@@ -48,8 +48,9 @@ typedef enum PhysicalReg {
   PhysicalReg_SCRATCH_1 = 100, PhysicalReg_SCRATCH_2, PhysicalReg_SCRATCH_3, PhysicalReg_SCRATCH_4,
   PhysicalReg_SCRATCH_5, PhysicalReg_SCRATCH_6, PhysicalReg_SCRATCH_7, PhysicalReg_SCRATCH_8,
   PhysicalReg_SCRATCH_9, PhysicalReg_SCRATCH_10,
-  PhysicalReg_GLUE_DVMDEX = 900,
-  PhysicalReg_GLUE = 901
+
+  //This should be the last entry:
+  PhysicalReg_Last
 } PhysicalReg;
 
 typedef enum Reg_No {
@@ -160,21 +161,25 @@ typedef enum InstrPrefix {
     prefix_gs                       = 0x65
 } InstrPrefix;
 
-//last 2 bits: decide xmm, gp, fs
-//virtual, scratch, temp, hard match with ncg_o1_data.h
-typedef enum LowOpndRegType {
-  LowOpndRegType_gp = 0,
-  LowOpndRegType_fs = 1,
-  LowOpndRegType_xmm = 2,
-  LowOpndRegType_fs_s = 3,
-  LowOpndRegType_ss = 4,
-  LowOpndRegType_scratch = 8, //used by NCG O1
-  LowOpndRegType_temp = 16,
-  LowOpndRegType_hard = 32,   //NCG O1
-  LowOpndRegType_virtual = 64, //used by NCG O1
-  LowOpndRegType_glue = 128,
-  LowOpndRegType_invalid = 256, //Invalid type, used by NCG O1
-} LowOpndRegType;
+enum LowOpndRegType
+{
+    LowOpndRegType_gp = 0,
+    LowOpndRegType_fs = 1,
+    LowOpndRegType_xmm = 2,
+    LowOpndRegType_fs_s = 3,
+    LowOpndRegType_ss = 4,
+    LowOpndRegType_invalid = 256,
+};
+
+enum LogicalRegType
+{
+    LogicalType_invalid = 0,
+    LowOpndRegType_scratch = 8,
+    LowOpndRegType_temp = 16,
+    LowOpndRegType_hard = 32,
+    LowOpndRegType_virtual = 64,
+    LowOpndRegType_glue = 128,
+};
 
 //if inline, separte enc_wrapper.cpp into two files, one of them is .inl
 //           enc_wrapper.cpp needs to handle both cases
-- 
1.7.4.1

