From 7e16e300278eb9cc3f94ae72f4326813db241f61 Mon Sep 17 00:00:00 2001
From: Razvan A Lupusoru <razvan.a.lupusoru@intel.com>
Date: Thu, 13 Jun 2013 14:04:41 -0700
Subject: Dalvik: Added and updated utility functions

BZ: 116027

InstrUtils.h:
- Added constructor for decoded instruction to ensure fields are initialized.

CompilerIR.h:
- Removed the MirRewriteRule struct because it was not needed.
- Added enum to differentiate when applying actions to basic block children.
- Added class to use when iterating through children blocks

Dataflow.cpp:
- Updated printer to include information about MIR flags.

InvariantRemoval.cpp:
LoopInformation.cpp:
AnalysisO1.cpp:
LowerO1.cpp:
InlineTransformation.cpp:
- Using the new flags helper to get flags from extended MIRs as well.

IntermediateRep.cpp:
- Added helper to create a block in growable list.
- Added helper to hide a basic block from CFG.
- Added helpers to replace child of a basic block.
- Updated define register rewriting to consider whether it needs to rewrite
uses when it updates the define.
- Implemented methods for iterating through children blocks.
- Added helper to move a chain of MIRs.
- Updated MIR insertion functions to ensure MIR is moved because otherwise
links are broken.

Utility.cpp:
- Updated printing of number of blocks to measure size of list of blocks directly
because during CFG building the value may not be correct.
- Renamed API function for getting next BB from bitvector and growable list.

Jit.cpp:
- Switch jumped over initialization of variables.

Category: device-enablement
Domain: AOSP-Dalvik-Compiler-CG; AOSP-Dalvik-Compiler-ME; AOSP-Dalvik-Interpreter; AOSP-Dalvik-Runtime
Origin: internal
Upstream-Candidate: no, needs rework

Change-Id: Id34d8d07b7bbc4151db9aaa12a417418aacc95d1
Orig-MCG-Change-Id: Iaf72e967633b03e2bbb061e1710db237bec20cd7
Signed-off-by: Razvan A Lupusoru <razvan.a.lupusoru@intel.com>
Signed-off-by: Qiming Shi <qiming.shi@intel.com>
Signed-off-by: Serguei Katkov <serguei.i.katkov@intel.com>
---
 libdex/InstrUtils.h                     |   14 +
 vm/compiler/BBOptimization.cpp          |   34 +-
 vm/compiler/Checks.cpp                  |    5 +-
 vm/compiler/Compiler.h                  |    2 +-
 vm/compiler/CompilerIR.h                |  200 +++++++----
 vm/compiler/Dataflow.cpp                |   58 +++-
 vm/compiler/Dataflow.h                  |    2 +
 vm/compiler/InlineTransformation.cpp    |    2 +-
 vm/compiler/IntermediateRep.cpp         |  601 +++++++++++++++++++++++++++----
 vm/compiler/InvariantRemoval.cpp        |   10 +-
 vm/compiler/LoopInformation.cpp         |   60 ++--
 vm/compiler/LoopOpt.cpp                 |    4 +-
 vm/compiler/Utility.cpp                 |   21 +-
 vm/compiler/codegen/x86/AnalysisO1.cpp  |   15 +-
 vm/compiler/codegen/x86/Lower.cpp       |    8 +-
 vm/compiler/codegen/x86/pcg/Utility.cpp |   11 +-
 vm/interp/Jit.cpp                       |   10 +-
 17 files changed, 812 insertions(+), 245 deletions(-)

diff --git a/libdex/InstrUtils.h b/libdex/InstrUtils.h
index 5af1664..3c4908a 100644
--- a/libdex/InstrUtils.h
+++ b/libdex/InstrUtils.h
@@ -127,6 +127,20 @@ extern InstructionInfoTables gDexOpcodeInfo;
  * Holds the contents of a decoded instruction.
  */
 struct DecodedInstruction {
+
+    /**
+     * @brief Constructor for initializing a decoded instruction
+     */
+    DecodedInstruction (void) :
+            vA (0), vB (0), vB_wide (0L), vC (0), opcode (OP_NOP), indexType (kIndexUnknown)
+    {
+        //Set all arguments to 0
+        for (int i = 0; i < 5; i++)
+        {
+            arg[i] = 0;
+        }
+    }
+
     u4      vA;
     u4      vB;
     u8      vB_wide;        /* for kFmt51l */
diff --git a/vm/compiler/BBOptimization.cpp b/vm/compiler/BBOptimization.cpp
index 1cf99d7..17e4f08 100644
--- a/vm/compiler/BBOptimization.cpp
+++ b/vm/compiler/BBOptimization.cpp
@@ -179,8 +179,8 @@ static void insertPreLoopHeader (CompilationUnit *cUnit, LoopInformation *info,
 
     BitVectorIterator bvIterator;
     dvmBitVectorIteratorInit(entry->predecessors, &bvIterator);
-    for (BasicBlock *predBB = getNextBasicBlockViaBitVector (bvIterator, cUnit); predBB != 0;
-                     predBB = getNextBasicBlockViaBitVector (bvIterator, cUnit))
+    for (BasicBlock *predBB = dvmCompilerGetNextBasicBlockViaBitVector (bvIterator, cUnit->blockList); predBB != 0;
+                     predBB = dvmCompilerGetNextBasicBlockViaBitVector (bvIterator, cUnit->blockList))
     {
         // If the type is a backward chaining cell or inserted pre-header, go to the next one
         if ((predBB->blockType != kChainingCellBackwardBranch) && (predBB != preHeader))
@@ -309,8 +309,8 @@ static bool testLoopHelper (CompilationUnit *cUnit, LoopInformation *info, void
     //Now check all the basic blocks in the loop
     BitVectorIterator bvIterator;
     dvmBitVectorIteratorInit (allBlocks, &bvIterator);
-    for (BasicBlock *loopBB = getNextBasicBlockViaBitVector (bvIterator, cUnit); loopBB != 0;
-                     loopBB = getNextBasicBlockViaBitVector (bvIterator, cUnit))
+    for (BasicBlock *loopBB = dvmCompilerGetNextBasicBlockViaBitVector (bvIterator, cUnit->blockList); loopBB != 0;
+                     loopBB = dvmCompilerGetNextBasicBlockViaBitVector (bvIterator, cUnit->blockList))
     {
         //Check if the block only connects to blocks in the loop, backward block, or loop exit block
         if ( (loopBB->taken != 0) &&
@@ -335,8 +335,8 @@ static bool testLoopHelper (CompilationUnit *cUnit, LoopInformation *info, void
 
     //Check if all backward blocks go to the entry
     dvmBitVectorIteratorInit (const_cast < BitVector* > (backwardBlocks), &bvIterator);
-    for (BasicBlock *backBB = getNextBasicBlockViaBitVector (bvIterator, cUnit); backBB != 0;
-                     backBB = getNextBasicBlockViaBitVector (bvIterator, cUnit))
+    for (BasicBlock *backBB = dvmCompilerGetNextBasicBlockViaBitVector (bvIterator, cUnit->blockList); backBB != 0;
+                     backBB = dvmCompilerGetNextBasicBlockViaBitVector (bvIterator, cUnit->blockList))
     {
         if (backBB->fallThrough != entry)
         {
@@ -459,8 +459,8 @@ static BasicBlock *handleTopLoop (CompilationUnit *cUnit, LoopInformation *info)
 
     // Collect all out coming to all exit blocks
     dvmBitVectorIteratorInit(notLoop, &bvIterator);
-    for (BasicBlock *bb = getNextBasicBlockViaBitVector (bvIterator, cUnit); bb != 0;
-                     bb = getNextBasicBlockViaBitVector (bvIterator, cUnit))
+    for (BasicBlock *bb = dvmCompilerGetNextBasicBlockViaBitVector (bvIterator, cUnit->blockList); bb != 0;
+                     bb = dvmCompilerGetNextBasicBlockViaBitVector (bvIterator, cUnit->blockList))
     {
         BitVector *swap = tmp;
         tmp = tmp1;
@@ -505,8 +505,9 @@ static BasicBlock *handleTopLoop (CompilationUnit *cUnit, LoopInformation *info)
 
         // Now all tail blocks should be re-directed to new loop tail block (old loop entry)
         dvmBitVectorIteratorInit(tailblocks, &bvIterator);
-        for (BasicBlock *tailblock = getNextBasicBlockViaBitVector (bvIterator, cUnit); tailblock != 0;
-                         tailblock = getNextBasicBlockViaBitVector (bvIterator, cUnit))
+        for (BasicBlock *tailblock = dvmCompilerGetNextBasicBlockViaBitVector (bvIterator, cUnit->blockList);
+                         tailblock != 0;
+                         tailblock = dvmCompilerGetNextBasicBlockViaBitVector (bvIterator, cUnit->blockList))
         {
             // Attach backedge to newBB
             if (tailblock->taken == entry)
@@ -549,8 +550,9 @@ bool dvmCompilerFormLoopWorker (CompilationUnit *cUnit, LoopInformation *info, v
 
     // For each tail block we should add a Backward Branch
     dvmBitVectorIteratorInit(info->getBackwardBranches (), &bvIterator);
-    for (BasicBlock *tailBlock = getNextBasicBlockViaBitVector (bvIterator, cUnit); tailBlock != 0;
-                     tailBlock = getNextBasicBlockViaBitVector (bvIterator, cUnit))
+    for (BasicBlock *tailBlock = dvmCompilerGetNextBasicBlockViaBitVector (bvIterator, cUnit->blockList);
+                     tailBlock != 0;
+                     tailBlock = dvmCompilerGetNextBasicBlockViaBitVector (bvIterator, cUnit->blockList))
     {
         BasicBlock *backward = dvmCompilerNewBBinCunit(cUnit, kChainingCellBackwardBranch);
         backward->startOffset = tailBlock->startOffset;
@@ -563,15 +565,15 @@ bool dvmCompilerFormLoopWorker (CompilationUnit *cUnit, LoopInformation *info, v
     BitVector *basicBlocks = info->getBasicBlocks ();
 
     dvmBitVectorIteratorInit(info->getExitLoops (), &bvIterator);
-    for (BasicBlock *notLoop = getNextBasicBlockViaBitVector (bvIterator, cUnit); notLoop != 0;
-                     notLoop = getNextBasicBlockViaBitVector (bvIterator, cUnit))
+    for (BasicBlock *notLoop = dvmCompilerGetNextBasicBlockViaBitVector (bvIterator, cUnit->blockList); notLoop != 0;
+                     notLoop = dvmCompilerGetNextBasicBlockViaBitVector (bvIterator, cUnit->blockList))
     {
         dvmIntersectBitVectors (tmp, notLoop->predecessors, basicBlocks);
 
         // Add Exit BB for found specific exit
         dvmBitVectorIteratorInit(tmp, &bvIterator2);
-        for (BasicBlock *out = getNextBasicBlockViaBitVector (bvIterator2, cUnit); out != 0;
-                         out = getNextBasicBlockViaBitVector (bvIterator2, cUnit))
+        for (BasicBlock *out = dvmCompilerGetNextBasicBlockViaBitVector (bvIterator2, cUnit->blockList); out != 0;
+                         out = dvmCompilerGetNextBasicBlockViaBitVector (bvIterator2, cUnit->blockList))
         {
             BasicBlock *exitBlock = dvmCompilerNewBBinCunit(cUnit, kDalvikByteCode);
             exitBlock->startOffset = out->startOffset;
diff --git a/vm/compiler/Checks.cpp b/vm/compiler/Checks.cpp
index a9e50fb..161aa8d 100644
--- a/vm/compiler/Checks.cpp
+++ b/vm/compiler/Checks.cpp
@@ -763,10 +763,7 @@ void walkBasicBlock (CompilationUnit *cUnit, SRemoveData *removeData, MIR *first
             list.push_back (mir);
         }
 
-        /* Skip extended MIR instructions */
-        if (dInsn->opcode >= kNumPackedOpcodes) continue;
-
-        int instrFlags = dexGetFlagsFromOpcode(dInsn->opcode);
+        int instrFlags = dvmCompilerGetOpcodeFlags (dInsn->opcode);
 
         /* Instruction is clean */
         if ((instrFlags & kInstrCanThrow) == 0) continue;
diff --git a/vm/compiler/Compiler.h b/vm/compiler/Compiler.h
index de89bdf..43222e3 100644
--- a/vm/compiler/Compiler.h
+++ b/vm/compiler/Compiler.h
@@ -301,7 +301,7 @@ MIR *dvmCompilerFindHighestMIRInColor (MIR *elem);
 MIR *dvmCompilerFindLowestMIRInColor (MIR *elem);
 
 /* Get the next BasicBlock from a BitVector */
-BasicBlock *getNextBasicBlockViaBitVector (BitVectorIterator &bvIterator, const CompilationUnit *cUnit);
+BasicBlock *dvmCompilerGetNextBasicBlockViaBitVector (BitVectorIterator &bvIterator, const GrowableList &blockList);
 
 /* Build the def use chains */
 bool dvmCompilerBuildDefUseChain (CompilationUnit *cUnit, BasicBlock *bb);
diff --git a/vm/compiler/CompilerIR.h b/vm/compiler/CompilerIR.h
index 6e6a8e2..b88b3df 100644
--- a/vm/compiler/CompilerIR.h
+++ b/vm/compiler/CompilerIR.h
@@ -209,6 +209,15 @@ typedef enum BlockListType {
     kSparseSwitch,
 } BlockListType;
 
+/**
+ * @brief Used to provide directives which refer to a BasicBlock's children.
+ */
+typedef enum ChildBlockType {
+    kChildTypeFallthrough,       //!< @brief Used for the fallthrough child
+    kChildTypeTaken,             //!< @brief Used for the taken child
+    kChildTypeSwitchOrException, //!< @brief Used whenever there are multiple children due to either exception or switch
+} ChildBlockType;
+
 typedef struct BasicBlock {
     int id;
     bool visited;
@@ -253,6 +262,53 @@ typedef struct SuccessorBlockInfo {
     int key;
 } SuccessorBlockInfo;
 
+/**
+ * @brief Used to iterate through the children of a basic block.
+ * @details If a child of basic block is updated, this iterator does not ensure to visit it
+ * if it already visited its location once.
+ */
+class ChildBlockIterator
+{
+public:
+    /**
+     * @brief Constructs a child iterator
+     * @param bb The basic whose children we need to iterate through.
+     */
+    ChildBlockIterator (BasicBlock *bb);
+
+    /**
+     * @brief Used to obtain a pointer to unvisited child
+     * @return Returns pointer to an unvisited child. When all children are visited it returns null.
+     */
+    BasicBlock **getNextChildPtr (void);
+
+private:
+    /**
+     * @brief Used to keep track of the basic block whose children we are visiting
+     */
+    BasicBlock *basicBlock;
+
+    /**
+     * @brief Whether we visited fallthrough child
+     */
+    bool visitedFallthrough;
+
+    /**
+     * @brief Whether we visited taken child
+     */
+    bool visitedTaken;
+
+    /**
+     * @brief Whether we have blocks to visit in the successor list
+     */
+    bool haveSuccessors;
+
+    /**
+     * @brief Used to iterate through the block's successor list
+     */
+    GrowableListIterator successorIter;
+};
+
 //Forward Declarations
 struct LoopAnalysis;
 class LoopInformation;
@@ -370,64 +426,32 @@ typedef struct CompilationUnit {
     std::map<int, int> *constantValues; // Constant values map using the ssa register as a key
 }CompilationUnit;
 
-/**
- * @brief Used for holding the rewrite rule for updating a MIR's operands.
- */
-class MirRewriteRule
-{
-public:
-    /**
-     * @brief Constructor
-     * @param mir The MIR to update
-     * @param oldVR The VR to rewrite
-     * @param newVR The VR to use as replacement after rewrite
-     */
-    MirRewriteRule (MIR * mir, int oldVR, int newVR) :
-            mir (mir), oldVR (oldVR), newVR (newVR)
-    {
-    }
-
-    /**
-     * @brief Returns the mir that needs updated.
-     */
-    MIR *getMir (void) const
-    {
-        return mir;
-    }
-
-    /**
-     * @brief Returns the VR to rewrite.
-     */
-    int getOldVR (void) const
-    {
-        return oldVR;
-    }
-
-    /**
-     * @brief Returns the VR to use as replacement after rewrite.
-     */
-    int getNewVR (void) const
-    {
-        return newVR;
-    }
-
-private:
-    MIR * mir;      //!< The MIR to update
-    int oldVR;      //!< The VR to rewrite
-    int newVR;      //!< The VR to use as replacement after rewrite.
-};
-
 #if defined(WITH_SELF_VERIFICATION)
 #define HEAP_ACCESS_SHADOW(_state) cUnit->heapMemOp = _state
 #else
 #define HEAP_ACCESS_SHADOW(_state)
 #endif
 
-BasicBlock *dvmCompilerNewBB(BBType blockType, int blockId);
+/**
+ * @brief Used to create a new basic block.
+ * @param blockType The block type to create.
+ * @param blockId The block id for this new block.
+ * @return Returns the newly created block.
+ */
+BasicBlock *dvmCompilerNewBB (BBType blockType, int blockId);
+
+/**
+ * @brief Creates a new block and adds its to the block list.
+ * @details If a cUnit block list is provided, this function does not ensure to update cUnit->numBlocks.
+ * @param blockList The block list to which we should add to.
+ * @param blockType The block type to create.
+ * @return Returns the newly created block.
+ */
+BasicBlock *dvmCompilerNewBBinList (GrowableList &blockList, BBType blockType);
 
 /**
  * @brief Allocates a new basic block and adds it to the compilation unit.
- * @details Automatically generates an id for the BB
+ * @details Automatically generates an id for the BB. It also ensures to update cUnit->numBlocks.
  * @param cUnit Compilation Unit
  * @param blockType Type of block we want to create
  * @return Returns the newly created BB
@@ -435,6 +459,14 @@ BasicBlock *dvmCompilerNewBB(BBType blockType, int blockId);
 BasicBlock *dvmCompilerNewBBinCunit (CompilationUnit *cUnit, BBType blockType);
 
 /**
+ * @brief Used to hide a basic block from block list. It ensures that all CFG links to this block are severed.
+ * @details Currently we don't have mechanism to remove from a growable list, so we fake that we remove it.
+ * @param blockList The block list from which to hide block.
+ * @param bb The basic block to hide.
+ */
+void dvmCompilerHideBasicBlock (GrowableList &blockList, BasicBlock *bb);
+
+/**
  * @brief Used for allocating a new MIR.
  * @return Returns the newly created MIR.
  */
@@ -446,7 +478,32 @@ void dvmCompilerAppendMIR(BasicBlock *bb, MIR *mir);
 
 void dvmCompilerPrependMIR(BasicBlock *bb, MIR *mir);
 
-void dvmCompilerInsertMIRAfter(BasicBlock *bb, MIR *currentMIR, MIR *newMIR);
+/**
+ * @brief Insert an MIR instruction before the specified MIR. If no MIR to insert before is provided, the
+ * insertion happens at beginning of block.
+ * @param bb the Basic Block where the insertion is to happen
+ * @param mirToInsertBefore the specified mir to insert before (if null, insertion happens at beginning of basic block)
+ * @param newMIR the mir to insert
+ */
+void dvmCompilerInsertMIRBefore (BasicBlock *bb, MIR *mirToInsertBefore, MIR *newMIR);
+
+/**
+ * @brief Insert an MIR instruction after the specified MIR. If no MIR to insert after is provided, the
+ * insertion happens at end of block.
+ * @param bb the Basic Block where the insertion is to happen
+ * @param mirToInsertAfter the specified mir to insert after (if null, insertion happens at end of basic block)
+ * @param newMIR the mir to insert
+ */
+void dvmCompilerInsertMIRAfter (BasicBlock *bb, MIR *mirToInsertAfter, MIR *newMIR);
+
+/**
+ * @brief Moves a chain of MIRs after mirToInsertAfter. If no MIR to insert after is provided, the
+ * insertion happens at end of block. All MIRs linked forward to mirChainStart are moved.
+ * @param bb the Basic Block where the insertion is to happen
+ * @param mirToInsertAfter the specified mir to insert after (if null, insertion happens at end of basic block)
+ * @param mirChainStart The beginning of the MIR chain to be moved
+ */
+void dvmCompilerMoveLinkedMIRsAfter (BasicBlock *bb, MIR *mirToInsertAfter, MIR *mirChainStart);
 
 void dvmCompilerAppendLIR(CompilationUnit *cUnit, LIR *lir);
 
@@ -469,6 +526,26 @@ void dvmCompilerAddInstructionsToBasicBlocks (CompilationUnit *cUnit, BitVector
 void dvmCompilerPrependInstructionsToBasicBlocks (CompilationUnit *cUnit, BitVector *basicBlocks,
         const std::vector<MIR *> &toAdd);
 
+/**
+ * @brief Used to replace one of the children of a block with a new child.
+ * @param newChild The new child for this basic block.
+ * @param parent The basic block whose child should be replaced.
+ * @param oldChild The child which should be replaced
+ * @return Returns whether replacing child succeeds.
+ */
+bool dvmCompilerReplaceChildBasicBlock (BasicBlock *newChild, BasicBlock *parent, BasicBlock *oldChild);
+
+/**
+ * @brief Used to replace one of the children of a block with a new child.
+ * @details Guaranteed to succeed if the child type is either fallthrough or taken.
+ * @param newChild The new child for this basic block.
+ * @param parent The basic block whose child should be replaced.
+ * @param childType The type of the child which should be replaced. Fallthrough replaced by default.
+ * @return Returns whether replacing child succeeds.
+ */
+bool dvmCompilerReplaceChildBasicBlock (BasicBlock *newChild, BasicBlock *parent, ChildBlockType childType =
+        kChildTypeFallthrough);
+
 /* Insert a BasicBlock between a parent and child */
 bool dvmCompilerInsertBasicBlockBetween (BasicBlock *newBlock, BasicBlock *parent, BasicBlock *child);
 
@@ -516,22 +593,14 @@ void dvmCompilerDumpCompilationUnit(CompilationUnit *cUnit);
 
 /**
  * @brief Used to rewrite a MIR's def register with a new register.
- * @details Also ensures to fix all of the uses of the def. This is guaranteed to
- * not rewrite unless it will succeed.
+ * @details This is guaranteed to not rewrite unless it will succeed.
  * @param mir the MIR to rewrite
  * @param oldVR the old VR that we want to rewrite
  * @param newVR the new VR we want to use
+ * @param shouldRewriteUses Since we are changing the def register, when this is set to true
+ * it will walk to the uses and change those to match the new register.
  * @return Returns true if successfully rewrote with the given rewrite rules.
- */bool dvmCompilerRewriteMirDef (MIR *mir, int oldVR, int newVR);
-
-/**
- * @brief Used to rewrite multiple MIRs' define register with a new register.
- * @details Also ensures to fix all of the uses of the def. This is guaranteed to
- * not rewrite unless it will succeed.
- * @param rewriteList List of rewrite rules which contains MIRs whose def
- * register must be rewritten.
- * @return Returns true if successfully rewrote with the given rewrite rules.
- */bool dvmCompilerRewriteMirDef (const std::vector<MirRewriteRule> &rewriteList);
+ */bool dvmCompilerRewriteMirDef (MIR *mir, int oldVR, int newVR, bool shouldRewriteUses = true);
 
 /**
  * @brief Rewrite the uses of a MIR.
@@ -543,4 +612,11 @@ void dvmCompilerDumpCompilationUnit(CompilationUnit *cUnit);
  */bool dvmCompilerRewriteMirUses (DecodedInstruction &dalvikInsn, int oldVR,
         int newVR);
 
+/**
+ * @brief Given a dalvik Opcode or an extended opcode, it returns the flags.
+ * @param opcode The opcode for which to get flags
+ * @return Returns the flags for the specified opcode.
+ */
+OpcodeFlags dvmCompilerGetOpcodeFlags (int opcode);
+
 #endif  // DALVIK_VM_COMPILER_IR_H_
diff --git a/vm/compiler/Dataflow.cpp b/vm/compiler/Dataflow.cpp
index ccd0661..973ad80 100644
--- a/vm/compiler/Dataflow.cpp
+++ b/vm/compiler/Dataflow.cpp
@@ -996,16 +996,59 @@ void dvmCompilerExtendedDisassembler (const CompilationUnit *cUnit,
     //If not an extended, we can just send it to whoever is best suited
     if (value < kMirOpFirst)
     {
+        char *decodedInstruction;
+
         if (cUnit != NULL && mir != NULL && mir->ssaRep != NULL)
         {
-            char *tmp = dvmCompilerFullDisassembler(cUnit, mir);
-            snprintf (buffer, len, "%s", tmp);
+            decodedInstruction = dvmCompilerFullDisassembler(cUnit, mir);
         }
         else
         {
-            char *tmp = dvmCompilerGetDalvikDisassembly(insn, NULL);
-            snprintf (buffer, len, "%s", tmp);
+            decodedInstruction = dvmCompilerGetDalvikDisassembly(insn, NULL);
+        }
+
+        assert (decodedInstruction != 0);
+
+        //We want to put a note about the inlining status
+        const char * inliningNote = "";
+        if ((mir->OptimizationFlags & MIR_INLINED) != 0)
+        {
+            inliningNote = " (no-op)";
+        }
+        else if ((mir->OptimizationFlags & MIR_INLINED_PRED) != 0)
+        {
+            inliningNote = " (prediction inline)";
         }
+        else if ((mir->OptimizationFlags & MIR_CALLEE) != 0)
+        {
+            inliningNote = " (inlined)";
+        }
+
+        //We would like to put a note as well in case of null/range check elimination
+        const char * checkEliminationNote = "";
+        if ( (mir->OptimizationFlags & MIR_IGNORE_NULL_CHECK) != 0
+                && (mir->OptimizationFlags & MIR_IGNORE_RANGE_CHECK) != 0 )
+        {
+            checkEliminationNote = " (N | B)";
+        }
+        else
+        {
+            if ((mir->OptimizationFlags & MIR_IGNORE_RANGE_CHECK) != 0)
+            {
+                checkEliminationNote = " (B)";
+            }
+            else
+            {
+                if ((mir->OptimizationFlags & MIR_IGNORE_NULL_CHECK)  != 0)
+                {
+                    checkEliminationNote = " (N)";
+                }
+            }
+        }
+
+        //Now actually put everything in the desired buffer
+        snprintf (buffer, len, "%s%s%s", decodedInstruction, checkEliminationNote, inliningNote);
+
         return;
     }
 
@@ -1114,13 +1157,12 @@ void dvmCompilerExtendedDisassembler (const CompilationUnit *cUnit,
             {
                 snprintf (buffer, len, "kMirOpCheckInlinePrediction: %s, Class %s",
                         getSSAName (cUnit, mir->dalvikInsn.vC, operand0),
-                        mir->meta.callsiteInfo->classDescriptor);
+                        mir->meta.callsiteInfo != 0 ? mir->meta.callsiteInfo->classDescriptor : "Unknown");
             }
             else
             {
-                snprintf (buffer, len, "kMirOpCheckInlinePrediction: v%d, Class %s",
-                        insn->vC,
-                        mir != NULL ? mir->meta.callsiteInfo->classDescriptor : "Unknown");
+                snprintf (buffer, len, "kMirOpCheckInlinePrediction: v%d, Class %s", insn->vC,
+                        mir != 0 && mir->meta.callsiteInfo != 0 ? mir->meta.callsiteInfo->classDescriptor : "Unknown");
             }
             break;
         case kMirOpRegisterize: {
diff --git a/vm/compiler/Dataflow.h b/vm/compiler/Dataflow.h
index 3581774..96817f9 100644
--- a/vm/compiler/Dataflow.h
+++ b/vm/compiler/Dataflow.h
@@ -104,6 +104,8 @@ typedef enum DataFlowAttributePos {
                                  DF_NULL_OBJECT_CHECK_2)
 
 #define DF_A_IS_REG             (DF_UA | DF_UA_WIDE | DF_DA | DF_DA_WIDE)
+#define DF_A_IS_USED_REG        (DF_UA | DF_UA_WIDE)
+#define DF_A_IS_DEFINED_REG     (DF_DA | DF_DA_WIDE)
 #define DF_B_IS_REG             (DF_UB | DF_UB_WIDE)
 #define DF_C_IS_REG             (DF_UC | DF_UC_WIDE)
 #define DF_IS_GETTER_OR_SETTER  (DF_IS_GETTER | DF_IS_SETTER)
diff --git a/vm/compiler/InlineTransformation.cpp b/vm/compiler/InlineTransformation.cpp
index d021362..bcf730b 100755
--- a/vm/compiler/InlineTransformation.cpp
+++ b/vm/compiler/InlineTransformation.cpp
@@ -387,7 +387,7 @@ static bool tryInlineVirtualCallsite(CompilationUnit *cUnit,
 static bool handleInliningHelper (CompilationUnit *cUnit, JitTranslationInfo *info, BasicBlock *bb, MIR *mir)
 {
     Opcode opcode = mir->dalvikInsn.opcode;
-    int flags = (int)dexGetFlagsFromOpcode(opcode);
+    int flags = dvmCompilerGetOpcodeFlags (opcode);
 
     /* No invoke - continue */
     if ((flags & kInstrInvoke) == 0)
diff --git a/vm/compiler/IntermediateRep.cpp b/vm/compiler/IntermediateRep.cpp
index f6eed01..f832af9 100644
--- a/vm/compiler/IntermediateRep.cpp
+++ b/vm/compiler/IntermediateRep.cpp
@@ -19,7 +19,27 @@
 #include "Dataflow.h"
 #include <map>
 
-/* Allocate a new basic block */
+/**
+ * @brief Used to replace child of basic block and update predecessors.
+ * @param newChild The new child for this basic block.
+ * @param parent The basic block whose child should be replaced.
+ * @param childPtr The pointer to old child block which needs to be updated with new child.
+ */
+static void replaceChild (BasicBlock *newChild, BasicBlock *parent, BasicBlock **childPtr)
+{
+    assert (childPtr != 0);
+
+    //Get the old child
+    BasicBlock *oldChild = *childPtr;
+
+    //Set the new child
+    *childPtr = newChild;
+
+    //Update the predecessors
+    dvmCompilerUpdatePredecessors (parent, oldChild, newChild);
+}
+
+/* Allocates a new basic block */
 BasicBlock *dvmCompilerNewBB(BBType blockType, int blockId)
 {
     //Call the backend, it might want to allocate the BasicBlock itself
@@ -40,18 +60,99 @@ BasicBlock *dvmCompilerNewBB(BBType blockType, int blockId)
     return bb;
 }
 
-/* Allocate a new basic block and add it to the compilation unit */
+/* Allocates a new basic block and adds it to the block list. Does not update cUnit's numBlocks. */
+BasicBlock *dvmCompilerNewBBinList (GrowableList &blockList, BBType blockType)
+{
+    //To create a unique id we get the size of the block list
+    int blockId = dvmGrowableListSize (&blockList);
+
+    //Create the new block
+    BasicBlock *newBlock = dvmCompilerNewBB (blockType, blockId);
+
+    //Add it to the block list
+    dvmInsertGrowableList (&blockList, (intptr_t) newBlock);
+
+    return newBlock;
+}
+
+/* Allocates a new basic block and adds it to the compilation unit */
 BasicBlock *dvmCompilerNewBBinCunit (CompilationUnit *cUnit, BBType blockType)
 {
-    // Create a new BB and assign it an id
-    BasicBlock *newBlock = dvmCompilerNewBB (blockType, cUnit->numBlocks++);
+    // Create a new BB in the cUnit's block list
+    BasicBlock *newBlock = dvmCompilerNewBBinList (cUnit->blockList, blockType);
 
-    // Once created, add it to the cUnit
-    dvmInsertGrowableList (&(cUnit->blockList), (intptr_t) newBlock);
+    //Update the number of blocks in cUnit
+    cUnit->numBlocks = dvmGrowableListSize (&(cUnit->blockList));
 
     return newBlock;
 }
 
+/* Used to hide a basic block from block list. It ensures that all CFG links to this block are severed */
+void dvmCompilerHideBasicBlock (GrowableList &blockList, BasicBlock *bbToHide)
+{
+    //Paranoid
+    if (bbToHide == 0)
+    {
+        return;
+    }
+
+    //First lets make it a dalvik bytecode block so it doesn't have any special meaning
+    bbToHide->blockType = kDalvikByteCode;
+
+    //Mark it as hidden
+    bbToHide->hidden = true;
+
+    //Detach it from its MIRs so we don't generate code for them. Also detached MIRs
+    //are updated to know that they no longer have a parent.
+    for (MIR *mir = bbToHide->firstMIRInsn; mir != 0; mir = mir->next)
+    {
+        mir->bb = 0;
+    }
+    bbToHide->firstMIRInsn = 0;
+    bbToHide->lastMIRInsn = 0;
+
+    BitVectorIterator bvIterator;
+    dvmBitVectorIteratorInit(bbToHide->predecessors, &bvIterator);
+
+    //Now go through its predecessors to detach it
+    for (BasicBlock *predBB = dvmCompilerGetNextBasicBlockViaBitVector (bvIterator, blockList);
+            predBB != 0;
+            predBB = dvmCompilerGetNextBasicBlockViaBitVector (bvIterator, blockList))
+    {
+        //Iterate through children of predecessor
+        ChildBlockIterator childIter (predBB);
+
+        for (BasicBlock **childPtr = childIter.getNextChildPtr ();
+                childPtr != 0;
+                childPtr = childIter.getNextChildPtr ())
+        {
+            //Get the child
+            BasicBlock *child = *childPtr;
+
+            //Paranoid
+            assert (child != 0);
+
+            //Is the child equal to the BB we are hiding
+            if (child == bbToHide)
+            {
+                //Replace child with null child
+                replaceChild (0, predBB, childPtr);
+            }
+        }
+    }
+
+    //Iterate through children of bb we are hiding
+    ChildBlockIterator successorChildIter (bbToHide);
+
+    for (BasicBlock **childPtr = successorChildIter.getNextChildPtr ();
+            childPtr != 0;
+            childPtr = successorChildIter.getNextChildPtr ())
+    {
+        //Replace child with null child
+        replaceChild (0, bbToHide, childPtr);
+    }
+}
+
 /* Allocate a new MIR */
 MIR *dvmCompilerNewMIR (void)
 {
@@ -66,6 +167,14 @@ MIR *dvmCompilerNewMIR (void)
 /* Insert an MIR instruction to the end of a basic block */
 void dvmCompilerAppendMIR(BasicBlock *bb, MIR *mir)
 {
+    //If this mir has a parent BB already, we need to remove it from there
+    if (mir->bb != 0)
+    {
+        bool removed = dvmCompilerRemoveMIR (mir);
+        (void) removed;
+        assert (removed == true);
+    }
+
     if (bb->firstMIRInsn == NULL) {
         assert(bb->lastMIRInsn == NULL);
         bb->lastMIRInsn = bb->firstMIRInsn = mir;
@@ -84,6 +193,14 @@ void dvmCompilerAppendMIR(BasicBlock *bb, MIR *mir)
 /* Insert an MIR instruction to the head of a basic block */
 void dvmCompilerPrependMIR(BasicBlock *bb, MIR *mir)
 {
+    //If this mir has a parent BB already, we need to remove it from there
+    if (mir->bb != 0)
+    {
+        bool removed = dvmCompilerRemoveMIR (mir);
+        (void) removed;
+        assert (removed == true);
+    }
+
     if (bb->firstMIRInsn == NULL) {
         assert(bb->lastMIRInsn == NULL);
         bb->lastMIRInsn = bb->firstMIRInsn = mir;
@@ -99,12 +216,85 @@ void dvmCompilerPrependMIR(BasicBlock *bb, MIR *mir)
     mir->bb = bb;
 }
 
+/* Insert an MIR instruction before the specified MIR */
+void dvmCompilerInsertMIRBefore (BasicBlock *bb, MIR *mirToInsertBefore, MIR *newMIR)
+{
+    //Paranoid
+    if (newMIR == 0)
+    {
+        //We have no work to do
+        return;
+    }
+
+    //If this mir has a parent BB already, we need to remove it from there
+    if (newMIR->bb != 0)
+    {
+        bool removed = dvmCompilerRemoveMIR (newMIR);
+        (void) removed;
+        assert (removed == true);
+    }
+
+    //If the mir to insert before is null, we insert at beginning of block
+    if (mirToInsertBefore == 0)
+    {
+        dvmCompilerPrependMIR (bb, newMIR);
+
+        //We have finished the work
+        return;
+    }
+
+    MIR *prevMIR = mirToInsertBefore->prev;
+
+    if (prevMIR != 0)
+    {
+        //We are inserting a new MIR after the previous one
+        prevMIR->next = newMIR;
+    }
+    else
+    {
+        //Current MIR was first in block but now we are inserting before it
+        bb->firstMIRInsn = newMIR;
+    }
+
+    prevMIR->next = newMIR;
+    newMIR->prev = prevMIR;
+    newMIR->next = mirToInsertBefore;
+    mirToInsertBefore->prev = newMIR;
+
+    //Set BB for mir
+    newMIR->bb = bb;
+}
+
 /* Insert an MIR instruction after the specified MIR */
-void dvmCompilerInsertMIRAfter(BasicBlock *bb, MIR *currentMIR, MIR *newMIR)
+void dvmCompilerInsertMIRAfter (BasicBlock *bb, MIR *mirToInsertAfter, MIR *newMIR)
 {
-    newMIR->prev = currentMIR;
-    newMIR->next = currentMIR->next;
-    currentMIR->next = newMIR;
+    //Paranoid
+    if (newMIR == 0)
+    {
+        //We have no work to do
+        return;
+    }
+
+    //If this mir has a parent BB already, we need to remove it from there
+    if (newMIR->bb != 0)
+    {
+        bool removed = dvmCompilerRemoveMIR (newMIR);
+        (void) removed;
+        assert (removed == true);
+    }
+
+    //If the mir to insert before is null, we insert at end of block
+    if (mirToInsertAfter == 0)
+    {
+        dvmCompilerAppendMIR (bb, newMIR);
+
+        //We have finished the work
+        return;
+    }
+
+    newMIR->next = mirToInsertAfter->next;
+    mirToInsertAfter->next = newMIR;
+    newMIR->prev = mirToInsertAfter;
 
     if (newMIR->next) {
         /* Is not the last MIR in the block */
@@ -118,6 +308,111 @@ void dvmCompilerInsertMIRAfter(BasicBlock *bb, MIR *currentMIR, MIR *newMIR)
     newMIR->bb = bb;
 }
 
+void dvmCompilerMoveLinkedMIRsAfter (BasicBlock *bb, MIR *mirToInsertAfter, MIR *mirChainStart)
+{
+    //Paranoid
+    if (mirChainStart == 0)
+    {
+        //We have no work to do
+        return;
+    }
+
+    //If we have a previous MIR, then we need to fix its links
+    if (mirChainStart->prev != 0)
+    {
+        MIR *prevMir = mirChainStart->prev;
+
+        //Paranoid
+        assert (prevMir->bb == mirChainStart->bb);
+
+        //Get the previous MIR's block
+        BasicBlock *prevBlock = prevMir->bb;
+
+        //The previous MIR becomes the last one in block since we are removing the rest
+        prevMir->next = 0;
+        prevBlock->lastMIRInsn = prevMir;
+    }
+    else
+    {
+        //We don't have a previous MIR so if the start has a BB, the chain start must be the first MIR
+        BasicBlock *mirChainBlock = mirChainStart->bb;
+
+        if (mirChainBlock != 0)
+        {
+            assert (mirChainBlock->firstMIRInsn == mirChainStart);
+
+            //We are removing from chain start so the new block doesn't have anymore instructions
+            mirChainBlock->firstMIRInsn = 0;
+            mirChainBlock->lastMIRInsn = 0;
+        }
+    }
+
+    //At this point we have removed the chain from its parent block if we needed to.
+    //Now go through each MIR to make it part of this new block and also to find lastMIR.
+
+    //We need to find the chain end so initialize it to the start until we start searching
+    MIR *mirChainEnd = mirChainStart;
+    while (true)
+    {
+        //Set up the new BB of this mir
+        mirChainEnd->bb = bb;
+
+        //If our current end does not have a next, then we truly have reached the end
+        if (mirChainEnd->next == 0)
+        {
+            break;
+        }
+        else
+        {
+            mirChainEnd = mirChainEnd->next;
+        }
+    }
+
+    //If we don't have a MIR to insert after, then it must be the case we want to insert to end of BB
+    if (mirToInsertAfter == 0)
+    {
+        //Check if we have a first MIR because if we don't we append to front
+        if (bb->firstMIRInsn == 0)
+        {
+            assert(bb->lastMIRInsn == 0);
+            bb->firstMIRInsn = mirChainStart;
+            mirChainStart->prev = 0;
+        }
+        else
+        {
+            bb->lastMIRInsn->next = mirChainStart;
+            mirChainStart->prev = bb->lastMIRInsn;
+        }
+
+        //The last instruction is the chain end
+        bb->lastMIRInsn = mirChainEnd;
+    }
+    else
+    {
+        //Paranoid
+        assert (mirToInsertAfter->bb == bb);
+
+        //Keep track of the next for the MIR we need to insert after
+        MIR *mirToInsertAfterNext = mirToInsertAfter->next;
+
+        //Now do the actual insertion
+        mirToInsertAfter->next = mirChainStart;
+        mirChainStart->prev = mirToInsertAfter;
+
+        //Check if we had a next so we can link it to the chain end
+        if (mirToInsertAfterNext == 0)
+        {
+            //The last instruction now is the chain end
+            bb->lastMIRInsn = mirChainEnd;
+        }
+        else
+        {
+            mirChainEnd->next = mirToInsertAfterNext;
+            mirToInsertAfterNext->prev = mirChainEnd;
+        }
+    }
+}
+
 /*
  * Append an LIR instruction to the LIR list maintained by a compilation
  * unit
@@ -169,14 +464,15 @@ void dvmCompilerInsertLIRAfter(LIR *currentLIR, LIR *newLIR)
 
 /*
  * @brief Remove a MIR using its internal BasicBlock pointer
- * @param mir MIR to be removed
+ * @param mir MIR to be removed (null allowed)
+ * @return Returns true if successfully removed.
  */
 bool dvmCompilerRemoveMIR (MIR *mir)
 {
     //Paranoid
     if (mir == 0)
     {
-        return 0;
+        return false;
     }
 
     //Call generic function
@@ -354,6 +650,68 @@ void dvmCompilerPrependInstructionsToBasicBlocks (CompilationUnit *cUnit, BitVec
     }
 }
 
+bool dvmCompilerReplaceChildBasicBlock (BasicBlock *newChild, BasicBlock *parent, BasicBlock *oldChild)
+{
+    //Parent must always be set
+    assert (parent != 0);
+
+    //If we don't have a child to replace then we cannot do anything
+    if (oldChild == 0)
+    {
+        return false;
+    }
+
+    //Assume we don't successfully replace child
+    bool replacedChild = false;
+
+    //Iterate through block's children
+    ChildBlockIterator childIter (parent);
+    for (BasicBlock **childPtr = childIter.getNextChildPtr(); childPtr != 0; childPtr = childIter.getNextChildPtr())
+    {
+        //Get the child
+        BasicBlock *child = *childPtr;
+
+        //If we have a match for replacement
+        if (child == oldChild)
+        {
+            replaceChild (newChild, parent, childPtr);
+
+            //We successfully replaced child
+            replacedChild = true;
+        }
+    }
+
+    return replacedChild;
+}
+
+bool dvmCompilerReplaceChildBasicBlock (BasicBlock *newChild, BasicBlock *parent, ChildBlockType childType)
+{
+    //Parent must always be set
+    assert (parent != 0);
+
+    BasicBlock **childPtr = 0;
+
+    //Decide which child we need to update
+    switch (childType)
+    {
+        case kChildTypeFallthrough:
+            childPtr = &(parent->fallThrough);
+            break;
+        case kChildTypeTaken:
+            childPtr = &(parent->taken);
+            break;
+        default:
+            ALOGD ("JIT_INFO: Unsupported child type %d in replacement of basic block children.", childType);
+            return false;
+    }
+
+    //Do the actual work
+    replaceChild (newChild, parent, childPtr);
+
+    //We have replaced child
+    return true;
+}
+
 bool dvmCompilerInsertBasicBlockBetween (BasicBlock *newBlock, BasicBlock *parent, BasicBlock *child)
 {
     //Paranoid
@@ -444,9 +802,6 @@ BasicBlock *dvmCompilerCopyBasicBlock (CompilationUnit *cUnit, const BasicBlock
         //Get a copy first
         MIR *copy = dvmCompilerCopyMIR (mir);
 
-        //Update the parent of the MIR
-        copy->bb = resultBB;
-
         //Append it
         dvmCompilerAppendMIR (resultBB, copy);
     }
@@ -738,13 +1093,14 @@ bool dvmCompilerRewriteMirUses (DecodedInstruction &dalvikInsn, int oldVR,
 
 /**
  * @brief Fixes the uses when the VR previously defined changed.
- * @param rewriteRules The rewrite rules for current update.
+ * @param oldVR the old VR that we want to rewrite
+ * @param newVR the new VR we want to use
  * @param chain The first link in chain of uses.
  * @param newDecodedInst Updated by function to contain the rewritten
  * instruction for each mir.
  * @return Returns true if all uses were rewritten correctly.
  */
-static bool rewriteUses (const MirRewriteRule &rewriteRules, SUsedChain *chain,
+static bool rewriteUses (int oldVR, int newVR, SUsedChain *chain,
         std::map<MIR *, DecodedInstruction> &newDecodedInst)
 {
     //Walk the chain
@@ -752,12 +1108,18 @@ static bool rewriteUses (const MirRewriteRule &rewriteRules, SUsedChain *chain,
     {
         MIR *mir = chain->mir;
 
+        //Paranoid
+        if (mir == 0)
+        {
+            //This should never happen but we skip it if we have no MIR to rewrite
+            continue;
+        }
+
         //Make a copy of the dalvik instruction that can be updated
         DecodedInstruction dalvikInsn = mir->dalvikInsn;
 
         //Call the rewrite helper function
-        bool res = dvmCompilerRewriteMirUses (dalvikInsn,
-                rewriteRules.getOldVR (), rewriteRules.getNewVR ());
+        bool res = dvmCompilerRewriteMirUses (dalvikInsn, oldVR, newVR);
 
         //If we failed, fail everything
         if (res == false)
@@ -774,70 +1136,49 @@ static bool rewriteUses (const MirRewriteRule &rewriteRules, SUsedChain *chain,
 }
 
 //Rewrite Mir for one instruction
-bool dvmCompilerRewriteMirDef (MIR *mir, int oldVR, int newVR)
-{
-    MirRewriteRule rewriteIt (mir, oldVR, newVR);
-
-    //Create vector
-    std::vector<MirRewriteRule> rewrites;
-    rewrites.push_back (rewriteIt);
-
-    //Call generic function
-    return dvmCompilerRewriteMirDef (rewrites);
-}
-
-
-bool dvmCompilerRewriteMirDef (const std::vector<MirRewriteRule> &rewriteList)
+bool dvmCompilerRewriteMirDef (MIR *mir, int oldVR, int newVR, bool shouldRewriteUses)
 {
     //Used to keep track of the rewritten instruction before we commit it
     std::map<MIR *, DecodedInstruction> newDecodedInst;
 
-    //Initialize iterator for our rewrite list
-    std::vector<MirRewriteRule>::const_iterator iter;
-
-    //Iterate through all of the MIRs we need to rewrite
-    for (iter = rewriteList.begin (); iter != rewriteList.end (); iter++)
-    {
-        const MirRewriteRule &rewrite = (*iter);
-
-        //Get the MIR to be rewritten
-        MIR *mir = rewrite.getMir ();
-
-        //Paranoid
-        assert (mir != 0);
+    //Paranoid
+    assert (mir != 0);
 
-        //Get a local copy of the decoded instruction
-        DecodedInstruction dalvikInsn = mir->dalvikInsn;
+    //Get a local copy of the decoded instruction
+    DecodedInstruction dalvikInsn = mir->dalvikInsn;
 
-        //Get dataflow flags
-        int dfAttributes = dvmCompilerDataFlowAttributes[dalvikInsn.opcode];
+    //Get dataflow flags
+    int dfAttributes = dvmCompilerDataFlowAttributes[dalvikInsn.opcode];
 
-        //Check to see if we have defs for this MIR
-        if ((dfAttributes & DF_HAS_DEFS) == 0)
-        {
-            //This function can only rewrite the defs
-            return false;
-        }
+    //Check to see if we have defs for this MIR
+    if ((dfAttributes & DF_HAS_DEFS) == 0)
+    {
+        //This function can only rewrite the defs
+        return false;
+    }
 
-        //Check to make sure that the define matches desired VR to replace
-        if (mir->dalvikInsn.vA != static_cast<u4> (rewrite.getOldVR ()))
-        {
-            return false;
-        }
+    //Check to make sure that the define matches desired VR to replace
+    if (mir->dalvikInsn.vA != static_cast<u4> (oldVR))
+    {
+        return false;
+    }
 
-        //Check if use overlaps the define
-        if ((dfAttributes & (DF_UA | DF_UA_WIDE)) != 0)
-        {
-            //We should be able to fix this scenario but for now reject it
-            return false;
-        }
+    //Check if use overlaps the define
+    if ((dfAttributes & (DF_UA | DF_UA_WIDE)) != 0)
+    {
+        //We should be able to fix this scenario but for now reject it
+        return false;
+    }
 
-        //Now that we know we are fine to do the replacement, let's do it
-        dalvikInsn.vA = static_cast<u4> (rewrite.getNewVR ());
+    //Now that we know we are fine to do the replacement, let's do it
+    dalvikInsn.vA = static_cast<u4> (newVR);
 
-        //Keep track of this rewrite in order to commit it later
-        newDecodedInst[mir] = dalvikInsn;
+    //Keep track of this rewrite in order to commit it later
+    newDecodedInst[mir] = dalvikInsn;
 
+    //Check if we need to rewrite the uses now that use the new def
+    if (shouldRewriteUses == true)
+    {
         //Get local copy of ssa representation
         SSARepresentation *ssaRep = mir->ssaRep;
 
@@ -852,7 +1193,7 @@ bool dvmCompilerRewriteMirDef (const std::vector<MirRewriteRule> &rewriteList)
         SUsedChain *chain = ssaRep->usedNext[0];
 
         //Now fix the uses of this updated define
-        bool success = rewriteUses (rewrite, chain, newDecodedInst);
+        bool success = rewriteUses (oldVR, newVR, chain, newDecodedInst);
 
         //No use to keep going if we failed
         if (success == false)
@@ -867,18 +1208,15 @@ bool dvmCompilerRewriteMirDef (const std::vector<MirRewriteRule> &rewriteList)
         if (ssaRep->numDefs >= 2)
         {
             //Prepare the wide part of the old and new VRs
-            int oldVRWide = rewrite.getOldVR () + 1;
-            int newVRWide = rewrite.getNewVR () + 1;
-
-            //Create the rewrite rules for the wide part
-            MirRewriteRule rewriteWide (mir, oldVRWide, newVRWide);
+            int oldVRWide = oldVR + 1;
+            int newVRWide = newVR + 1;
 
             //Get the chain for the wide define
             chain = ssaRep->usedNext[1];
 
             //Now try to rewrite the uses of the wide part.
             //Don't affect success whether or not we fail here.
-            rewriteUses (rewriteWide, chain, newDecodedInst);
+            rewriteUses (oldVRWide, newVRWide, chain, newDecodedInst);
         }
     }
 
@@ -898,3 +1236,110 @@ bool dvmCompilerRewriteMirDef (const std::vector<MirRewriteRule> &rewriteList)
     //If we make it here, we succeeded
     return true;
 }
+
+OpcodeFlags dvmCompilerGetOpcodeFlags (int opcode)
+{
+    OpcodeFlags flags = 0;
+
+    //First check if this is an extended opcode
+    if (opcode >= static_cast<int> (kNumPackedOpcodes))
+    {
+        ExtendedMIROpcode extOp = static_cast<ExtendedMIROpcode> (opcode);
+
+        switch (extOp)
+        {
+            case kMirOpNullCheck:
+            case kMirOpBoundCheck:
+                //Instruction can continue or it may throw
+                flags = kInstrCanContinue | kInstrCanThrow;
+                break;
+            case kMirOpCheckInlinePrediction:
+                //This extended MIR has conditional branching semantics
+                flags = kInstrCanContinue | kInstrCanBranch;
+                break;
+            default:
+                break;
+        }
+    }
+    else
+    {
+        //Just get the flags provided by the dex helper
+        flags = dexGetFlagsFromOpcode (static_cast<Opcode> (opcode));
+    }
+
+    return flags;
+}
+
+ChildBlockIterator::ChildBlockIterator (BasicBlock *bb)
+{
+    //Initialize basic block
+    basicBlock = bb;
+
+    //We have not yet visited any of the children
+    visitedFallthrough = false;
+    visitedTaken = false;
+
+    //Check if we have successors
+    if (basicBlock != 0 && basicBlock->successorBlockList.blockListType != kNotUsed)
+    {
+        haveSuccessors = true;
+        dvmGrowableListIteratorInit (&(basicBlock->successorBlockList.blocks), &successorIter);
+    }
+    else
+    {
+        haveSuccessors = false;
+    }
+}
+
+BasicBlock **ChildBlockIterator::getNextChildPtr (void)
+{
+    //We check if we have a basic block. If we don't we cannot get next child
+    if (basicBlock == 0)
+    {
+        return 0;
+    }
+
+    //If we haven't visited fallthrough, return that
+    if (visitedFallthrough == false)
+    {
+        visitedFallthrough = true;
+
+        if (basicBlock->fallThrough != 0)
+        {
+            return &(basicBlock->fallThrough);
+        }
+    }
+
+    //If we haven't visited taken, return that
+    if (visitedTaken == false)
+    {
+        visitedTaken = true;
+
+        if (basicBlock->taken != 0)
+        {
+            return &(basicBlock->taken);
+        }
+    }
+
+    //We visited both taken and fallthrough. Now check if we have successors we need to visit
+    if (haveSuccessors == true)
+    {
+        //Get information about next successor block
+        SuccessorBlockInfo *successorBlockInfo = reinterpret_cast<SuccessorBlockInfo *> (dvmGrowableListIteratorNext (
+                &successorIter));
+
+        //If we don't have anymore successors, return 0
+        if (successorBlockInfo == 0)
+        {
+            return 0;
+        }
+
+        //Paranoid
+        assert (successorBlockInfo->block != 0);
+
+        return &(successorBlockInfo->block);
+    }
+
+    //If we make it here we found no remaining children
+    return 0;
+}
diff --git a/vm/compiler/InvariantRemoval.cpp b/vm/compiler/InvariantRemoval.cpp
index 55853b9..7b584fa 100644
--- a/vm/compiler/InvariantRemoval.cpp
+++ b/vm/compiler/InvariantRemoval.cpp
@@ -612,7 +612,7 @@ static void findIgetIputCandidates (CompilationUnit *cUnit, LoopInformation *inf
     dvmBitVectorIteratorInit ( const_cast<BitVector *> (blocks), &bvIterator);
     while (true)
     {
-        BasicBlock *bb = getNextBasicBlockViaBitVector (bvIterator, cUnit);
+        BasicBlock *bb = dvmCompilerGetNextBasicBlockViaBitVector (bvIterator, cUnit->blockList);
 
         //Check if done
         if (bb == 0)
@@ -769,13 +769,7 @@ static bool guaranteedToThrowFirstIteration (const CompilationUnit *cUnit, const
         //Get Dalvik instruction
         DecodedInstruction &insn = mir->dalvikInsn;
 
-        //The extended MIRs do not throw
-        if (static_cast<int> (insn.opcode) >= kMirOpFirst)
-        {
-            continue;
-        }
-
-        int flags = dexGetFlagsFromOpcode(insn.opcode);
+        int flags = dvmCompilerGetOpcodeFlags (insn.opcode);
 
         //If instruction cannot throw, then we continue
         if ((flags & kInstrCanThrow) == 0)
diff --git a/vm/compiler/LoopInformation.cpp b/vm/compiler/LoopInformation.cpp
index ff9514c..d7796da 100644
--- a/vm/compiler/LoopInformation.cpp
+++ b/vm/compiler/LoopInformation.cpp
@@ -117,8 +117,8 @@ static BitVector* getLoopTailBlocks (CompilationUnit *cUnit, BasicBlock *bb)
 
     // If the predecessor is dominated by this entry, it is a backward branch
     dvmBitVectorIteratorInit(bb->predecessors, &bvIterator);
-    for (BasicBlock *predBB = getNextBasicBlockViaBitVector (bvIterator, cUnit); predBB != 0;
-                     predBB = getNextBasicBlockViaBitVector (bvIterator, cUnit))
+    for (BasicBlock *predBB = dvmCompilerGetNextBasicBlockViaBitVector (bvIterator, cUnit->blockList); predBB != 0;
+                     predBB = dvmCompilerGetNextBasicBlockViaBitVector (bvIterator, cUnit->blockList))
     {
         //If we have no dominator information, we can skip it
         if (predBB->dominators == 0)
@@ -163,8 +163,9 @@ static bool getAllBBInLoop (CompilationUnit *cUnit, BasicBlock *entry, BitVector
     // Start from tail blocks except entry loop if it is a tail block at the same time
     BitVectorIterator bvIterator;
     dvmBitVectorIteratorInit(tailblocks, &bvIterator);
-    for (BasicBlock *tailblock = getNextBasicBlockViaBitVector (bvIterator, cUnit); tailblock != 0;
-                     tailblock = getNextBasicBlockViaBitVector (bvIterator, cUnit))
+    for (BasicBlock *tailblock = dvmCompilerGetNextBasicBlockViaBitVector (bvIterator, cUnit->blockList);
+                     tailblock != 0;
+                     tailblock = dvmCompilerGetNextBasicBlockViaBitVector (bvIterator, cUnit->blockList))
     {
         if (tailblock != entry)
         {
@@ -186,8 +187,8 @@ static bool getAllBBInLoop (CompilationUnit *cUnit, BasicBlock *entry, BitVector
         dvmSetBit (basicBlocks, cur->id);
 
         dvmBitVectorIteratorInit(cur->predecessors, &bvIterator);
-        for (BasicBlock *pred = getNextBasicBlockViaBitVector (bvIterator, cUnit); pred != 0;
-                         pred = getNextBasicBlockViaBitVector (bvIterator, cUnit))
+        for (BasicBlock *pred = dvmCompilerGetNextBasicBlockViaBitVector (bvIterator, cUnit->blockList); pred != 0;
+                         pred = dvmCompilerGetNextBasicBlockViaBitVector (bvIterator, cUnit->blockList))
         {
             if (dvmIsBitSet (basicBlocks, pred->id) == false)
             {
@@ -215,8 +216,8 @@ static void getOutsFromLoop (CompilationUnit *cUnit, BitVector *basicBlocks, Bit
     // Iterate over BB in a loop and if its edge comes out of a loop => add it to bit vector
     BitVectorIterator bvIterator;
     dvmBitVectorIteratorInit(basicBlocks, &bvIterator);
-    for (BasicBlock *cur = getNextBasicBlockViaBitVector (bvIterator, cUnit); cur != 0;
-                     cur = getNextBasicBlockViaBitVector (bvIterator, cUnit))
+    for (BasicBlock *cur = dvmCompilerGetNextBasicBlockViaBitVector (bvIterator, cUnit->blockList); cur != 0;
+                     cur = dvmCompilerGetNextBasicBlockViaBitVector (bvIterator, cUnit->blockList))
     {
         if ((cur->taken != 0) && (dvmIsBitSet (basicBlocks, cur->taken->id) == false))
         {
@@ -340,8 +341,9 @@ LoopInformation * LoopInformation::getLoopInformation (CompilationUnit *cUnit, L
         // Last thing, we do not want kPreBackwardBlock and kChainingCellBackwardBranch to be in our loop
         BitVectorIterator bvIterator;
         dvmBitVectorIteratorInit (info->backward, &bvIterator);
-        for (BasicBlock *current = getNextBasicBlockViaBitVector (bvIterator, cUnit); current != 0;
-                         current = getNextBasicBlockViaBitVector (bvIterator, cUnit))
+        for (BasicBlock *current = dvmCompilerGetNextBasicBlockViaBitVector (bvIterator, cUnit->blockList);
+                         current != 0;
+                         current = dvmCompilerGetNextBasicBlockViaBitVector (bvIterator, cUnit->blockList))
         {
             if (current->blockType == kChainingCellBackwardBranch)
             {
@@ -350,8 +352,9 @@ LoopInformation * LoopInformation::getLoopInformation (CompilationUnit *cUnit, L
                 // Also, let's check if there is a kPreBackwardBlock predecessor
                 BitVectorIterator bvIterator2;
                 dvmBitVectorIteratorInit (current->predecessors, &bvIterator2);
-                for (BasicBlock *predBB = getNextBasicBlockViaBitVector (bvIterator2, cUnit); predBB != 0;
-                                 predBB = getNextBasicBlockViaBitVector (bvIterator2, cUnit))
+                for (BasicBlock *predBB = dvmCompilerGetNextBasicBlockViaBitVector (bvIterator2, cUnit->blockList);
+                                 predBB != 0;
+                                 predBB = dvmCompilerGetNextBasicBlockViaBitVector (bvIterator2, cUnit->blockList))
                 {
                     if (predBB->blockType == kPreBackwardBlock)
                     {
@@ -533,7 +536,7 @@ BitVector *LoopInformation::getPostExitLoops (const CompilationUnit *cUnit)
     BitVectorIterator bvIterator;
     dvmBitVectorIteratorInit(exitLoop, &bvIterator);
     BasicBlock *bb;
-    while ((bb = getNextBasicBlockViaBitVector (bvIterator, cUnit)) != 0)
+    while ((bb = dvmCompilerGetNextBasicBlockViaBitVector (bvIterator, cUnit->blockList)) != 0)
     {
         assert (bb->taken == 0);
         assert (bb->fallThrough != 0);
@@ -672,8 +675,8 @@ bool LoopInformation::executedPerIteration (const CompilationUnit *cUnit, MIR *m
     //Go through the backward chaining cells
     BitVectorIterator bvIterator;
     dvmBitVectorIteratorInit (backward, &bvIterator);
-    for (BasicBlock *bwcc = getNextBasicBlockViaBitVector (bvIterator, cUnit); bwcc != 0;
-                     bwcc = getNextBasicBlockViaBitVector (bvIterator, cUnit))
+    for (BasicBlock *bwcc = dvmCompilerGetNextBasicBlockViaBitVector (bvIterator, cUnit->blockList); bwcc != 0;
+                     bwcc = dvmCompilerGetNextBasicBlockViaBitVector (bvIterator, cUnit->blockList))
     {
         //To prove that the mir is executed per iteration, it's block must dominate each backward chaining cell
         if (dvmIsBitSet (bwcc->dominators, current->id) == false)
@@ -724,8 +727,8 @@ MIR *LoopInformation::getPhiInstruction (CompilationUnit *cUnit, unsigned int vr
     //Iterate through them
     BitVectorIterator bvIterator;
     dvmBitVectorIteratorInit (blocks, &bvIterator);
-    for (BasicBlock *bb = getNextBasicBlockViaBitVector (bvIterator, cUnit); bb != 0;
-                     bb = getNextBasicBlockViaBitVector (bvIterator, cUnit))
+    for (BasicBlock *bb = dvmCompilerGetNextBasicBlockViaBitVector (bvIterator, cUnit->blockList); bb != 0;
+                     bb = dvmCompilerGetNextBasicBlockViaBitVector (bvIterator, cUnit->blockList))
     {
         //Go through its instructions
         for (MIR *mir = bb->firstMIRInsn; mir != 0; mir = mir->next)
@@ -959,13 +962,7 @@ bool LoopInformation::canThrow (const CompilationUnit *cUnit) const
             //Get dalvik instruction
             DecodedInstruction &insn = mir->dalvikInsn;
 
-            //The extended MIRs do not throw
-            if (static_cast<int> (insn.opcode) >= kMirOpFirst)
-            {
-                continue;
-            }
-
-            int flags = dexGetFlagsFromOpcode (insn.opcode);
+            int flags = dvmCompilerGetOpcodeFlags (insn.opcode);
 
             if ( (flags & kInstrCanThrow) != 0)
             {
@@ -1013,14 +1010,9 @@ bool LoopInformation::hasInvoke (const CompilationUnit *cUnit) const
             //Get dalvik instruction
             DecodedInstruction &insn = mir->dalvikInsn;
 
-            //The extended MIRs do not throw
-            if (static_cast<int> (insn.opcode) >= kMirOpFirst)
-            {
-                continue;
-            }
-
-            int flags = dexGetFlagsFromOpcode (insn.opcode);
+            int flags = dvmCompilerGetOpcodeFlags (insn.opcode);
 
+            //Check whether it is an invoke
             if ( (flags & kInstrInvoke) != 0)
             {
                 return true;
@@ -1124,7 +1116,7 @@ void LoopInformation::handlePredecessor (CompilationUnit *cUnit, std::map<BasicB
     dvmBitVectorIteratorInit (preheader->predecessors, &bvIterator);
     while (true)
     {
-        BasicBlock *bb = getNextBasicBlockViaBitVector (bvIterator, cUnit);
+        BasicBlock *bb = dvmCompilerGetNextBasicBlockViaBitVector (bvIterator, cUnit->blockList);
 
         //Check if done
         if (bb == 0)
@@ -1206,7 +1198,7 @@ void LoopInformation::peelLoopHelper (CompilationUnit *cUnit)
     dvmBitVectorIteratorInit ( (BitVector *) blocks, &bvIterator);
     while (true)
     {
-        BasicBlock *bb = getNextBasicBlockViaBitVector (bvIterator, cUnit);
+        BasicBlock *bb = dvmCompilerGetNextBasicBlockViaBitVector (bvIterator, cUnit->blockList);
 
         //Check if done
         if (bb == 0)
@@ -1315,7 +1307,7 @@ unsigned int LoopInformation::countInstructions (CompilationUnit *cUnit)
     dvmBitVectorIteratorInit ( (BitVector *) blocks, &bvIterator);
     while (true)
     {
-        BasicBlock *bb = getNextBasicBlockViaBitVector (bvIterator, cUnit);
+        BasicBlock *bb = dvmCompilerGetNextBasicBlockViaBitVector (bvIterator, cUnit->blockList);
 
         //Check if done
         if (bb == 0)
diff --git a/vm/compiler/LoopOpt.cpp b/vm/compiler/LoopOpt.cpp
index 53ed591..881f935 100644
--- a/vm/compiler/LoopOpt.cpp
+++ b/vm/compiler/LoopOpt.cpp
@@ -493,8 +493,8 @@ bool dvmCompilerCheckLoops (const CompilationUnit *cUnit, const Pass *curPass)
 
                 BitVectorIterator bvIterator;
                 dvmBitVectorIteratorInit(blocks, &bvIterator);
-                for (BasicBlock *bb = getNextBasicBlockViaBitVector(bvIterator, cUnit); bb != 0;
-                                 bb = getNextBasicBlockViaBitVector(bvIterator, cUnit))
+                for (BasicBlock *bb = dvmCompilerGetNextBasicBlockViaBitVector(bvIterator, cUnit->blockList); bb != 0;
+                                 bb = dvmCompilerGetNextBasicBlockViaBitVector(bvIterator, cUnit->blockList))
                 {
                     if (bb == backward)
                     {
diff --git a/vm/compiler/Utility.cpp b/vm/compiler/Utility.cpp
index e2e8016..3b0cb16 100644
--- a/vm/compiler/Utility.cpp
+++ b/vm/compiler/Utility.cpp
@@ -295,8 +295,17 @@ bool dvmGrowableListSetLastIterator(GrowableListIterator *iterator, intptr_t ele
 
 intptr_t dvmGrowableListGetElement(const GrowableList *gList, size_t idx)
 {
-    assert(idx < gList->numUsed);
-    return gList->elemList[idx];
+    //Check for overflow
+    if (idx >= gList->numUsed)
+    {
+        //Return null because we cannot get element with this index
+        return 0;
+    }
+    else
+    {
+        //Return the element with this index from the list
+        return gList->elemList[idx];
+    }
 }
 
 /* Debug Utility - dump a compilation unit */
@@ -323,7 +332,7 @@ void dvmCompilerDumpCompilationUnit(CompilationUnit *cUnit)
     ALOGD("Compiling %s %s", cUnit->method->clazz->descriptor,
          cUnit->method->name);
     ALOGD("%d insns", dvmGetMethodInsnsSize(cUnit->method));
-    ALOGD("%d blocks in total", cUnit->numBlocks);
+    ALOGD("%d blocks in total", dvmGrowableListSize(&cUnit->blockList));
     GrowableListIterator iterator;
 
     dvmGrowableListIteratorInit(&cUnit->blockList, &iterator);
@@ -578,10 +587,10 @@ void dvmGetBlockName(BasicBlock *bb, char *name)
 /**
  * @brief Get the next BasicBlock when considering a BasicBlock index BitVector
  * @param bvIterator the BitVector iterator
- * @param cUnit the CompilationUnit
+ * @param blockList The list of basic blocks
  * @return 0 if finished, the BasicBlock otherwise
  */
-BasicBlock *getNextBasicBlockViaBitVector (BitVectorIterator &bvIterator, const CompilationUnit *cUnit)
+BasicBlock *dvmCompilerGetNextBasicBlockViaBitVector (BitVectorIterator &bvIterator, const GrowableList &blockList)
 {
     //Get next element
     int blockIdx = dvmBitVectorIteratorNext(&bvIterator);
@@ -593,7 +602,7 @@ BasicBlock *getNextBasicBlockViaBitVector (BitVectorIterator &bvIterator, const
     }
 
     //Get BasicBlock
-    BasicBlock *bb = (BasicBlock *) dvmGrowableListGetElement(&cUnit->blockList, blockIdx);
+    BasicBlock *bb = (BasicBlock *) dvmGrowableListGetElement (&blockList, blockIdx);
 
     //Return the element
     return bb;
diff --git a/vm/compiler/codegen/x86/AnalysisO1.cpp b/vm/compiler/codegen/x86/AnalysisO1.cpp
index b5a00d9..a2fcd02 100644
--- a/vm/compiler/codegen/x86/AnalysisO1.cpp
+++ b/vm/compiler/codegen/x86/AnalysisO1.cpp
@@ -295,15 +295,12 @@ void insertAccess(int tableIndex, LiveRange* startP, int rangeStart);
  * @param opcode the Dalvik mnemonic
  * @return true if opcode can branch or switch
  */
-static inline bool isCurrentByteCodeJump(Opcode opcode) {
-    // Since extended MIRs are not normal dex opcodes, we cannot
-    // obtain any flag information (dexGetFlagsFromOpcode will overflow)
-    // As of now, none of the Extended MIRs branch so state it with this test
-    if ((int) opcode >= (int) kMirOpFirst)
-        return false;
+static inline bool isCurrentByteCodeJump(Opcode opcode)
+{
+    //Get the opcode flags
+    int flags = dvmCompilerGetOpcodeFlags (opcode);
 
-    // For regular MIRs, just find it if it can branch or switch
-    int flags = dexGetFlagsFromOpcode(opcode);
+    //Check whether it can branch or switch
     return (flags & (kInstrCanBranch | kInstrCanSwitch)) != 0;
 }
 
diff --git a/vm/compiler/codegen/x86/Lower.cpp b/vm/compiler/codegen/x86/Lower.cpp
index d1693db..f11409e 100644
--- a/vm/compiler/codegen/x86/Lower.cpp
+++ b/vm/compiler/codegen/x86/Lower.cpp
@@ -533,11 +533,13 @@ void endOfTrace (CompilationUnit *cUnit) {
 
 int lowerByteCodeCanThrowCheck(const Method* method, const MIR * mir, const u2 * dalvikPC) {
     bool delay_requested = false;
+
+    int flags = dvmCompilerGetOpcodeFlags (mir->dalvikInsn.opcode);
+
     // Delay free VRs if we potentially can exit to interpreter
     // We do not activate delay if VRs state is not changed
-    if ((int)(mir->dalvikInsn.opcode) < (int)kMirOpFirst // Not applicable to extended MIR
-        && (dexGetFlagsFromOpcode(mir->dalvikInsn.opcode) & kInstrCanThrow)!=0
-    ) {
+    if ((flags & kInstrCanThrow) != 0)
+    {
         int dfAttributes = dvmCompilerDataFlowAttributes[mir->dalvikInsn.opcode];
 
         if ( (dfAttributes & DF_IS_CALL) == 0) { // Not applicable to calls
diff --git a/vm/compiler/codegen/x86/pcg/Utility.cpp b/vm/compiler/codegen/x86/pcg/Utility.cpp
index 56e3f19..b478f30 100644
--- a/vm/compiler/codegen/x86/pcg/Utility.cpp
+++ b/vm/compiler/codegen/x86/pcg/Utility.cpp
@@ -221,17 +221,10 @@ bool dvmCompilerPcgBlockEndsInInvoke (BasicBlockPCG *bb)
     }
 
     //Get the opcode
-    Opcode opcode = mir->dalvikInsn.opcode;
-
-    //Is it extended?
-    if (opcode >= static_cast<Opcode> (kMirOpFirst))
-    {
-        //Then it is not an invoke
-        return false;
-    }
+    int opcode = mir->dalvikInsn.opcode;
 
     //Get the flags
-    int flags = dexGetFlagsFromOpcode (opcode);
+    int flags = dvmCompilerGetOpcodeFlags (opcode);
 
     if ((flags & kInstrInvoke) == 0) {
         return false;
diff --git a/vm/interp/Jit.cpp b/vm/interp/Jit.cpp
index b225262..697976a 100644
--- a/vm/interp/Jit.cpp
+++ b/vm/interp/Jit.cpp
@@ -796,9 +796,10 @@ void dvmCheckJit(const u2* pc, Thread* self)
     self->lastPC = pc;
 
     switch (self->jitState) {
-        int offset;
-        DecodedInstruction decInsn;
-        case kJitTSelect:
+        case kJitTSelect: {
+            int offset;
+            DecodedInstruction decInsn;
+
             /* First instruction - just remember the PC and exit */
             if (lastPC == NULL) break;
             /* Grow the trace around the last PC if jitState is kJitTSelect */
@@ -908,7 +909,8 @@ void dvmCheckJit(const u2* pc, Thread* self)
                     stayOneMoreInst = true;
                 }
             }
-            /* NOTE: intentional fallthrough for returns */
+        }
+        /* NOTE: intentional fallthrough for returns */
         case kJitTSelectEnd:
             {
                 /* Empty trace - set to bail to interpreter */
-- 
1.7.4.1

