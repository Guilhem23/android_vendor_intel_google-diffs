From b23506efc6310bab4b0b1a3b3d94c64f5ff61b90 Mon Sep 17 00:00:00 2001
From: Jean Christophe Beyler <jean.christophe.beyler@intel.com>
Date: Sat, 10 Aug 2013 19:37:01 -0700
Subject: Dalvik: Error Framework for LCG and PCG

BZ: 130217

Generalize the error framework and move it to handle both LCG and PCG:

- There was an implementation of the error framework for LCG
- This patch moves the error framework to being implemented as well for PCG
- Moving things upwards to also be the building stone for the ME error
    framework

Category: device-enablement
Domain: AOSP-Dalvik-Compiler-CG; AOSP-Dalvik-Compiler-ME; AOSP-Dalvik-Runtime
Origin: internal
Upstream-Candidate: no, needs rework

Change-Id: Iae74adae0ad37c76c336e04a033c2d08b7bf1486
Orig-MCG-Change-Id: Ia0f45ae22e6b7cb2fd7764b573ca3c772171f8ac
Signed-off-by: Jean Christophe Beyler <jean.christophe.beyler@intel.com>
Signed-off-by: Tim Hartley <timothy.d.hartley@intel.com>
Reviewed-on: http://android.intel.com:8080/125074
Reviewed-by: Lupusoru, Razvan A <razvan.a.lupusoru@intel.com>
Reviewed-by: Banerji, Udayan <udayan.banerji@intel.com>
Tested-by: Chen, Dong-Yuan <dong-yuan.chen@intel.com>
Reviewed-by: Chen, Dong-Yuan <dong-yuan.chen@intel.com>
Reviewed-by: Shou, Yixin <yixin.shou@intel.com>
Reviewed-by: cactus <cactus@intel.com>
Tested-by: cactus <cactus@intel.com>
Signed-off-by: Serguei Katkov <serguei.i.katkov@intel.com>
---
 vm/Dvm.mk                                          |    5 +-
 vm/Globals.h                                       |   10 +-
 vm/Init.cpp                                        |   25 ++-
 vm/compiler/CompilationError.cpp                   |  211 ++++++++++++++++
 vm/compiler/CompilationError.h                     |  216 ++++++++++++++++
 vm/compiler/CompilerIR.h                           |    4 +
 vm/compiler/Frontend.cpp                           |   20 +--
 vm/compiler/codegen/x86/BackEndEntry.cpp           |  116 +++++++++
 vm/compiler/codegen/x86/CompilationErrorX86.cpp    |   73 ++++++
 vm/compiler/codegen/x86/CompilationErrorX86.h      |   73 ++++++
 vm/compiler/codegen/x86/lightcg/AnalysisO1.cpp     |    3 +-
 .../codegen/x86/lightcg/BytecodeVisitor.cpp        |    2 +
 vm/compiler/codegen/x86/lightcg/CodegenErrors.cpp  |  265 --------------------
 vm/compiler/codegen/x86/lightcg/CodegenErrors.h    |  173 -------------
 .../codegen/x86/lightcg/CodegenInterface.cpp       |  108 ++------
 .../codegen/x86/lightcg/CompilationErrorLCG.cpp    |  157 ++++++++++++
 .../codegen/x86/lightcg/CompilationErrorLCG.h      |  151 +++++++++++
 .../codegen/x86/lightcg/ExceptionHandling.cpp      |    2 +
 .../codegen/x86/lightcg/InstructionGeneration.cpp  |    2 +
 vm/compiler/codegen/x86/lightcg/Lower.cpp          |    1 +
 vm/compiler/codegen/x86/lightcg/Lower.h            |   22 ++-
 vm/compiler/codegen/x86/lightcg/LowerGetPut.cpp    |    2 +
 vm/compiler/codegen/x86/lightcg/LowerHelper.cpp    |    1 +
 vm/compiler/codegen/x86/lightcg/LowerInvoke.cpp    |    2 +
 vm/compiler/codegen/x86/lightcg/LowerJump.cpp      |    1 +
 vm/compiler/codegen/x86/lightcg/NcgAot.cpp         |    2 +
 .../codegen/x86/lightcg/RegisterizationBE.cpp      |    3 +-
 vm/compiler/codegen/x86/lightcg/Scheduler.cpp      |    2 +
 vm/compiler/codegen/x86/pcg/Analysis.cpp           |    5 +-
 vm/compiler/codegen/x86/pcg/Android.mk             |    1 +
 .../codegen/x86/pcg/ChainingCellException.cpp      |   85 +++----
 vm/compiler/codegen/x86/pcg/Client.cpp             |   17 +-
 vm/compiler/codegen/x86/pcg/CodeGeneration.cpp     |   39 ++--
 .../codegen/x86/pcg/CompilationErrorPCG.cpp        |   82 ++++++
 vm/compiler/codegen/x86/pcg/CompilationErrorPCG.h  |   86 +++++++
 vm/compiler/codegen/x86/pcg/CompilationUnitPCG.cpp |    4 +-
 vm/compiler/codegen/x86/pcg/Labels.cpp             |   13 +-
 vm/compiler/codegen/x86/pcg/Labels.h               |    6 +-
 vm/compiler/codegen/x86/pcg/LowerALU.cpp           |    2 +-
 vm/compiler/codegen/x86/pcg/LowerCall.cpp          |   39 ++--
 vm/compiler/codegen/x86/pcg/LowerGetPut.cpp        |   34 ++--
 vm/compiler/codegen/x86/pcg/LowerJump.cpp          |    7 +-
 vm/compiler/codegen/x86/pcg/LowerJump.h            |    3 +-
 vm/compiler/codegen/x86/pcg/LowerMemory.cpp        |    6 +-
 vm/compiler/codegen/x86/pcg/LowerMemory.h          |    3 +-
 vm/compiler/codegen/x86/pcg/LowerOther.cpp         |   14 +-
 vm/compiler/codegen/x86/pcg/PcgInterface.cpp       |   73 +++---
 vm/compiler/codegen/x86/pcg/PersistentInfo.cpp     |   25 ++-
 vm/compiler/codegen/x86/pcg/PersistentInfo.h       |    9 +-
 vm/compiler/codegen/x86/pcg/UtilityPCG.cpp         |   33 ++--
 vm/compiler/codegen/x86/pcg/UtilityPCG.h           |    3 +-
 vm/compiler/codegen/x86/x86Specific.cpp            |   13 +
 vm/compiler/codegen/x86/x86Specific.h              |    7 +
 53 files changed, 1508 insertions(+), 753 deletions(-)
 create mode 100644 vm/compiler/CompilationError.cpp
 create mode 100644 vm/compiler/CompilationError.h
 create mode 100644 vm/compiler/codegen/x86/BackEndEntry.cpp
 create mode 100644 vm/compiler/codegen/x86/CompilationErrorX86.cpp
 create mode 100644 vm/compiler/codegen/x86/CompilationErrorX86.h
 delete mode 100644 vm/compiler/codegen/x86/lightcg/CodegenErrors.cpp
 delete mode 100644 vm/compiler/codegen/x86/lightcg/CodegenErrors.h
 create mode 100644 vm/compiler/codegen/x86/lightcg/CompilationErrorLCG.cpp
 create mode 100644 vm/compiler/codegen/x86/lightcg/CompilationErrorLCG.h
 create mode 100644 vm/compiler/codegen/x86/pcg/CompilationErrorPCG.cpp
 create mode 100644 vm/compiler/codegen/x86/pcg/CompilationErrorPCG.h

diff --git a/vm/Dvm.mk b/vm/Dvm.mk
index 0f5fb3f..3e03a43 100644
--- a/vm/Dvm.mk
+++ b/vm/Dvm.mk
@@ -372,13 +372,16 @@ ifeq ($(dvm_arch),x86)
               compiler/codegen/$(dvm_arch_variant)/lightcg/Scheduler.cpp \
               compiler/codegen/$(dvm_arch_variant)/lightcg/InstructionGeneration.cpp \
               compiler/codegen/$(dvm_arch_variant)/lightcg/ExceptionHandling.cpp \
-              compiler/codegen/$(dvm_arch_variant)/lightcg/CodegenErrors.cpp \
               compiler/codegen/$(dvm_arch_variant)/lightcg/RegisterizationBE.cpp \
               compiler/codegen/$(dvm_arch_variant)/lightcg/StackExtensionX86.cpp \
               compiler/codegen/$(dvm_arch_variant)/lightcg/CompileTable.cpp \
+              compiler/codegen/$(dvm_arch_variant)/lightcg/CompilationErrorLCG.cpp \
               compiler/codegen/$(dvm_arch_variant)/lightcg/Profile.cpp \
+              compiler/codegen/$(dvm_arch_variant)/CompilationErrorX86.cpp \
               compiler/codegen/$(dvm_arch_variant)/x86Specific.cpp \
+              compiler/codegen/$(dvm_arch_variant)/BackEndEntry.cpp \
               compiler/PassDriver.cpp \
+              compiler/CompilationError.cpp \
               compiler/Checks.cpp \
               compiler/LoopRegisterUsage.cpp \
               compiler/InvariantRemoval.cpp \
diff --git a/vm/Globals.h b/vm/Globals.h
index a56a25c..373fc09 100644
--- a/vm/Globals.h
+++ b/vm/Globals.h
@@ -83,6 +83,7 @@ enum ProfilerClockSource {
 
 
 //Forward declarations
+class CompilationErrorHandler;
 struct CompilationUnit;
 struct JitTranslationInfo;
 struct JitTranslationDescription;
@@ -848,6 +849,9 @@ typedef struct sJitFramework
     /** @brief Back-end BasicBlock allocater pointer */
     BasicBlock * (*backEndBasicBlockAllocation) (void);
 
+    /** @brief Back-end CompilationErrorHandler allocater pointer */
+    CompilationErrorHandler * (*backEndCompilationErrorHandlerAllocation) (void);
+
     /** @brief Back-end Dumping a BasicBlock */
     void (*backEndDumpSpecificBB) (CompilationUnit *, BasicBlock *, FILE *, bool);
 
@@ -943,9 +947,6 @@ struct DvmJitGlobals {
     /* Compiled code cache */
     void* codeCache;
 
-    /* Jit Errors Bit-field */
-    unsigned int jitErrorFlags;
-
     /* If flag is true, we abort the VM if any error happens during JIT
      * compilation, even if we can possibly ignore it and move on
      */
@@ -1058,6 +1059,9 @@ struct DvmJitGlobals {
     /* Flag to control the number of the minimum vectorized iterations */
     unsigned char minVectorizedIterations;
 
+    /* Integer to control the number of backend retries */
+    int backEndRetries;
+
     /* Structure to handle the Jit framework */
     SJitFramework jitFramework;
 
diff --git a/vm/Init.cpp b/vm/Init.cpp
index 2afe6ea..a5aaf1b 100644
--- a/vm/Init.cpp
+++ b/vm/Init.cpp
@@ -1558,6 +1558,21 @@ int processOptions(int argc, const char* const argv[], bool ignoreUnrecognized)
             gDvmJit.nestedLoops = true;
         } else if (strncmp(argv[i], "-Xjittestloops", 14) == 0) {
             gDvmJit.testLoops = true;
+        } else if (strncmp (argv[i], "-Xjitbackendretries:", 20) == 0) {
+            char *endptr = NULL;
+            //Get requested style
+            long res = strtol (argv[i] + 20, &endptr, 0);
+
+            //Error checking: basic ones first
+            if (endptr != 0 && *endptr == '\0' && res != LONG_MIN && res != LONG_MAX && res > 0)
+            {
+                dvmFprintf (stderr, "Setting Back-end retries to: %ld\n", res);
+                gDvmJit.backEndRetries = res;
+            }
+            else
+            {
+                dvmFprintf (stderr, "Refusing option for %s, it is not a valid number: must be only a strictly positive number\n", argv[i]);
+            }
         } else if (strncmp(argv[i], "-Xjitbranchloops", 16) == 0) {
             gDvmJit.branchLoops = true;
         } else if (strncmp(argv[i], "-Xjitnobackendregisterization", 29) == 0) {
@@ -1882,12 +1897,13 @@ static void setJitFramework ()
     //Now set the default function pointers
     SJitFramework &jitFramework = gDvmJit.jitFramework;
 
-    jitFramework.backEndFunction = dvmCompilerMIR2LIR;
+    jitFramework.backEndFunction = dvmCompilerLCGMIR2LIR;
     jitFramework.middleEndFunction = dvmCompileTrace;
-    jitFramework.backEndDumpSpecificBB = x86StandAloneArchSpecificDumpBB;
-    jitFramework.backEndBasicBlockAllocation = x86StandAloneArchSpecificNewBB;
+    jitFramework.backEndDumpSpecificBB = dvmCompilerLCGDumpBB;
+    jitFramework.backEndBasicBlockAllocation = dvmCompilerLCGNewBB;
     jitFramework.backEndInvokeArgsDone = dvmCompilerHandleInvokeArgsHeader;
     jitFramework.backendSupportExtendedOp = dvmCompilerArchSupportsExtendedOp;
+    jitFramework.backEndCompilationErrorHandlerAllocation = dvmCompilerLCGNewCompilationErrorHandler;
 }
 #endif
 
@@ -1977,6 +1993,9 @@ static void setCommandLineDefaults()
     //This is configurable via command line.
     gDvmJit.maximumInliningNumBytecodes = 20;
 
+   //Backend should allow two retries
+    gDvmJit.backEndRetries = 2;
+
     gDvmJit.ignorePasses = 0;
     gDvmJit.debugPasses = 0;
     gDvmJit.debugAllPasses = false;
diff --git a/vm/compiler/CompilationError.cpp b/vm/compiler/CompilationError.cpp
new file mode 100644
index 0000000..e562598
--- /dev/null
+++ b/vm/compiler/CompilationError.cpp
@@ -0,0 +1,211 @@
+/*
+ * Copyright (C) 2013 Intel Corporation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "CompilationError.h"
+
+//Middle-end Errors: currently empty :)
+START_ERRORS
+    NEW_ERROR (kErrorLoopCompilation,  "Loop compilation failed", true, false),
+    NEW_ERROR (kErrorTraceCompilation,  "Trace compilation failed", true, false),
+    NEW_ERROR (kErrorTraceTooLarge,  "Trace compilation failed", true, false),
+    NEW_ERROR (kErrorQuitLoopMode,  "QuitLoopMode tripped", true, false),
+END_ERRORS
+
+//Constructor first
+CompilationErrorHandler::CompilationErrorHandler (void)
+{
+    disableOpt = 0;
+    backEndRegisterization = 0;
+    errorFlags = 0;
+}
+
+//Destructor second
+CompilationErrorHandler::~CompilationErrorHandler (void)
+{
+    //Remove everything from the retryCounts vector
+    std::vector<unsigned int> dummy;
+    retryCounts.swap (dummy);
+}
+
+void CompilationErrorHandler::saveOptimizationState (void)
+{
+    disableOpt = gDvmJit.disableOpt;
+    backEndRegisterization = gDvmJit.backEndRegisterization;
+}
+
+void CompilationErrorHandler::restoreCompilationState (void) const
+{
+    gDvmJit.disableOpt = disableOpt;
+    gDvmJit.backEndRegisterization = backEndRegisterization;
+}
+
+void CompilationErrorHandler::fixErrors (CompilationUnit *cUnit)
+{
+    // Checks if any error has occurred. If not, we do not need to retry.
+    if (isAnyErrorSet () == false)
+    {
+        return;
+    }
+
+    //Have a boolean to know if we've had an error already
+    bool hadError = false;
+
+    //Get the maximum error number the system is aware of so far:
+    unsigned int maxError = getMaximumErrors ();
+
+    // Check which errors have been raised
+    for (unsigned int errorIndex = 0; errorIndex <= maxError; errorIndex++) {
+        //Is it set?
+        if (isErrorSet (errorIndex) == true)
+        {
+            //Get the error from the table
+            const CompilationError *error = getError (errorIndex);
+
+            //Skip if 0, actually paranoid but we will check
+            if (error == 0)
+            {
+                ALOGD ("JIT_INFO: Error framework could not find error entry");
+                continue;
+            }
+
+            //Is it the first error?
+            if (hadError == false)
+            {
+                //Let the error framework do some initial printing then
+                signalFirstError (cUnit);
+
+                //Set flag to true to not come back here
+                hadError = true;
+            }
+
+            //Handle the error
+            handleError (cUnit, error);
+
+            //Resolve the error if possible
+            if (error->canResolve == true)
+            {
+                resolveError (cUnit, error);
+            }
+        }
+    }
+}
+
+unsigned int CompilationErrorHandler::getMaximumErrors (void) const
+{
+    //Take the minimum of the size of the array and kJitErrorMaxME
+    unsigned int enumMax = kJitErrorMaxME;
+    unsigned int arrayMax = sizeof (gErrorInformation) / sizeof (gErrorInformation[0]);
+    unsigned int min = (enumMax < arrayMax) ? enumMax : arrayMax;
+
+    return min;
+}
+
+const CompilationError *CompilationErrorHandler::getError (unsigned int index) const
+{
+    //Be paranoid
+    if (index >= getMaximumErrors ())
+    {
+        return 0;
+    }
+
+    //Safe to access the array
+    return gErrorInformation + index;
+}
+
+void CompilationErrorHandler::handleError (CompilationUnit *cUnit, const CompilationError *error) const
+{
+    //First real question is: is the error fatal?
+    bool fatalError = error->isFatal;
+
+    // If we are set to abort on error and error cannot be resolved, then the error is fatal.
+    fatalError = (fatalError == true) || (gDvmJit.abortOnCompilerError == true && error->canResolve == false);
+
+    // If it is fatal then we are bailing really quickly
+    if (fatalError == true)
+    {
+        ALOGE ("\t%s", error->errorMessage);
+        ALOGE ("FATAL_ERRORS in JIT. Aborting compilation.");
+        dvmCompilerAbort (cUnit);
+    }
+    else
+    {
+        //Otherwise, just print out the message
+        ALOGI ("\t%s", error->errorMessage);
+    }
+}
+
+void CompilationErrorHandler::signalFirstError (CompilationUnit *cUnit) const
+{
+    ALOGI ("++++++++++++++++++++++++++++++++++++++++++++");
+    ALOGI ("JIT_INFO: ME Issues while compiling trace  %s%s, offset %d",
+            cUnit->method->clazz->descriptor, cUnit->method->name,
+            cUnit->traceDesc->trace[0].info.frag.startOffset);
+}
+
+void CompilationErrorHandler::resolveError (CompilationUnit *cUnit, const CompilationError *error)
+{
+    //By default, do nothing
+}
+
+bool CompilationErrorHandler::decideOnRemainingErrors (void)
+{
+    //If anything is still set, the ME says to just forget it
+    return (getTopRetryCount () != 0) && (isAnyErrorSet () == false);
+}
+
+void CompilationErrorHandler::reset (void)
+{
+    //Just clear the flags
+    clearErrors ();
+}
+
+void CompilationErrorHandler::pushRetryCount (unsigned int count)
+{
+    retryCounts.push_back (count);
+}
+
+void CompilationErrorHandler::decrementTopRetryCount (void)
+{
+    unsigned int idx = retryCounts.size ();
+
+    //If at least one element
+    if (idx > 0)
+    {
+        //Go back one to get the actual index
+        idx--;
+
+        //Decrement
+        retryCounts[idx]--;
+    }
+}
+
+unsigned int CompilationErrorHandler::getTopRetryCount (void) const
+{
+    unsigned int idx = retryCounts.size ();
+
+    //If at least one element
+    if (idx > 0)
+    {
+        //Go back one
+        idx--;
+
+        return retryCounts[idx];
+    }
+
+    //By default return 0
+    return 0;
+
+}
diff --git a/vm/compiler/CompilationError.h b/vm/compiler/CompilationError.h
new file mode 100644
index 0000000..5582913
--- /dev/null
+++ b/vm/compiler/CompilationError.h
@@ -0,0 +1,216 @@
+/*
+ * Copyright (C) 2013 Intel Corporation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef CODEGEN_COMPILATION_ERROR_H_
+#define CODEGEN_COMPILATION_ERROR_H_
+
+#include "Dalvik.h"
+#include "CompilerIR.h"
+
+/**
+ * @class CompilationErrors
+ * @brief Compilation Errors from the Middle-End
+ */
+enum CompilationErrors {
+    kErrorLoopCompilation,   /**< @brief Loop compilation failed */
+    kErrorTraceCompilation,
+    kErrorTraceTooLarge,
+    kErrorQuitLoopMode,
+    /** @brief The final Middle-End error so that the Back-ends can start at this value */
+    kJitErrorMaxME,
+};
+
+/**
+ * @class CompilationError
+ * @brief Used to keep track of information associated with an error
+ */
+struct CompilationError
+{
+    /** @brief Type of error */
+    int type;
+
+    /** @brief Error message */
+    const char * errorMessage;
+
+    /** @brief Whether we can possibly fix the error */
+    bool canResolve;
+
+    /** @brief Whether error is fatal */
+    bool isFatal;
+};
+
+/**
+ * @class CompilationErrorHandler
+ * @brief CompilationErrorHandler is an error handler for compilation
+ */
+class CompilationErrorHandler
+{
+    protected:
+        int disableOpt;                     /**< @brief Disable the optimizations */
+        bool backEndRegisterization;        /**< @brief Backend registerization */
+        unsigned long long errorFlags;      /**< @brief Error flags */
+        std::vector<unsigned int> retryCounts; /**< @brief Retry counts */
+
+    public:
+        /**
+         * @brief Constructor
+         */
+        CompilationErrorHandler (void);
+
+        /**
+         * @brief Destructor
+         */
+        virtual ~CompilationErrorHandler (void);
+
+        /**
+         * @brief Tries to fix any errors encountered and decides if retrying has a point or not
+         * @param cUnit CompilationUnit context
+         */
+        virtual void fixErrors (CompilationUnit *cUnit);
+
+        /**
+         * @brief Save the error flags that can be changed by dvmCanFixErrorsAndRetry
+         */
+        void saveOptimizationState (void);
+
+        /**
+         * @brief Restore compilation state
+         */
+        void restoreCompilationState (void) const;
+
+        /**
+         * @brief Set an error flag
+         * @param error the error we wish to set
+         */
+        void setError (int error) {errorFlags |= (1 << error);}
+
+        /**
+         * @brief Clear an error
+         * @param error the error we wish to clear
+         */
+        void clearError (int error) {errorFlags &= ~ (1 << error);};
+
+        /**
+         * @brief Reset the handler except any retry information
+         */
+        void reset (void);
+
+        /**
+         * @brief Is an error set?
+         * @param error the error we wish to check
+         */
+        bool isErrorSet (int error) const {return ( (errorFlags & (1 << error)) != 0);}
+
+        /**
+         * @brief Clear all errors
+         */
+        void clearErrors (void) {errorFlags = 0;}
+
+        /**
+         * @brief Is any error set?
+         * @return if any error is set
+         */
+        bool isAnyErrorSet (void) const {return (errorFlags != 0);}
+
+        /**
+         * @brief Returns the maximum number of errors
+         * @return the maximum number of errors
+         */
+        virtual unsigned int getMaximumErrors (void) const;
+
+        /**
+         * @brief Get a JitCompilationError
+         * @param index the index we are interested in
+         * @return a pointer to the corresponding JitCompilationError or 0 if invalid
+         */
+        virtual const CompilationError *getError (unsigned int index) const;
+
+        /**
+         * @brief Handle an error
+         * @param cUnit the CompilationUnit
+         * @param error the error we wish to handle
+         */
+        virtual void handleError (CompilationUnit *cUnit, const CompilationError *error) const;
+
+        /**
+         * @brief Resolve the error
+         * @param cUnit the CompilationUnit
+         * @param error the error we wish to resolve
+         */
+        virtual void resolveError (CompilationUnit *cUnit, const CompilationError *error);
+
+        /**
+         * @brief Decide if we still have an issue or not?
+         * @return return if there still is an error remaining?
+         */
+        virtual bool decideOnRemainingErrors (void);
+
+        /**
+         * @brief Signal that a first error occured
+         * @param cUnit the CompilationUnit
+         */
+        virtual void signalFirstError (CompilationUnit *cUnit) const;
+
+        /**
+         * @brief Check for a particular mask in the disable optimization
+         * @param mask the mask we want to check for
+         * @return whether or not the mask on the disableOpt field is different than 0
+         */
+        bool checkDisableOptimization (int mask) {return (disableOpt & mask) != 0;}
+
+        /**
+         * @brief Set a disable optimization
+         * @param mask the mask we want to set
+         */
+        void setDisableOptimization (int mask) {disableOpt |= mask;}
+
+        /**
+         * @brief Push a new retry count
+         * @param count the new retry count
+         */
+        void pushRetryCount (unsigned int count);
+
+        /**
+         * @brief Pop the retry count
+         */
+        void popRetryCount (void) {retryCounts.pop_back ();}
+
+        /**
+         * @brief Decrement the top retry count
+         */
+        void decrementTopRetryCount (void);
+
+        /**
+         * @brief Get the top retry count
+         * @return the top retry count
+         */
+        unsigned int getTopRetryCount (void) const;
+};
+
+
+/* Three macros to help error definitions */
+#define START_ERRORS \
+    static CompilationError gErrorInformation[] = {
+
+#define NEW_ERROR(TYPE, MESSAGE, CANRESOLVE, ISFATAL) \
+        { \
+            TYPE, MESSAGE, CANRESOLVE, ISFATAL \
+        }
+
+#define END_ERRORS \
+    };
+
+#endif
diff --git a/vm/compiler/CompilerIR.h b/vm/compiler/CompilerIR.h
index 5c23098..e0b39bf 100644
--- a/vm/compiler/CompilerIR.h
+++ b/vm/compiler/CompilerIR.h
@@ -388,6 +388,7 @@ private:
 };
 
 //Forward Declarations
+class CompilationErrorHandler;
 struct LoopAnalysis;
 class LoopInformation;
 struct RegisterPool;
@@ -468,6 +469,9 @@ typedef struct CompilationUnit {
     LoopInformation *loopInformation;
 #endif
 
+    /* Error framework */
+    CompilationErrorHandler *errorHandler;
+
     /* Map SSA names to location */
     RegLocation *regLocation;
     int sequenceNumber;
diff --git a/vm/compiler/Frontend.cpp b/vm/compiler/Frontend.cpp
index d8820c6..479fb58 100644
--- a/vm/compiler/Frontend.cpp
+++ b/vm/compiler/Frontend.cpp
@@ -2240,15 +2240,7 @@ static bool compileLoop(CompilationUnit *cUnit, unsigned int startOffset,
         //Call if need be
         if (callBackend == true)
         {
-            //Get backend function call
-            void (*mir2lir) (CompilationUnit *, JitTranslationInfo *) = gDvmJit.jitFramework.backEndFunction;
-
-            //If defined, call it
-            if (mir2lir != 0)
-            {
-                /* Convert MIR to LIR, etc. */
-                mir2lir (cUnit, info);
-            }
+            dvmCompilerMIR2LIR (cUnit, info);
         }
         else
         {
@@ -2964,15 +2956,7 @@ bool dvmCompileTrace(JitTraceDescription *desc, int numMaxInsts,
         //Call if need be
         if (callBackend == true)
         {
-            //Get backend function call
-            void (*mir2lir) (CompilationUnit *, JitTranslationInfo *) = gDvmJit.jitFramework.backEndFunction;
-
-            //If defined, call it
-            if (mir2lir != 0)
-            {
-                /* Convert MIR to LIR, etc. */
-                mir2lir (&cUnit, info);
-            }
+            dvmCompilerMIR2LIR (&cUnit, info);
         }
         else
         {
diff --git a/vm/compiler/codegen/x86/BackEndEntry.cpp b/vm/compiler/codegen/x86/BackEndEntry.cpp
new file mode 100644
index 0000000..a954710
--- /dev/null
+++ b/vm/compiler/codegen/x86/BackEndEntry.cpp
@@ -0,0 +1,116 @@
+/*
+ * Copyright (C) 2013 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "Dalvik.h"
+#include "CompilationError.h"
+#include "CompilationUnit.h"
+#include "x86Specific.h"
+
+void dvmCompilerMIR2LIR (CompilationUnit *cUnit, JitTranslationInfo *info)
+{
+    CompilationErrorHandler *meHandler = cUnit->errorHandler;
+
+    //Create the error handler for the backend
+    CompilationErrorHandler *errorHandler = dvmCompilerArchSpecificNewCompilationErrorHandler ();
+
+    //Paranoid
+    assert (errorHandler != 0);
+
+    //Set it in the cUnit
+    cUnit->errorHandler = errorHandler;
+
+    //Get number of base retries
+    int baseRetries = gDvmJit.backEndRetries;
+
+    //Push maximum
+    errorHandler->pushRetryCount (baseRetries);
+
+    //Try to lower MIR
+    bool retry = true;
+    while (retry == true)
+    {
+        //Be optimist
+        retry = false;
+
+        //Get backend compiler entry
+        void (*backEndCompiler) (CompilationUnit *, JitTranslationInfo *) = gDvmJit.jitFramework.backEndFunction;
+
+        if (backEndCompiler != 0)
+        {
+            //Do the compilation
+            backEndCompiler (cUnit, info);
+        }
+        else
+        {
+            ALOGD ("JIT INFO: No backend defined");
+        }
+
+        //Check for errors
+        bool success = (errorHandler->isAnyErrorSet () == false);
+
+        //If there was a problem
+        if (success == false)
+        {
+            //Resolve any errors
+            errorHandler->fixErrors (cUnit);
+
+            //Should we try again?
+            retry = errorHandler->decideOnRemainingErrors ();
+
+            //If so, we should reset the handler
+            errorHandler->reset ();
+        }
+
+        //If we want to retry
+        if (retry == true)
+        {
+            //Do we have a retry at least?
+            if (errorHandler->getTopRetryCount () == 0)
+            {
+                retry = false;
+
+                //Abort if the flag is set.
+                if (gDvmJit.abortOnCompilerError == true) {
+                    ALOGE("Too many retries for trace  %s%s, offset %d", cUnit->method->clazz->descriptor,
+                            cUnit->method->name, cUnit->traceDesc->trace[0].info.frag.startOffset);
+
+                    //This will cause a full abort due to the flag
+                    dvmCompilerAbort(cUnit);
+                }
+
+                ALOGD("Too many retries while compiling trace  %s%s, offset %d", cUnit->method->clazz->descriptor,
+                        cUnit->method->name, cUnit->traceDesc->trace[0].info.frag.startOffset);
+                ALOGD("Rejecting Trace");
+
+            }
+            else
+            {
+                //Decrement the recount
+                errorHandler->decrementTopRetryCount ();
+            }
+
+            //Ignore errors in previous compilations
+            errorHandler->clearErrors ();
+        }
+    }
+
+    //Call the destructor, don't free it because it's allocated on the arena but might require some clean-up
+    errorHandler->~CompilationErrorHandler ();
+
+    //Set the error handler of the cUnit back
+    cUnit->errorHandler = meHandler;
+}
+
diff --git a/vm/compiler/codegen/x86/CompilationErrorX86.cpp b/vm/compiler/codegen/x86/CompilationErrorX86.cpp
new file mode 100644
index 0000000..36509e9
--- /dev/null
+++ b/vm/compiler/codegen/x86/CompilationErrorX86.cpp
@@ -0,0 +1,73 @@
+/*
+ * Copyright (C) 2013 Intel Corporation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "CompilationErrorX86.h"
+#include "CompilationUnit.h"
+#include "Lower.h"
+
+/**
+ * @brief Table that stores information about errors defined in JitCompilationErrors
+ */
+START_ERRORS
+    NEW_ERROR (kJitErrorCodeCacheFull,        "Jit code cache is full.",                                 true, false),
+    NEW_ERROR (kJitErrorUnsupportedBytecode,  "Trace contains bytecode with no implementation.",              false, false),
+    NEW_ERROR (kJitErrorUnsupportedVectorization, "Requested vectorization is not supported.",                    false, false),
+    NEW_ERROR (kJitErrorUnsupportedInstruction,   "Architecture does not support desired x86 instruction.",       false, false),
+END_ERRORS
+
+unsigned int CompilationErrorHandlerX86::getMaximumErrors (void) const
+{
+    //Take the minimum of the size of the array and kJitErrorMaxME but without the offset of the ME's enumeration
+    unsigned int enumMax = kJitErrorMaxDefinedX86 - kJitFirstErrorX86;
+    unsigned int arrayMax = sizeof (gErrorInformation) / sizeof (gErrorInformation[0]);
+    unsigned int min = (enumMax < arrayMax) ? enumMax : arrayMax;
+
+    //Now add back the ME's enumeration
+    return min + kJitFirstErrorX86;
+}
+
+const CompilationError *CompilationErrorHandlerX86::getError (unsigned int index) const
+{
+    //Check the index
+    if (index < kJitFirstErrorX86)
+    {
+        //Not ours, send it to our parent
+        return CompilationErrorHandler::getError (index);
+    }
+
+    //Is it too much?
+    if (index >= kJitErrorMaxDefinedX86)
+    {
+        return 0;
+    }
+
+    //Safe to hit the index with the delta
+    return gErrorInformation + (index - kJitFirstErrorX86);
+}
+
+void CompilationErrorHandlerX86::resolveError (CompilationUnit *cUnit, const CompilationError *error)
+{
+    switch (error->type)
+    {
+        case kJitErrorCodeCacheFull:
+            gDvmJit.codeCacheFull = true;
+            break;
+        default:
+            //We don't know about it maybe the base class does
+            CompilationErrorHandler::resolveError (cUnit, error);
+            break;
+    }
+}
diff --git a/vm/compiler/codegen/x86/CompilationErrorX86.h b/vm/compiler/codegen/x86/CompilationErrorX86.h
new file mode 100644
index 0000000..50c3c30
--- /dev/null
+++ b/vm/compiler/codegen/x86/CompilationErrorX86.h
@@ -0,0 +1,73 @@
+/*
+ * Copyright (C) 2013 Intel Corporation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef DALVIK_VM_COMPILATIONERRORX86_H_
+#define DALVIK_VM_COMPILATIONERRORX86_H_
+
+#include "Dalvik.h"
+#include "compiler/CompilationError.h"
+
+/**
+ * @enum JitX86CompilationErrors
+ * @brief Possible errors which can happen during compilation
+ */
+enum JitX86CompilationErrors {
+    /** @brief First x86 error */
+    kJitFirstErrorX86 = kJitErrorMaxME,
+    /** @brief JIT code cache is full */
+    kJitErrorCodeCacheFull = kJitFirstErrorX86,
+    /** @brief Trace contains a bytecode with no JIT implementation */
+    kJitErrorUnsupportedBytecode,
+    /** @brief Unsupported case for vectorization */
+    kJitErrorUnsupportedVectorization,
+    /** @brief Unsupported case for vectorization */
+    kJitErrorUnsupportedInstruction,
+    /** @brief Guarding value
+     * THIS NEEDS TO BE THE LAST VALUE
+     */
+    kJitErrorMaxDefinedX86
+};
+
+/**
+ * @class CompilationErrorHandlerX86
+ * @brief The compilation error framework for the X86 back-ends
+ */
+class CompilationErrorHandlerX86: public CompilationErrorHandler
+{
+    public:
+
+        /**
+         * @brief Returns the maximum number of errors
+         * @return the maximum number of errors
+         */
+        virtual unsigned int getMaximumErrors (void) const;
+
+        /**
+         * @brief Get a JitCompilationError
+         * @param index the index we are interested in
+         * @return a pointer to the corresponding JitCompilationError or 0 if invalid
+         */
+        virtual const CompilationError *getError (unsigned int index) const;
+
+        /**
+         * @brief Resolve the errors
+         * @param cUnit the CompilationUnit
+         * @param error the error we wish to handle
+         */
+        virtual void resolveError (CompilationUnit *cUnit, const CompilationError *error);
+};
+
+#endif
diff --git a/vm/compiler/codegen/x86/lightcg/AnalysisO1.cpp b/vm/compiler/codegen/x86/lightcg/AnalysisO1.cpp
index 8915f38..1b54b85 100644
--- a/vm/compiler/codegen/x86/lightcg/AnalysisO1.cpp
+++ b/vm/compiler/codegen/x86/lightcg/AnalysisO1.cpp
@@ -18,6 +18,7 @@
 /*! \file AnalysisO1.cpp
   \brief This file implements register allocator, constant folding
 */
+#include "CompilationErrorLCG.h"
 #include "CompilationUnit.h"
 #include "libdex/DexOpcodes.h"
 #include "libdex/DexFile.h"
@@ -1344,7 +1345,7 @@ static bool shouldRejectBasicBlock(BasicBlock_O1* bb) {
     bool shouldReject = false;
 
     // Set a generic error message in case someone forgets to set a proper one
-    JitCompilationErrors errorIfRejected = kJitErrorCodegen;
+    JitLCGCompilationErrors errorIfRejected = static_cast<JitLCGCompilationErrors> (kJitErrorCodegen);
 
     /**
      * Rejection Scenario 1:
diff --git a/vm/compiler/codegen/x86/lightcg/BytecodeVisitor.cpp b/vm/compiler/codegen/x86/lightcg/BytecodeVisitor.cpp
index 562af4e..e71e1fe 100644
--- a/vm/compiler/codegen/x86/lightcg/BytecodeVisitor.cpp
+++ b/vm/compiler/codegen/x86/lightcg/BytecodeVisitor.cpp
@@ -18,6 +18,8 @@
 /*! \file BytecodeVisitor.cpp
     \brief This file implements visitors of the bytecode
 */
+#include "CompilationErrorLCG.h"
+#include "CompilationUnit.h"
 #include "libdex/DexOpcodes.h"
 #include "libdex/DexFile.h"
 #include "Lower.h"
diff --git a/vm/compiler/codegen/x86/lightcg/CodegenErrors.cpp b/vm/compiler/codegen/x86/lightcg/CodegenErrors.cpp
deleted file mode 100644
index 2be1d23..0000000
--- a/vm/compiler/codegen/x86/lightcg/CodegenErrors.cpp
+++ /dev/null
@@ -1,265 +0,0 @@
-/*
- * Copyright (C) 2012-2013 Intel Corporation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "CodegenErrors.h"
-
-/**
- * @class ErrorInformation Used to keep track of information associated with an error
- */
-
-struct ErrorInformation
-{
-    /** @brief Type of error */
-    JitCompilationErrors type;
-
-    /** @brief Error message */
-    const char * errorMessage;
-
-    /** @brief Whether we can possibly fix the error */
-    bool canResolve;
-
-    /** @brief Whether error is fatal */
-    bool isFatal;
-};
-
-/**
- * @brief Three macros to help error definitions
- */
-
-
-#define START_ERRORS \
-    static ErrorInformation gErrorInformation[] = {
-
-#define NEW_ERROR(TYPE, MESSAGE, CANRESOLVE, ISFATAL) \
-        { \
-            TYPE, MESSAGE, CANRESOLVE, ISFATAL \
-        }
-
-#define END_ERRORS \
-    };
-
-/**
- * @brief Table that stores information about errors defined in
- * JitCompilationErrors
- */
-START_ERRORS
-    NEW_ERROR (kJitErrorMaxVR,                          "Exceeded maximum allowed VRs in a basic block.",               false, false),
-    NEW_ERROR (kJitErrorShortJumpOffset,                "Jump offset greater than 8-bits.",                              true, false),
-    NEW_ERROR (kJitErrorUnsupportedBytecode,            "Trace contains bytecode with no implementation.",              false, false),
-    NEW_ERROR (kJitErrorUnresolvedField,                "Trace contains SGET / SPUT bytecode with unresolved field.",   false, false),
-    NEW_ERROR (kJitErrorInvalidBBId,                    "Cannot find BasicBlock_O1 corresponding to a BasicBlock.",     false, false),
-    NEW_ERROR (kJitErrorCodeCacheFull,                  "Jit code cache is full.",                                       true, false),
-    NEW_ERROR (kJitErrorRegAllocFailed,                 "Failure in register allocator or register tables.",            false, false),
-    NEW_ERROR (kJitErrorMallocFailed,                   "Malloc failure during trace compilation.",                      false, true),
-    NEW_ERROR (kJitErrorMaxXferPoints,                  "Exceeded maximum number of transfer points per BB.",           false, false),
-    NEW_ERROR (kJitErrorMaxDestRegPerSource,            "Exceeded number of destination regs for a source reg.",        false, false),
-    NEW_ERROR (kJitErrorStateTransfer,                  "Problem with state transfer in JIT.",                          false, false),
-    NEW_ERROR (kJitErrorTraceFormation,                 "Problem with trace formation.",                                false, false),
-    NEW_ERROR (kJitErrorNullBoundCheckFailed,           "Problem while performing null or bound check.",                false, false),
-    NEW_ERROR (kJitErrorMergeLiveRange,                 "Problem while merging live ranges (mergeLiveRange).",          false, false),
-    NEW_ERROR (kJitErrorGlobalData,                     "Global data not defined.",                                     false, false),
-    NEW_ERROR (kJitErrorInsScheduling,                  "Problem during instruction scheduling.",                       false, false),
-    NEW_ERROR (kJitErrorBERegisterization,              "Issue registerizing the trace in the backend.",                 true, false),
-    NEW_ERROR (kJitErrorSpill,                          "The trace provoked a spill.",                                   true, false),
-    NEW_ERROR (kJitErrorBBCannotBeHandled,              "The backend decided it cannot safely handle the Basic Block.", false, false),
-    NEW_ERROR (kJitErrorConstInitFail,                  "Patching of Double/Long constants failed.",                     true, false),
-    NEW_ERROR (kJitErrorChainingCell,                   "An issue was encountered while generating chaining cell.",     false, false),
-    NEW_ERROR (kJitErrorInvalidOperandSize,             "Invalid Operand Size was encountered.",                        false, false),
-    NEW_ERROR (kJitErrorPlugin,                         "Problem with the plugin system.",                              false, false),
-    NEW_ERROR (kJitErrorConstantFolding,                "Constant folding failed due to unhandled case.",               false, false),
-    NEW_ERROR (kJitErrorPcgUnknownChainingBlockType,    "Unknown chaining block type seen in PCG GL.",                  false, false),
-    NEW_ERROR (kJitErrorPcgUnexpectedDataType,          "Unexpected data type in PCG GL.",                              false, false),
-    NEW_ERROR (kJitErrorPcgUnsupportedCallDataType,     "Unsupported call data type seen in PCG GL.",                   false, false),
-    NEW_ERROR (kJitErrorPcgPostInvokeEntryNotFound,     "Post-invoke entry block was not found.",                       false, false),
-    NEW_ERROR (kJitErrorUnsupportedVectorization,       "Requested vectorization is not supported.",                    false, false),
-    NEW_ERROR (kJitErrorUnsupportedInstruction,         "Architecture does not support desired x86 instruction.",       false, false),
-    NEW_ERROR (kJitErrorCodegen,                        "Undefined issues in trace formation.",                         false, false),
-END_ERRORS
-
-
-/**
- * @brief Tries to resolve errors from which we can recover.
- * @param cUnit Compilation unit
- * @param isLastAttempt whether the next compilation attempt will be the last one
- */
-inline void resolveErrors(CompilationUnit * cUnit, bool isLastAttempt) {
-    /* Handle any errors which can be handled */
-
-    //Handle error due to large jump offset
-    if ( IS_JIT_ERROR_SET(kJitErrorShortJumpOffset)) {
-        gDvmJit.disableOpt |= (1 << kShortJumpOffset);
-        ALOGI("JIT_INFO: Successfully resolved short jump offset issue");
-        //Clear the error:
-        CLEAR_JIT_ERROR(kJitErrorShortJumpOffset);
-    }
-
-    //Handle error due to spilling
-    if (IS_JIT_ERROR_SET(kJitErrorSpill)) {
-        //Clear the error:
-        CLEAR_JIT_ERROR(kJitErrorSpill);
-
-        //Ok we are going to see if we are registerizing something
-        int max = cUnit->maximumRegisterization;
-
-        // We should only get this error if maximum registerization is > 0
-        assert (max > 0);
-
-        // Divide it by 2, fastest way to get to 0 if we have issues across the board
-        // If it is a last attempt then force setting to 0
-        // It is better to compile instead of give a last try for registerization
-        int newMax = (isLastAttempt == true) ? 0 : max / 2;
-        cUnit->maximumRegisterization = newMax;
-        ALOGI("Trying less registerization from %d to %d", max, newMax);
-    }
-
-    //Handle error due to backend
-    if (IS_JIT_ERROR_SET(kJitErrorBERegisterization)) {
-        //If registerization in the Backend is on
-        if (gDvmJit.backEndRegisterization == true) {
-
-            //Turn off registerization
-            gDvmJit.backEndRegisterization = false;
-
-            //Set maximum registerization for this cUnit to 0
-            //since we disabled registerization
-            cUnit->maximumRegisterization = 0;
-
-            //Clear the error.
-            //Registerization can cause other errors
-            //Let's clear all errors for now, and see if they
-            //re-occur without registerization.
-            CLEAR_ALL_JIT_ERRORS();
-
-            //Notify about this special action
-            ALOGI("Ignoring other issues and retrying without backend registerization");
-        }
-    }
-
-    //Handle constant initialization failure
-    if (IS_JIT_ERROR_SET(kJitErrorConstInitFail) == true) {
-        gDvmJit.disableOpt |= (1 << kElimConstInitOpt);
-        ALOGI("Resolved error due to constant initialization failure");
-        //Clear the error:
-        CLEAR_JIT_ERROR(kJitErrorConstInitFail);
-    }
-}
-
-/**
- * @brief Checks whether a compilation should be re-attempted
- * Fixes anything which can be fixed. At the end we
- * either don't have an error, have fixed the error, or
- * cannot recover from the error. For the second case, we
- * retry the compilation.
- * @param cUnit Compilation Unit context
- * @param isLastAttempt whether the next compilation attempt will be the last one
- * @return whether we can retry the trace.
- */
-bool dvmCanFixErrorsAndRetry(CompilationUnit *cUnit, bool isLastAttempt){
-    // Make sure that the error information table is synced up with the
-    // error enum JitCompilationErrors
-    assert (NELEM(gErrorInformation) == static_cast<int>(kJitErrorMaxDefined));
-
-    // Checks if any error has occurred. If not, we do not need to retry.
-    if (IS_ANY_JIT_ERROR_SET() == false) {
-        return false;
-    }
-
-    bool firstError = true;
-
-    //Get the maximum error number the system is aware of so far:
-    int maxError = static_cast<int>(kJitErrorCodegen);
-
-    // Check which errors have been raised
-    for (int errorIndex = 0; errorIndex <= maxError; errorIndex++) {
-
-        //Get the error from the table
-        JitCompilationErrors error = gErrorInformation[errorIndex].type;
-
-        if (IS_JIT_ERROR_SET(error) == true) {
-
-            // If this is the first error we are seeing, print some information
-            // to be noticeable in the logs
-            if (firstError == true) {
-                ALOGD("++++++++++++++++++++++++++++++++++++++++++++");
-                ALOGD("JIT_INFO: Issues while compiling trace  %s%s, offset %d",
-                        cUnit->method->clazz->descriptor, cUnit->method->name,
-                        cUnit->traceDesc->trace[0].info.frag.startOffset);
-
-                // If kJitErrorCodegen is the first error we encounter,
-                // somebody forgot to raise an error flag somewhere.
-                // Otherwise, we should clear the flag because another
-                // non-generic message will be printed out.
-                if (error != kJitErrorCodegen) {
-                    CLEAR_JIT_ERROR(kJitErrorCodegen);
-                }
-
-                firstError = false;
-            }
-
-            // Paranoid. Make sure we actually found an entry
-            assert (errorIndex < NELEM(gErrorInformation));
-
-            // Find out if error is fatal
-            bool fatalError = gErrorInformation[errorIndex].isFatal;
-
-            // If we are set to abort on error and error cannot be resolved, then
-            // the error is fatal.
-            fatalError = (fatalError == true) ||
-                            (gDvmJit.abortOnCompilerError == true
-                                && gErrorInformation[errorIndex].canResolve == false);
-
-            // Print error message
-            if (fatalError == true) {
-                ALOGE("\t%s",
-                        gErrorInformation[errorIndex].errorMessage);
-                ALOGE("FATAL_ERRORS in JIT. Aborting compilation.");
-                dvmCompilerAbort(cUnit);
-            }
-            else {
-                ALOGD("\t%s",
-                        gErrorInformation[errorIndex].errorMessage);
-            }
-        }
-    }
-
-    // Handle any errors which can be resolved
-    resolveErrors(cUnit, isLastAttempt);
-
-    // If we have no errors set at this point, we have successfully resolved
-    // them and thus we can retry the trace now.
-    if (IS_ANY_JIT_ERROR_SET() == false){
-        ALOGD("JIT_INFO: Retrying trace %s%s, offset %d", cUnit->method->clazz->descriptor,
-                cUnit->method->name, cUnit->traceDesc->trace[0].info.frag.startOffset);
-        ALOGD("++++++++++++++++++++++++++++++++++++++++++++");
-        return true;
-    }
-
-    // Otherwise, error cannot be handled or does not have a handler
-    ALOGD("JIT_INFO: Terminating trace due to unresolved issues");
-    ALOGD("++++++++++++++++++++++++++++++++++++++++++++");
-
-    return false;
-}
-
-void dvmSaveOptimizationState(SErrorCompilationState &info) {
-    info.disableOpt = gDvmJit.disableOpt;
-    info.backEndRegisterization = gDvmJit.backEndRegisterization;
-}
-
-void dvmRestoreCompilationState(SErrorCompilationState &info) {
-    gDvmJit.disableOpt = info.disableOpt;
-    gDvmJit.backEndRegisterization = info.backEndRegisterization;
-}
diff --git a/vm/compiler/codegen/x86/lightcg/CodegenErrors.h b/vm/compiler/codegen/x86/lightcg/CodegenErrors.h
deleted file mode 100644
index e5dfc79..0000000
--- a/vm/compiler/codegen/x86/lightcg/CodegenErrors.h
+++ /dev/null
@@ -1,173 +0,0 @@
-/*
- * Copyright (C) 2012-2013 Intel Corporation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/**
- * @enum JitCompilationErrors
- * @brief Possible errors which can happen during compilation
- * Values indicate bit position in DvmJitGlobals.jitErrorFlags + 1
- * IMPORTANT: Update jitErrorMessages when making changes to this list
- */
-
-#ifndef CODEGEN_X86_CODEGEN_ERRORS_H_
-#define CODEGEN_X86_CODEGEN_ERRORS_H_
-
-#include "Dalvik.h"
-#include "../../CompilerIR.h"
-
-/**
- * @brief Keep any information that can be changed by the error framework
- */
-typedef struct sErrorCompilationState {
-    int disableOpt;                 /**< @brief Disable the optimizations */
-    bool backEndRegisterization;    /**< @brief Backend registerization */
-}SErrorCompilationState;
-
-/**
- * @class ErrorFlags
- */
-enum JitCompilationErrors {
-    /** @brief Exceeded maximum allowed VRs in a basic block */
-    kJitErrorMaxVR = 0,
-    /** @brief 8-bit jump offset not enough to reach label */
-    kJitErrorShortJumpOffset,
-    /** @brief Trace contains a bytecode with no JIT implementation */
-    kJitErrorUnsupportedBytecode,
-    /** @brief Field ptr unresolved for SGET/SPUT bytecodes */
-    kJitErrorUnresolvedField,
-    /** @brief Cannot find BasicBlock_O1 corresponding to a BasicBlock */
-    kJitErrorInvalidBBId,
-    /** @brief JIT code cache is full */
-    kJitErrorCodeCacheFull,
-    /** @brief Failures while allocating registers or error
-     *  in locating / putting registers in register tables
-     */
-    kJitErrorRegAllocFailed,
-    /** @brief Malloc failed. */
-    kJitErrorMallocFailed,
-    /** @brief Exceeded maximum number of transfer points per BB */
-    kJitErrorMaxXferPoints,
-    /** @brief Exceeded number of destination regs for a source reg */
-    kJitErrorMaxDestRegPerSource,
-    /** @brief Problem with state transfer in JIT */
-    kJitErrorStateTransfer,
-    /** @brief General trace formation issues */
-    kJitErrorTraceFormation,
-    /** @brief Errors while performing Null and Bound checks */
-    kJitErrorNullBoundCheckFailed,
-    /** @brief Errors while merging LiveRanges */
-    kJitErrorMergeLiveRange,
-    /** @brief Errors while accessing global data */
-    kJitErrorGlobalData,
-    /** @brief Errors while scheduling instructions */
-    kJitErrorInsScheduling,
-    /** @brief Errors due to backend registerization */
-    kJitErrorBERegisterization,
-    /** @brief Errors due to spilling logical registers */
-    kJitErrorSpill,
-    /** @brief Set when a basic block is reject by backend */
-    kJitErrorBBCannotBeHandled,
-    /** @brief Errors while performing double/long constant initialization */
-    kJitErrorConstInitFail,
-    /** @brief Error while generating chaining cell */
-    kJitErrorChainingCell,
-    /** @brief Invalid operand size */
-    kJitErrorInvalidOperandSize,
-    /** @brief Problem with the plugin system */
-    kJitErrorPlugin,
-    /** @brief Unhandled case during constant folding */
-    kJitErrorConstantFolding,
-    /** @brief Unknown chaining block type seen in PCG GL */
-    kJitErrorPcgUnknownChainingBlockType,
-    /** @brief Unexpected data type seen in PCG GL */
-    kJitErrorPcgUnexpectedDataType,
-    /** @brief Unsupported call data type in PCG GL */
-    kJitErrorPcgUnsupportedCallDataType,
-    /** @brief The post-invoke entry block was not found */
-    kJitErrorPcgPostInvokeEntryNotFound,
-    /** @brief Unsupported case for vectorization */
-    kJitErrorUnsupportedVectorization,
-    /** @brief Unsupported x86 instruction on architecture */
-    kJitErrorUnsupportedInstruction,
-
-    /* ----- Add more errors above ---------------------------
-     * ----- Don't add new errors beyond this point ----------
-     * When adding more errors, update error information table
-     * in CodegenErrors.cpp
-     */
-
-    /** @brief Indicates "some" error happened
-     * Specifically, the purpose is that if someone forgets
-     * to use SET_JIT_ERROR at the specific error location,
-     * but does throw a return, the function handling that
-     * return can set this generic error. Also useful if a
-     * function can set multiple errors, the calling function
-     * won't have to worry about which one to set. Hopefully
-     * all of the errors have been individually set too.
-     * THIS NEEDS TO BE THE SECOND LAST VALUE
-     */
-    kJitErrorCodegen,
-    /** @brief Guarding value
-     * THIS NEEDS TO BE THE LAST VALUE
-     */
-    kJitErrorMaxDefined
-};
-
-/*
- * Getter / Setter for  JitCompilationErrors
- */
-/* Sets a particular error */
-#define SET_JIT_ERROR(jit_error)  gDvmJit.jitErrorFlags |= (1 << (int) jit_error);
-
-/* Clears only a particular error */
-#define CLEAR_JIT_ERROR(jit_error) gDvmJit.jitErrorFlags &= ~(1 << (int) jit_error);                                                                                    \
-
-/* Checks if a particular error is set */
-#define IS_JIT_ERROR_SET(jit_error) ( (gDvmJit.jitErrorFlags & (1 << (int) jit_error)) != 0 )
-
-/* Clears all errors */
-#define CLEAR_ALL_JIT_ERRORS() gDvmJit.jitErrorFlags = 0;                                                                                  \
-
-/* Checks if ANY error is set */
-#define IS_ANY_JIT_ERROR_SET() (gDvmJit.jitErrorFlags != 0)
-
-/* Max retries limits the number of retries for a given trace, used in CodegenInterface.cpp */
-#define MAX_RETRIES 2
-
-/**
- * @brief Checks whether a compilation should be re-attempted
- * Fixes anything which can be fixed. At the end we
- * either don't have an error, have fixed the error, or
- * cannot recover from the error. For the second case, we
- * retry the compilation.
- * @param cUnit Compilation Unit context
- * @param isLastAttempt whether the next compilation attempt will be the last one
- * @return whether we can retry the trace.
- */
-bool dvmCanFixErrorsAndRetry(CompilationUnit *cUnit, bool isLastAttempt);
-
-/**
- * @brief Save the error flags that can be changed by dvmCanFixErrorsAndRetry
- * @param info the information relating to flags that can be changed by the framework (updated by the function)
- */
-void dvmSaveOptimizationState(SErrorCompilationState &info);
-
-/**
- * @brief Restore compilation state
- * @param info the state we want to reset to
- */
-void dvmRestoreCompilationState(SErrorCompilationState &info);
-
-#endif
diff --git a/vm/compiler/codegen/x86/lightcg/CodegenInterface.cpp b/vm/compiler/codegen/x86/lightcg/CodegenInterface.cpp
index fa53889..cf23fb3 100644
--- a/vm/compiler/codegen/x86/lightcg/CodegenInterface.cpp
+++ b/vm/compiler/codegen/x86/lightcg/CodegenInterface.cpp
@@ -14,6 +14,7 @@
  * limitations under the License.
  */
 #include <sys/mman.h>
+#include "CompilationErrorLCG.h"
 #include "CompilationUnit.h"
 #include "Dalvik.h"
 #include "libdex/DexOpcodes.h"
@@ -28,7 +29,6 @@
 #include "Singleton.h"
 #include "ExceptionHandling.h"
 #include "Scheduler.h"
-#include "CodegenErrors.h"
 #include "Profile.h"
 
 #ifdef HAVE_ANDROID_OS
@@ -2068,14 +2068,11 @@ static void createSwitchTable(CompilationUnit_O1 *cUnit)
     stream = reinterpret_cast<char *>(ptr);
 }
 
-//! \brief Lower middle-level IR ro low-level IR
-//!
-//! \details Entry function to invoke the backend of the JIT compiler
-//!
-//! \param cUnit: The current compilation unit
-//! \param info: JitTranslationInfo. Holds generated code address on success
-static void compilerMIR2LIRJit(CompilationUnit_O1 *cUnit, JitTranslationInfo *info)
+void dvmCompilerLCGMIR2LIR (CompilationUnit *cUnitME, JitTranslationInfo *info)
 {
+    //Get the CompilationUnit_O1
+    CompilationUnit_O1 *cUnit = static_cast<CompilationUnit_O1 *> (cUnitME);
+
     //Used to determine whether we need a fallthrough jump
     BasicBlock *nextFallThrough = 0;
     // Define the code_block_table for tracking various type of code blocks
@@ -2159,8 +2156,8 @@ static void compilerMIR2LIRJit(CompilationUnit_O1 *cUnit, JitTranslationInfo *in
             int retCode = preprocessingBB (cUnit, bb);
 
             if (retCode < 0) {
-                endOfTrace (cUnit);
                 SET_JIT_ERROR(kJitErrorCodegen);
+                endOfTrace (cUnit);
                 return;
             }
         }
@@ -2416,7 +2413,7 @@ static void compilerMIR2LIRJit(CompilationUnit_O1 *cUnit, JitTranslationInfo *in
         // We hit code cache size limit either after dumping exception handling
         // state or after calling endOfTrace. Bail out for this trace!
         ALOGI("JIT_INFO: Code cache full after endOfTrace (trace uses %uB)", (stream - streamStart));
-        SET_JIT_ERROR(kJitErrorCodeCacheFull);
+        SET_JIT_ERROR_MANUAL (cUnit, kJitErrorCodeCacheFull);
         PROTECT_CODE_CACHE(stream, unprotected_code_cache_bytes);
         code_block_table.clear();
         return;
@@ -2433,7 +2430,7 @@ static void compilerMIR2LIRJit(CompilationUnit_O1 *cUnit, JitTranslationInfo *in
         // if the size of the trace exceeds the code cache limit
         if(gDvmJit.codeCacheByteUsed +  (streamAfterSwitchTable - streamStart)  + CODE_CACHE_PADDING > gDvmJit.codeCacheSize) {
             ALOGI("JIT_INFO: Code cache full after switch table section (trace uses %uB)", (stream - streamStart));
-            SET_JIT_ERROR(kJitErrorCodeCacheFull);
+            SET_JIT_ERROR_MANUAL (cUnit, kJitErrorCodeCacheFull);
             gDvmJit.codeCacheFull = true;
             endOfTrace(cUnit);
             PROTECT_CODE_CACHE(stream, unprotected_code_cache_bytes);
@@ -2458,7 +2455,7 @@ static void compilerMIR2LIRJit(CompilationUnit_O1 *cUnit, JitTranslationInfo *in
     cUnit->totalSize = (stream - streamStart);
     if(gDvmJit.codeCacheByteUsed + cUnit->totalSize + CODE_CACHE_PADDING > gDvmJit.codeCacheSize) {
         ALOGI("JIT_INFO: Code cache full after ChainingCellCounts (trace uses %uB)", (stream - streamStart));
-        SET_JIT_ERROR(kJitErrorCodeCacheFull);
+        SET_JIT_ERROR_MANUAL (cUnit, kJitErrorCodeCacheFull);
         gDvmJit.codeCacheFull = true;
         PROTECT_CODE_CACHE(stream, unprotected_code_cache_bytes);
         code_block_table.clear();
@@ -2481,7 +2478,7 @@ static void compilerMIR2LIRJit(CompilationUnit_O1 *cUnit, JitTranslationInfo *in
     /* Check if the trace installation will cause the code cache full */
     if(gDvmJit.codeCacheByteUsed + cUnit->totalSize + CODE_CACHE_PADDING > gDvmJit.codeCacheSize) {
         ALOGI("JIT_INFO: Code cache full after Trace Description (trace uses %uB)", (stream - streamStart));
-        SET_JIT_ERROR(kJitErrorCodeCacheFull);
+        SET_JIT_ERROR_MANUAL (cUnit, kJitErrorCodeCacheFull);
         gDvmJit.codeCacheFull = true;
         cUnit->baseAddr = NULL;
         PROTECT_CODE_CACHE(stream, unprotected_code_cache_bytes);
@@ -2509,7 +2506,7 @@ static void compilerMIR2LIRJit(CompilationUnit_O1 *cUnit, JitTranslationInfo *in
         //  Sum of bytes used in code cache, constant data section should be lower than code cache size
         if((gDvmJit.codeCacheByteUsed + (streamEnd - streamStart)) > gDvmJit.codeCacheSize) {
             ALOGI("JIT_INFO: Code cache full after ChainingCellCounts and constant data section");
-            SET_JIT_ERROR(kJitErrorCodeCacheFull);
+            SET_JIT_ERROR_MANUAL (cUnit, kJitErrorCodeCacheFull);
             gDvmJit.codeCacheFull = true;
             cUnit->baseAddr = NULL;
             PROTECT_CODE_CACHE(stream, unprotected_code_cache_bytes);
@@ -2525,7 +2522,7 @@ static void compilerMIR2LIRJit(CompilationUnit_O1 *cUnit, JitTranslationInfo *in
 
         if (patchCount < 0) {// if patchCount is less than 0, trigger error recovery
             ALOGI("JIT_INFO: Constant init opt could not patch all required locations");
-            SET_JIT_ERROR(kJitErrorConstInitFail);
+            SET_JIT_ERROR_MANUAL (cUnit, kJitErrorConstInitFail);
             cUnit->baseAddr = NULL;
             cUnit->constListHead = NULL;
             return;
@@ -2564,69 +2561,6 @@ static void compilerMIR2LIRJit(CompilationUnit_O1 *cUnit, JitTranslationInfo *in
 #endif
 }
 
-//! \brief Helper function to call compilerMIR2LIRJit
-//!
-//! \details Calls dvmCompilerMIR2LIRJit, checks for errors
-//! and retries if possible.
-//!
-//! \param cUnit: The current compilation unit
-//! \param info: JitTranslationInfo.
-void dvmCompilerMIR2LIR(CompilationUnit *cUnit, JitTranslationInfo *info) {
-
-    //Make a x86 version of our CompilationUnit
-    CompilationUnit_O1 &x86CUnit = *static_cast<CompilationUnit_O1*>(cUnit);
-
-   //Save the optimization state to restore it at the end of this compilation
-   SErrorCompilationState compilationState;
-   dvmSaveOptimizationState (compilationState);
-
-   //Start the counter
-   int numTries = 0;
-   bool isLastAttempt = false;
-
-   //Try to lower MIR
-   do {
-        //See if we have been here too many times:
-        if (numTries > MAX_RETRIES) {
-
-            //Abort if the flag is set.
-            if (gDvmJit.abortOnCompilerError == true) {
-                ALOGE("Too many retries for trace  %s%s, offset %d", cUnit->method->clazz->descriptor,
-                        cUnit->method->name, cUnit->traceDesc->trace[0].info.frag.startOffset);
-
-                //This will cause a full abort due to the flag
-                dvmCompilerAbort(cUnit);
-            }
-
-            ALOGD("Too many retries while compiling trace  %s%s, offset %d", cUnit->method->clazz->descriptor,
-                    cUnit->method->name, cUnit->traceDesc->trace[0].info.frag.startOffset);
-            ALOGD("Rejecting Trace");
-
-            //Restore the compilation state
-            dvmRestoreCompilationState (compilationState);
-            //Make sure 'NULL' will be returned as compilation result
-            cUnit->baseAddr = NULL;
-            info->codeAddress = NULL;
-            return;
-        }
-
-        //Ignore errors in previous compilations
-        CLEAR_ALL_JIT_ERRORS();
-
-        //Do the trace compilation
-        numTries++;
-        compilerMIR2LIRJit(&x86CUnit, info);
-
-        //Once done, see if errors happened, and if so
-        //see if we can retry and come back
-        isLastAttempt = numTries == MAX_RETRIES;
-    } while (IS_ANY_JIT_ERROR_SET() && dvmCanFixErrorsAndRetry(&x86CUnit, isLastAttempt));
-
-   //Restore the compilation state
-   dvmRestoreCompilationState (compilationState);
-}
-
-
 /*
  * Perform translation chain operation.
  */
@@ -2825,7 +2759,7 @@ bool dvmCompilerFindRegClass (MIR *mir, int vR, RegisterClass &regClass, bool on
     return true;
 }
 
-BasicBlock *x86StandAloneArchSpecificNewBB (void)
+BasicBlock *dvmCompilerLCGNewBB (void)
 {
     // Make space on arena for this BB
     void * space = dvmCompilerNew(sizeof(BasicBlock_O1), true);
@@ -2839,7 +2773,7 @@ BasicBlock *x86StandAloneArchSpecificNewBB (void)
     return newBB;
 }
 
-void x86StandAloneArchSpecificDumpBB (CompilationUnit *cUnit, BasicBlock *bb, FILE *file, bool beforeMIRs)
+void dvmCompilerLCGDumpBB (CompilationUnit *cUnit, BasicBlock *bb, FILE *file, bool beforeMIRs)
 {
     // We have already created the x86 specific BB so cast is okay
     BasicBlock_O1 * curBB = reinterpret_cast<BasicBlock_O1 *>(bb);
@@ -2860,3 +2794,17 @@ bool dvmCompilerDataStructureSizeCheck(int dvmJitGlobalsSize)
 {
     return (dvmJitGlobalsSize == sizeof(DvmJitGlobals));
 }
+
+CompilationErrorHandler *dvmCompilerLCGNewCompilationErrorHandler (void)
+{
+    CompilationErrorHandlerLCG *res;
+
+    //Make space for it
+    void *space = dvmCompilerNew (sizeof (*res), true);
+
+    //Ensure the constructor is called
+    res = new (space) CompilationErrorHandlerLCG ();
+
+    //Return it
+    return res;
+}
diff --git a/vm/compiler/codegen/x86/lightcg/CompilationErrorLCG.cpp b/vm/compiler/codegen/x86/lightcg/CompilationErrorLCG.cpp
new file mode 100644
index 0000000..f165355
--- /dev/null
+++ b/vm/compiler/codegen/x86/lightcg/CompilationErrorLCG.cpp
@@ -0,0 +1,157 @@
+/*
+ * Copyright (C) 2013 Intel Corporation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "CompilationErrorLCG.h"
+#include "CompilationUnit.h"
+#include "Lower.h"
+
+/**
+ * @brief Table that stores information about errors defined in JitCompilationErrors
+ */
+START_ERRORS
+    NEW_ERROR (kJitErrorMaxVR,                "Exceeded maximum allowed VRs in a basic block.",               false, false),
+    NEW_ERROR (kJitErrorShortJumpOffset,      "Jump offset greater than 8-bits.",                              true, false),
+    NEW_ERROR (kJitErrorUnresolvedField,      "Trace contains SGET / SPUT bytecode with unresolved field.",   false, false),
+    NEW_ERROR (kJitErrorInvalidBBId,          "Cannot find BasicBlock_O1 corresponding to a BasicBlock.",     false, false),
+    NEW_ERROR (kJitErrorRegAllocFailed,       "Failure in register allocator or register tables.",            false, false),
+    NEW_ERROR (kJitErrorMallocFailed,         "Malloc failure during trace compilation.",                      false, true),
+    NEW_ERROR (kJitErrorMaxXferPoints,        "Exceeded maximum number of transfer points per BB.",           false, false),
+    NEW_ERROR (kJitErrorMaxDestRegPerSource,  "Exceeded number of destination regs for a source reg.",        false, false),
+    NEW_ERROR (kJitErrorStateTransfer,        "Problem with state transfer in JIT.",                          false, false),
+    NEW_ERROR (kJitErrorTraceFormation,       "Problem with trace formation.",                                false, false),
+    NEW_ERROR (kJitErrorNullBoundCheckFailed, "Problem while performing null or bound check.",                false, false),
+    NEW_ERROR (kJitErrorMergeLiveRange,       "Problem while merging live ranges  (mergeLiveRange).",          false, false),
+    NEW_ERROR (kJitErrorGlobalData,           "Global data not defined.",                                     false, false),
+    NEW_ERROR (kJitErrorInsScheduling,        "Problem during instruction scheduling.",                       false, false),
+    NEW_ERROR (kJitErrorBERegisterization,    "Issue registerizing the trace in the backend.",                 true, false),
+    NEW_ERROR (kJitErrorSpill,                "The trace provoked a spill.",                                   true, false),
+    NEW_ERROR (kJitErrorBBCannotBeHandled,    "The backend decided it cannot safely handle the Basic Block.", false, false),
+    NEW_ERROR (kJitErrorConstInitFail,        "Patching of Double/Long constants failed.",                     true, false),
+    NEW_ERROR (kJitErrorChainingCell,         "An issue was encountered while generating chaining cell.",     false, false),
+    NEW_ERROR (kJitErrorInvalidOperandSize,   "Invalid Operand Size was encountered.",                        false, false),
+    NEW_ERROR (kJitErrorPlugin,               "Problem with the plugin system.",                              false, false),
+    NEW_ERROR (kJitErrorConstantFolding,      "Constant folding failed due to unhandled case.",               false, false),
+    NEW_ERROR (kJitErrorCodegen,              "Undefined issues in trace formation.",                         false, false),
+END_ERRORS
+
+
+//CompilationErrorHandlerLCG implementation is below
+
+
+void CompilationErrorHandlerLCG::resolveError (CompilationUnit *cUnit, const CompilationError *error)
+{
+    //If the error isn't kJitErrorCodegen, we can clear it here
+    // However: If kJitErrorCodegen is the first error we encounter, somebody forgot to raise an error flag somewhere.
+    // Otherwise, we should clear the flag because another non-generic message will be printed out.
+    if (error->type != kJitErrorCodegen)
+    {
+        clearError (kJitErrorCodegen);
+    }
+
+    switch (error->type)
+    {
+        case kJitErrorShortJumpOffset:
+            gDvmJit.disableOpt |= (1 << kShortJumpOffset);
+            ALOGI ("JIT_INFO: Successfully resolved short jump offset issue");
+            //Clear the error:
+            clearError (kJitErrorShortJumpOffset);
+            break;
+
+        case kJitErrorSpill:
+            {
+                //Clear the error:
+                clearError (kJitErrorSpill);
+
+                //Ok we are going to see if we are registerizing something
+                int max = cUnit->maximumRegisterization;
+
+                // We should only get this error if maximum registerization is > 0
+                assert (max > 0);
+
+                // Divide it by 2, fastest way to get to 0 if we have issues across the board
+                // If it is a last attempt then force setting to 0
+                // It is better to compile instead of give a last try for registerization
+                int newMax = (getTopRetryCount () == 0) ? 0 : max / 2;
+                cUnit->maximumRegisterization = newMax;
+                ALOGI ("Trying less registerization from %d to %d", max, newMax);
+            }
+            break;
+
+        case kJitErrorBERegisterization:
+            //If registerization in the Backend is on
+            if (gDvmJit.backEndRegisterization == true) {
+
+                //Turn off registerization
+                gDvmJit.backEndRegisterization = false;
+
+                //Set maximum registerization for this cUnit to 0
+                //since we disabled registerization
+                cUnit->maximumRegisterization = 0;
+
+                //Clear the error.
+                //Registerization can cause other errors
+                //Let's clear all errors for now, and see if they
+                //re-occur without registerization.
+                clearErrors ();
+
+                //Notify about this special action
+                ALOGI ("Ignoring other issues and retrying without backend registerization");
+            }
+            break;
+
+        case kJitErrorConstInitFail:
+            gDvmJit.disableOpt |= (1 << kElimConstInitOpt);
+            ALOGI ("Resolved error due to constant initialization failure");
+            //Clear the error:
+            clearError (kJitErrorConstInitFail);
+            break;
+
+        default:
+            //We don't know about it but the X86 might might
+            CompilationErrorHandlerX86::resolveError (cUnit, error);
+            break;
+    }
+}
+
+unsigned int CompilationErrorHandlerLCG::getMaximumErrors (void) const
+{
+    //Take the minimum of the size of the array and kJitErrorMaxME but without the offset of the ME's enumeration
+    unsigned int enumMax = kJitErrorMaxDefinedLCG - kJitFirstErrorLCG;
+    unsigned int arrayMax = sizeof (gErrorInformation) / sizeof (gErrorInformation[0]);
+    unsigned int min = (enumMax < arrayMax) ? enumMax : arrayMax;
+
+    //Now add back the ME's enumeration
+    return min + kJitFirstErrorLCG;
+}
+
+const CompilationError *CompilationErrorHandlerLCG::getError (unsigned int index) const
+{
+    //Check the index
+    if (index < kJitFirstErrorLCG)
+    {
+        //Not ours, send it to our parent
+        return CompilationErrorHandlerX86::getError (index);
+    }
+
+    //Is it too much?
+    if (index >= kJitErrorMaxDefinedLCG)
+    {
+        return 0;
+    }
+
+    //Safe to hit the index with the delta
+    return gErrorInformation + (index - kJitFirstErrorLCG);
+}
diff --git a/vm/compiler/codegen/x86/lightcg/CompilationErrorLCG.h b/vm/compiler/codegen/x86/lightcg/CompilationErrorLCG.h
new file mode 100644
index 0000000..8fad575
--- /dev/null
+++ b/vm/compiler/codegen/x86/lightcg/CompilationErrorLCG.h
@@ -0,0 +1,151 @@
+/*
+ * Copyright (C) 2013 Intel Corporation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef DALVIK_VM_COMPILATIONERRORLCG_H_
+#define DALVIK_VM_COMPILATIONERRORLCG_H_
+
+#include "CompilationErrorX86.h"
+#include "Dalvik.h"
+
+//Macros used in order to limit the changes to the BE
+#define SET_JIT_ERROR_MANUAL(X,Y) \
+    do \
+    {\
+        if (X != 0) \
+        { \
+            X->errorHandler->setError (Y); \
+        } \
+        else \
+        { \
+            /* Make if fail in assert world */ \
+            assert (0); \
+            ALOGD ("JIT_INFO: Setting an error flag without context"); \
+        } \
+    } while (0)
+
+#define SET_JIT_ERROR(X) SET_JIT_ERROR_MANUAL (gCompilationUnit, X)
+#define IS_ANY_JIT_ERROR_SET(X) gCompilationUnit->errorHandler->isAnyErrorSet ()
+#define CLEAR_ALL_JIT_ERRORS(X) gCompilationUnit->errorHandler->clearErrors ()
+
+/**
+ * @enum JitLCGCompilationErrors
+ * @brief Possible errors which can happen during compilation
+ */
+enum JitLCGCompilationErrors {
+    /** @brief First extended error */
+    kJitFirstErrorLCG = kJitErrorMaxDefinedX86,
+    /** @brief Exceeded maximum allowed VRs in a basic block */
+    kJitErrorMaxVR = kJitFirstErrorLCG,
+    /** @brief 8-bit jump offset not enough to reach label */
+    kJitErrorShortJumpOffset,
+    /** @brief Field ptr unresolved for SGET/SPUT bytecodes */
+    kJitErrorUnresolvedField,
+    /** @brief Cannot find BasicBlock_O1 corresponding to a BasicBlock */
+    kJitErrorInvalidBBId,
+    /** @brief Failures while allocating registers or error
+     *  in locating / putting registers in register tables
+     */
+    kJitErrorRegAllocFailed,
+    /** @brief Malloc failed. */
+    kJitErrorMallocFailed,
+    /** @brief Exceeded maximum number of transfer points per BB */
+    kJitErrorMaxXferPoints,
+    /** @brief Exceeded number of destination regs for a source reg */
+    kJitErrorMaxDestRegPerSource,
+    /** @brief Problem with state transfer in JIT */
+    kJitErrorStateTransfer,
+    /** @brief General trace formation issues */
+    kJitErrorTraceFormation,
+    /** @brief Errors while performing Null and Bound checks */
+    kJitErrorNullBoundCheckFailed,
+    /** @brief Errors while merging LiveRanges */
+    kJitErrorMergeLiveRange,
+    /** @brief Errors while accessing global data */
+    kJitErrorGlobalData,
+    /** @brief Errors while scheduling instructions */
+    kJitErrorInsScheduling,
+    /** @brief Errors due to backend registerization */
+    kJitErrorBERegisterization,
+    /** @brief Errors due to spilling logical registers */
+    kJitErrorSpill,
+    /** @brief Set when a basic block is reject by backend */
+    kJitErrorBBCannotBeHandled,
+    /** @brief Errors while performing double/long constant initialization */
+    kJitErrorConstInitFail,
+    /** @brief Error while generating chaining cell */
+    kJitErrorChainingCell,
+    /** @brief Invalid operand size */
+    kJitErrorInvalidOperandSize,
+    /** @brief Problem with the plugin system */
+    kJitErrorPlugin,
+    /** @brief Unhandled case during constant folding */
+    kJitErrorConstantFolding,
+
+    /* ----- Add more errors above ---------------------------
+     * ----- Don't add new errors beyond this point ----------
+     * When adding more errors, update error information table
+     * in CodegenErrors.cpp
+     */
+
+    /** @brief Indicates "some" error happened
+     * Specifically, the purpose is that if someone forgets
+     * to use error setting at the specific error location,
+     * but does throw a return, the function handling that
+     * return can set this generic error. Also useful if a
+     * function can set multiple errors, the calling function
+     * won't have to worry about which one to set. Hopefully
+     * all of the errors have been individually set too.
+     *
+     * This should be the last error
+     */
+    kJitErrorCodegen,
+
+    /** @brief Guarding value
+     * THIS NEEDS TO BE THE LAST VALUE
+     */
+    kJitErrorMaxDefinedLCG
+};
+
+/**
+ * @class CompilationErrorHandlerLCG
+ * @brief The compilation error framework for the LightCG
+ */
+class CompilationErrorHandlerLCG: public CompilationErrorHandlerX86
+{
+    public:
+
+        /**
+         * @brief Returns the maximum number of errors
+         * @return the maximum number of errors
+         */
+        virtual unsigned int getMaximumErrors (void) const;
+
+        /**
+         * @brief Get a JitCompilationError
+         * @param index the index we are interested in
+         * @return a pointer to the corresponding JitCompilationError or 0 if invalid
+         */
+        virtual const CompilationError *getError (unsigned int index) const;
+
+        /**
+         * @brief Resolve the errors
+         * @param cUnit the CompilationUnit
+         * @param error the error we wish to handle
+         */
+        virtual void resolveError (CompilationUnit *cUnit, const CompilationError *error);
+};
+
+#endif
diff --git a/vm/compiler/codegen/x86/lightcg/ExceptionHandling.cpp b/vm/compiler/codegen/x86/lightcg/ExceptionHandling.cpp
index 049c17f..3147197 100644
--- a/vm/compiler/codegen/x86/lightcg/ExceptionHandling.cpp
+++ b/vm/compiler/codegen/x86/lightcg/ExceptionHandling.cpp
@@ -19,6 +19,8 @@
  * @brief Implements interfaces and utilities used for managed exception handling.
  */
 
+#include "CompilationErrorLCG.h"
+#include "CompilationUnit.h"
 #include "Lower.h"
 #include "ExceptionHandling.h"
 #include "NcgAot.h"
diff --git a/vm/compiler/codegen/x86/lightcg/InstructionGeneration.cpp b/vm/compiler/codegen/x86/lightcg/InstructionGeneration.cpp
index 2dc238f..8c76d1c 100644
--- a/vm/compiler/codegen/x86/lightcg/InstructionGeneration.cpp
+++ b/vm/compiler/codegen/x86/lightcg/InstructionGeneration.cpp
@@ -14,6 +14,8 @@
  * limitations under the License.
  */
 
+#include "CompilationErrorLCG.h"
+#include "CompilationUnit.h"
 #include "Dalvik.h"
 #include "InstructionGeneration.h"
 #include "libdex/DexOpcodes.h"
diff --git a/vm/compiler/codegen/x86/lightcg/Lower.cpp b/vm/compiler/codegen/x86/lightcg/Lower.cpp
index 2302769..268c1fb 100644
--- a/vm/compiler/codegen/x86/lightcg/Lower.cpp
+++ b/vm/compiler/codegen/x86/lightcg/Lower.cpp
@@ -20,6 +20,7 @@
 
 */
 
+#include "CompilationErrorLCG.h"
 #include "CompilationUnit.h"
 #include "libdex/DexOpcodes.h"
 #include "libdex/DexFile.h"
diff --git a/vm/compiler/codegen/x86/lightcg/Lower.h b/vm/compiler/codegen/x86/lightcg/Lower.h
index cf46940..a8b2f93 100644
--- a/vm/compiler/codegen/x86/lightcg/Lower.h
+++ b/vm/compiler/codegen/x86/lightcg/Lower.h
@@ -48,7 +48,6 @@
 #define INVOKE_FIX //optimization
 #define GETVR_FIX //optimization
 
-#include "CodegenErrors.h"
 #include "Dalvik.h"
 #include "enc_wrapper.h"
 #include "AnalysisO1.h"
@@ -1497,20 +1496,20 @@ OpndSize estOpndSizeFromImm(int target);
 int preprocessingBB (CompilationUnit *cUnit, BasicBlock *bb);
 
 /**
- * @brief Architecture specific BasicBlock creator
+ * @brief LCG BasicBlock creator
  * @details Initializes x86 specific BasicBlock fields
  * @return newly created BasicBlock
  */
-BasicBlock *x86StandAloneArchSpecificNewBB (void);
+BasicBlock *dvmCompilerLCGNewBB (void);
 
 /**
- * @brief Architecture specific BasicBlock printing
+ * @brief LCG BasicBlock printing
  * @param cUnit the CompilationUnit
  * @param bb the BasicBlock
  * @param file the File in which to dump the BasicBlock
  * @param beforeMIRs is this call performed before generating the dumps for the MIRs
  */
-void x86StandAloneArchSpecificDumpBB (CompilationUnit *cUnit, BasicBlock *bb, FILE *file, bool beforeMIRs);
+void dvmCompilerLCGDumpBB (CompilationUnit *cUnit, BasicBlock *bb, FILE *file, bool beforeMIRs);
 
 /**
  * @brief Handle the invoke label
@@ -1519,6 +1518,12 @@ void x86StandAloneArchSpecificDumpBB (CompilationUnit *cUnit, BasicBlock *bb, FI
  */
 const char *dvmCompilerHandleInvokeArgsHeader (int value);
 
+/**
+ * @brief LCG Compilation Error Handler allocation
+ * @return the new CompilationErrorHandler
+ */
+CompilationErrorHandler *dvmCompilerLCGNewCompilationErrorHandler (void);
+
 void pushCallerSavedRegs(void);
 void popCallerSavedRegs(void);
 
@@ -1591,4 +1596,11 @@ bool vec_extract_imm_reg_reg (int index, int srcReg, bool isSrcPhysical, int des
  */
 bool dvmCompilerArchitectureSupportsSSE41 (void);
 
+/**
+ * @brief Entry point of the LCG backend
+ * @param cUnit the CompilationUnit
+ * @param info the JitTranslationInfo
+ */
+void dvmCompilerLCGMIR2LIR (CompilationUnit *cUnit, JitTranslationInfo *info);
+
 #endif
diff --git a/vm/compiler/codegen/x86/lightcg/LowerGetPut.cpp b/vm/compiler/codegen/x86/lightcg/LowerGetPut.cpp
index dad1bdf..8679d26 100644
--- a/vm/compiler/codegen/x86/lightcg/LowerGetPut.cpp
+++ b/vm/compiler/codegen/x86/lightcg/LowerGetPut.cpp
@@ -18,6 +18,8 @@
 /*! \file compiler/codegen/x86/LowerGetPut.cpp
     \brief This file lowers the following bytecodes: XGET|PUT_XXX
 */
+#include "CompilationErrorLCG.h"
+#include "CompilationUnit.h"
 #include "libdex/DexOpcodes.h"
 #include "libdex/DexFile.h"
 #include "Lower.h"
diff --git a/vm/compiler/codegen/x86/lightcg/LowerHelper.cpp b/vm/compiler/codegen/x86/lightcg/LowerHelper.cpp
index 0ffe3b1..c75057e 100644
--- a/vm/compiler/codegen/x86/lightcg/LowerHelper.cpp
+++ b/vm/compiler/codegen/x86/lightcg/LowerHelper.cpp
@@ -36,6 +36,7 @@ When allocating a physical register for an operand, we can't spill the operands
   at end of each native instruction, call endNativeCode to also reset the flags to true.
 */
 
+#include "CompilationErrorLCG.h"
 #include "CompilationUnit.h"
 #include "libdex/DexOpcodes.h"
 #include "libdex/DexFile.h"
diff --git a/vm/compiler/codegen/x86/lightcg/LowerInvoke.cpp b/vm/compiler/codegen/x86/lightcg/LowerInvoke.cpp
index e74d80e..b8b9892 100644
--- a/vm/compiler/codegen/x86/lightcg/LowerInvoke.cpp
+++ b/vm/compiler/codegen/x86/lightcg/LowerInvoke.cpp
@@ -18,6 +18,8 @@
 /*! \file LowerInvoke.cpp
     \brief This file lowers the following bytecodes: INVOKE_XXX
 */
+#include "CompilationErrorLCG.h"
+#include "CompilationUnit.h"
 #include "libdex/DexOpcodes.h"
 #include "libdex/DexFile.h"
 #include "mterp/Mterp.h"
diff --git a/vm/compiler/codegen/x86/lightcg/LowerJump.cpp b/vm/compiler/codegen/x86/lightcg/LowerJump.cpp
index 73a9a37..027acde 100644
--- a/vm/compiler/codegen/x86/lightcg/LowerJump.cpp
+++ b/vm/compiler/codegen/x86/lightcg/LowerJump.cpp
@@ -20,6 +20,7 @@
  * @file vm/compiler/codegen/x86/LowerJump.cpp
  * @brief This file lowers the following bytecodes: IF_XXX, GOTO
  */
+#include "CompilationErrorLCG.h"
 #include "CompilationUnit.h"
 #include <math.h>
 #include "libdex/DexOpcodes.h"
diff --git a/vm/compiler/codegen/x86/lightcg/NcgAot.cpp b/vm/compiler/codegen/x86/lightcg/NcgAot.cpp
index d4c01f9..9588f62 100644
--- a/vm/compiler/codegen/x86/lightcg/NcgAot.cpp
+++ b/vm/compiler/codegen/x86/lightcg/NcgAot.cpp
@@ -15,6 +15,8 @@
  */
 
 
+#include "CompilationErrorLCG.h"
+#include "CompilationUnit.h"
 #include "Lower.h"
 #include "NcgAot.h"
 #include "NcgHelper.h"
diff --git a/vm/compiler/codegen/x86/lightcg/RegisterizationBE.cpp b/vm/compiler/codegen/x86/lightcg/RegisterizationBE.cpp
index da07a8a..3ec6e1a 100644
--- a/vm/compiler/codegen/x86/lightcg/RegisterizationBE.cpp
+++ b/vm/compiler/codegen/x86/lightcg/RegisterizationBE.cpp
@@ -17,10 +17,11 @@
 #include <map>
 #include <set>
 #include <algorithm>
+#include "CompilationErrorLCG.h"
+#include "CompilationUnit.h"
 #include "Dalvik.h"
 #include "Lower.h"
 #include "AnalysisO1.h"
-#include "CodegenErrors.h"
 #include "RegisterizationBE.h"
 
 //#define DEBUG_REGISTERIZATION
diff --git a/vm/compiler/codegen/x86/lightcg/Scheduler.cpp b/vm/compiler/codegen/x86/lightcg/Scheduler.cpp
index 311dedb..3fd80bd 100644
--- a/vm/compiler/codegen/x86/lightcg/Scheduler.cpp
+++ b/vm/compiler/codegen/x86/lightcg/Scheduler.cpp
@@ -19,6 +19,8 @@
     \details Scheduling algorithm implemented is basic block scheduling.
 */
 
+#include "CompilationErrorLCG.h"
+#include "CompilationUnit.h"
 #include "Lower.h"
 #include "interp/InterpDefs.h"
 #include "Scheduler.h"
diff --git a/vm/compiler/codegen/x86/pcg/Analysis.cpp b/vm/compiler/codegen/x86/pcg/Analysis.cpp
index 673c60e..a783961 100644
--- a/vm/compiler/codegen/x86/pcg/Analysis.cpp
+++ b/vm/compiler/codegen/x86/pcg/Analysis.cpp
@@ -15,7 +15,7 @@
  */
 
 #include "Analysis.h"
-#include "CodegenErrors.h"
+#include "CompilationErrorPCG.h"
 #include "BasicBlockPCG.h"
 #include "CompilationUnitPCG.h"
 #include "Dataflow.h"
@@ -578,9 +578,8 @@ static void initGensAndKills (CompilationUnitPCG *cUnit)
                 //Paranoid
                 if (vrDefsBv == 0)
                 {
-                    //Bail using a LCG error, this will have to get changed
                     //For the moment just make it fail with the generic error
-                    SET_JIT_ERROR (kJitErrorCodegen);
+                    cUnit->errorHandler->setError (kJitErrorPcgCodegen);
 
                     //Just return because this is already a bad enough situation
                     return;
diff --git a/vm/compiler/codegen/x86/pcg/Android.mk b/vm/compiler/codegen/x86/pcg/Android.mk
index 5a83b92..35bf468 100644
--- a/vm/compiler/codegen/x86/pcg/Android.mk
+++ b/vm/compiler/codegen/x86/pcg/Android.mk
@@ -21,6 +21,7 @@ PCG_SRC_FILES := \
     Client.cpp \
     ChainingCellException.cpp \
     CodeGeneration.cpp \
+    CompilationErrorPCG.cpp \
     CompilationUnitPCG.cpp \
     Labels.cpp \
     LowerALU.cpp \
diff --git a/vm/compiler/codegen/x86/pcg/ChainingCellException.cpp b/vm/compiler/codegen/x86/pcg/ChainingCellException.cpp
index 6993a93..ba9f276 100644
--- a/vm/compiler/codegen/x86/pcg/ChainingCellException.cpp
+++ b/vm/compiler/codegen/x86/pcg/ChainingCellException.cpp
@@ -17,6 +17,7 @@
 #include "BasicBlockPCG.h"
 #include "ChainingCellException.h"
 #include "CodeGeneration.h"
+#include "CompilationErrorPCG.h"
 #include "CompilationUnitPCG.h"
 #include "CompilerIR.h"
 #include "Dataflow.h"
@@ -47,12 +48,12 @@ void dvmCompilerPcgGenerateJsrdvmJitToExceptionThrown (CompilationUnitPCG *cUnit
     CGInst parms[3] = {parmEdi, parmEbp, CGInstInvalid};
 
     //Get symbol to the dvmJitToExceptionThrown callback
-    CGSymbol callback = singletonPtr<PersistentInfo> ()->getCallBack ("dvmJitToExceptionThrown");
+    CGSymbol callback = singletonPtr<PersistentInfo> ()->getCallBack (cUnit, "dvmJitToExceptionThrown");
 
     //Paranoid
     assert (callback != 0);
 
-    dvmCompilerPcgCreateJsr(callback, parms);
+    dvmCompilerPcgCreateJsr (cUnit, callback, parms);
 }
 
 /**
@@ -84,7 +85,7 @@ static uint8_t* dvmCompilerPcgEmitSingletonChainingCell (CompilationUnitPCG *cUn
     // Make sure we don't overflow the code cache
     if (freeSpace < SINGLETON_CC_SIZE)
     {
-        SET_JIT_ERROR(kJitErrorCodeCacheFull);
+        cUnit->errorHandler->setError (kJitErrorCodeCacheFull);
         return 0;
     }
 
@@ -95,15 +96,15 @@ static uint8_t* dvmCompilerPcgEmitSingletonChainingCell (CompilationUnitPCG *cUn
 
     // This is the "real" beginning of the chaining cell.  Any branches to this
     // block should land here, so bind the symbol to this address.
-    dvmCompilerPcgBindSymbolAddress (blockSymbol, currCachePtr);
+    dvmCompilerPcgBindSymbolAddress (cUnit, blockSymbol, currCachePtr);
 
     // Now lay down the call instruction.  This is
     // "call dvmJitToInterpTraceSelect".
     *currCachePtr++ = 0xe8;
 
     //Get symbol to the dvmJitToInterpTraceSelect callback
-    CGSymbol callback = singletonPtr<PersistentInfo> ()->getCallBack ("dvmJitToInterpTraceSelect");
-    void * callbackAddress = dvmCompilerPcgGetSymbolAddress (callback);
+    CGSymbol callback = singletonPtr<PersistentInfo> ()->getCallBack (cUnit, "dvmJitToInterpTraceSelect");
+    void * callbackAddress = dvmCompilerPcgGetSymbolAddress (cUnit, callback);
 
     * ( (int32_t*)currCachePtr) = (int32_t)callbackAddress - ( (int32_t)currCachePtr + 4);
     if (cUnit->checkDebugMask (DebugMaskBytecode) == true)
@@ -179,7 +180,7 @@ static uint8_t* dvmCompilerPcgEmitPredictedChainingCell (CompilationUnitPCG *cUn
     // Make sure we don't overflow the code cache
     if (freeSpace < PREDICTED_CC_SIZE)
     {
-        SET_JIT_ERROR(kJitErrorCodeCacheFull);
+        cUnit->errorHandler->setError (kJitErrorCodeCacheFull);
         return 0;
     }
 
@@ -189,7 +190,7 @@ static uint8_t* dvmCompilerPcgEmitPredictedChainingCell (CompilationUnitPCG *cUn
     }
 
     // This is the beginning of the chaining cell. All symbol referenced will be made to this location.
-    dvmCompilerPcgBindSymbolAddress (blockSymbol, currCachePtr);
+    dvmCompilerPcgBindSymbolAddress (cUnit, blockSymbol, currCachePtr);
     int *intStream = (int *)currCachePtr;
 
     intStream[0] = PREDICTED_CHAIN_BX_PAIR_INIT;
@@ -247,7 +248,7 @@ static uint8_t* dvmCompilerPcgEmitHotChainingCell (CompilationUnitPCG *cUnit,
     // Make sure we don't overflow the code cache
     if (freeSpace < HOT_CC_SIZE)
     {
-        SET_JIT_ERROR(kJitErrorCodeCacheFull);
+        cUnit->errorHandler->setError (kJitErrorCodeCacheFull);
         return 0;
     }
 
@@ -258,14 +259,14 @@ static uint8_t* dvmCompilerPcgEmitHotChainingCell (CompilationUnitPCG *cUnit,
 
     // This is the "real" beginning of the chaining cell.  Any branches to this
     // block should land here, so bind the symbol to this address.
-    dvmCompilerPcgBindSymbolAddress (blockSymbol, currCachePtr);
+    dvmCompilerPcgBindSymbolAddress (cUnit, blockSymbol, currCachePtr);
 
     // Now lay down the call instruction.
     *currCachePtr++ = 0xe8;
 
     //Get symbol to the dvmJitToInterpTraceSelect callback
-    CGSymbol callback = singletonPtr<PersistentInfo> ()->getCallBack ("dvmJitToInterpTraceSelect");
-    void * callbackAddress = dvmCompilerPcgGetSymbolAddress (callback);
+    CGSymbol callback = singletonPtr<PersistentInfo> ()->getCallBack (cUnit, "dvmJitToInterpTraceSelect");
+    void * callbackAddress = dvmCompilerPcgGetSymbolAddress (cUnit, callback);
 
     * ( (int32_t*)currCachePtr) = (int32_t)callbackAddress - ( (int32_t)currCachePtr + 4);
 
@@ -379,7 +380,7 @@ static uint8_t* dvmCompilerPcgEmitNormalChainingCell (
     // Make sure we don't overflow the code cache
     if (freeSpace < NORMAL_CC_SIZE)
     {
-        SET_JIT_ERROR(kJitErrorCodeCacheFull);
+        cUnit->errorHandler->setError (kJitErrorCodeCacheFull);
         return 0;
     }
 
@@ -396,14 +397,14 @@ static uint8_t* dvmCompilerPcgEmitNormalChainingCell (
 
     // This is the "real" beginning of the chaining cell.  Any branches to this
     // block should land here, so bind the symbol to this address.
-    dvmCompilerPcgBindSymbolAddress (blockSymbol, currCachePtr);
+    dvmCompilerPcgBindSymbolAddress (cUnit, blockSymbol, currCachePtr);
 
     // Now lay down the call instruction.  This is "call dvmJitToInterpNormal".
     *currCachePtr++ = 0xe8;
 
     //Get symbol to the dvmJitToInterpNormal callback
-    CGSymbol callback = singletonPtr<PersistentInfo> ()->getCallBack ("dvmJitToInterpNormal");
-    void * callbackAddress = dvmCompilerPcgGetSymbolAddress (callback);
+    CGSymbol callback = singletonPtr<PersistentInfo> ()->getCallBack (cUnit, "dvmJitToInterpNormal");
+    void * callbackAddress = dvmCompilerPcgGetSymbolAddress (cUnit, callback);
 
     * ( (int32_t*)currCachePtr) = (int32_t)callbackAddress - ( (int32_t)currCachePtr + 4);
 
@@ -439,11 +440,9 @@ static uint8_t* dvmCompilerPcgEmitNormalChainingCell (
             dvmCompilerPcgCreateSymbol(switchEntryName, 0, true);
 
         // Now that we have a symbol, we can create a relocation tracker for it
-        const SClientSymbolInfo *clientSymbolInfo =
-            singletonPtr<PersistentInfo> ()->getSymbolInfo (switchEntrySymbol);
+        const SClientSymbolInfo *clientSymbolInfo = singletonPtr<PersistentInfo> ()->getSymbolInfo (cUnit, switchEntrySymbol);
         // This chaining cell is associated with a switch statement
-        CRelocation * swRelocation = CRelocation::create (
-            clientSymbolInfo, (int32_t)0, (uint32_t)currCachePtr - (uint32_t)startAddr, CGRelocationType32);
+        CRelocation * swRelocation = CRelocation::create (clientSymbolInfo, (int32_t)0, (uint32_t)currCachePtr - (uint32_t)startAddr, CGRelocationType32);
 
         // That should be sufficient to accomplish the write to this location,
         // once the switch table entry symbol gets associated with an address,
@@ -514,7 +513,7 @@ static uint8_t* dvmCompilerPcgEmitBackwardBranchChainingCell (CompilationUnitPCG
     // Make sure we don't overflow the code cache
     if (freeSpace < BACKWARD_BRANCH_CC_SIZE)
     {
-        SET_JIT_ERROR(kJitErrorCodeCacheFull);
+        cUnit->errorHandler->setError (kJitErrorCodeCacheFull);
         return 0;
     }
 
@@ -531,15 +530,15 @@ static uint8_t* dvmCompilerPcgEmitBackwardBranchChainingCell (CompilationUnitPCG
 
     // This is the "real" beginning of the chaining cell.  Any branches to this
     // block should land here, so bind the symbol to this address.
-    dvmCompilerPcgBindSymbolAddress (blockSymbol, currCachePtr);
+    dvmCompilerPcgBindSymbolAddress (cUnit, blockSymbol, currCachePtr);
 
     // Lay down the call instruction.
     // This is "call dvmJitToInterpBackwardBranch".
     *currCachePtr++ = 0xe8;
 
     //Get symbol to the dvmJitToInterpNormal callback
-    CGSymbol callback = singletonPtr<PersistentInfo> ()->getCallBack ("dvmJitToInterpBackwardBranch");
-    void * callbackAddress = dvmCompilerPcgGetSymbolAddress (callback);
+    CGSymbol callback = singletonPtr<PersistentInfo> ()->getCallBack (cUnit, "dvmJitToInterpBackwardBranch");
+    void * callbackAddress = dvmCompilerPcgGetSymbolAddress (cUnit, callback);
 
     * ( (int32_t*)currCachePtr) = (int32_t)callbackAddress -
        ( (int32_t)currCachePtr + 4);
@@ -564,9 +563,8 @@ static uint8_t* dvmCompilerPcgEmitBackwardBranchChainingCell (CompilationUnitPCG
     {
         ALOGI ("JIT INFO: PCG: writebackSymbol is not found");
 
-        //Bail using a LCG error, this will have to get changed
         //For the moment just make it fail with the generic error
-        SET_JIT_ERROR (kJitErrorCodegen);
+        cUnit->errorHandler->setError (kJitErrorPcgCodegen);
 
         //Just return because this is already a bad enough situation
         return currCachePtr;
@@ -623,7 +621,7 @@ static uint8_t* dvmCompilerPcgEmitBackwardBranchChainingCell (CompilationUnitPCG
     // Lay down the code address of the jump target that must be used in the
     // event of unchaining.  This must be the address of the writeback block
     // for this chaining cell.
-    * ( (const void**)currCachePtr) = dvmCompilerPcgGetSymbolAddress (writebackSymbol);
+    * ( (const void**)currCachePtr) = dvmCompilerPcgGetSymbolAddress (cUnit, writebackSymbol);
 
     if (cUnit->checkDebugMask (DebugMaskBytecode) == true)
     {
@@ -686,9 +684,8 @@ void dvmCompilerPcgGenerateRaiseExceptionSimple (CompilationUnitPCG *cUnit)
     //Paranoid test
     if (bb == 0)
     {
-        //Bail using a LCG error, this will have to get changed
         //For the moment just make it fail with the generic error
-        SET_JIT_ERROR (kJitErrorCodegen);
+        cUnit->errorHandler->setError (kJitErrorPcgCodegen);
 
         //Just return because this is already a bad enough situation
         return;
@@ -727,7 +724,7 @@ void dvmCompilerPcgGenerateCalldvmJitToExceptionThrown (CompilationUnitPCG *cUni
     CGInst parms[3] = {parmEdi, parmEbp, CGInstInvalid};
 
     //Get symbol to the dvmJitToExceptionThrown callback
-    CGSymbol callback = singletonPtr<PersistentInfo> ()->getCallBack ("dvmJitToExceptionThrown");
+    CGSymbol callback = singletonPtr<PersistentInfo> ()->getCallBack (cUnit, "dvmJitToExceptionThrown");
 
     //Paranoid
     assert (callback != 0);
@@ -735,7 +732,6 @@ void dvmCompilerPcgGenerateCalldvmJitToExceptionThrown (CompilationUnitPCG *cUni
     CGCreateNewInst ("call", "nl", callback, parms);
 }
 
-
 void dvmCompilerPcgGenerateNullCheck (CompilationUnitPCG *cUnit, CGInst base, MIR *mir, int ssaNum)
 {
     //First check if the ME said to ignore it
@@ -797,12 +793,12 @@ static void dvmCompilerPcgGenerateSpeculativeNullCheck (CompilationUnitPCG *cUni
     CGInst parms[3] = {parmEdi, parmEbp, CGInstInvalid};
 
     //Get symbol to the dvmJitToInterpPunt callback
-    CGSymbol callback = singletonPtr<PersistentInfo> ()->getCallBack ("dvmJitToInterpPunt");
+    CGSymbol callback = singletonPtr<PersistentInfo> ()->getCallBack (cUnit, "dvmJitToInterpPunt");
 
     //Paranoid
     assert (callback != 0);
 
-    dvmCompilerPcgCreateJsr (callback, parms);
+    dvmCompilerPcgCreateJsr (cUnit, callback, parms);
 
     CGBindLabel (nullCheckPassedLabel);
 }
@@ -853,8 +849,8 @@ void dvmCompilerPcgGenerateSpeculativeNullChecks (CompilationUnitPCG *cUnit)
             int vrOffset = dvmCompilerPcgGetVROffsetRelativeToVMPtr (cUnit, virtualReg);
             CGAddr addr = CGCreateAddr (cUnit->getVMPtr (), CGInstInvalid, 0, CGSymbolInvalid, vrOffset);
 
-            size = dvmCompilerPcgGetOpcodeAndSizeForDtype (dtype, &opcode);
-            if (IS_ANY_JIT_ERROR_SET() == true) {
+            size = dvmCompilerPcgGetOpcodeAndSizeForDtype (cUnit, dtype, &opcode);
+            if (cUnit->errorHandler->isAnyErrorSet () == true) {
                 return;
             }
 
@@ -968,7 +964,7 @@ uint8_t *dvmCompilerPcgEmitChainingCells (CompilationUnitPCG *cUnit,
 
                 default:
                     ALOGE ("\n+++ PCG ERROR +++ Unknown chaining block type seen : %d.", (int)chainingBlock->blockType);
-                    SET_JIT_ERROR(kJitErrorPcgUnknownChainingBlockType);
+                    cUnit->errorHandler->setError (kJitErrorPcgUnknownChainingBlockType);
                     assert(0);
                     return 0;
             }
@@ -976,7 +972,7 @@ uint8_t *dvmCompilerPcgEmitChainingCells (CompilationUnitPCG *cUnit,
             if (newCachePtr == 0)
             {
                 // The code cache is full.  Return 0 to indicate this.
-                SET_JIT_ERROR(kJitErrorCodeCacheFull);
+                cUnit->errorHandler->setError (kJitErrorCodeCacheFull);
                 return 0;
             }
 
@@ -1004,7 +1000,7 @@ uint8_t *dvmCompilerPcgEmitChainingCells (CompilationUnitPCG *cUnit,
     // padding.  Return 0 if not.
     if (freeSpace < padding + sizeof (pcgChainCellCounts))
     {
-        SET_JIT_ERROR(kJitErrorCodeCacheFull);
+        cUnit->errorHandler->setError (kJitErrorCodeCacheFull);
         return 0;
     }
     freeSpace -= padding + sizeof (pcgChainCellCounts);
@@ -1053,7 +1049,7 @@ uint8_t* dvmCompilerPcgEmitSwitchTables(CompilationUnitPCG *cUnit,
 
     // Make sure we have enough room in the code cache for the switch table
     if (freeSpace < a) {
-        SET_JIT_ERROR(kJitErrorCodeCacheFull);
+        cUnit->errorHandler->setError (kJitErrorCodeCacheFull);
         return 0;
     }
 
@@ -1089,8 +1085,7 @@ uint8_t* dvmCompilerPcgEmitSwitchTables(CompilationUnitPCG *cUnit,
 
         // So that the compiled switch instruction has a pointer to the switch
         // table, we need to bind the symbol to the code cache address
-        dvmCompilerPcgBindSymbolAddress (
-            bb->switchTableSymbol, currCachePtr);
+        dvmCompilerPcgBindSymbolAddress (cUnit, bb->switchTableSymbol, currCachePtr);
 
         // To set up the switch table, all we need to do is go through
         // switchChainingCellEntries and add the cache pointer to the
@@ -1104,17 +1099,13 @@ uint8_t* dvmCompilerPcgEmitSwitchTables(CompilationUnitPCG *cUnit,
 
             // Now that we know where the symbol should live, bind it, and add the
             // finalized relocation to the tracking system
-            dvmCompilerPcgBindSymbolAddress (
-                switchTableEntryRelocation->getSymbolInfo ()->cgSymbol,
-                currCachePtr);
+            dvmCompilerPcgBindSymbolAddress (cUnit, switchTableEntryRelocation->getSymbolInfo ()->cgSymbol, currCachePtr);
             cUnit->addRelocation(switchTableEntryRelocation);
 
             // And since the chaining cell locations have already been bound,
             // find that address, and put it here in the switch table entry
             * ( (const uint8_t**)currCachePtr) =
-                (const uint8_t*)
-                dvmCompilerPcgGetSymbolAddress
-                (chainingCellBlock->chainingCellSymbol);
+                (const uint8_t*) dvmCompilerPcgGetSymbolAddress (cUnit, chainingCellBlock->chainingCellSymbol);
             currCachePtr += 4;
         }
     }
diff --git a/vm/compiler/codegen/x86/pcg/Client.cpp b/vm/compiler/codegen/x86/pcg/Client.cpp
index 80b20eb..4486030 100644
--- a/vm/compiler/codegen/x86/pcg/Client.cpp
+++ b/vm/compiler/codegen/x86/pcg/Client.cpp
@@ -16,6 +16,7 @@
 
 #include <cassert>
 
+#include "CompilationErrorPCG.h"
 #include "CompilationUnitPCG.h"
 #include "libpcg.h"
 #include "PersistentInfo.h"
@@ -88,7 +89,8 @@ extern uint64_t CGGetSymbolAddressFromClient(CGSymbol symbol)
  */
 CGSymbol CGGetSymbolForNameFromClient(const char *symbolName)
 {
-    return singletonPtr<PersistentInfo> ()->getCallBack (symbolName);
+    //TODO: fix the signature of this function so it can pass the client symbol
+    return singletonPtr<PersistentInfo> ()->getCallBack (0, symbolName);
 }
 
 /**
@@ -98,7 +100,8 @@ CGSymbol CGGetSymbolForNameFromClient(const char *symbolName)
  */
 const char *CGGetSymbolNameFromClient(CGSymbol symbol)
 {
-    const SClientSymbolInfo *clientSymbolInfo = singletonPtr<PersistentInfo> ()->getSymbolInfo (symbol);
+    //TODO: fix the signature of this function so it can pass the client symbol
+    const SClientSymbolInfo *clientSymbolInfo = singletonPtr<PersistentInfo> ()->getSymbolInfo (0, symbol);
 
     //Paranoid
     assert (clientSymbolInfo != 0);
@@ -180,7 +183,7 @@ void CGAddRelocationToClient (void *clientRoutineHandle, uint64_t codeOffset, CG
     //Paranoid
     assert (cUnit != 0);
 
-    SClientSymbolInfo *clientSymbolInfo = singletonPtr<PersistentInfo> ()->getSymbolInfo (symbol);
+    SClientSymbolInfo *clientSymbolInfo = singletonPtr<PersistentInfo> ()->getSymbolInfo (cUnit, symbol);
     if (clientSymbolInfo != 0)
     {
         CRelocation *relocation = CRelocation::create (clientSymbolInfo, (int32_t)addend, (uint32_t)codeOffset, relocationType);
@@ -191,16 +194,12 @@ void CGAddRelocationToClient (void *clientRoutineHandle, uint64_t codeOffset, CG
         }
         else
         {
-            ALOGE ("\n+++ PCG ERROR +++ Could not create a relocation");
-            //TODO: use the error framework
-            exit (-1);
+            cUnit->errorHandler->setError (kJitErrorPcgRelocationCreation);
         }
     }
     else
     {
-        ALOGE ("\n+++ PCG ERROR +++ Could not find a Symbol Info");
-        //TODO: use the error framework
-        exit (-1);
+        cUnit->errorHandler->setError (kJitErrorPcgUnknownSymbol);
     }
 }
 
diff --git a/vm/compiler/codegen/x86/pcg/CodeGeneration.cpp b/vm/compiler/codegen/x86/pcg/CodeGeneration.cpp
index a08a861..4e6383a 100644
--- a/vm/compiler/codegen/x86/pcg/CodeGeneration.cpp
+++ b/vm/compiler/codegen/x86/pcg/CodeGeneration.cpp
@@ -17,8 +17,8 @@
 #include "Analysis.h"
 #include "BasicBlockPCG.h"
 #include "ChainingCellException.h"
-#include "CodegenErrors.h"
 #include "CodeGeneration.h"
+#include "CompilationErrorPCG.h"
 #include "CompilationUnitPCG.h"
 #include "CompilerIR.h"
 #include "Dataflow.h"
@@ -834,10 +834,10 @@ static bool dvmCompilerPcgTranslateInsn (CompilationUnitPCG *cUnit, MIR *mir)
                     dvmCompilerGetOpcodeName (dalvikOpCode), dalvikOpCode);
             LOGE ("Jit (PCG): unsupported MIR opcode");
             assert (0);
-            SET_JIT_ERROR(kJitErrorUnsupportedBytecode);
+            cUnit->errorHandler->setError (kJitErrorUnsupportedBytecode);
     }
 
-    if (IS_ANY_JIT_ERROR_SET() == true)
+    if (cUnit->errorHandler->isAnyErrorSet () == true)
     {
         return false;
     }
@@ -1135,12 +1135,12 @@ static bool dvmCompilerPcgTranslateBB (CompilationUnitPCG *cUnit, BasicBlockPCG
                 CGInst parms[3] = {parmEdi, parmEbp, CGInstInvalid};
 
                 //Get symbol to the dvmJitToExceptionThrown callback
-                CGSymbol callback = singletonPtr<PersistentInfo> ()->getCallBack ("dvmJitToInterpPunt");
+                CGSymbol callback = singletonPtr<PersistentInfo> ()->getCallBack (cUnit, "dvmJitToInterpPunt");
 
                 //Paranoid
                 assert (callback != 0);
 
-                dvmCompilerPcgCreateJsr (callback, parms);
+                dvmCompilerPcgCreateJsr (cUnit, callback, parms);
             }
             else
             {
@@ -1172,9 +1172,9 @@ static bool dvmCompilerPcgTranslateBB (CompilationUnitPCG *cUnit, BasicBlockPCG
             return true;
 
         default:
-            ALOGE ("\n+++ PCG ERROR +++ Unknown block type seen : %d.",
-                    (int)bb->blockType);
-            exit (-1);
+            //Set the error
+            cUnit->errorHandler->setError (kJitErrorPcgUnknownBlockType);
+            break;
     }
 
     return true;
@@ -1348,9 +1348,8 @@ static bool dvmCompilerPcgTranslateCUnit (CompilationUnitPCG *cUnit, JitTranslat
                 //Paranoid test
                 if (bb == 0)
                 {
-                    //Bail using a LCG error, this will have to get changed
                     //For the moment just make it fail with the generic error
-                    SET_JIT_ERROR (kJitErrorCodegen);
+                    cUnit->errorHandler->setError (kJitErrorPcgCodegen);
 
                     //Just return because this is already a bad enough situation
                     return false;
@@ -1371,7 +1370,7 @@ static bool dvmCompilerPcgTranslateCUnit (CompilationUnitPCG *cUnit, JitTranslat
                 CGInst parms[3] = {parmEdi, parmEbp, CGInstInvalid};
 
                 //Create the JSR
-                dvmCompilerPcgCreateJsr (bb->chainingCellSymbol, parms);
+                dvmCompilerPcgCreateJsr (cUnit, bb->chainingCellSymbol, parms);
             }
         }
     }
@@ -1420,7 +1419,7 @@ bool dvmCompilerPcgGenerateIlForTrace (CompilationUnitPCG *cUnit, JitTranslation
     dvmCompilerPcgGenerateEntryIl (cUnit);
     dvmCompilerPcgGenerateSpeculativeNullChecks (cUnit);
 
-    if (IS_ANY_JIT_ERROR_SET() == true)
+    if (cUnit->errorHandler->isAnyErrorSet () == true)
     {
         return false;
     }
@@ -1454,7 +1453,7 @@ uint8_t* dvmCompilerPcgEmitMemConsts(CompilationUnitPCG *cUnit,
         uint8_t *alignedCachePtr = (uint8_t*)align ((char*)currCachePtr, it->first.align);
         size_t requiredSpace = (alignedCachePtr + it->first.length) - currCachePtr;
         if (*freeSpace < requiredSpace) {
-            SET_JIT_ERROR(kJitErrorCodeCacheFull);
+            cUnit->errorHandler->setError (kJitErrorCodeCacheFull);
             return 0;
         }
 
@@ -1469,7 +1468,7 @@ uint8_t* dvmCompilerPcgEmitMemConsts(CompilationUnitPCG *cUnit,
                    it->first.length, it->first.align);
         }
 
-        dvmCompilerPcgBindSymbolAddress (it->second, currCachePtr);
+        dvmCompilerPcgBindSymbolAddress (cUnit, it->second, currCachePtr);
         memcpy(currCachePtr, it->first.value, it->first.length);
         currCachePtr += it->first.length;
         *freeSpace -= requiredSpace;
@@ -1493,7 +1492,7 @@ void dvmCompilerPcgEmitCode (CompilationUnitPCG *cUnit, JitTranslationInfo* info
     // Allocate space for the chaining information.
     if (freeSpace < cExtraBytesForChaining)
     {
-        SET_JIT_ERROR(kJitErrorCodeCacheFull);
+        cUnit->errorHandler->setError (kJitErrorCodeCacheFull);
         return;
     }
 
@@ -1507,7 +1506,7 @@ void dvmCompilerPcgEmitCode (CompilationUnitPCG *cUnit, JitTranslationInfo* info
     if (CGGetBinaryCode (currCachePtr, freeSpace, 0x80000000, &startAddr, &endAddr, &requiredAlign) == false)
 
     {
-        SET_JIT_ERROR(kJitErrorCodeCacheFull);
+        cUnit->errorHandler->setError (kJitErrorCodeCacheFull);
         return;
     }
 
@@ -1526,7 +1525,7 @@ void dvmCompilerPcgEmitCode (CompilationUnitPCG *cUnit, JitTranslationInfo* info
     std::list<SwitchTableCCXRef> switchChainingCellEntries;
     currCachePtr = dvmCompilerPcgEmitChainingCells (cUnit, startAddr, endAddr + 1, freeSpace, &switchChainingCellEntries);
 
-    if (IS_ANY_JIT_ERROR_SET() == true)
+    if (cUnit->errorHandler->isAnyErrorSet () == true)
     {
         return;
     }
@@ -1539,7 +1538,7 @@ void dvmCompilerPcgEmitCode (CompilationUnitPCG *cUnit, JitTranslationInfo* info
 
     freeSpace -= currCachePtr - oldCachePtr;
 
-    if (IS_ANY_JIT_ERROR_SET() == true)
+    if (cUnit->errorHandler->isAnyErrorSet () == true)
     {
         return;
     }
@@ -1547,7 +1546,7 @@ void dvmCompilerPcgEmitCode (CompilationUnitPCG *cUnit, JitTranslationInfo* info
     // lay down the memory constants, if there are any.
     currCachePtr = dvmCompilerPcgEmitMemConsts(cUnit, currCachePtr, &freeSpace);
 
-    if (IS_ANY_JIT_ERROR_SET() == true)
+    if (cUnit->errorHandler->isAnyErrorSet () == true)
     {
         return;
     }
@@ -1607,7 +1606,7 @@ void *dvmCompilerPcgCreateHookFunction (void)
 #ifdef DEBUG_HOOK
 static void dvmCompilerPcgDebugHook (void)
 {
-    CGSymbol target = singletonPtr<PersistentInfo> ()->getCallBack ("debugHook");
+    CGSymbol target = singletonPtr<PersistentInfo> ()->getCallBack (cUnit, "debugHook");
     CGCreateNewInst ("call", "n", target);
 }
 #endif // DEBUG_HOOK
diff --git a/vm/compiler/codegen/x86/pcg/CompilationErrorPCG.cpp b/vm/compiler/codegen/x86/pcg/CompilationErrorPCG.cpp
new file mode 100644
index 0000000..b537d0b
--- /dev/null
+++ b/vm/compiler/codegen/x86/pcg/CompilationErrorPCG.cpp
@@ -0,0 +1,82 @@
+/*
+ * Copyright (C) 2013 Intel Corporation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "CompilationErrorPCG.h"
+#include "CompilationUnit.h"
+#include "Lower.h"
+
+/**
+ * @brief Table that stores information about errors defined in JitCompilationErrors
+ */
+START_ERRORS
+    NEW_ERROR (kJitErrorPcgUnknownChainingBlockType,    "Unknown chaining block type seen in PCG GL.",                  false, false),
+    NEW_ERROR (kJitErrorPcgUnexpectedDataType,          "Unexpected data type seen in PCG GL.",                         false, false),
+    NEW_ERROR (kJitErrorPcgUnsupportedCallDataType,     "Unsupported call data type in PCG GL.",                        false, false),
+    NEW_ERROR (kJitErrorPcgUnknownBlockType,            "Unknown basic block type in PCG GL.",                          false, false),
+    NEW_ERROR (kJitErrorPcgPreBackward,                 "Problem when handling the pre-backward branch in PCG GL.",     false, false),
+    NEW_ERROR (kJitErrorPcgAgetUnknownType,             "Unknown type when handling the Aget bytecode in PCG GL.",      false, false),
+    NEW_ERROR (kJitErrorPcgAputUnknownType,             "Unknown type when handling the Aput bytecode in PCG GL.",      false, false),
+    NEW_ERROR (kJitErrorPcgJsrCreation,                 "Issue when handling the Jsr creation in PCG GL.",              false, false),
+    NEW_ERROR (kJitErrorPcgUnknownSymbol,               "Unknown symbol request in PCG GL.",                            false, false),
+    NEW_ERROR (kJitErrorPcgUnknownCallback,             "Unknown callback request in PCG GL.",                          false, false),
+    NEW_ERROR (kJitErrorPcgCodegen,                     "Undefined issues in trace formation.",                         false, false),
+    NEW_ERROR (kJitErrorPcgPostInvokeEntryNotFound,     "The post-invoke entry block was not found.",                   false, false),
+    NEW_ERROR (kJitErrorPcgRelocationCreation,          "Error when creating a relocation in PCG GL.",                  false, false),
+END_ERRORS
+
+unsigned int CompilationErrorHandlerPCG::getMaximumErrors (void) const
+{
+    //Take the minimum of the size of the array and kJitErrorMaxME but without the offset of the ME's enumeration
+    unsigned int enumMax = kJitErrorMaxDefinedPCG - kJitFirstErrorPCG;
+    unsigned int arrayMax = sizeof (gErrorInformation) / sizeof (gErrorInformation[0]);
+    unsigned int min = (enumMax < arrayMax) ? enumMax : arrayMax;
+
+    //Now add back the ME's enumeration
+    return min + kJitFirstErrorPCG;
+}
+
+const CompilationError *CompilationErrorHandlerPCG::getError (unsigned int index) const
+{
+    //Check the index
+    if (index < kJitFirstErrorPCG)
+    {
+        //Not ours, send it to our parent
+        return CompilationErrorHandlerX86::getError (index);
+    }
+
+    //Is it too much?
+    if (index >= kJitErrorMaxDefinedPCG)
+    {
+        return 0;
+    }
+
+    //Safe to hit the index with the delta
+    return gErrorInformation + (index - kJitFirstErrorPCG);
+}
+
+CompilationErrorHandler *dvmCompilerPcgNewCompilationErrorHandler (void)
+{
+    CompilationErrorHandlerPCG *res;
+
+    //Make space for it
+    void *space = dvmCompilerNew (sizeof (*res), true);
+
+    //Ensure the constructor is called
+    res = new (space) CompilationErrorHandlerPCG ();
+
+    //Return it
+    return res;
+}
diff --git a/vm/compiler/codegen/x86/pcg/CompilationErrorPCG.h b/vm/compiler/codegen/x86/pcg/CompilationErrorPCG.h
new file mode 100644
index 0000000..6d330ac
--- /dev/null
+++ b/vm/compiler/codegen/x86/pcg/CompilationErrorPCG.h
@@ -0,0 +1,86 @@
+/*
+ * Copyright (C) 2013 Intel Corporation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef DALVIK_VM_COMPILATIONERRORPCGCG_H_
+#define DALVIK_VM_COMPILATIONERRORPCGCG_H_
+
+#include "CompilationErrorX86.h"
+
+/**
+ * @enum JitPCGCompilationErrors
+ * @brief Possible errors which can happen during compilation
+ */
+enum JitPCGCompilationErrors {
+    /** @brief First extended error */
+    kJitFirstErrorPCG = kJitErrorMaxDefinedX86,
+    /** @brief Unknown chaining block type seen in PCG GL */
+    kJitErrorPcgUnknownChainingBlockType = kJitFirstErrorPCG,
+    /** @brief Unexpected data type seen in PCG GL */
+    kJitErrorPcgUnexpectedDataType,
+    /** @brief Unsupported call data type in PCG GL */
+    kJitErrorPcgUnsupportedCallDataType,
+    /** @brief Unknown Block type seen */
+    kJitErrorPcgUnknownBlockType,
+    /** @brief Problem with the PBWCC */
+    kJitErrorPcgPreBackward,
+    /** @brief Problem while handling an Aget */
+    kJitErrorPcgAgetUnknownType,
+    /** @brief Problem while handling an Aput */
+    kJitErrorPcgAputUnknownType,
+    /** @brief Error at the generation of the Jsr */
+    kJitErrorPcgJsrCreation,
+    /** @brief Error while getting a symbol */
+    kJitErrorPcgUnknownSymbol,
+    /** @brief Error while getting a callback */
+    kJitErrorPcgUnknownCallback,
+    /** @brief Indicates "some" error happened */
+    kJitErrorPcgCodegen,
+    /** @brief The post-invoke entry block was not found */
+    kJitErrorPcgPostInvokeEntryNotFound,
+    /** @brief Error when creating a relocation */
+    kJitErrorPcgRelocationCreation,
+    /** @brief Maximum defines */
+    kJitErrorMaxDefinedPCG
+};
+
+/**
+ * @class CompilationErrorHandlerPCG
+ * @brief The compilation error framework for the PCG backend
+ */
+class CompilationErrorHandlerPCG: public CompilationErrorHandlerX86
+{
+    public:
+
+        /**
+         * @brief Returns the maximum number of errors
+         * @return the maximum number of errors
+         */
+        virtual unsigned int getMaximumErrors (void) const;
+
+        /**
+         * @brief Get a JitCompilationError
+         * @param index the index we are interested in
+         * @return a pointer to the corresponding JitCompilationError or 0 if invalid
+         */
+        virtual const CompilationError *getError (unsigned int index) const;
+};
+
+/**
+ * @brief PCG Compilation Error Handler allocation
+ * @return the new CompilationErrorHandler
+ */
+CompilationErrorHandler *dvmCompilerPcgNewCompilationErrorHandler (void);
+#endif
diff --git a/vm/compiler/codegen/x86/pcg/CompilationUnitPCG.cpp b/vm/compiler/codegen/x86/pcg/CompilationUnitPCG.cpp
index 7ff2afe..3e62f45 100644
--- a/vm/compiler/codegen/x86/pcg/CompilationUnitPCG.cpp
+++ b/vm/compiler/codegen/x86/pcg/CompilationUnitPCG.cpp
@@ -425,10 +425,10 @@ void CompilationUnitPCG::bindBlockSymbolAddresses (uint8_t *startAddr)
         CGLabel cgLabel = it->first;
         CGSymbol cgSymbol = it->second;
 
-        CGGetLabelNameAndOffset(cgLabel, &labelOffset);
+        CGGetLabelNameAndOffset (cgLabel, &labelOffset);
         labelAddr = startAddr + labelOffset;
 
-        dvmCompilerPcgBindSymbolAddress(cgSymbol, labelAddr);
+        dvmCompilerPcgBindSymbolAddress (this, cgSymbol, labelAddr);
     }
 }
 
diff --git a/vm/compiler/codegen/x86/pcg/Labels.cpp b/vm/compiler/codegen/x86/pcg/Labels.cpp
index c14a29f..5295214 100644
--- a/vm/compiler/codegen/x86/pcg/Labels.cpp
+++ b/vm/compiler/codegen/x86/pcg/Labels.cpp
@@ -15,7 +15,7 @@
  */
 
 #include "BasicBlockPCG.h"
-#include "CodegenErrors.h"
+#include "CompilationErrorPCG.h"
 #include "CompilationUnitPCG.h"
 #include "CompilerIR.h"
 #include "Labels.h"
@@ -69,17 +69,16 @@ void dvmCompilerPcgBindBlockLabel (BasicBlockPCG *bb)
     bb->blockBound = true;
 }
 
-void dvmCompilerPcgBindSymbolAddress (CGSymbol cgSymbol, void *address)
+void dvmCompilerPcgBindSymbolAddress (CompilationUnitPCG *cUnit, CGSymbol cgSymbol, void *address)
 {
     //Get the right client symbol information
-    SClientSymbolInfo *clientSymbol = singletonPtr<PersistentInfo> ()->getSymbolInfo (cgSymbol);
+    SClientSymbolInfo *clientSymbol = singletonPtr<PersistentInfo> ()->getSymbolInfo (cUnit, cgSymbol);
 
     //Paranoid test
     if (clientSymbol == 0)
     {
-        //Bail using a LCG error, this will have to get changed
         //For the moment just make it fail with the generic error
-        SET_JIT_ERROR (kJitErrorCodegen);
+        cUnit->errorHandler->setError (kJitErrorPcgCodegen);
 
         //Just return because this is already a bad enough situation
         return;
@@ -89,10 +88,10 @@ void dvmCompilerPcgBindSymbolAddress (CGSymbol cgSymbol, void *address)
     clientSymbol->address = address;
 }
 
-void* dvmCompilerPcgGetSymbolAddress (CGSymbol cgSymbol)
+void* dvmCompilerPcgGetSymbolAddress (CompilationUnitPCG *cUnit, CGSymbol cgSymbol)
 {
     //Get the right client symbol information
-    SClientSymbolInfo *clientSymbol = singletonPtr<PersistentInfo> ()->getSymbolInfo (cgSymbol, true);
+    SClientSymbolInfo *clientSymbol = singletonPtr<PersistentInfo> ()->getSymbolInfo (cUnit, cgSymbol, true);
 
     //Paranoid
     assert (clientSymbol != 0);
diff --git a/vm/compiler/codegen/x86/pcg/Labels.h b/vm/compiler/codegen/x86/pcg/Labels.h
index 614e103..65c45e1 100644
--- a/vm/compiler/codegen/x86/pcg/Labels.h
+++ b/vm/compiler/codegen/x86/pcg/Labels.h
@@ -37,17 +37,19 @@ CGSymbol dvmCompilerPcgCreateSymbol (const std::string &name, void *address, boo
 
 /**
  * @brief Get the address of a symbol
+ * @param cUnit the CompilationUnitPCG
  * @param cgSymbol the CGSymbol
  * @return the address of a given symbol
  */
-void* dvmCompilerPcgGetSymbolAddress (CGSymbol cgSymbol);
+void* dvmCompilerPcgGetSymbolAddress (CompilationUnitPCG *cUnit, CGSymbol cgSymbol);
 
 /**
  * @brief Bind the address of a symbol
+ * @param cUnit the CompilationUnitPCG
  * @param cgSymbol the CGSymbol
  * @param address the address of a given symbol
  */
-void dvmCompilerPcgBindSymbolAddress (CGSymbol cgSymbol, void *address);
+void dvmCompilerPcgBindSymbolAddress (CompilationUnitPCG *cUnit, CGSymbol cgSymbol, void *address);
 
 /**
  * @brief Bind a BasicBlock
diff --git a/vm/compiler/codegen/x86/pcg/LowerALU.cpp b/vm/compiler/codegen/x86/pcg/LowerALU.cpp
index 776a554..08a5978 100644
--- a/vm/compiler/codegen/x86/pcg/LowerALU.cpp
+++ b/vm/compiler/codegen/x86/pcg/LowerALU.cpp
@@ -15,7 +15,7 @@
  */
 
 #include "ChainingCellException.h"
-#include "CodegenErrors.h"
+#include "CompilationErrorPCG.h"
 #include "CompilationUnitPCG.h"
 #include "CompilerIR.h"
 #include "Dataflow.h"
diff --git a/vm/compiler/codegen/x86/pcg/LowerCall.cpp b/vm/compiler/codegen/x86/pcg/LowerCall.cpp
index 8369f0a..004c512 100644
--- a/vm/compiler/codegen/x86/pcg/LowerCall.cpp
+++ b/vm/compiler/codegen/x86/pcg/LowerCall.cpp
@@ -16,6 +16,7 @@
 
 #include "BasicBlockPCG.h"
 #include "ChainingCellException.h"
+#include "CompilationErrorPCG.h"
 #include "CompilationUnitPCG.h"
 #include "Dataflow.h"
 #include "LowerCall.h"
@@ -78,9 +79,8 @@ static void generatePredictedChain (CompilationUnitPCG *cUnit, BasicBlockPCG *bb
     //Paranoid check
     if (target == 0)
     {
-        //Bail using a LCG error, this will have to get changed
         //For the moment just make it fail with the generic error
-        SET_JIT_ERROR (kJitErrorCodegen);
+        cUnit->errorHandler->setError (kJitErrorPcgCodegen);
 
         //Just return because this is already a bad enough situation
         return;
@@ -136,7 +136,7 @@ static void generatePredictedChain (CompilationUnitPCG *cUnit, BasicBlockPCG *bb
         CGInst parmEbp = dvmCompilerPcgGenerateFramePtrMov (cUnit);
         CGInst parms_2[3] = {parmEdi, parmEbp, CGInstInvalid};
         CGInst theCall = CGCreateNewInst ("icall", "nl",
-                singletonPtr<PersistentInfo> ()->getCallBack ("dvmFindInterfaceMethodInCache"),
+                singletonPtr<PersistentInfo> ()->getCallBack (cUnit, "dvmFindInterfaceMethodInCache"),
                 parms_2);
         CGSetRreg (theCall, "eax");
 
@@ -192,7 +192,7 @@ static void generatePredictedChain (CompilationUnitPCG *cUnit, BasicBlockPCG *bb
 
         //Get call back
         //Get symbol to the dvmJitToPatchPredictedChain callback
-        CGSymbol callback = singletonPtr<PersistentInfo> ()->getCallBack ("dvmJitToPatchPredictedChain");
+        CGSymbol callback = singletonPtr<PersistentInfo> ()->getCallBack (cUnit, "dvmJitToPatchPredictedChain");
 
         //Paranoid
         assert (callback != 0);
@@ -255,7 +255,7 @@ static void generatePredictedChain (CompilationUnitPCG *cUnit, BasicBlockPCG *bb
         CGInst parms[3] = {parmEdi, parmEbp, CGInstInvalid};
 
         //Get symbol to the dvmJitToPatchPredictedChain callback
-        CGSymbol callback = singletonPtr<PersistentInfo> ()->getCallBack ("dvmJitToPatchPredictedChain");
+        CGSymbol callback = singletonPtr<PersistentInfo> ()->getCallBack (cUnit, "dvmJitToPatchPredictedChain");
 
         //Paranoid
         assert (callback != 0);
@@ -315,12 +315,12 @@ void dvmCompilerPcgTranslateInvokeVirtual (CompilationUnitPCG *cUnit, MIR *mir)
     CGInst parms[3] = {parmEdi, parmEbp, CGInstInvalid};
 
     //Get symbol to the common_errNullObject callback
-    CGSymbol callback = singletonPtr<PersistentInfo> ()->getCallBack ("common_errNullObject");
+    CGSymbol callback = singletonPtr<PersistentInfo> ()->getCallBack (cUnit, "common_errNullObject");
 
     //Paranoid
     assert (callback != 0);
 
-    dvmCompilerPcgCreateJsr (callback, parms);
+    dvmCompilerPcgCreateJsr (cUnit, callback, parms);
 
     CGBindLabel (notNull);
 
@@ -496,9 +496,8 @@ void dvmCompilerPcgTranslateReturn (CompilationUnitPCG *cUnit, MIR *mir, bool is
         pcgDtype resDtype = dvmCompilerPcgGetDtypeForSSANum (cUnit, ssaNum);
         int32_t dtypeSize = (dalvikOpCode == OP_RETURN_WIDE) ? 8 : 4;
         const char *opcode;
-
         resDtype = dvmCompilerPcgApplyDefaultDtype (resDtype, dtypeSize);
-        dvmCompilerPcgGetOpcodeAndSizeForDtype (resDtype, &opcode);
+        dvmCompilerPcgGetOpcodeAndSizeForDtype (cUnit, resDtype, &opcode);
 
         // self->interpSave.retval = vA
         int32_t offset = offsetof (Thread, interpSave.retval);
@@ -531,8 +530,8 @@ void dvmCompilerPcgTranslateReturn (CompilationUnitPCG *cUnit, MIR *mir, bool is
 
     CGInst parms[5] = {parmEbp, selfIl, saveAreaIl, prevFrameIl, CGInstInvalid};
 
-    CGSymbol target = singletonPtr<PersistentInfo> ()->getCallBack ("dvmJitHelper_returnFromMethod");
-    dvmCompilerPcgCreateJsr (target, parms);
+    CGSymbol target = singletonPtr<PersistentInfo> ()->getCallBack (cUnit, "dvmJitHelper_returnFromMethod");
+    dvmCompilerPcgCreateJsr (cUnit, target, parms);
     return;
 }
 
@@ -625,7 +624,7 @@ void dvmCompilerPcgTranslateExecuteInline (CompilationUnitPCG *cUnit, MIR *mir)
                 CGInst result = CGCreateNewInst ("lsub", "rr", xoredLoad,
                         shiftedLoad);
                 self = dvmCompilerPcgGetSelfPointer (cUnit);
-                dvmCompilerPcgCreateTypedStore (self, CGInstInvalid, 0,
+                dvmCompilerPcgCreateTypedStore (cUnit, self, CGInstInvalid, 0,
                     CGSymbolInvalid, offsetof (Thread, interpSave.retval),
                     LLreg, result);
                 return;
@@ -688,7 +687,7 @@ void dvmCompilerPcgTranslateExecuteInline (CompilationUnitPCG *cUnit, MIR *mir)
                     int objectSize = (dalvikOpCode == OP_MOVE_RESULT_WIDE) ? 8 : 4;
 
                     dtype = dvmCompilerPcgApplyDefaultDtype (dtype, objectSize);
-                    dvmCompilerPcgGetOpcodeAndSizeForDtype (dtype, &opcode);
+                    dvmCompilerPcgGetOpcodeAndSizeForDtype (cUnit, dtype, &opcode);
                     if (dtype == LLreg)
                     {
                         result = CGCreateNewInst("movsd12sd", "r", result);
@@ -806,7 +805,7 @@ void dvmCompilerPcgTranslateExecuteInline (CompilationUnitPCG *cUnit, MIR *mir)
                 ssaNum = ssaRep->uses[0];
                 pcgDtype dtype = dvmCompilerPcgGetDtypeForSSANum (cUnit, ssaNum);
                 dtype = dvmCompilerPcgApplyDefaultDtype (dtype, dtypeSize);
-                dvmCompilerPcgGetOpcodeAndSizeForDtype (dtype, &opcode);
+                dvmCompilerPcgGetOpcodeAndSizeForDtype (cUnit, dtype, &opcode);
                 CGInst load = dvmCompilerPcgGetVirtualReg (cUnit, ssaNum, opcode, dtypeSize);
                 self = dvmCompilerPcgGetSelfPointer (cUnit);
                 CGAddr addr = CGCreateAddr (self, CGInstInvalid, 0, CGSymbolInvalid, offsetof (Thread, interpSave.retval));
@@ -835,7 +834,7 @@ void dvmCompilerPcgTranslateExecuteInline (CompilationUnitPCG *cUnit, MIR *mir)
         pcgDtype dtype = dvmCompilerPcgGetDtypeForSSANum (cUnit, ssaNum);
 
         dtype = dvmCompilerPcgApplyDefaultDtype (dtype, 4);
-        dtypeSize = dvmCompilerPcgGetOpcodeAndSizeForDtype (dtype, &opcode);
+        dtypeSize = dvmCompilerPcgGetOpcodeAndSizeForDtype (cUnit, dtype, &opcode);
         CGInst load = dvmCompilerPcgGetVirtualReg (cUnit, ssaRep->uses[i], opcode, dtypeSize);
         CGAddr addr = CGCreateAddr (spIl, CGInstInvalid, 0, CGSymbolInvalid, i * 4);
         CGCreateNewInst (opcode, "mr", addr, dtypeSize, (void*)1, load);
@@ -887,7 +886,7 @@ void dvmCompilerPcgTranslateMoveResult (CompilationUnitPCG *cUnit, MIR *mir)
     int objectSize = (dalvikOpCode == OP_MOVE_RESULT_WIDE) ? 8 : 4;
 
     dtype = dvmCompilerPcgApplyDefaultDtype (dtype, objectSize);
-    dvmCompilerPcgGetOpcodeAndSizeForDtype (dtype, &opcode);
+    dvmCompilerPcgGetOpcodeAndSizeForDtype (cUnit, dtype, &opcode);
 
     CGInst selfPointer = dvmCompilerPcgGetSelfPointer (cUnit);
     CGAddr addr = CGCreateAddr (selfPointer, CGInstInvalid, 0, CGSymbolInvalid, offsetof (Thread, interpSave.retval));
@@ -995,7 +994,7 @@ CGInst dvmCompilerPcgGetFallthroughTargetSymbolInst (CompilationUnitPCG *cUnit,
         //But in case we don't, then we set error and bail out early
         if (fromInterp == 0)
         {
-            SET_JIT_ERROR (kJitErrorPcgPostInvokeEntryNotFound);
+            cUnit->errorHandler->setError (kJitErrorPcgPostInvokeEntryNotFound);
             return CGInstInvalid;
         }
 
@@ -1100,8 +1099,8 @@ void dvmCompilerPcgCommonInvokeMethodJmp (CompilationUnitPCG *cUnit, const MIR *
             break;
     }
 
-    CGSymbol target = singletonPtr<PersistentInfo> ()->getCallBack (targetName);
-    dvmCompilerPcgCreateJsr (target, parms);
+    CGSymbol target = singletonPtr<PersistentInfo> ()->getCallBack (cUnit, targetName);
+    dvmCompilerPcgCreateJsr (cUnit, target, parms);
 }
 
 void dvmCompilerPcgStoreInvokeArgs (CompilationUnitPCG *cUnit, const MIR *mir)
@@ -1121,7 +1120,7 @@ void dvmCompilerPcgStoreInvokeArgs (CompilationUnitPCG *cUnit, const MIR *mir)
         pcgDtype dtype = dvmCompilerPcgGetDtypeForSSANum (cUnit, ssaNum);
 
         dtype = dvmCompilerPcgApplyDefaultDtype (dtype, 4);
-        dtypeSize = dvmCompilerPcgGetOpcodeAndSizeForDtype (dtype, &opcode);
+        dtypeSize = dvmCompilerPcgGetOpcodeAndSizeForDtype (cUnit, dtype, &opcode);
         CGInst load = dvmCompilerPcgGetVirtualReg (cUnit, ssaNum, opcode, dtypeSize);
         CGAddr addr = CGCreateAddr (cUnit->getVMPtr (), CGInstInvalid, 0, CGSymbolInvalid,
                 offset);
diff --git a/vm/compiler/codegen/x86/pcg/LowerGetPut.cpp b/vm/compiler/codegen/x86/pcg/LowerGetPut.cpp
index ccf2281..429afc8 100644
--- a/vm/compiler/codegen/x86/pcg/LowerGetPut.cpp
+++ b/vm/compiler/codegen/x86/pcg/LowerGetPut.cpp
@@ -16,6 +16,7 @@
 
 #include "BasicBlockPCG.h"
 #include "ChainingCellException.h"
+#include "CompilationErrorPCG.h"
 #include "CompilationUnitPCG.h"
 #include "CompilerIR.h"
 #include "Dataflow.h"
@@ -43,7 +44,7 @@ void dvmCompilerPcgTranslateIput (CompilationUnitPCG *cUnit, MIR *mir)
     const char *opcode;
 
     int baseN = (dalvikOpCode == OP_IPUT_WIDE_QUICK) ? 2 : 1;
-    dvmCompilerPcgGetOpcodeAndSizeForDtype (dtype, &opcode);
+    dvmCompilerPcgGetOpcodeAndSizeForDtype (cUnit, dtype, &opcode);
     CGInst base = dvmCompilerPcgGetVirtualReg (cUnit, ssaRep->uses[baseN], "mov", 4);
 
     dvmCompilerPcgGenerateNullCheck (cUnit, base, mir, ssaRep->uses[baseN]);
@@ -75,7 +76,8 @@ void dvmCompilerPcgTranslateAget (CompilationUnitPCG *cUnit, MIR *mir)
     int objectSize = (dalvikOpCode == OP_AGET_WIDE) ? 8 : 4;
 
     dtype = dvmCompilerPcgApplyDefaultDtype(dtype, objectSize);
-    dvmCompilerPcgGetOpcodeAndSizeForDtype (dtype, &opcode);
+    dvmCompilerPcgGetOpcodeAndSizeForDtype (cUnit, dtype, &opcode);
+
     dvmCompilerPcgGenerateNullCheck (cUnit, base, mir, ssaRep->uses[0]);
 
     CGInst index = dvmCompilerPcgGetVirtualReg (cUnit, ssaRep->uses[1], "mov", 4);
@@ -125,8 +127,7 @@ void dvmCompilerPcgTranslateAget (CompilationUnitPCG *cUnit, MIR *mir)
             }
             break;
         default:
-            ALOGI ("\nNOT REACHED\n");
-            exit (-1);
+            cUnit->errorHandler->setError (kJitErrorPcgAgetUnknownType);
             break;
     }
 }
@@ -149,7 +150,7 @@ void dvmCompilerPcgTranslateAput (CompilationUnitPCG *cUnit, MIR *mir)
     pcgDtype dtype = dvmCompilerPcgGetDtypeForSSANum (cUnit, ssaNum);
     dtype = dvmCompilerPcgApplyDefaultDtype (dtype, objectSize);
 
-    dvmCompilerPcgGetOpcodeAndSizeForDtype (dtype, &opcode);
+    dvmCompilerPcgGetOpcodeAndSizeForDtype (cUnit, dtype, &opcode);
 
     dvmCompilerPcgGenerateNullCheck (cUnit, base, mir, ssaRep->uses[baseN]);
 
@@ -187,8 +188,7 @@ void dvmCompilerPcgTranslateAput (CompilationUnitPCG *cUnit, MIR *mir)
             }
             break;
         default:
-            ALOGI ("\nNOT REACHED\n");
-            exit (-1);
+            cUnit->errorHandler->setError (kJitErrorPcgAputUnknownType);
             break;
     }
 }
@@ -219,7 +219,7 @@ void dvmCompilerPcgTranslateAputObject (CompilationUnitPCG *cUnit, MIR *mir)
     CGInst t0 = dvmCompilerPcgCreateSimpleLoad (A, OFFSETOF_MEMBER (Object,clazz));
     CGInst t1 = dvmCompilerPcgCreateSimpleLoad (base, OFFSETOF_MEMBER (Object,clazz));
 
-    CGSymbol target = singletonPtr<PersistentInfo> ()->getCallBack ("dvmCanPutArrayElement");
+    CGSymbol target = singletonPtr<PersistentInfo> ()->getCallBack (cUnit, "dvmCanPutArrayElement");
     CGInst spIl = CGCreateNewInst ("sub", "ri", CGGetStackPointerDef (), 16);
     CGInst parms[3];
     CGSetRreg (spIl, "esp");
@@ -267,7 +267,7 @@ bool dvmCompilerPcgTranslateSgetSput (CompilationUnitPCG *cUnit, MIR *mir, bool
     CGInst parms[3];
 
     dtype = dvmCompilerPcgApplyDefaultDtype (dtype, objectSize);
-    dvmCompilerPcgGetOpcodeAndSizeForDtype (dtype, &opcode);
+    dvmCompilerPcgGetOpcodeAndSizeForDtype (cUnit, dtype, &opcode);
 
     // This comment is from LowerGetPut.cpp.  We need to figure out how to
     // handle this.  In general, having a mechanism for PCG to report a
@@ -290,7 +290,7 @@ bool dvmCompilerPcgTranslateSgetSput (CompilationUnitPCG *cUnit, MIR *mir, bool
     if (isGet == true)
     {
         if (isWide == true && isVolatile == true) {
-            CGSymbol target = singletonPtr<PersistentInfo> ()->getCallBack ("dvmQuasiAtomicRead64");
+            CGSymbol target = singletonPtr<PersistentInfo> ()->getCallBack (cUnit, "dvmQuasiAtomicRead64");
             CGInst add = CGCreateNewInst("lea", "d", addr);
             CGInst spIl = CGCreateNewInst("sub", "ri",
                                           CGGetStackPointerDef(), 4);
@@ -333,7 +333,7 @@ bool dvmCompilerPcgTranslateSgetSput (CompilationUnitPCG *cUnit, MIR *mir, bool
             //     call dvmQuasiAtomicSwap64
             //     add esp, 12
             //
-            CGSymbol target = singletonPtr<PersistentInfo> ()->getCallBack ("dvmQuasiAtomicSwap64");
+            CGSymbol target = singletonPtr<PersistentInfo> ()->getCallBack (cUnit, "dvmQuasiAtomicSwap64");
             CGInst add = CGCreateNewInst("lea", "d", addr);
             CGInst spIl = CGCreateNewInst ("sub", "ri", CGGetStackPointerDef (), 12);
             CGSetRreg (spIl, "esp");
@@ -376,7 +376,7 @@ void dvmCompilerPcgTranslateIgetObjectQuick (CompilationUnitPCG *cUnit, MIR *mir
     pcgDtype dtype = dvmCompilerPcgGetDtypeForSSANum (cUnit, ssaNum);
     dtype = dvmCompilerPcgApplyDefaultDtype (dtype, 4);
 
-    dvmCompilerPcgGetOpcodeAndSizeForDtype (dtype, &opcode);
+    dvmCompilerPcgGetOpcodeAndSizeForDtype (cUnit, dtype, &opcode);
 
     CGInst B = dvmCompilerPcgGetVirtualReg (cUnit, ssaRep->uses[0], "mov", 4);
 
@@ -401,7 +401,7 @@ void dvmCompilerPcgTranslateIgetWideQuick (CompilationUnitPCG *cUnit, MIR *mir)
     assert (ssaRep != 0);
     pcgDtype dtype = dvmCompilerPcgGetDtypeForSSANum (cUnit, ssaRep->defs[0]);
     dtype = dvmCompilerPcgApplyDefaultDtype (dtype, 8);
-    dvmCompilerPcgGetOpcodeAndSizeForDtype (dtype, &opcode);
+    dvmCompilerPcgGetOpcodeAndSizeForDtype (cUnit, dtype, &opcode);
 
     CGInst B = dvmCompilerPcgGetVirtualReg (cUnit, ssaRep->uses[0], "mov", 4);
 
@@ -440,11 +440,11 @@ void dvmCompilerPcgTranslateIgetIput (CompilationUnitPCG *cUnit, MIR *mir, bool
     {
         pcgDtype dtype = dvmCompilerPcgGetDtypeForSSANum (cUnit, ssaRep->defs[0]);
         dtype = dvmCompilerPcgApplyDefaultDtype (dtype, (isWide) ? 8 : 4);
-        memSize = dvmCompilerPcgGetOpcodeAndSizeForDtype (dtype, &opcode);
+        memSize = dvmCompilerPcgGetOpcodeAndSizeForDtype (cUnit, dtype, &opcode);
 
         if (isWide == true && isVolatile == true)
         {
-            CGSymbol target = singletonPtr<PersistentInfo> ()->getCallBack ("dvmQuasiAtomicRead64");
+            CGSymbol target = singletonPtr<PersistentInfo> ()->getCallBack (cUnit, "dvmQuasiAtomicRead64");
             CGInst add = CGCreateNewInst ("add", "rr", B, fieldOffsetInst);
             CGInst spIl = CGCreateNewInst ("sub", "ri",
                     CGGetStackPointerDef (), 16);
@@ -479,13 +479,13 @@ void dvmCompilerPcgTranslateIgetIput (CompilationUnitPCG *cUnit, MIR *mir, bool
     {
         pcgDtype dtype = dvmCompilerPcgGetDtypeForSSANum (cUnit, ssaRep->uses[0]);
         dtype = dvmCompilerPcgApplyDefaultDtype (dtype, (isWide) ? 8 : 4);
-        memSize = dvmCompilerPcgGetOpcodeAndSizeForDtype (dtype, &opcode);
+        memSize = dvmCompilerPcgGetOpcodeAndSizeForDtype (cUnit, dtype, &opcode);
 
         CGInst A = dvmCompilerPcgGetVirtualReg (cUnit, ssaRep->uses[0], opcode, memSize);
         CGAddr addr = CGCreateAddr (B, fieldOffsetInst, 1, CGSymbolInvalid, 0);
 
         if (isWide == true && isVolatile == true) {
-            CGSymbol target = singletonPtr<PersistentInfo> ()->getCallBack ("dvmQuasiAtomicSwap64");
+            CGSymbol target = singletonPtr<PersistentInfo> ()->getCallBack (cUnit, "dvmQuasiAtomicSwap64");
             CGInst add = CGCreateNewInst("lea", "d", addr);
             CGInst spIl = CGCreateNewInst ("sub", "ri", CGGetStackPointerDef (), 12);
             CGSetRreg (spIl, "esp");
diff --git a/vm/compiler/codegen/x86/pcg/LowerJump.cpp b/vm/compiler/codegen/x86/pcg/LowerJump.cpp
index 2bb7c7a..0e7a7f5 100644
--- a/vm/compiler/codegen/x86/pcg/LowerJump.cpp
+++ b/vm/compiler/codegen/x86/pcg/LowerJump.cpp
@@ -15,6 +15,7 @@
  */
 
 #include "BasicBlockPCG.h"
+#include "CompilationErrorPCG.h"
 #include "CompilationUnitPCG.h"
 #include "Dataflow.h"
 #include "LowerJump.h"
@@ -29,12 +30,12 @@ void dvmCompilerPcgTranslateDirectJumpToBlock (BasicBlockPCG *bb)
 /**
  * @details Create a JSR and conditionally add an spaddi depending on whether we're registerizing, or not.
  */
-CGInst dvmCompilerPcgCreateJsr (CGSymbol symbol, CGInst *parms, CGInst reg)
+CGInst dvmCompilerPcgCreateJsr (CompilationUnitPCG *cUnit, CGSymbol symbol, CGInst *parms, CGInst reg)
 {
     if (symbol != CGSymbolInvalid && reg != CGInstInvalid)
     {
-        ALOGI ("\nPCG : huh?\n");
-        exit (-1);
+        cUnit->errorHandler->setError (kJitErrorPcgJsrCreation);
+        return CGInstInvalid;
     }
 
     CGInst spadd = CGCreateNewInst ("spaddi", "ri", CGGetStackPointerDef (), 0);
diff --git a/vm/compiler/codegen/x86/pcg/LowerJump.h b/vm/compiler/codegen/x86/pcg/LowerJump.h
index a6d3bca..1452d0c 100644
--- a/vm/compiler/codegen/x86/pcg/LowerJump.h
+++ b/vm/compiler/codegen/x86/pcg/LowerJump.h
@@ -31,12 +31,13 @@ void dvmCompilerPcgTranslateDirectJumpToBlock (BasicBlockPCG *bb);
 
 /**
  * @brief Create JSR
+ * @param cUnit the CompilationUnitPCG
  * @param symbol the CGSymbol
  * @param parms the instruction (default: 0)
  * @param reg the register (default: CGInstInvalid)
  * @return the instruction generated
  */
-CGInst dvmCompilerPcgCreateJsr (CGSymbol symbol, CGInst *parms = 0, CGInst reg = CGInstInvalid);
+CGInst dvmCompilerPcgCreateJsr (CompilationUnitPCG *cUnit, CGSymbol symbol, CGInst *parms = 0, CGInst reg = CGInstInvalid);
 
 /**
  * @brief Create a conditional jump
diff --git a/vm/compiler/codegen/x86/pcg/LowerMemory.cpp b/vm/compiler/codegen/x86/pcg/LowerMemory.cpp
index de84310..da0f8a8 100644
--- a/vm/compiler/codegen/x86/pcg/LowerMemory.cpp
+++ b/vm/compiler/codegen/x86/pcg/LowerMemory.cpp
@@ -25,11 +25,11 @@
 #define offEBPSelf 8
 
 // Create a store of an arbitrarily typed value.
-CGInst dvmCompilerPcgCreateTypedStore (CGInst base, CGInst index, uint32_t scale,
+CGInst dvmCompilerPcgCreateTypedStore (CompilationUnitPCG *cUnit, CGInst base, CGInst index, uint32_t scale,
                                        CGSymbol ltbase, int32_t offset, pcgDtype dtype, CGInst r)
 {
     const char *opc;
-    int32_t size = dvmCompilerPcgGetOpcodeAndSizeForDtype (dtype, &opc);
+    int32_t size = dvmCompilerPcgGetOpcodeAndSizeForDtype (cUnit, dtype, &opc);
 
     CGAddr addr = CGCreateAddr (base, index, scale, ltbase, offset);
     return CGCreateNewInst (opc, "mr", addr, size, (void*)1, r);
@@ -81,7 +81,7 @@ void dvmCompilerPcgStoreVirtualReg (CompilationUnitPCG *cUnit, int ssaNum, int s
     pcgDtype dtype = dvmCompilerPcgGetDtypeForSSANum (cUnit, ssaNum);
     const char *opcode;
     u2 virtualReg = dvmExtractSSARegister (cUnit, ssaNum);
-    int32_t storeSize = dvmCompilerPcgGetOpcodeAndSizeForDtype (dtype, &opcode);
+    int32_t storeSize = dvmCompilerPcgGetOpcodeAndSizeForDtype (cUnit, dtype, &opcode);
 
     if (storeSize == 8 && storeMask == 1)
     {
diff --git a/vm/compiler/codegen/x86/pcg/LowerMemory.h b/vm/compiler/codegen/x86/pcg/LowerMemory.h
index ac841e2..f6b1296 100644
--- a/vm/compiler/codegen/x86/pcg/LowerMemory.h
+++ b/vm/compiler/codegen/x86/pcg/LowerMemory.h
@@ -21,6 +21,7 @@
 
 /**
  * @brief Create a typed store
+ * @param cUnit the CompilationUnitPCG
  * @param base the base register
  * @param index the index register
  * @param scale the scale for the store
@@ -29,7 +30,7 @@
  * @param dtype the type of the store
  * @param r the register containing what to store
  */
-CGInst dvmCompilerPcgCreateTypedStore (CGInst base, CGInst index, uint32_t scale,
+CGInst dvmCompilerPcgCreateTypedStore (CompilationUnitPCG *cUnit, CGInst base, CGInst index, uint32_t scale,
                                        CGSymbol ltbase, int32_t offset, pcgDtype dtype, CGInst r);
 
 /**
diff --git a/vm/compiler/codegen/x86/pcg/LowerOther.cpp b/vm/compiler/codegen/x86/pcg/LowerOther.cpp
index d08a067..1711657 100644
--- a/vm/compiler/codegen/x86/pcg/LowerOther.cpp
+++ b/vm/compiler/codegen/x86/pcg/LowerOther.cpp
@@ -65,7 +65,7 @@ void dvmCompilerPcgTranslateMonitorExit (CompilationUnitPCG *cUnit, MIR *mir)
     dvmCompilerPcgCreateSimpleStore (spIl, 4, A);
 
     //Get symbol to the dvmJitToExceptionThrown callback
-    CGSymbol callback = singletonPtr<PersistentInfo> ()->getCallBack ("dvmUnlockObject");
+    CGSymbol callback = singletonPtr<PersistentInfo> ()->getCallBack (cUnit, "dvmUnlockObject");
 
     //Paranoid
     assert (callback != 0);
@@ -110,7 +110,7 @@ void dvmCompilerPcgTranslateMonitorEnter (CompilationUnitPCG *cUnit, MIR *mir)
     dvmCompilerPcgCreateSimpleStore (spIl, 4, A);
 
     //Get symbol to the dvmJitToExceptionThrown callback
-    CGSymbol callback = singletonPtr<PersistentInfo> ()->getCallBack ("dvmLockObject");
+    CGSymbol callback = singletonPtr<PersistentInfo> ()->getCallBack (cUnit, "dvmLockObject");
 
     //Paranoid
     assert (callback != 0);
@@ -229,7 +229,7 @@ void dvmCompilerPcgCommonCheckCastInstanceOf (CompilationUnitPCG *cUnit, MIR *mi
     parms[2] = CGInstInvalid;
 
     //Get symbol to the dvmJitToExceptionThrown callback
-    CGSymbol callback = singletonPtr<PersistentInfo> ()->getCallBack ("dvmInstanceofNonTrivial");
+    CGSymbol callback = singletonPtr<PersistentInfo> ()->getCallBack (cUnit, "dvmInstanceofNonTrivial");
 
     //Paranoid
     assert (callback != 0);
@@ -355,7 +355,7 @@ static void dvmCompilerPcgCreateJumpToPackedSwitchEntry (
     CGInst parmEdi = dvmCompilerPcgGenerateVMPtrMov (cUnit);
     CGInst parmEbp = dvmCompilerPcgGenerateFramePtrMov (cUnit);
     CGInst parms[3] = {parmEdi, parmEbp, CGInstInvalid};
-    dvmCompilerPcgCreateJsr (CGSymbolInvalid, parms, jumpTarget);
+    dvmCompilerPcgCreateJsr (cUnit, CGSymbolInvalid, parms, jumpTarget);
 }
 
 /**
@@ -389,12 +389,12 @@ static void dvmCompilerPcgCreateSwitchPunt (
     CGInst noChainParms[4] = {parmEdi, parmEbp, rPCInEaxInst, CGInstInvalid};
 
     //Get symbol to the dvmJitToInterpNoChain callback
-    CGSymbol callback = singletonPtr<PersistentInfo> ()->getCallBack ("dvmJitToInterpNoChain");
+    CGSymbol callback = singletonPtr<PersistentInfo> ()->getCallBack (cUnit, "dvmJitToInterpNoChain");
 
     //Paranoid
     assert (callback != 0);
 
-    dvmCompilerPcgCreateJsr (callback, noChainParms);
+    dvmCompilerPcgCreateJsr (cUnit, callback, noChainParms);
 }
 
 void dvmCompilerPcgTranslatePackedSwitch (CompilationUnitPCG *cUnit, MIR *mir)
@@ -555,7 +555,7 @@ void dvmCompilerPcgTranslateSparseSwitch (CompilationUnitPCG *cUnit, MIR *mir)
 
         // Create an indirect jump to the chaining cell or the
         // chained address (in eax)
-        dvmCompilerPcgCreateJsr (CGSymbolInvalid, parms, jumpTarget);
+        dvmCompilerPcgCreateJsr (cUnit, CGSymbolInvalid, parms, jumpTarget);
 
     } else {
 
diff --git a/vm/compiler/codegen/x86/pcg/PcgInterface.cpp b/vm/compiler/codegen/x86/pcg/PcgInterface.cpp
index 57be569..6a4e4a5 100644
--- a/vm/compiler/codegen/x86/pcg/PcgInterface.cpp
+++ b/vm/compiler/codegen/x86/pcg/PcgInterface.cpp
@@ -19,6 +19,7 @@
 #include "Analysis.h"
 #include "BasicBlockPCG.h"
 #include "CodeGeneration.h"
+#include "CompilationErrorPCG.h"
 #include "CompilationUnitPCG.h"
 #include "CompilerInternals.h"
 #include "libpcg.h"
@@ -97,6 +98,11 @@ static void pcgConfigureTrace (CompilationUnitPCG *cUnit)
  */
 void pcgDvmCompilerMIR2LIR (CompilationUnit *cUnitME, JitTranslationInfo* info)
 {
+    //Create a client context for the error system
+    jmp_buf client_context;
+    jmp_buf *prev_context = CGGetSetjmpContext();
+
+    //Create a cUnit for this cUnitME
     CompilationUnitPCG cUnit (cUnitME);
 
     // cUnit->baseAddr gives the address of the entry point for the compiled
@@ -108,51 +114,55 @@ void pcgDvmCompilerMIR2LIR (CompilationUnit *cUnitME, JitTranslationInfo* info)
     cUnitME->baseAddr = 0;
     info->codeAddress = 0;
 
-    if (cUnitME->printMe == true) {
-        cUnit.setDebugLevel (DebugMaskDisasm);
-    }
-
-    if (cUnit.checkDebugMask (DebugMaskTrace) == true)
+    //Prepare the set jump system
+    if (setjmp(client_context) == 0)
     {
-        CGSetTraceOutputFile (stdout);
-    }
+        //If that succeeded, we can proceed
+        //Provide to PCG the context
+        CGSetSetjmpContext (&client_context);
 
-    CGCreateRoutine (&cUnit);
-
-    // clear any previous JIT errors
-    CLEAR_ALL_JIT_ERRORS();
+        if (cUnitME->printMe == true) {
+            cUnit.setDebugLevel (DebugMaskDisasm);
+        }
 
-    //If analysis succeeds continue
-    if (dvmCompilerPcgNewRegisterizeVRAnalysis (&cUnit) == true)
-    {
-        cUnit.registerizeAnalysisDone ();
-        dvmCompilerPcgModSSANum (&cUnit);
+        if (cUnit.checkDebugMask (DebugMaskTrace) == true)
+        {
+            CGSetTraceOutputFile (stdout);
+        }
 
-        pcgConfigureTrace (&cUnit);
+        CGCreateRoutine (&cUnit);
 
-        bool success = dvmCompilerPcgGenerateIlForTrace (&cUnit, info);
+        // clear any previous JIT errors
+        cUnit.errorHandler->clearErrors ();
 
-        // Note that if !success, we leave cUnit->baseAddr as 0.
-        if (success == true)
+        //If analysis succeeds continue
+        if (dvmCompilerPcgNewRegisterizeVRAnalysis (&cUnit) == true)
         {
-            CGCompileRoutine (&cUnit);
-            dvmCompilerPcgEmitCode (&cUnit, info);
+            cUnit.registerizeAnalysisDone ();
+            dvmCompilerPcgModSSANum (&cUnit);
 
-            if (IS_JIT_ERROR_SET(kJitErrorCodeCacheFull) == true)
-            {
-                gDvmJit.codeCacheFull = true;
-            }
+            pcgConfigureTrace (&cUnit);
 
-            if (IS_ANY_JIT_ERROR_SET())
+            bool success = dvmCompilerPcgGenerateIlForTrace (&cUnit, info);
+
+            // Note that if !success, we leave cUnit->baseAddr as 0.
+            if (success == true)
             {
-                // We call this to print errors set down in EmitCode,
-                // true means we won't retry
-                dvmCanFixErrorsAndRetry(&cUnit, true);
+                CGCompileRoutine (&cUnit);
+                dvmCompilerPcgEmitCode (&cUnit, info);
             }
         }
+
+        CGEndRoutine (0);
+    }
+    else {
+        ALOGD ("JIT_INFO: PCG did not compile the trace %s%s@%#x\n",
+                cUnit.method->clazz->descriptor, cUnit.method->name,
+                cUnit.traceDesc->trace[0].info.frag.startOffset);
     }
 
-    CGEndRoutine (0);
+    //Set jmp back
+    CGSetSetjmpContext(prev_context);
 
     //Copy back
     CompilationUnit *cUnitLimited = &cUnit;
@@ -237,6 +247,7 @@ extern "C" void setupPcgJit (void)
     jitFramework.backEndDumpSpecificBB = 0;
     jitFramework.backEndInvokeArgsDone = dvmCompilerPcgHandleInvokeArgsHeader;
     jitFramework.backendSupportExtendedOp = dvmCompilerPcgSupportsExtendedOp;
+    jitFramework.backEndCompilationErrorHandlerAllocation = dvmCompilerPcgNewCompilationErrorHandler;
 
     // Register callbacks
     CGRegisterCallbackRoutine("CGGetMemConstSymbolFromClient",
diff --git a/vm/compiler/codegen/x86/pcg/PersistentInfo.cpp b/vm/compiler/codegen/x86/pcg/PersistentInfo.cpp
index f9174e4..1977392 100644
--- a/vm/compiler/codegen/x86/pcg/PersistentInfo.cpp
+++ b/vm/compiler/codegen/x86/pcg/PersistentInfo.cpp
@@ -15,6 +15,8 @@
  */
 #include <dlfcn.h>
 
+#include "CompilationErrorPCG.h"
+#include "CompilationUnitPCG.h"
 #include "Labels.h"
 #include "PersistentInfo.h"
 
@@ -23,7 +25,7 @@ PersistentInfo::PersistentInfo (void)
     dummySymbol = 0;
 }
 
-SClientSymbolInfo* PersistentInfo::getSymbolInfo (const CGSymbol &symbol, bool failOnNotFound)
+SClientSymbolInfo* PersistentInfo::getSymbolInfo (CompilationUnitPCG *cUnit, const CGSymbol &symbol, bool failOnNotFound)
 {
     std::map<CGSymbol, SClientSymbolInfo>::iterator it = symbolToSymbolInfo.find (symbol);
 
@@ -31,9 +33,13 @@ SClientSymbolInfo* PersistentInfo::getSymbolInfo (const CGSymbol &symbol, bool f
     {
         if (failOnNotFound == true)
         {
-            //TODO : change this exit to use the error framework
-            ALOGI("PCG Error:  Requested unsupported symbol information\n");
-            exit(-1);
+            assert (cUnit != 0);
+
+            //TODO: this should be removed when the client signature is fixed
+            if (cUnit != 0)
+            {
+                cUnit->errorHandler->setError (kJitErrorPcgUnknownSymbol);
+            }
         }
 
         //Report not found
@@ -44,7 +50,7 @@ SClientSymbolInfo* PersistentInfo::getSymbolInfo (const CGSymbol &symbol, bool f
     return &(it->second);
 }
 
-CGSymbol PersistentInfo::getCallBack (const char * c_name)
+CGSymbol PersistentInfo::getCallBack (CompilationUnitPCG *cUnit, const char * c_name)
 {
     std::string name(c_name);
     std::map<std::string, CGSymbol>::const_iterator it = callBacks.find (name);
@@ -92,10 +98,11 @@ CGSymbol PersistentInfo::getCallBack (const char * c_name)
                     dummyName += 'a';
                 }
 
-                //TODO : change this exit to use the error framework, then it can return the dummySymbol
-                ALOGI("PCG Error:  Requested unsupported callback %s\n", c_name);
-                exit(-1);
-
+                //TODO: this should be removed when the client signature is fixed
+                if (cUnit != 0)
+                {
+                    cUnit->errorHandler->setError (kJitErrorPcgUnknownCallback);
+                }
                 return dummySymbol;
             }
         }
diff --git a/vm/compiler/codegen/x86/pcg/PersistentInfo.h b/vm/compiler/codegen/x86/pcg/PersistentInfo.h
index f15c974..b4bb913 100644
--- a/vm/compiler/codegen/x86/pcg/PersistentInfo.h
+++ b/vm/compiler/codegen/x86/pcg/PersistentInfo.h
@@ -22,6 +22,9 @@
 #include "libpcg.h"
 #include "UtilityPCG.h"
 
+//Forward declaration
+class CompilationUnitPCG;
+
 class PersistentInfo
 {
     protected:
@@ -42,12 +45,13 @@ class PersistentInfo
 
         /**
          * @brief Get a SClientSymbolInfo Symbol using a name
+         * @param cUnit CompilationUnitPCG
          * @param symbol the symbol we are looking for
          * @param failOnNotFound if true, we fail the code generation if name is not found, otherwise we return 0
          * @return the symbol info if found, 0 if not found and failOnNotFound == false
          */
          //TODO: most likely these symbols are CUnit related and should be moved there, that should be checked
-        SClientSymbolInfo* getSymbolInfo (const CGSymbol &symbol, bool failOnNotFound = false);
+        SClientSymbolInfo* getSymbolInfo (CompilationUnitPCG *cUnit, const CGSymbol &symbol, bool failOnNotFound = false);
 
         /**
          * @brief Set a SClientSymbolInfo
@@ -58,10 +62,11 @@ class PersistentInfo
 
         /**
          * @brief Get a CGSymbol call back using its name name
+         * @param cUnit CompilationUnitPCG
          * @param name the associated name for the callback CGSymbol we are looking for
          * @return the symbol if found, 0 if not found
          */
-        CGSymbol getCallBack (const char *name);
+        CGSymbol getCallBack (CompilationUnitPCG *cUnit, const char *name);
 
         /**
          * @brief Set a CGSymbol call back
diff --git a/vm/compiler/codegen/x86/pcg/UtilityPCG.cpp b/vm/compiler/codegen/x86/pcg/UtilityPCG.cpp
index 271c4b8..e83b8b3 100644
--- a/vm/compiler/codegen/x86/pcg/UtilityPCG.cpp
+++ b/vm/compiler/codegen/x86/pcg/UtilityPCG.cpp
@@ -16,7 +16,7 @@
 
 #include "BasicBlockPCG.h"
 #include "CodeGeneration.h"
-#include "CodegenErrors.h"
+#include "CompilationErrorPCG.h"
 #include "CompilationUnitPCG.h"
 #include "Dataflow.h"
 #include "Labels.h"
@@ -30,11 +30,12 @@
 
 /**
  * @brief Get a call and register from a type
+ * @param cUnit the CompilationUnitPCG
  * @param dtype the pcgDtype
  * @param rregPtr the register to use
  * @return the call opcode
  */
-static const char *getCallOpcodeAndRreg (pcgDtype dtype, const char **rregPtr)
+static const char *getCallOpcodeAndRreg (CompilationUnitPCG *cUnit, pcgDtype dtype, const char **rregPtr)
 {
     switch (dtype)
     {
@@ -65,12 +66,12 @@ static const char *getCallOpcodeAndRreg (pcgDtype dtype, const char **rregPtr)
     // We can add support for FP results, but they aren't currently needed, so just give an error here.
     ALOGE ("PCG Error: Unsupported call dtype");
     assert(0);
-    SET_JIT_ERROR(kJitErrorPcgUnsupportedCallDataType);
+    cUnit->errorHandler->setError (kJitErrorPcgUnsupportedCallDataType);
     *rregPtr = "";
     return "";
 }
 
-int32_t dvmCompilerPcgGetOpcodeAndSizeForDtype (pcgDtype dtype, const char **opcPtr)
+int32_t dvmCompilerPcgGetOpcodeAndSizeForDtype (CompilationUnitPCG *cUnit, pcgDtype dtype, const char **opcPtr)
 {
     int32_t size;
     const char *pcgOpcode;
@@ -108,10 +109,9 @@ int32_t dvmCompilerPcgGetOpcodeAndSizeForDtype (pcgDtype dtype, const char **opc
             break;
 
         default:
-            ALOGE ("\n+++ PCG ERROR +++ Unexpected data type seen : %d.",
-                  dtype);
+            ALOGE ("\n+++ PCG ERROR +++ Unexpected data type seen : %d.", dtype);
             assert (0);
-            SET_JIT_ERROR(kJitErrorPcgUnexpectedDataType);
+            cUnit->errorHandler->setError (kJitErrorPcgUnexpectedDataType);
             return -1;
     }
 
@@ -206,7 +206,7 @@ void dvmCompilerPcgSetVirtualReg (CompilationUnitPCG *cUnit, int ssaNum, const c
     if (info.registerize == true)
     {
         pcgDtype regDtype = dvmCompilerPcgGetDtypeForSSANum (cUnit, ssaNum);
-        dvmCompilerPcgGetOpcodeAndSizeForDtype (regDtype, &pcgOpcode);
+        dvmCompilerPcgGetOpcodeAndSizeForDtype (cUnit, regDtype, &pcgOpcode);
         CGInst copy = CGCreateNewInst (pcgOpcode, "r", storeVal);
 
         CGAddTempDef (info.parentSSANum, copy);
@@ -607,9 +607,9 @@ CGInst dvmCompilerPcgGetResClasses (CGInst selfPtr)
  */
 CGInst dvmCompilerPcgGenerateX86Call (CompilationUnitPCG *cUnit, const char *targetName, pcgDtype resultDtype, int nArgs, ...)
 {
-    CGSymbol target = singletonPtr<PersistentInfo> ()->getCallBack (targetName);
+    CGSymbol target = singletonPtr<PersistentInfo> ()->getCallBack (cUnit, targetName);
     const char *rreg;
-    const char *callOpc = getCallOpcodeAndRreg (resultDtype, &rreg);
+    const char *callOpc = getCallOpcodeAndRreg (cUnit, resultDtype, &rreg);
     const char *copyOpc = 0;
     int32_t stackSize, offset, i;
     va_list args;
@@ -626,7 +626,7 @@ CGInst dvmCompilerPcgGenerateX86Call (CompilationUnitPCG *cUnit, const char *tar
         // Advance past the actual argument.  It isn't needed here.
         va_arg (args, CGInst);
 
-        stackSize += dvmCompilerPcgGetOpcodeAndSizeForDtype (argDtype, &copyOpc);
+        stackSize += dvmCompilerPcgGetOpcodeAndSizeForDtype (cUnit, argDtype, &copyOpc);
     }
     va_end (args);
 
@@ -649,9 +649,8 @@ CGInst dvmCompilerPcgGenerateX86Call (CompilationUnitPCG *cUnit, const char *tar
         pcgDtype argDtype = (pcgDtype)va_arg (args, int);
         CGInst arg = va_arg (args, CGInst);
 
-        int32_t argSize = dvmCompilerPcgGetOpcodeAndSizeForDtype (argDtype, &copyOpc);
-        dvmCompilerPcgCreateTypedStore (spIl, CGInstInvalid, 0, CGSymbolInvalid, offset,
-                argDtype, arg);
+        int32_t argSize = dvmCompilerPcgGetOpcodeAndSizeForDtype (cUnit, argDtype, &copyOpc);
+        dvmCompilerPcgCreateTypedStore (cUnit, spIl, CGInstInvalid, 0, CGSymbolInvalid, offset, argDtype, arg);
         offset += argSize;
     }
     va_end (args);
@@ -666,7 +665,7 @@ CGInst dvmCompilerPcgGenerateX86Call (CompilationUnitPCG *cUnit, const char *tar
 
     if (resultDtype != NOreg)
     {
-        dvmCompilerPcgGetOpcodeAndSizeForDtype (resultDtype, &copyOpc);
+        dvmCompilerPcgGetOpcodeAndSizeForDtype (cUnit, resultDtype, &copyOpc);
         theCall = CGCreateNewInst (copyOpc, "r", theCall);
     }
 
@@ -755,7 +754,7 @@ void dvmCompilerPcgHandleInitialLoad (CompilationUnitPCG *cUnit, BasicBlock *bb,
 
     //Get size and opcode
     const char *pcgOpcode = 0;
-    int32_t size = dvmCompilerPcgGetOpcodeAndSizeForDtype (dtype, &pcgOpcode);
+    int32_t size = dvmCompilerPcgGetOpcodeAndSizeForDtype (cUnit, dtype, &pcgOpcode);
 
     //Get the handle for the VR
     void *handle = dvmCompilerPcgGetVRHandle (virtualReg, size);
@@ -836,7 +835,7 @@ CGInst dvmCompilerPcgResolveClass(CompilationUnitPCG *cUnit, u4 classIdx)
     parms[2] = CGCreateNewInst ("mov", "r", tmpInst);
     parms[3] = CGInstInvalid;
     CGSetRreg (parms[2], "eax");
-    CGSymbol target = singletonPtr<PersistentInfo> ()->getCallBack (".class_resolve");
+    CGSymbol target = singletonPtr<PersistentInfo> ()->getCallBack (cUnit, ".class_resolve");
 
     CGInst call = CGCreateNewInst ("icall", "nl", target, parms);
     CGSetRreg (call, "eax");
diff --git a/vm/compiler/codegen/x86/pcg/UtilityPCG.h b/vm/compiler/codegen/x86/pcg/UtilityPCG.h
index 023dc89..f907e50 100644
--- a/vm/compiler/codegen/x86/pcg/UtilityPCG.h
+++ b/vm/compiler/codegen/x86/pcg/UtilityPCG.h
@@ -87,12 +87,13 @@ pcgDtype dvmCompilerPcgGetDtypeForSSANum(CompilationUnitPCG *cUnit, int ssaNum);
 
 /**
  * @brief Get the opcode and size for a given dtype move
+ * @param cUnit the CompilationUnitPCG
  * @param dtype the pcgDtype
  * @param opc_ptr the name of the move opcode associated
  * @return the size for the dtype move
  */
 //TODO: this should return a boolean and fill in size and opc via the arguments
-int32_t dvmCompilerPcgGetOpcodeAndSizeForDtype (pcgDtype dtype, const char **opc_ptr);
+int32_t dvmCompilerPcgGetOpcodeAndSizeForDtype (CompilationUnitPCG *cUnit, pcgDtype dtype, const char **opc_ptr);
 
 /**
  * @brief Compute a default translation dtype in case the input dtype is unknown (NOreg)
diff --git a/vm/compiler/codegen/x86/x86Specific.cpp b/vm/compiler/codegen/x86/x86Specific.cpp
index addb7ac..6576fe3 100644
--- a/vm/compiler/codegen/x86/x86Specific.cpp
+++ b/vm/compiler/codegen/x86/x86Specific.cpp
@@ -29,6 +29,19 @@ BasicBlock *dvmCompilerArchSpecificNewBB(void)
     return 0;
 }
 
+CompilationErrorHandler *dvmCompilerArchSpecificNewCompilationErrorHandler (void)
+{
+    CompilationErrorHandler* (*fctPtr) (void) = gDvmJit.jitFramework.backEndCompilationErrorHandlerAllocation;
+
+    //If we have a function pointer, call it
+    if (fctPtr != 0)
+    {
+        return fctPtr ();
+    }
+
+    return 0;
+}
+
 void dvmCompilerDumpArchSpecificBB(CompilationUnit *cUnit, BasicBlock *bb, FILE *file, bool beforeMIRs)
 {
     void (*fctPtr) (CompilationUnit *, BasicBlock *, FILE *, bool) = gDvmJit.jitFramework.backEndDumpSpecificBB;
diff --git a/vm/compiler/codegen/x86/x86Specific.h b/vm/compiler/codegen/x86/x86Specific.h
index 9ace400..55d36ab 100644
--- a/vm/compiler/codegen/x86/x86Specific.h
+++ b/vm/compiler/codegen/x86/x86Specific.h
@@ -31,6 +31,13 @@ struct CompilationUnit;
 BasicBlock *dvmCompilerArchSpecificNewBB(void);
 
 /**
+ * @brief Architecture specific CompilationErrorHandler creator
+ * @details Initializes x86 specific CompilationErrorHandler fields
+ * @return newly created CompilationErrorHandler
+ */
+CompilationErrorHandler *dvmCompilerArchSpecificNewCompilationErrorHandler (void);
+
+/**
  * @brief Architecture specific BasicBlock printing
  * @param cUnit the CompilationUnit
  * @param bb the BasicBlock
-- 
1.7.4.1

