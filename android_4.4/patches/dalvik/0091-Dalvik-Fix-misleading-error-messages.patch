From b295a13f2053b04fe8b3d8c0a6f1f5be6a8fccda Mon Sep 17 00:00:00 2001
From: Udayan Banerji <udayan.banerji@intel.com>
Date: Tue, 5 Mar 2013 11:43:28 -0800
Subject: Dalvik: Fix misleading error messages

BZ: 89586

Changes the error message printing to print out only fatal errors as errors
and print everything else as just information

Category: device-enablement
Domain: AOSP-Dalvik-Compiler-CG
Origin: internal
Upstream-Candidate: no, needs rework

Change-Id: I5d6c7fab12f5e7d02f9807dd542f4cea7b55a0f7
Orig-MCG-Change-Id: I7357d90c5faa9c6b35dc1b44850438107add81c1
Signed-off-by: Udayan Banerji <udayan.banerji@intel.com>
Signed-off-by: Qiming Shi <qiming.shi@intel.com>
Signed-off-by: Serguei Katkov <serguei.i.katkov@intel.com>
---
 vm/compiler/codegen/x86/AnalysisO1.cpp        |  174 ++++++++++++------------
 vm/compiler/codegen/x86/BytecodeVisitor.cpp   |   14 +-
 vm/compiler/codegen/x86/CodegenErrors.cpp     |   26 ++--
 vm/compiler/codegen/x86/CodegenInterface.cpp  |   16 +-
 vm/compiler/codegen/x86/ExceptionHandling.cpp |    2 +-
 vm/compiler/codegen/x86/Lower.cpp             |    6 +-
 vm/compiler/codegen/x86/LowerGetPut.cpp       |    2 +-
 vm/compiler/codegen/x86/LowerHelper.cpp       |   36 +++---
 vm/compiler/codegen/x86/LowerJump.cpp         |   26 ++--
 vm/compiler/codegen/x86/NcgAot.cpp            |    2 +-
 vm/compiler/codegen/x86/Schedule.cpp          |    6 +-
 11 files changed, 155 insertions(+), 155 deletions(-)

diff --git a/vm/compiler/codegen/x86/AnalysisO1.cpp b/vm/compiler/codegen/x86/AnalysisO1.cpp
index 868ff39..651a98f 100644
--- a/vm/compiler/codegen/x86/AnalysisO1.cpp
+++ b/vm/compiler/codegen/x86/AnalysisO1.cpp
@@ -369,7 +369,7 @@ static int updateSpillIndexUsed(void) {
         if(isVirtualReg(compileTable[k].physicalType)) continue;
         if(compileTable[k].spill_loc_index >= 0) {
             if(compileTable[k].spill_loc_index > 4*(MAX_SPILL_JIT_IA-1)) {
-                ALOGE("JIT_ERROR: spill_loc_index is wrong for entry %d: %d\n",
+                ALOGI("JIT_INFO: spill_loc_index is wrong for entry %d: %d\n",
                       k, compileTable[k].spill_loc_index);
                 SET_JIT_ERROR(kJitErrorRegAllocFailed);
                 return -1;
@@ -489,7 +489,7 @@ static int initializeMemVRTable(void) {
             /* the low half of VR is not in memVRTable
                add an entry for the low half in memVRTable */
             if(num_memory_vr >= NUM_MEM_VR_ENTRY) {
-                ALOGE("JIT_ERROR: Index %d exceeds size of memVRTable\n", num_memory_vr);
+                ALOGI("JIT_INFO: Index %d exceeds size of memVRTable\n", num_memory_vr);
                 SET_JIT_ERROR(kJitErrorRegAllocFailed);
                 return -1;
             }
@@ -506,7 +506,7 @@ static int initializeMemVRTable(void) {
             /* the high half of VR is not in memVRTable
                add an entry for the high half in memVRTable */
             if(num_memory_vr >= NUM_MEM_VR_ENTRY) {
-                ALOGE("JIT_ERROR: Index %d exceeds size of memVRTable for 64-bit OpndSize\n", num_memory_vr);
+                ALOGI("JIT_INFO: Index %d exceeds size of memVRTable for 64-bit OpndSize\n", num_memory_vr);
                 SET_JIT_ERROR(kJitErrorRegAllocFailed);
                 return -1;
             }
@@ -679,7 +679,7 @@ int codeGenBasicBlockJit(const Method* method, BasicBlock* bb) {
             return cg_ret;
         }
     }
-    ALOGE("JIT_ERROR: Cannot find the corresponding O1 basic block for id %d type %d",
+    ALOGI("JIT_INFO: Cannot find the corresponding O1 basic block for id %d type %d",
          bb->id, bb->blockType);
     SET_JIT_ERROR(kJitErrorInvalidBBId);
     return -1;
@@ -926,7 +926,7 @@ int codeGenBasicBlock(const Method* method, BasicBlock_O1* bb) {
             bool retCode = lowerByteCodeJit(method, mir, rPC);
             if(gDvmJit.codeCacheByteUsed + (stream - streamStart) +
                  CODE_CACHE_PADDING > gDvmJit.codeCacheSize) {
-                 ALOGE("JIT_ERROR: Code cache full while lowering bytecode %s", dexGetOpcodeName(mir->dalvikInsn.opcode));
+                 ALOGI("JIT_INFO: Code cache full while lowering bytecode %s", dexGetOpcodeName(mir->dalvikInsn.opcode));
                  gDvmJit.codeCacheFull = true;
                  SET_JIT_ERROR(kJitErrorCodeCacheFull);
                  return -1;
@@ -934,7 +934,7 @@ int codeGenBasicBlock(const Method* method, BasicBlock_O1* bb) {
 
             if (retCode){
                 SET_JIT_ERROR(kJitErrorUnsupportedBytecode);
-                ALOGE("JIT_ERROR: Unsupported bytecode %s\n", dexGetOpcodeName(mir->dalvikInsn.opcode));
+                ALOGI("JIT_INFO: Unsupported bytecode %s\n", dexGetOpcodeName(mir->dalvikInsn.opcode));
                 return -1;
             }
 
@@ -1136,7 +1136,7 @@ int mergeEntry2(BasicBlock_O1* bb) {
 #endif
         bb->num_regs++;
         if(bb->num_regs >= MAX_REG_PER_BASICBLOCK) {
-            ALOGE("JIT_ERROR: Number of VRs (%d) in a basic block, exceed maximum (%d)\n", bb->num_regs, MAX_REG_PER_BASICBLOCK);
+            ALOGI("JIT_INFO: Number of VRs (%d) in a basic block, exceed maximum (%d)\n", bb->num_regs, MAX_REG_PER_BASICBLOCK);
             SET_JIT_ERROR(kJitErrorMaxVR);
             return -1;
         }
@@ -1236,7 +1236,7 @@ static int updateReachingDefA(int indexToA, OverlapCase isBPartiallyOverlapA) {
         //insert the def to variable @ currentInfo
         k = currentBB->infoBasicBlock[indexToA].num_reaching_defs;
         if(k >= 3) {
-            ALOGE("JIT_ERROR: more than 3 reaching defs at updateReachingDefA");
+            ALOGI("JIT_INFO: more than 3 reaching defs at updateReachingDefA");
             SET_JIT_ERROR(kJitErrorRegAllocFailed);
             return -1;
         }
@@ -1303,7 +1303,7 @@ static int updateReachingDefB1(int indexToA) {
         }
         if(insert1) {
             if(tmpInfo.num_reaching_defs >= 3) {
-                ALOGE("JIT_ERROR: more than 3 reaching defs for tmpInfo at updateReachingDefB1");
+                ALOGI("JIT_INFO: more than 3 reaching defs for tmpInfo at updateReachingDefB1");
                 SET_JIT_ERROR(kJitErrorRegAllocFailed);
                 return -1;
             }
@@ -1332,14 +1332,14 @@ static int updateReachingDefB2(void) {
                currentInfo.reachingDefs[k].physicalType == tmpInfo.reachingDefs[k2].physicalType) {
                 merged = true;
                 if(currentInfo.reachingDefs[k].offsetPC != tmpInfo.reachingDefs[k2].offsetPC) {
-                    ALOGE("JIT_ERROR: defs on the same VR %d %d with different offsetPC %d vs %d",
+                    ALOGI("JIT_INFO: defs on the same VR %d %d with different offsetPC %d vs %d",
                           currentInfo.reachingDefs[k].regNum, currentInfo.reachingDefs[k].physicalType,
                           currentInfo.reachingDefs[k].offsetPC, tmpInfo.reachingDefs[k2].offsetPC);
                     SET_JIT_ERROR(kJitErrorRegAllocFailed);
                     return -1;
                 }
                 if(currentInfo.reachingDefs[k].accessType != tmpInfo.reachingDefs[k2].accessType) {
-                    ALOGE("JIT_ERROR: defs on the same VR %d %d with different accessType\n",
+                    ALOGI("JIT_INFO: defs on the same VR %d %d with different accessType\n",
                           currentInfo.reachingDefs[k].regNum, currentInfo.reachingDefs[k].physicalType);
                     SET_JIT_ERROR(kJitErrorRegAllocFailed);
                     return -1;
@@ -1349,7 +1349,7 @@ static int updateReachingDefB2(void) {
         }
         if(!merged) {
             if(currentInfo.num_reaching_defs >= 3) {
-                ALOGE("JIT_ERROR: more than 3 reaching defs for currentInfo at updateReachingDefB2\n");
+                ALOGI("JIT_INFO: more than 3 reaching defs for currentInfo at updateReachingDefB2\n");
                 SET_JIT_ERROR(kJitErrorRegAllocFailed);
                 return -1;
             }
@@ -1428,7 +1428,7 @@ void updateDefUseTable() {
 RegAccessType insertAUse(DefUsePair* ptr, int offsetPC, int regNum, LowOpndRegType physicalType) {
     DefOrUseLink* tLink = (DefOrUseLink*)malloc(sizeof(DefOrUseLink));
     if(tLink == NULL) {
-        ALOGE("JIT_ERROR: Memory allocation failed at insertAUse");
+        ALOGI("JIT_INFO: Memory allocation failed at insertAUse");
         SET_JIT_ERROR(kJitErrorMallocFailed);
         return REGACCESS_UNKNOWN;
     }
@@ -1463,7 +1463,7 @@ RegAccessType insertAUse(DefUsePair* ptr, int offsetPC, int regNum, LowOpndRegTy
 DefUsePair* insertADef(int offsetPC, int regNum, LowOpndRegType pType, RegAccessType rType) {
     DefUsePair* ptr = (DefUsePair*)malloc(sizeof(DefUsePair));
     if(ptr == NULL) {
-        ALOGE("JIT_ERROR: Memory allocation failed at insertADef");
+        ALOGI("JIT_INFO: Memory allocation failed at insertADef");
         SET_JIT_ERROR(kJitErrorMallocFailed);
         return NULL;
     }
@@ -1548,7 +1548,7 @@ static int insertLoadXfer(int offset, int regNum, LowOpndRegType pType) {
 #endif
     currentBB->num_xfer_points++;
     if(currentBB->num_xfer_points >= MAX_XFER_PER_BB) {
-        ALOGE("JIT_ERROR: Number of transfer points (%d) exceed maximum (%d)", currentBB->num_xfer_points, MAX_XFER_PER_BB);
+        ALOGI("JIT_INFO: Number of transfer points (%d) exceed maximum (%d)", currentBB->num_xfer_points, MAX_XFER_PER_BB);
         SET_JIT_ERROR(kJitErrorMaxXferPoints);
         return -1;
     }
@@ -1662,7 +1662,7 @@ int updateXferPoints() {
 #endif
                 currentBB->num_xfer_points++;
                 if(currentBB->num_xfer_points >= MAX_XFER_PER_BB) {
-                    ALOGE("JIT_ERROR: Number of transfer points (%d) exceed maximum (%d)", currentBB->num_xfer_points, MAX_XFER_PER_BB);
+                    ALOGI("JIT_INFO: Number of transfer points (%d) exceed maximum (%d)", currentBB->num_xfer_points, MAX_XFER_PER_BB);
                     SET_JIT_ERROR(kJitErrorMaxXferPoints);
                     return -1;
                 }
@@ -1751,7 +1751,7 @@ int updateXferPoints() {
 #endif
             currentBB->num_xfer_points++;
             if(currentBB->num_xfer_points >= MAX_XFER_PER_BB) {
-                ALOGE("JIT_ERROR: Number of transfer points (%d) exceed maximum (%d)", currentBB->num_xfer_points, MAX_XFER_PER_BB);
+                ALOGI("JIT_INFO: Number of transfer points (%d) exceed maximum (%d)", currentBB->num_xfer_points, MAX_XFER_PER_BB);
                 SET_JIT_ERROR(kJitErrorMaxXferPoints);
                 return -1;
             }
@@ -1787,7 +1787,7 @@ static int updateLiveTable(void) {
             ptr->num_uses = 1;
             ptr->uses = (DefOrUseLink*)malloc(sizeof(DefOrUseLink));
             if(ptr->uses == NULL) {
-                ALOGE("JIT_ERROR: Memory allocation failed in updateLiveTable");
+                ALOGI("JIT_INFO: Memory allocation failed in updateLiveTable");
                 SET_JIT_ERROR(kJitErrorMallocFailed);
                 return -1;
             }
@@ -1960,13 +1960,13 @@ static int mergeLiveRange(int tableIndex, int rangeStart, int rangeEnd) {
     }
 
     if(endIndex < startIndex+1) {
-        ALOGE("JIT_ERROR: mergeLiveRange endIndex %d is less than startIndex %d\n", endIndex, startIndex);
+        ALOGI("JIT_INFO: mergeLiveRange endIndex %d is less than startIndex %d\n", endIndex, startIndex);
         SET_JIT_ERROR(kJitErrorMergeLiveRange);
         return -1;
     }
     ///////// use ptrStart & ptrEnd_prev
     if(ptrStart == NULL || ptrEnd_prev == NULL) {
-        ALOGE("JIT_ERROR: mergeLiveRange ptr is NULL\n");
+        ALOGI("JIT_INFO: mergeLiveRange ptr is NULL\n");
         SET_JIT_ERROR(kJitErrorMergeLiveRange);
         return -1;
     }
@@ -1981,7 +1981,7 @@ static int mergeLiveRange(int tableIndex, int rangeStart, int rangeEnd) {
     ALOGI("LIVERANGE merge entries for tableIndex %d from %d to %d", tableIndex, startIndex+1, endIndex-1);
 #endif
     if(ptrStart->num_access <= 0) {
-        ALOGE("JIT_ERROR: mergeLiveRange number of access");
+        ALOGI("JIT_INFO: mergeLiveRange number of access");
         SET_JIT_ERROR(kJitErrorMergeLiveRange);
     }
 #ifdef DEBUG_LIVE_RANGE
@@ -2470,7 +2470,7 @@ int registerAlloc(int type, int reg, bool isPhysical, bool updateRefCount) {
     if(newType & LowOpndRegType_scratch) reg = reg - PhysicalReg_SCRATCH_1 + 1;
     int tIndex = searchCompileTable(newType, reg);
     if(tIndex < 0) {
-      ALOGE("JIT_ERROR: reg %d type %d not found in registerAlloc\n", reg, newType);
+      ALOGI("JIT_INFO: reg %d type %d not found in registerAlloc\n", reg, newType);
       SET_JIT_ERROR(kJitErrorRegAllocFailed);
       return PhysicalReg_Null;
     }
@@ -2534,7 +2534,7 @@ int registerAlloc(int type, int reg, bool isPhysical, bool updateRefCount) {
 //!This is used when MOVE_OPT is on, it tries to alias a virtual register with a temporary to remove a move
 int registerAllocMove(int reg, int type, bool isPhysical, int srcReg) {
     if(srcReg == PhysicalReg_EDI || srcReg == PhysicalReg_ESP || srcReg == PhysicalReg_EBP) {
-        ALOGE("JIT_ERROR: Cannot move from srcReg EDI or ESP or EBP");
+        ALOGI("JIT_INFO: Cannot move from srcReg EDI or ESP or EBP");
         SET_JIT_ERROR(kJitErrorRegAllocFailed);
         return -1;
     }
@@ -2545,7 +2545,7 @@ int registerAllocMove(int reg, int type, bool isPhysical, int srcReg) {
     if(newType & LowOpndRegType_scratch) reg = reg - PhysicalReg_SCRATCH_1 + 1;
     int index = searchCompileTable(newType, reg);
     if(index < 0) {
-        ALOGE("JIT_ERROR: reg %d type %d not found in registerAllocMove", reg, newType);
+        ALOGI("JIT_INFO: reg %d type %d not found in registerAllocMove", reg, newType);
         SET_JIT_ERROR(kJitErrorRegAllocFailed);
         return -1;
     }
@@ -2598,7 +2598,7 @@ int getFreeReg(int type, int reg, int indexToCompileTable) {
 
         int index = searchVirtualInfoOfBB((LowOpndRegType)(type&MASK_FOR_TYPE), reg, currentBB);
         if(index < 0) {
-            ALOGE("JIT_ERROR: VR %d %d not found in infoBasicBlock of currentBB %d (num of VRs %d)",
+            ALOGI("JIT_INFO: VR %d %d not found in infoBasicBlock of currentBB %d (num of VRs %d)",
                   reg, type, currentBB->bb_index, currentBB->num_regs);
             SET_JIT_ERROR(kJitErrorRegAllocFailed);
             //Error trickles down to dvmCompilerMIR2LIR, trace is rejected
@@ -2650,7 +2650,7 @@ int getFreeReg(int type, int reg, int indexToCompileTable) {
         if(vr_num >= 0) {
             int index3 = searchCompileTable(LowOpndRegType_gp | LowOpndRegType_virtual, vr_num);
             if(index3 < 0) {
-                ALOGE("JIT_ERROR: Inavlid linkage VR for temporary register %d", vr_num);
+                ALOGI("JIT_INFO: Inavlid linkage VR for temporary register %d", vr_num);
                 SET_JIT_ERROR(kJitErrorRegAllocFailed);
                 //Error trickles down to dvmCompilerMIR2LIR, trace is rejected
                 return -1;
@@ -2659,7 +2659,7 @@ int getFreeReg(int type, int reg, int indexToCompileTable) {
             if(compileTable[index3].physicalReg == PhysicalReg_Null) {
                 int index2 = searchVirtualInfoOfBB(LowOpndRegType_gp, vr_num, currentBB);
                 if(index2 < 0) {
-                    ALOGE("JIT_ERROR: In tracing linkage to VR %d", vr_num);
+                    ALOGI("JIT_INFO: In tracing linkage to VR %d", vr_num);
                     SET_JIT_ERROR(kJitErrorRegAllocFailed);
                     //Error trickles down to dvmCompilerMIR2LIR, trace is rejected
                     return -1;
@@ -2859,7 +2859,7 @@ PhysicalReg spillForLogicalReg(int type, int reg, int indexToCompileTable) {
     }
     if(index < 0) {
         dumpCompileTable();
-        ALOGE("JIT_ERROR: no register to spill for logical %d %d\n", reg, type);
+        ALOGI("JIT_INFO: no register to spill for logical %d %d\n", reg, type);
         SET_JIT_ERROR(kJitErrorRegAllocFailed);
         //Error trickles down to dvmCompilerMIR2LIR, trace is rejected
         return PhysicalReg_Null;
@@ -2878,7 +2878,7 @@ PhysicalReg spillForLogicalReg(int type, int reg, int indexToCompileTable) {
 //!Return the physical register that was allocated to the variable
 int spillLogicalReg(int spill_index, bool updateTable) {
     if((compileTable[spill_index].physicalType & LowOpndRegType_hard) != 0) {
-        ALOGE("JIT_ERROR: can't spill a hard-coded register");
+        ALOGI("JIT_INFO: can't spill a hard-coded register");
         SET_JIT_ERROR(kJitErrorRegAllocFailed);
         //Error trickles down to dvmCompilerMIR2LIR, trace is rejected
         return -1;
@@ -2951,7 +2951,7 @@ int unspillLogicalReg(int spill_index, int physicalReg) {
 int spillVirtualReg(int vrNum, LowOpndRegType type, bool updateTable) {
     int index = searchCompileTable(type | LowOpndRegType_virtual, vrNum);
     if(index < 0) {
-        ALOGE("JIT_ERROR: Cannot find VR %d %d in spillVirtualReg", vrNum, type);
+        ALOGI("JIT_INFO: Cannot find VR %d %d in spillVirtualReg", vrNum, type);
         SET_JIT_ERROR(kJitErrorRegAllocFailed);
         return -1;
     }
@@ -3004,7 +3004,7 @@ int spillForHardReg(int regNum, int type) {
 //! allocConstraints specify how many times a hardcoded register is used in this basic block
 void updateCurrentBBWithConstraints(PhysicalReg reg) {
     if(reg > PhysicalReg_EBP) {
-        ALOGE("JIT_ERROR: Register %d out of range in updateCurrentBBWithConstraints\n", reg);
+        ALOGI("JIT_INFO: Register %d out of range in updateCurrentBBWithConstraints\n", reg);
         SET_JIT_ERROR(kJitErrorRegAllocFailed);
         return;
     }
@@ -3072,7 +3072,7 @@ int sortAllocConstraint(RegAllocConstraint* allocConstraints,
 int findVirtualRegInTable(u2 vA, LowOpndRegType type) {
     int k = searchCompileTable(type | LowOpndRegType_virtual, vA);
     if(k < 0) {
-        ALOGE("JIT_ERROR: Couldn't find virtual register %d type %d in compiler table\n", vA, type);
+        ALOGI("JIT_INFO: Couldn't find virtual register %d type %d in compiler table\n", vA, type);
         SET_JIT_ERROR(kJitErrorRegAllocFailed);
         //Error trickles down to dvmCompilerMIR2LIR, trace is rejected
         return -1;
@@ -3121,7 +3121,7 @@ int isVirtualRegConstant(int regNum, LowOpndRegType type, int* valuePtr, bool up
         if(updateRefCount) {
             int indexOrig = searchCompileTable(type | LowOpndRegType_virtual, regNum);
             if(indexOrig < 0) {
-                ALOGE("JIT_ERROR: Cannot find VR in isVirtualRegConstant num %d type %d\n", regNum, type);
+                ALOGI("JIT_INFO: Cannot find VR in isVirtualRegConstant num %d type %d\n", regNum, type);
                 SET_JIT_ERROR(kJitErrorRegAllocFailed);
                 return -1;
             }
@@ -3377,7 +3377,7 @@ static int getDeadStmts() {
                 num_defs++;
                 DefUsePair* indexT = searchDefUseTable(offsetPC, infoByteCode[k].regNum, infoByteCode[k].physicalType);
                 if(indexT == NULL) {
-                    ALOGE("JIT_ERROR: Def at %x of VR %d %d not in table\n",
+                    ALOGI("JIT_INFO: Def at %x of VR %d %d not in table\n",
                         offsetPC, infoByteCode[k].regNum, infoByteCode[k].physicalType);
                     SET_JIT_ERROR(kJitErrorRegAllocFailed);
                     return -1;
@@ -3521,14 +3521,14 @@ void setVRToMemory(int regNum, OpndSize size) {
     int indexH = -1;
     if(size == OpndSize_64) indexH = searchMemTable(regNum+1);
     if(indexL < 0) {
-        ALOGE("JIT_ERROR: VR %d not in memVRTable at setVRToMemory", regNum);
+        ALOGI("JIT_INFO: VR %d not in memVRTable at setVRToMemory", regNum);
         SET_JIT_ERROR(kJitErrorRegAllocFailed);
         return;
     }
     memVRTable[indexL].inMemory = true;
     if(size == OpndSize_64) {
         if(indexH < 0) {
-            ALOGE("JIT_ERROR: VR %d not in memVRTabl at setVRToMemory for upper 64-bits", regNum+1);
+            ALOGI("JIT_INFO: VR %d not in memVRTabl at setVRToMemory for upper 64-bits", regNum+1);
             SET_JIT_ERROR(kJitErrorRegAllocFailed);
             return;
         }
@@ -3540,13 +3540,13 @@ void setVRToMemory(int regNum, OpndSize size) {
 //!
 bool isVRNullCheck(int regNum, OpndSize size) {
     if(size != OpndSize_32) {
-        ALOGE("JIT_ERROR: isVRNullCheck size is not 32 for register %d", regNum);
+        ALOGI("JIT_INFO: isVRNullCheck size is not 32 for register %d", regNum);
         SET_JIT_ERROR(kJitErrorNullBoundCheckFailed);
         return false;
     }
     int indexL = searchMemTable(regNum);
     if(indexL < 0) {
-        ALOGE("JIT_ERROR: VR %d not in memVRTable at isVRNullCheck", regNum);
+        ALOGI("JIT_INFO: VR %d not in memVRTable at isVRNullCheck", regNum);
         SET_JIT_ERROR(kJitErrorRegAllocFailed);
         return false;
     }
@@ -3555,7 +3555,7 @@ bool isVRNullCheck(int regNum, OpndSize size) {
 bool isVRBoundCheck(int vr_array, int vr_index) {
     int indexL = searchMemTable(vr_array);
     if(indexL < 0) {
-        ALOGE("JIT_ERROR: VR %d not in memVRTable at isVRBoundCheck", vr_array);
+        ALOGI("JIT_INFO: VR %d not in memVRTable at isVRBoundCheck", vr_array);
         SET_JIT_ERROR(kJitErrorNullBoundCheckFailed);
         return false;
     }
@@ -3571,13 +3571,13 @@ bool isVRBoundCheck(int vr_array, int vr_index) {
 //! \return -1 if error happened, 0 otherwise
 int setVRNullCheck(int regNum, OpndSize size) {
     if(size != OpndSize_32) {
-        ALOGE("JIT_ERROR: setVRNullCheck size should be 32\n");
+        ALOGI("JIT_INFO: setVRNullCheck size should be 32\n");
         SET_JIT_ERROR(kJitErrorNullBoundCheckFailed);
         return -1;
     }
     int indexL = searchMemTable(regNum);
     if(indexL < 0) {
-        ALOGE("JIT_ERROR: VR %d not in memVRTable at setVRNullCheck", regNum);
+        ALOGI("JIT_INFO: VR %d not in memVRTable at setVRNullCheck", regNum);
         SET_JIT_ERROR(kJitErrorRegAllocFailed);
         return -1;
     }
@@ -3587,7 +3587,7 @@ int setVRNullCheck(int regNum, OpndSize size) {
 void setVRBoundCheck(int vr_array, int vr_index) {
     int indexL = searchMemTable(vr_array);
     if(indexL < 0) {
-        ALOGE("JIT_ERROR: VR %d not in memVRTable at setVRBoundCheck", vr_array);
+        ALOGI("JIT_INFO: VR %d not in memVRTable at setVRBoundCheck", vr_array);
         SET_JIT_ERROR(kJitErrorRegAllocFailed);
         return;
     }
@@ -3655,7 +3655,7 @@ int requestVRFreeDelay(int regNum, u4 reason) {
     if(indexL >= 0) {
         memVRTable[indexL].delayFreeFlags |= reason;
     } else {
-        ALOGE("JIT_ERROR: At requestVRFreeDelay: VR %d not in memVRTable", regNum);
+        ALOGI("JIT_INFO: At requestVRFreeDelay: VR %d not in memVRTable", regNum);
         SET_JIT_ERROR(kJitErrorRegAllocFailed);
         return -1;
     }
@@ -3820,7 +3820,7 @@ int getSpillIndex(bool isGLUE, OpndSize size) {
             return k;
         }
     }
-    ALOGE("JIT_ERROR: Cannot find spill position in spillLogicalReg\n");
+    ALOGI("JIT_INFO: Cannot find spill position in spillLogicalReg\n");
     SET_JIT_ERROR(kJitErrorRegAllocFailed);
     return -1;
 }
@@ -4128,7 +4128,7 @@ bool isTemp8Bit(int type, int reg) {
             return infoByteCodeTemp[k].is8Bit;
         }
     }
-    ALOGE("JIT_ERROR: Could not find reg %d type %d at isTemp8Bit", reg, type);
+    ALOGI("JIT_INFO: Could not find reg %d type %d at isTemp8Bit", reg, type);
     SET_JIT_ERROR(kJitErrorRegAllocFailed);
     return false;
 }
@@ -4142,7 +4142,7 @@ bool isTemp8Bit(int type, int reg) {
 bool isVRLive(int vA) {
     int index = searchMemTable(vA);
     if(index < 0) {
-        ALOGE("JIT_ERROR: Could not find VR %d in memTable at isVRLive", vA);
+        ALOGI("JIT_INFO: Could not find VR %d in memTable at isVRLive", vA);
         SET_JIT_ERROR(kJitErrorRegAllocFailed);
         return false;
     }
@@ -4166,7 +4166,7 @@ bool isLastByteCodeOfLiveRange(int compileIndex) {
         /* check live ranges for the VR */
         index = searchMemTable(compileTable[k].regNum);
         if(index < 0) {
-            ALOGE("JIT_ERROR: Could not find 32-bit VR %d in memTable at isLastByteCodeOfLiveRange", compileTable[k].regNum);
+            ALOGI("JIT_INFO: Could not find 32-bit VR %d in memTable at isLastByteCodeOfLiveRange", compileTable[k].regNum);
             SET_JIT_ERROR(kJitErrorRegAllocFailed);
             return false;
         }
@@ -4182,7 +4182,7 @@ bool isLastByteCodeOfLiveRange(int compileIndex) {
     index = searchMemTable(compileTable[k].regNum);
     bool tmpB = false;
     if(index < 0) {
-        ALOGE("JIT_ERROR: Could not find 64-bit VR %d (lower 32) in memTable at isLastByteCodeOfLiveRange", compileTable[k].regNum);
+        ALOGI("JIT_INFO: Could not find 64-bit VR %d (lower 32) in memTable at isLastByteCodeOfLiveRange", compileTable[k].regNum);
         SET_JIT_ERROR(kJitErrorRegAllocFailed);
         return false;
     }
@@ -4198,7 +4198,7 @@ bool isLastByteCodeOfLiveRange(int compileIndex) {
     /* check live ranges of the high half */
     index = searchMemTable(compileTable[k].regNum+1);
     if(index < 0) {
-        ALOGE("JIT_ERROR: Could not find 64-bit VR %d (upper 32) in memTable at isLastByteCodeOfLiveRange", compileTable[k].regNum+1);
+        ALOGI("JIT_INFO: Could not find 64-bit VR %d (upper 32) in memTable at isLastByteCodeOfLiveRange", compileTable[k].regNum+1);
         SET_JIT_ERROR(kJitErrorRegAllocFailed);
         return false;
     }
@@ -4222,7 +4222,7 @@ bool loopIndepUse(int compileIndex) {
     /* check live ranges of the low half */
     index = searchMemTable(compileTable[k].regNum);
     if(index < 0) {
-        ALOGE("JIT_ERROR: Could not find 32-bit VR %d in memTable at loopIndepUse", compileTable[k].regNum);
+        ALOGI("JIT_INFO: Could not find 32-bit VR %d in memTable at loopIndepUse", compileTable[k].regNum);
         SET_JIT_ERROR(kJitErrorRegAllocFailed);
         return false;
     }
@@ -4235,7 +4235,7 @@ bool loopIndepUse(int compileIndex) {
     /* check for the high half */
     index = searchMemTable(compileTable[k].regNum+1);
     if(index < 0) {
-        ALOGE("JIT_ERROR: Could not find 64-bit VR %d in memTable at loopIndepUse", compileTable[k].regNum+1);
+        ALOGI("JIT_INFO: Could not find 64-bit VR %d in memTable at loopIndepUse", compileTable[k].regNum+1);
         SET_JIT_ERROR(kJitErrorRegAllocFailed);
         return false;
     }
@@ -4257,7 +4257,7 @@ bool reachEndOfBB(int compileIndex) {
     /* check live ranges of the low half */
     index = searchMemTable(compileTable[k].regNum);
     if(index < 0) {
-        ALOGE("JIT_ERROR: Could not find 32-bit VR %d in memTable at reachEndOfBB", compileTable[k].regNum);
+        ALOGI("JIT_INFO: Could not find 32-bit VR %d in memTable at reachEndOfBB", compileTable[k].regNum);
         SET_JIT_ERROR(kJitErrorRegAllocFailed);
         return false;
     }
@@ -4277,7 +4277,7 @@ bool reachEndOfBB(int compileIndex) {
     /* check live ranges of the high half */
     index = searchMemTable(compileTable[k].regNum+1);
     if(index < 0) {
-        ALOGE("JIT_ERROR: Could not find 64-bit VR %d in memTable at reachEndOfBB", compileTable[k].regNum+1);
+        ALOGI("JIT_INFO: Could not find 64-bit VR %d in memTable at reachEndOfBB", compileTable[k].regNum+1);
         SET_JIT_ERROR(kJitErrorRegAllocFailed);
         return false;
     }
@@ -4307,7 +4307,7 @@ bool isNextToLastAccess(int compileIndex) {
     bool retCode = false;
     index = searchMemTable(compileTable[k].regNum);
     if(index < 0) {
-        ALOGE("JIT_ERROR: Could not find 32-bit VR %d in memTable at isNextToLastAccess", compileTable[k].regNum);
+        ALOGI("JIT_INFO: Could not find 32-bit VR %d in memTable at isNextToLastAccess", compileTable[k].regNum);
         SET_JIT_ERROR(kJitErrorRegAllocFailed);
         return false;
     }
@@ -4331,7 +4331,7 @@ bool isNextToLastAccess(int compileIndex) {
     /* check live ranges for the high half */
     index = searchMemTable(compileTable[k].regNum+1);
     if(index < 0) {
-        ALOGE("JIT_ERROR: Could not find 64-bit VR %d in memTable at isNextToLastAccess", compileTable[k].regNum+1);
+        ALOGI("JIT_INFO: Could not find 64-bit VR %d in memTable at isNextToLastAccess", compileTable[k].regNum+1);
         SET_JIT_ERROR(kJitErrorRegAllocFailed);
         return false;
     }
@@ -4362,7 +4362,7 @@ int getNextLiveRange(int compileIndex) {
     int index;
     index = searchMemTable(compileTable[k].regNum);
     if(index < 0) {
-        ALOGE("JIT_ERROR: Could not find 32-bit VR %d in memTable at getNextLiveRange", compileTable[k].regNum);
+        ALOGI("JIT_INFO: Could not find 32-bit VR %d in memTable at getNextLiveRange", compileTable[k].regNum);
         SET_JIT_ERROR(kJitErrorRegAllocFailed);
         return offsetPC;
     }
@@ -4384,7 +4384,7 @@ int getNextLiveRange(int compileIndex) {
     found = false;
     index = searchMemTable(compileTable[k].regNum+1);
     if(index < 0) {
-        ALOGE("JIT_ERROR: Could not find 64-bit VR %d in memTable at getNextLiveRange", compileTable[k].regNum+1);
+        ALOGI("JIT_INFO: Could not find 64-bit VR %d in memTable at getNextLiveRange", compileTable[k].regNum+1);
         SET_JIT_ERROR(kJitErrorRegAllocFailed);
         return offsetPC;
     }
@@ -4414,7 +4414,7 @@ int getNextAccess(int compileIndex) {
     /* check live ranges of the low half */
     index = searchMemTable(compileTable[k].regNum);
     if(index < 0) {
-        ALOGE("JIT_ERROR: Could not find 32-bit VR %d in memTable at getNextAccess", compileTable[k].regNum);
+        ALOGI("JIT_INFO: Could not find 32-bit VR %d in memTable at getNextAccess", compileTable[k].regNum);
         SET_JIT_ERROR(kJitErrorRegAllocFailed);
         return offsetPC;
     }
@@ -4446,7 +4446,7 @@ int getNextAccess(int compileIndex) {
     found = false;
     index = searchMemTable(compileTable[k].regNum+1);
     if(index < 0) {
-        ALOGE("JIT_ERROR: Could not find 64-bit VR %d in memTable at getNextAccess", compileTable[k].regNum+1);
+        ALOGI("JIT_INFO: Could not find 64-bit VR %d in memTable at getNextAccess", compileTable[k].regNum+1);
         SET_JIT_ERROR(kJitErrorRegAllocFailed);
         return offsetPC;
     }
@@ -4571,7 +4571,7 @@ int freeReg(bool spillGL) {
                     /* update spill info for temporaries */
                     spillIndexUsed[compileTable[k].spill_loc_index >> 2] = 0;
                     compileTable[k].spill_loc_index = -1;
-                    ALOGE("JIT_ERROR: free a temporary register with TRSTATE_SPILLED\n");
+                    ALOGI("JIT_INFO: free a temporary register with TRSTATE_SPILLED\n");
                     SET_JIT_ERROR(kJitErrorRegAllocFailed);
                     return -1;
                 }
@@ -4592,7 +4592,7 @@ void decreaseRefCount(int index) {
 #endif
     compileTable[index].refCount--;
     if(compileTable[index].refCount < 0) {
-        ALOGE("JIT_ERROR: refCount is negative for REG %d %d at decreaseRefCount",
+        ALOGI("JIT_INFO: refCount is negative for REG %d %d at decreaseRefCount",
                 compileTable[index].regNum, compileTable[index].physicalType);
         SET_JIT_ERROR(kJitErrorRegAllocFailed);
         return;
@@ -4605,7 +4605,7 @@ int updateRefCount(int reg, LowOpndRegType type) {
     if(currentBB == NULL) return 0;
     int index = searchCompileTable(LowOpndRegType_virtual | type, reg);
     if(index < 0) {
-        ALOGE("JIT_ERROR: virtual reg %d type %d not found in updateRefCount\n", reg, type);
+        ALOGI("JIT_INFO: virtual reg %d type %d not found in updateRefCount\n", reg, type);
         SET_JIT_ERROR(kJitErrorRegAllocFailed);
         return -1;
     }
@@ -4621,7 +4621,7 @@ int updateRefCount2(int reg, int type, bool isPhysical) {
     if(newType & LowOpndRegType_scratch) reg = reg - PhysicalReg_SCRATCH_1 + 1;
     int index = searchCompileTable(newType, reg);
     if(index < 0) {
-        ALOGE("JIT_ERROR: reg %d type %d not found in updateRefCount\n", reg, newType);
+        ALOGI("JIT_INFO: reg %d type %d not found in updateRefCount\n", reg, newType);
         SET_JIT_ERROR(kJitErrorRegAllocFailed);
         return -1;
     }
@@ -4635,7 +4635,7 @@ bool isGlueHandled(int glue_reg) {
     if(currentBB == NULL) return false;
     int index = searchCompileTable(LowOpndRegType_gp, glue_reg);
     if(index < 0) {
-        ALOGE("JIT_ERROR: glue reg %d not found in isGlueHandled\n", glue_reg);
+        ALOGI("JIT_INFO: glue reg %d not found in isGlueHandled\n", glue_reg);
         SET_JIT_ERROR(kJitErrorRegAllocFailed);
         return -1;
     }
@@ -4664,7 +4664,7 @@ int resetGlue(int glue_reg) {
         return 0;
     int index = searchCompileTable(LowOpndRegType_gp, glue_reg);
     if(index < 0) {
-        ALOGE("JIT_ERROR: glue reg %d not found in resetGlue\n", glue_reg);
+        ALOGI("JIT_INFO: glue reg %d not found in resetGlue\n", glue_reg);
         SET_JIT_ERROR(kJitErrorRegAllocFailed);
         return -1;
     }
@@ -4691,7 +4691,7 @@ int updateGlue(int reg, bool isPhysical, int glue_reg) {
         return 0;
     int index = searchCompileTable(LowOpndRegType_gp, glue_reg);
     if(index < 0) {
-        ALOGE("JIT_ERROR: updateGlue reg %d type %d\n", reg, glue_reg);
+        ALOGI("JIT_INFO: updateGlue reg %d type %d\n", reg, glue_reg);
         SET_JIT_ERROR(kJitErrorRegAllocFailed);
         return -1;
     }
@@ -4700,7 +4700,7 @@ int updateGlue(int reg, bool isPhysical, int glue_reg) {
     if(newType & LowOpndRegType_scratch) reg = reg - PhysicalReg_SCRATCH_1 + 1;
     int index2 = searchCompileTable(newType, reg);
     if(index2 < 0 || compileTable[index2].physicalReg == PhysicalReg_Null) {
-        ALOGE("JIT_ERROR: updateGlue reg %d type %d for index2", reg, newType);
+        ALOGI("JIT_INFO: updateGlue reg %d type %d for index2", reg, newType);
         SET_JIT_ERROR(kJitErrorRegAllocFailed);
         return -1;
     }
@@ -4721,7 +4721,7 @@ int checkVirtualReg(int reg, LowOpndRegType type, int updateRefCount) {
     if(currentBB == NULL) return PhysicalReg_Null;
     int index = searchCompileTable(LowOpndRegType_virtual | type, reg);
     if(index < 0) {
-        ALOGE("JIT_ERROR: virtual reg %d type %d not found in checkVirtualReg\n", reg, type);
+        ALOGI("JIT_INFO: virtual reg %d type %d not found in checkVirtualReg\n", reg, type);
         SET_JIT_ERROR(kJitErrorRegAllocFailed);
         return PhysicalReg_Null;
     }
@@ -4768,7 +4768,7 @@ bool checkTempReg2(int reg, int type, bool isPhysical, int physicalRegForVR, u2
                 return false;
         }
     }
-    ALOGE("JIT_ERROR: in checkTempReg2 %d %d\n", reg, newType);
+    ALOGI("JIT_INFO: in checkTempReg2 %d %d\n", reg, newType);
     SET_JIT_ERROR(kJitErrorRegAllocFailed);
     return false;
 }
@@ -4782,7 +4782,7 @@ int checkTempReg(int reg, int type, bool isPhysical, int vrNum) {
     if(newType & LowOpndRegType_scratch) reg = reg - PhysicalReg_SCRATCH_1 + 1;
     int index = searchCompileTable(newType, reg);
     if(index < 0) {
-        ALOGE("JIT_ERROR: temp reg %d type %d not found in checkTempReg\n", reg, newType);
+        ALOGI("JIT_INFO: temp reg %d type %d not found in checkTempReg\n", reg, newType);
         SET_JIT_ERROR(kJitErrorRegAllocFailed);
         return PhysicalReg_Null;
     }
@@ -4957,7 +4957,7 @@ int globalVREndOfBB(const Method* method) {
 #endif
                 compileTable[k].physicalReg = compileTable[k].physicalReg_prev;
                 if(allRegs[compileTable[k].physicalReg_prev].isUsed) {
-                    ALOGE("JIT_ERROR: Physical register for GG VR is still used\n");
+                    ALOGI("JIT_INFO: Physical register for GG VR is still used\n");
                     SET_JIT_ERROR(kJitErrorRegAllocFailed);
                     return -1;
                 }
@@ -4981,7 +4981,7 @@ int globalVREndOfBB(const Method* method) {
 int nextVersionOfHardReg(PhysicalReg pReg, int refCount) {
     int indexT = searchCompileTable(LowOpndRegType_gp | LowOpndRegType_hard, pReg);
     if(indexT < 0) {
-        ALOGE("JIT_ERROR: Physical reg not found at nextVersionOfHardReg");
+        ALOGI("JIT_INFO: Physical reg not found at nextVersionOfHardReg");
         SET_JIT_ERROR(kJitErrorRegAllocFailed);
         return -1;
     }
@@ -5013,7 +5013,7 @@ int insertFromVirtualInfo(BasicBlock_O1* bb, int k) {
         compileTable[num_compile_entries].gType = bb->infoBasicBlock[k].gType;
         num_compile_entries++;
         if(num_compile_entries >= COMPILE_TABLE_SIZE) {
-            ALOGE("JIT_ERROR: compileTable overflow at insertFromVirtualInfo");
+            ALOGI("JIT_INFO: compileTable overflow at insertFromVirtualInfo");
             SET_JIT_ERROR(kJitErrorRegAllocFailed);
             return -1;
         }
@@ -5040,7 +5040,7 @@ int insertFromTempInfo(int k) {
         compileTable[num_compile_entries].regNum = infoByteCodeTemp[k].regNum;
         num_compile_entries++;
         if(num_compile_entries >= COMPILE_TABLE_SIZE) {
-            ALOGE("JIT_ERROR: compileTable overflow at insertFromTempInfo");
+            ALOGI("JIT_INFO: compileTable overflow at insertFromTempInfo");
             SET_JIT_ERROR(kJitErrorRegAllocFailed);
             return -1;
         }
@@ -5067,7 +5067,7 @@ void insertGlueReg() {
 
     num_compile_entries++;
     if(num_compile_entries >= COMPILE_TABLE_SIZE) {
-        ALOGE("JIT_ERROR: compileTable overflow at insertGlueReg");
+        ALOGI("JIT_INFO: compileTable overflow at insertGlueReg");
         SET_JIT_ERROR(kJitErrorRegAllocFailed);
         return;
     }
@@ -5120,7 +5120,7 @@ bool isFirstOfHandler(BasicBlock_O1* bb) {
 BasicBlock_O1* createBasicBlock(int src_pc, int end_pc) {
     BasicBlock_O1* bb = (BasicBlock_O1*)malloc(sizeof(BasicBlock_O1));
     if(bb == NULL) {
-        ALOGE("JIT_ERROR: Out of memory when trying to alloc basic block for pc %d\n", src_pc);
+        ALOGI("JIT_INFO: Out of memory when trying to alloc basic block for pc %d\n", src_pc);
         SET_JIT_ERROR(kJitErrorMallocFailed);
         return NULL;
     }
@@ -5146,7 +5146,7 @@ BasicBlock_O1* createBasicBlock(int src_pc, int end_pc) {
     }
     num_bbs_for_method++;
     if(num_bbs_for_method >= MAX_NUM_BBS_PER_METHOD) {
-        ALOGE("JIT_ERROR: Exceeded maximum number of basic blocks\n");
+        ALOGI("JIT_INFO: Exceeded maximum number of basic blocks\n");
         SET_JIT_ERROR(kJitErrorTraceFormation);
         return NULL;
     }
@@ -5180,7 +5180,7 @@ void rememberState(int stateNum) {
             stateTable1_4[k].spill_loc_index = compileTable[k].spill_loc_index;
         }
         else {
-            ALOGE("JIT_ERROR: state table overflow at rememberState for compileTable");
+            ALOGI("JIT_INFO: state table overflow at rememberState for compileTable");
             SET_JIT_ERROR(kJitErrorRegAllocFailed);
             return;
         }
@@ -5208,7 +5208,7 @@ void rememberState(int stateNum) {
             stateTable2_4[k].inMemory = memVRTable[k].inMemory;
         }
         else {
-            ALOGE("JIT_ERROR: state table overflow at goToState for compileTable\n");
+            ALOGI("JIT_INFO: state table overflow at goToState for compileTable\n");
             SET_JIT_ERROR(kJitErrorRegAllocFailed);
             return;
         }
@@ -5244,7 +5244,7 @@ void goToState(int stateNum) {
             compileTable[k].spill_loc_index = stateTable1_4[k].spill_loc_index;
         }
         else {
-            ALOGE("JIT_ERROR: State table overflow at goToState");
+            ALOGI("JIT_INFO: State table overflow at goToState");
             SET_JIT_ERROR(kJitErrorStateTransfer);
             return;
         }
@@ -5272,7 +5272,7 @@ void goToState(int stateNum) {
             memVRTable[k].inMemory = stateTable2_4[k].inMemory;
         }
         else {
-            ALOGE("JIT_ERROR: state table overflow at goToState for memVRTable\n");
+            ALOGI("JIT_INFO: state table overflow at goToState for memVRTable\n");
             SET_JIT_ERROR(kJitErrorRegAllocFailed);
             return;
         }
@@ -5313,7 +5313,7 @@ int insertSrcReg(int srcPhysical, int targetReg, int targetSpill, int index) {
     for(k = 0; k < num_src_regs; k++) {
         if(srcRegs[k].physicalReg == srcPhysical) { //increase num_dests
             if(srcRegs[k].num_dests >= MAX_NUM_DEST) {
-                ALOGE("JIT_ERROR: Exceed number dst regs for a source reg\n");
+                ALOGI("JIT_INFO: Exceed number dst regs for a source reg\n");
                 SET_JIT_ERROR(kJitErrorMaxDestRegPerSource);
                 return -1;
             }
@@ -5325,7 +5325,7 @@ int insertSrcReg(int srcPhysical, int targetReg, int targetSpill, int index) {
         }
     }
     if(num_src_regs >= MAX_NUM_DEST) {
-        ALOGE("JIT_ERROR: Exceed number of source regs\n");
+        ALOGI("JIT_INFO: Exceed number of source regs\n");
         SET_JIT_ERROR(kJitErrorMaxDestRegPerSource);
         return -1;
     }
@@ -5568,7 +5568,7 @@ void constructSrcRegs(int stateNum) {
             }
         } //for k
         if(num_handled == prev_handled) {
-            ALOGE("JIT_ERROR: No progress in selecting order while in constructSrcReg");
+            ALOGI("JIT_INFO: No progress in selecting order while in constructSrcReg");
             SET_JIT_ERROR(kJitErrorStateTransfer);
             return;
         }
@@ -5580,7 +5580,7 @@ void constructSrcRegs(int stateNum) {
         }
     }
     if(num_in_order != num_src_regs) {
-        ALOGE("JIT_ERROR: num_in_order != num_src_regs while in constructSrcReg");
+        ALOGI("JIT_INFO: num_in_order != num_src_regs while in constructSrcReg");
         SET_JIT_ERROR(kJitErrorStateTransfer);
         return;
     }
@@ -5601,7 +5601,7 @@ void transferToState(int stateNum) {
     ALOGI("STATE: transfer to state %d", stateNum);
 #endif
     if(stateNum > 4 || stateNum < 1) {
-        ALOGE("JIT_ERROR: State table overflow at transferToState");
+        ALOGI("JIT_INFO: State table overflow at transferToState");
         SET_JIT_ERROR(kJitErrorStateTransfer);
         return;
     }
@@ -5676,7 +5676,7 @@ void transferToState(int stateNum) {
             targetBool = stateTable2_4[k].inMemory;
         }
         if(targetReg != memVRTable[k].regNum) {
-            ALOGE("JIT_ERROR: regNum mismatch in transferToState");
+            ALOGI("JIT_INFO: regNum mismatch in transferToState");
             SET_JIT_ERROR(kJitErrorStateTransfer);
             return;
         }
diff --git a/vm/compiler/codegen/x86/BytecodeVisitor.cpp b/vm/compiler/codegen/x86/BytecodeVisitor.cpp
index a241654..30bf10f 100644
--- a/vm/compiler/codegen/x86/BytecodeVisitor.cpp
+++ b/vm/compiler/codegen/x86/BytecodeVisitor.cpp
@@ -412,7 +412,7 @@ int getByteCodeSize() { //uses inst, unit in u2
     }
 #endif
     default:
-        ALOGE("JIT_ERROR: JIT does not support getting size of bytecode 0x%hx\n",
+        ALOGI("JIT_INFO: JIT does not support getting size of bytecode 0x%hx\n",
                 currentMIR->dalvikInsn.opcode);
         SET_JIT_ERROR(kJitErrorUnsupportedBytecode);
         assert(false && "All opcodes should be supported.");
@@ -431,7 +431,7 @@ int getByteCodeSize() { //uses inst, unit in u2
 static int touchOneVR(u2 vA, LowOpndRegType type) {
     int index = searchCompileTable(LowOpndRegType_virtual | type, vA);
     if(index < 0) {
-        ALOGE("JIT_ERROR: virtual reg %d type %d not found in touchOneVR\n", vA, type);
+        ALOGI("JIT_INFO: virtual reg %d type %d not found in touchOneVR\n", vA, type);
         SET_JIT_ERROR(kJitErrorRegAllocFailed);
         return -1;
     }
@@ -449,14 +449,14 @@ static int touchOneVR(u2 vA, LowOpndRegType type) {
 static int touchTwoVRs(u2 vA, u2 vB, LowOpndRegType type) {
     int index = searchCompileTable(LowOpndRegType_virtual | type, vA);
     if(index < 0) {
-        ALOGE("JIT_ERROR: virtual reg %d type %d not found in touchTwoVRs\n", vA, type);
+        ALOGI("JIT_INFO: virtual reg %d type %d not found in touchTwoVRs\n", vA, type);
         SET_JIT_ERROR(kJitErrorRegAllocFailed);
         return -1;
     }
     compileTable[index].refCount--;
     index = searchCompileTable(LowOpndRegType_virtual | type, vB);
     if(index < 0) {
-        ALOGE("JIT_ERROR: virtual reg %d type %d not found in touchTwoVRs\n", vB, type);
+        ALOGI("JIT_INFO: virtual reg %d type %d not found in touchTwoVRs\n", vB, type);
         SET_JIT_ERROR(kJitErrorRegAllocFailed);
         return -1;
     }
@@ -529,7 +529,7 @@ void setVRToConst(int regNum, OpndSize size, int* tmpValue) {
         constVRTable[indexH].value = tmpValue[1];
     }
     if(num_const_vr > MAX_CONST_REG) {
-        ALOGE("JIT_ERROR: constVRTable overflows at setVRToConst");
+        ALOGI("JIT_INFO: constVRTable overflows at setVRToConst");
         SET_JIT_ERROR(kJitErrorRegAllocFailed);
         return;
     }
@@ -3095,7 +3095,7 @@ int getVirtualRegInfo(VirtualRegInfo* infoArray, const MIR * currentMIR) {
         break;
 #endif
     default:
-        ALOGE("JIT_ERROR: JIT does not support bytecode 0x%hx when updating\n"
+        ALOGI("JIT_INFO: JIT does not support bytecode 0x%hx when updating\n"
                 "VR accesses\n", currentMIR->dalvikInsn.opcode);
         SET_JIT_ERROR(kJitErrorUnsupportedBytecode);
         assert(false && "All opcodes should be supported.");
@@ -6037,7 +6037,7 @@ int getTempRegInfo(TempRegInfo* infoArray, const MIR * currentMIR) { //returns a
     }
 #endif
     default:
-        ALOGE("JIT_ERROR: JIT does not support bytecode 0x%hx when updating\n"
+        ALOGI("JIT_INFO: JIT does not support bytecode 0x%hx when updating\n"
                 "temp accesses\n", currentMIR->dalvikInsn.opcode);
         SET_JIT_ERROR(kJitErrorUnsupportedBytecode);
         assert(false && "All opcodes should be supported.");
diff --git a/vm/compiler/codegen/x86/CodegenErrors.cpp b/vm/compiler/codegen/x86/CodegenErrors.cpp
index e12b826..645ad1a 100644
--- a/vm/compiler/codegen/x86/CodegenErrors.cpp
+++ b/vm/compiler/codegen/x86/CodegenErrors.cpp
@@ -37,7 +37,7 @@ static const char* jitErrorMessages[kJitErrorMaxDefined] = {
     "Problem while performing null or bound check",
     "Problem while merging live ranges (mergeLiveRange)",
     "Global data not defined",
-    "Error while scheduling instructions"
+    "Problem while scheduling instructions"
     //Add error messages here when adding error codes
 };
 
@@ -83,16 +83,16 @@ bool dvmCanFixErrorsAndRetry(CompilationUnit *cUnit){
             //This is the first error we are seeing. Print some information
             //to be noticeable in the logs
             if (!isError) {
-                ALOGE("++++++++++++++++++++++++++++++++++++++++++++");
-                ALOGE("Error while compiling trace  %s%s, offset %d", cUnit->method->clazz->descriptor,
+                ALOGI("++++++++++++++++++++++++++++++++++++++++++++");
+                ALOGI("JIT_INFO: Issues in trace  %s%s, offset %d", cUnit->method->clazz->descriptor,
                      cUnit->method->name, cUnit->traceDesc->trace[0].info.frag.startOffset);
 
                 //If kJitErrorCodegen is the first error we encounter,
                 //somebody forgot to raise an error flag somewhere.
                 //Print a message and reject the trace:
                 if (i == kJitErrorCodegen) {
-                    ALOGE("Unknown error. Error flag not set at error location");
-                    ALOGE("++++++++++++++++++++++++++++++++++++++++++++");
+                    ALOGI("Unknown issue in trace formation");
+                    ALOGI("++++++++++++++++++++++++++++++++++++++++++++");
                     return false;
                 }
 
@@ -100,13 +100,13 @@ bool dvmCanFixErrorsAndRetry(CompilationUnit *cUnit){
                 CLEAR_JIT_ERROR(kJitErrorCodegen);
 
                 isError = true;
-                ALOGE("The following errors occurred:");
+                ALOGE("The following issues were seen:");
             }
 
             if (jitErrorMessages[i] == '\0')
-                ALOGE("\tError: (message not defined for JIT error)");
+                ALOGI("\tIssue: (detailed description not available)");
             else
-                ALOGE("\tError: %s", jitErrorMessages[i]);
+                ALOGI("\tIssue: %s", jitErrorMessages[i]);
 
             if (isErrorFatal((JitCompilationErrors) i)) {
                 ALOGE("\t\t(FATAL ERROR)");
@@ -121,7 +121,7 @@ bool dvmCanFixErrorsAndRetry(CompilationUnit *cUnit){
     //Handle error due to large jump offset
     if ( IS_JIT_ERROR_SET(kJitErrorShortJumpOffset)) {
         gDvmJit.disableOpt |= (1 << kShortJumpOffset);
-        ALOGE("Resolved error due to short jump offset");
+        ALOGI("JIT_INFO: Successfully resolved short jump offset issue");
         //Clear the error:
         CLEAR_JIT_ERROR(kJitErrorShortJumpOffset);
     }
@@ -131,14 +131,14 @@ bool dvmCanFixErrorsAndRetry(CompilationUnit *cUnit){
      * retry the trace now.
      */
     if (!IS_ANY_JIT_ERROR_SET()){
-        ALOGE("Retrying trace %s%s, offset %d", cUnit->method->clazz->descriptor,
+        ALOGI("Retrying trace %s%s, offset %d", cUnit->method->clazz->descriptor,
                 cUnit->method->name, cUnit->traceDesc->trace[0].info.frag.startOffset);
-        ALOGE("++++++++++++++++++++++++++++++++++++++++++++");
+        ALOGI("++++++++++++++++++++++++++++++++++++++++++++");
         return true;
     }
 
     //Otherwise, error cannot be handled:
-    ALOGE("Terminating trace due to unresolved errors");
-    ALOGE("++++++++++++++++++++++++++++++++++++++++++++");
+    ALOGI("JIT_WARNING: Current trace has been rejected");
+    ALOGI("++++++++++++++++++++++++++++++++++++++++++++");
     return false;
 }
diff --git a/vm/compiler/codegen/x86/CodegenInterface.cpp b/vm/compiler/codegen/x86/CodegenInterface.cpp
index 658e37a..2838caa 100644
--- a/vm/compiler/codegen/x86/CodegenInterface.cpp
+++ b/vm/compiler/codegen/x86/CodegenInterface.cpp
@@ -873,7 +873,7 @@ u4* dvmJitUnchain(void* codeAddr)
                     predChainCell->clazz = PREDICTED_CHAIN_CLAZZ_INIT;
                     break;
                 default:
-                    ALOGE("JIT_ERROR: Unexpected chaining type: %d", i);
+                    ALOGI("JIT_INFO: Unexpected chaining type: %d", i);
                     //Error is beyond the scope of the x86 JIT back-end
                     ALOGE("\t FATAL ERROR. ABORTING!");
                     dvmAbort();  // dvmAbort OK here - can't safely recover
@@ -1330,7 +1330,7 @@ static bool generateCode (CompilationUnit *cUnit, BasicBlock *bb, BasicBlock **n
                 //Look if the code cache is full
                 if(gDvmJit.codeCacheByteUsed + (stream - streamStart) +
                         CODE_CACHE_PADDING > gDvmJit.codeCacheSize) {
-                    ALOGE("JIT_ERROR: Code cache full after lowerByteCodeJit (trace uses %uB)", (stream - streamStart));
+                    ALOGI("JIT_INFO: Code cache full after lowerByteCodeJit (trace uses %uB)", (stream - streamStart));
                     SET_JIT_ERROR(kJitErrorCodeCacheFull);
                     gDvmJit.codeCacheFull = true;
                     cUnit->baseAddr = NULL;
@@ -1342,7 +1342,7 @@ static bool generateCode (CompilationUnit *cUnit, BasicBlock *bb, BasicBlock **n
 
             //If not handle, error flag setting and return false
             if (notHandled) {
-                ALOGE("JIT_ERROR: Opcode 0x%x (%s) / Fmt %d at offset %#06x not handled\n",
+                ALOGI("JIT_INFO: Opcode 0x%x (%s) / Fmt %d at offset %#06x not handled\n",
                         dalvikOpCode, dexGetOpcodeName(dalvikOpCode), dalvikFormat, mir->offset);
                 SET_JIT_ERROR(kJitErrorUnsupportedBytecode);
                 cUnit->baseAddr = NULL;
@@ -1690,7 +1690,7 @@ static void compilerMIR2LIRJit(CompilationUnit *cUnit, JitTranslationInfo *info)
                     labelList[blockId].lop.generic.offset += nop_size; //skip over nop
                     break;
                 default:
-                    ALOGE("JIT_ERROR: Bad blocktype %d", chainingBlock->blockType);
+                    ALOGI("JIT_INFO: Bad blocktype %d", chainingBlock->blockType);
                     SET_JIT_ERROR(kJitErrorTraceFormation);
                     cUnit->baseAddr = NULL;
                     endOfTrace(true); /* need to free structures */
@@ -1698,7 +1698,7 @@ static void compilerMIR2LIRJit(CompilationUnit *cUnit, JitTranslationInfo *info)
             }
 
             if (gDvmJit.codeCacheByteUsed + (stream - streamStart) + CODE_CACHE_PADDING > gDvmJit.codeCacheSize) {
-                ALOGE("JIT_ERROR: Code cache full after ChainingCell (trace uses %uB)", (stream - streamStart));
+                ALOGI("JIT_INFO: Code cache full after ChainingCell (trace uses %uB)", (stream - streamStart));
                 SET_JIT_ERROR(kJitErrorCodeCacheFull);
                 gDvmJit.codeCacheFull = true;
                 cUnit->baseAddr = NULL;
@@ -1721,7 +1721,7 @@ static void compilerMIR2LIRJit(CompilationUnit *cUnit, JitTranslationInfo *info)
     if (gDvmJit.codeCacheFull) {
         // We hit code cache size limit either after dumping exception handling
         // state or after calling endOfTrace. Bail out for this trace!
-        ALOGE("JIT_ERROR: Code cache full after endOfTrace (trace uses %uB)", (stream - streamStart));
+        ALOGI("JIT_INFO: Code cache full after endOfTrace (trace uses %uB)", (stream - streamStart));
         SET_JIT_ERROR(kJitErrorCodeCacheFull);
         cUnit->baseAddr = NULL;
         PROTECT_CODE_CACHE(stream, unprotected_code_cache_bytes);
@@ -1743,7 +1743,7 @@ static void compilerMIR2LIRJit(CompilationUnit *cUnit, JitTranslationInfo *info)
     cUnit->baseAddr = streamMethodStart;
     cUnit->totalSize = (stream - streamStart);
     if(gDvmJit.codeCacheByteUsed + cUnit->totalSize + CODE_CACHE_PADDING > gDvmJit.codeCacheSize) {
-        ALOGE("JIT_ERROR: Code cache full after ChainingCellCounts (trace uses %uB)", (stream - streamStart));
+        ALOGI("JIT_INFO: Code cache full after ChainingCellCounts (trace uses %uB)", (stream - streamStart));
         SET_JIT_ERROR(kJitErrorCodeCacheFull);
         gDvmJit.codeCacheFull = true;
         cUnit->baseAddr = NULL;
@@ -1900,7 +1900,7 @@ bool dvmCompilerDoWork(CompilerWorkOrder *work)
             break;
         default:
             isCompile = false;
-            ALOGE("JIT_ERROR: Unknown work order type");
+            ALOGI("JIT_INFO: Unknown work order type");
             assert(0);  // Bail if debug build, discard otherwise
             ALOGE("\tError ignored");
     }
diff --git a/vm/compiler/codegen/x86/ExceptionHandling.cpp b/vm/compiler/codegen/x86/ExceptionHandling.cpp
index 18092b5..dabef82 100644
--- a/vm/compiler/codegen/x86/ExceptionHandling.cpp
+++ b/vm/compiler/codegen/x86/ExceptionHandling.cpp
@@ -115,7 +115,7 @@ void ExceptionHandlingRestoreState::dumpAllExceptionHandlingRestoreState(void) {
                 + sizeOfExceptionRestore + CODE_CACHE_PADDING
                 > gDvmJit.codeCacheSize) {
             gDvmJit.codeCacheFull = true;
-            ALOGE("JIT_ERROR: Code cache full while dumping exception handling restore state");
+            ALOGI("JIT_INFO: Code cache full while dumping exception handling restore state");
             SET_JIT_ERROR(kJitErrorCodeCacheFull);
             this->reset();
             return;
diff --git a/vm/compiler/codegen/x86/Lower.cpp b/vm/compiler/codegen/x86/Lower.cpp
index a708b64..8fc0126 100644
--- a/vm/compiler/codegen/x86/Lower.cpp
+++ b/vm/compiler/codegen/x86/Lower.cpp
@@ -262,7 +262,7 @@ int ncgMethodFake(Method* method) {
     unsigned int i;
     u2* rStart = (u2*)malloc(5*sizeof(u2));
     if(rStart == NULL) {
-        ALOGE("JIT_ERROR: Memory allocation failed at ncgMethodFake");
+        ALOGI("JIT_INFO: Memory allocation failed at ncgMethodFake");
         SET_JIT_ERROR(kJitErrorMallocFailed);
         return -1;
     }
@@ -558,7 +558,7 @@ int lowerByteCode(const Method* method, const MIR * mir, const u2 * dalvikPC) {
     //update mapFromBCtoNCG
     offsetNCG = stream - streamMethodStart;
     if(offsetPC >= BYTECODE_SIZE_PER_METHOD) {
-        ALOGE("JIT_ERROR: offsetPC %d exceeds BYTECODE_SIZE_PER_METHOD", offsetPC);
+        ALOGI("JIT_INFO: offsetPC %d exceeds BYTECODE_SIZE_PER_METHOD", offsetPC);
         SET_JIT_ERROR(kJitErrorTraceFormation);
         return -1;
     }
@@ -1045,7 +1045,7 @@ int lowerByteCode(const Method* method, const MIR * mir, const u2 * dalvikPC) {
     case OP_INVOKE_SUPER_QUICK_RANGE:
         return op_invoke_super_quick_range(mir);
     default:
-        ALOGE("JIT_ERROR: JIT does not support bytecode %s\n",
+        ALOGI("JIT_INFO: JIT does not support bytecode %s\n",
                 dexGetOpcodeName(mir->dalvikInsn.opcode));
         SET_JIT_ERROR(kJitErrorUnsupportedBytecode);
         assert(false && "All opcodes should be supported.");
diff --git a/vm/compiler/codegen/x86/LowerGetPut.cpp b/vm/compiler/codegen/x86/LowerGetPut.cpp
index 7bb302a..5306b8b 100644
--- a/vm/compiler/codegen/x86/LowerGetPut.cpp
+++ b/vm/compiler/codegen/x86/LowerGetPut.cpp
@@ -1291,7 +1291,7 @@ int sget_sput_common(StaticAccess flag, u2 vA, u2 referenceIndex, bool isObj,
          * and fall back to normal trace, which will not have this opcode.
          */
         if (!fieldPtr) {
-            ALOGE("JIT_ERROR: Unresolved fieldPtr at sget_sput_common");
+            ALOGI("JIT_INFO: Unresolved fieldPtr at sget_sput_common");
             SET_JIT_ERROR(kJitErrorUnresolvedField);
             return -1;
         }
diff --git a/vm/compiler/codegen/x86/LowerHelper.cpp b/vm/compiler/codegen/x86/LowerHelper.cpp
index 6fbcb22..9234324 100644
--- a/vm/compiler/codegen/x86/LowerHelper.cpp
+++ b/vm/compiler/codegen/x86/LowerHelper.cpp
@@ -260,7 +260,7 @@ LowOpMem* lower_mem(Mnemonic m, AtomOpCode m2, OpndSize size, int disp,
     }
 
     if (!isBasePhysical) {
-        ALOGE("JIT_ERROR: Base register not physical in lower_mem");
+        ALOGI("JIT_INFO: Base register not physical in lower_mem");
         SET_JIT_ERROR(kJitErrorInsScheduling);
         return NULL;
     }
@@ -304,7 +304,7 @@ LowOpReg* lower_reg(Mnemonic m, AtomOpCode m2, OpndSize size, int reg,
     }
 
     if (!isPhysical) {
-        ALOGE("JIT_ERROR: Register not physical at lower_reg");
+        ALOGI("JIT_INFO: Register not physical at lower_reg");
         SET_JIT_ERROR(kJitErrorInsScheduling);
         return NULL;
     }
@@ -393,7 +393,7 @@ LowOpRegReg* lower_reg_to_reg(Mnemonic m, AtomOpCode m2, OpndSize size, int regS
     }
 
     if (!isPhysical && !isPhysical2) {
-        ALOGE("JIT_ERROR: Registers not physical at lower_reg_to_reg");
+        ALOGI("JIT_INFO: Registers not physical at lower_reg_to_reg");
         SET_JIT_ERROR(kJitErrorInsScheduling);
         return NULL;
     }
@@ -561,7 +561,7 @@ LowOpMemReg* lower_mem_to_reg(Mnemonic m, AtomOpCode m2, OpndSize size, int disp
     }
 
     if (!isBasePhysical && !isPhysical) {
-        ALOGE("JIT_ERROR: Base register or operand register not physical in lower_mem_to_reg");
+        ALOGI("JIT_INFO: Base register or operand register not physical in lower_mem_to_reg");
         SET_JIT_ERROR(kJitErrorInsScheduling);
         return NULL;
     }
@@ -742,7 +742,7 @@ LowOpMemReg* lower_mem_scale_to_reg(Mnemonic m, OpndSize size, int base_reg,
     }
 
     if (!isBasePhysical && !isIndexPhysical && !isPhysical) {
-        ALOGE("JIT_ERROR: Base, index or operand register not physical at lower_mem_scale_to_reg");
+        ALOGI("JIT_INFO: Base, index or operand register not physical at lower_mem_scale_to_reg");
         SET_JIT_ERROR(kJitErrorInsScheduling);
         return NULL;
     }
@@ -809,7 +809,7 @@ LowOpRegMem* lower_reg_to_mem_scale(Mnemonic m, OpndSize size, int reg,
     }
 
     if (!isBasePhysical && !isIndexPhysical && !isPhysical) {
-        ALOGE("JIT_ERROR: Base, index or operand register not physical in lower_reg_to_mem_scale");
+        ALOGI("JIT_INFO: Base, index or operand register not physical in lower_reg_to_mem_scale");
         SET_JIT_ERROR(kJitErrorInsScheduling);
         return NULL;
     }
@@ -868,7 +868,7 @@ LowOpRegMem* lower_reg_to_mem(Mnemonic m, AtomOpCode m2, OpndSize size, int reg,
     }
 
     if (!isBasePhysical && !isPhysical) {
-        ALOGE("JIT_ERROR: Base or operand register not physical in lower_reg_to_mem");
+        ALOGI("JIT_INFO: Base or operand register not physical in lower_reg_to_mem");
         SET_JIT_ERROR(kJitErrorInsScheduling);
         return NULL;
     }
@@ -966,7 +966,7 @@ LowOpImmReg* lower_imm_to_reg(Mnemonic m, AtomOpCode m2, OpndSize size, int imm,
     }
 
     if (!isPhysical) {
-        ALOGE("JIT_ERROR: Operand register not physical in lower_imm_to_reg");
+        ALOGI("JIT_INFO: Operand register not physical in lower_imm_to_reg");
         SET_JIT_ERROR(kJitErrorInsScheduling);
         return NULL;
     }
@@ -1020,7 +1020,7 @@ LowOpImmMem* lower_imm_to_mem(Mnemonic m, AtomOpCode m2, OpndSize size, int imm,
     }
 
     if (!isBasePhysical) {
-        ALOGE("JIT_ERROR: Base register not physical in lower_imm_to_mem");
+        ALOGI("JIT_INFO: Base register not physical in lower_imm_to_mem");
         SET_JIT_ERROR(kJitErrorInsScheduling);
         return NULL;
     }
@@ -1085,7 +1085,7 @@ LowOpRegMem* lower_fp_to_mem(Mnemonic m, AtomOpCode m2, OpndSize size, int reg,
     }
 
     if (!isBasePhysical) {
-        ALOGE("JIT_ERROR: Base register not physical in lower_fp_to_mem");
+        ALOGI("JIT_INFO: Base register not physical in lower_fp_to_mem");
         SET_JIT_ERROR(kJitErrorInsScheduling);
         return NULL;
     }
@@ -1136,7 +1136,7 @@ LowOpMemReg* lower_mem_to_fp(Mnemonic m, AtomOpCode m2, OpndSize size, int disp,
     }
 
     if (!isBasePhysical) {
-        ALOGE("JIT_ERROR: Base register not physical in lower_mem_to_fp");
+        ALOGI("JIT_INFO: Base register not physical in lower_mem_to_fp");
         SET_JIT_ERROR(kJitErrorInsScheduling);
         return NULL;
     }
@@ -1482,7 +1482,7 @@ void fpu_VR(ALU_Opcode opc, OpndSize size, int vA) {
             }
         }
         if(!isInMemory(vA, size)) {
-            ALOGE("JIT_ERROR: VR not in memory for FPU operation");
+            ALOGI("JIT_INFO: VR not in memory for FPU operation");
             SET_JIT_ERROR(kJitErrorRegAllocFailed);
             return;
         }
@@ -1528,7 +1528,7 @@ void compare_imm_VR(OpndSize size, int imm,
     Mnemonic m = Mnemonic_CMP;
     if(gDvm.executionMode == kExecutionModeNcgO1) {
         if(size != OpndSize_32) {
-            ALOGE("JIT_ERROR: Only 32 bits supported in compare_imm_VR");
+            ALOGI("JIT_INFO: Only 32 bits supported in compare_imm_VR");
             SET_JIT_ERROR(kJitErrorRegAllocFailed);
             return;
         }
@@ -2031,7 +2031,7 @@ void move_imm_to_mem(OpndSize size, int imm,
                       int disp, int base_reg, bool isBasePhysical) {
     assert(size != OpndSize_64);
     if(size == OpndSize_64) {
-        ALOGE("JIT_ERROR: Trying to move 64-bit imm to memory");
+        ALOGI("JIT_INFO: Trying to move 64-bit imm to memory");
         SET_JIT_ERROR(kJitErrorRegAllocFailed);
         return;
     }
@@ -2043,7 +2043,7 @@ void move_imm_to_mem(OpndSize size, int imm,
 void set_VR_to_imm(u2 vA, OpndSize size, int imm) {
     assert(size != OpndSize_64);
     if(size == OpndSize_64) {
-        ALOGE("JIT_ERROR: Trying to set VR with 64-bit imm");
+        ALOGI("JIT_INFO: Trying to set VR with 64-bit imm");
         SET_JIT_ERROR(kJitErrorRegAllocFailed);
         return;
     }
@@ -2079,7 +2079,7 @@ void set_VR_to_imm_noupdateref(LowOp* op, u2 vA, OpndSize size, int imm) {
 void set_VR_to_imm_noalloc(u2 vA, OpndSize size, int imm) {
     assert(size != OpndSize_64);
     if(size == OpndSize_64) {
-        ALOGE("JIT_ERROR: Trying to move 64-bit imm to memory (noalloc)");
+        ALOGI("JIT_INFO: Trying to move 64-bit imm to memory (noalloc)");
         SET_JIT_ERROR(kJitErrorRegAllocFailed);
         return;
     }
@@ -2097,7 +2097,7 @@ void move_chain_to_reg(OpndSize size, int imm, int reg, bool isPhysical) {
 void move_imm_to_reg(OpndSize size, int imm, int reg, bool isPhysical) {
     assert(size != OpndSize_64);
     if(size == OpndSize_64) {
-        ALOGE("JIT_ERROR: Trying to move 64-bit imm to register");
+        ALOGI("JIT_INFO: Trying to move 64-bit imm to register");
         SET_JIT_ERROR(kJitErrorRegAllocFailed);
         return;
     }
@@ -2110,7 +2110,7 @@ void move_imm_to_reg(OpndSize size, int imm, int reg, bool isPhysical) {
 void move_imm_to_reg_noalloc(OpndSize size, int imm, int reg, bool isPhysical) {
     assert(size != OpndSize_64);
     if(size == OpndSize_64) {
-        ALOGE("JIT_ERROR: Trying to move 64-bit imm to register (noalloc)");
+        ALOGI("JIT_INFO: Trying to move 64-bit imm to register (noalloc)");
         SET_JIT_ERROR(kJitErrorRegAllocFailed);
         return;
     }
diff --git a/vm/compiler/codegen/x86/LowerJump.cpp b/vm/compiler/codegen/x86/LowerJump.cpp
index 2f8db8e..53ec08c 100644
--- a/vm/compiler/codegen/x86/LowerJump.cpp
+++ b/vm/compiler/codegen/x86/LowerJump.cpp
@@ -90,14 +90,14 @@ int updateJumpInst(char* jumpInst, OpndSize immSize, int relativeNCG) {
 #endif
     if(immSize == OpndSize_8) { //-128 to 127
         if(relativeNCG >= 128 || relativeNCG < -128) {
-            ALOGE("JIT_ERROR: Pre-allocated space for a forward jump is not big enough\n");
+            ALOGI("JIT_INFO: Pre-allocated space for a forward jump is not big enough\n");
             SET_JIT_ERROR(kJitErrorShortJumpOffset);
             return -1;
         }
     }
     if(immSize == OpndSize_16) { //-2^16 to 2^16-1
         if(relativeNCG >= 32768 || relativeNCG < -32768) {
-            ALOGE("JIT_ERROR: Pre-allocated space (16-bit) for a forward jump is not big enough\n");
+            ALOGI("JIT_INFO: Pre-allocated space (16-bit) for a forward jump is not big enough\n");
             SET_JIT_ERROR(kJitErrorShortJumpOffset);
             return -1;
         }
@@ -123,7 +123,7 @@ int insertLabel(const char* label, bool checkDup) {
     if(!checkDup) {
         item = (LabelMap*)malloc(sizeof(LabelMap));
         if(item == NULL) {
-            ALOGE("JIT_ERROR: Memory allocation failed at insertLabel with checkDup false");
+            ALOGI("JIT_INFO: Memory allocation failed at insertLabel with checkDup false");
             SET_JIT_ERROR(kJitErrorMallocFailed);
             return -1;
         }
@@ -140,7 +140,7 @@ int insertLabel(const char* label, bool checkDup) {
 
     item = (LabelMap*)malloc(sizeof(LabelMap));
     if(item == NULL) {
-        ALOGE("JIT_ERROR: Memory allocation failed at insertLabel with checkDup true");
+        ALOGI("JIT_INFO: Memory allocation failed at insertLabel with checkDup true");
         SET_JIT_ERROR(kJitErrorMallocFailed);
         return -1;
     }
@@ -166,7 +166,7 @@ int insertLabel(const char* label, bool checkDup) {
             //If this fails, the jump offset was not big enough. Raise the corresponding error flag
             //We may decide to re-compiler the trace with a large jump offset later
             if (retval == -1){
-                ALOGE("JIT_ERROR: Label \"%s\" too far away from jump location", label);
+                ALOGI("JIT_INFO: Label \"%s\" too far away from jump location", label);
                 SET_JIT_ERROR(kJitErrorShortJumpOffset);
                 return retval;
             }
@@ -221,7 +221,7 @@ char* findCodeForShortLabel(const char* label) {
 int insertLabelWorklist(const char* label, OpndSize immSize) {
     LabelMap* item = (LabelMap*)malloc(sizeof(LabelMap));
     if(item == NULL) {
-        ALOGE("JIT_ERROR: Memory allocation failed at insertLabelWorklist");
+        ALOGI("JIT_INFO: Memory allocation failed at insertLabelWorklist");
         SET_JIT_ERROR(kJitErrorMallocFailed);
         return -1;
     }
@@ -239,7 +239,7 @@ int insertLabelWorklist(const char* label, OpndSize immSize) {
 int insertShortWorklist(const char* label, OpndSize immSize) {
     LabelMap* item = (LabelMap*)malloc(sizeof(LabelMap));
     if(item == NULL) {
-        ALOGE("JIT_ERROR: Memory allocation failed at insertShortWorklist");
+        ALOGI("JIT_INFO: Memory allocation failed at insertShortWorklist");
         SET_JIT_ERROR(kJitErrorMallocFailed);
         return -1;
     }
@@ -283,7 +283,7 @@ int insertGlobalPCWorklist(char * offset, char * codeStart)
 {
     LabelMap* item = (LabelMap*)malloc(sizeof(LabelMap));
     if(item == NULL) {
-        ALOGE("JIT_ERROR: Memory allocation failed at insertGlobalPCWorklist");
+        ALOGI("JIT_INFO: Memory allocation failed at insertGlobalPCWorklist");
         SET_JIT_ERROR(kJitErrorMallocFailed);
         return -1;
     }
@@ -326,7 +326,7 @@ int insertChainingWorklist(int bbId, char * codeStart)
 {
     LabelMap* item = (LabelMap*)malloc(sizeof(LabelMap));
     if(item == NULL) {
-        ALOGE("JIT_ERROR: Memory allocation failed at insertChainingWorklist");
+        ALOGI("JIT_INFO: Memory allocation failed at insertChainingWorklist");
         SET_JIT_ERROR(kJitErrorMallocFailed);
         return -1;
     }
@@ -346,7 +346,7 @@ int insertGlobalDataWorklist(char * offset, const char* label)
 {
     LabelMap* item = (LabelMap*)malloc(sizeof(LabelMap));
     if(item == NULL) {
-        ALOGE("JIT_ERROR: Memory allocation failed at insertGlobalDataWorklist");
+        ALOGI("JIT_INFO: Memory allocation failed at insertGlobalDataWorklist");
         SET_JIT_ERROR(kJitErrorMallocFailed);
         return -1;
     }
@@ -368,7 +368,7 @@ int insertVMAPIWorklist(char * offset, const char* label)
 {
     LabelMap* item = (LabelMap*)malloc(sizeof(LabelMap));
     if(item == NULL) {
-        ALOGE("JIT_ERROR: Memory allocation failed at insertVMAPIWorklist");
+        ALOGI("JIT_INFO: Memory allocation failed at insertVMAPIWorklist");
         SET_JIT_ERROR(kJitErrorMallocFailed);
         return -1;
     }
@@ -807,7 +807,7 @@ int insertNCGWorklist(s4 relativePC, OpndSize immSize) {
 #endif
     NCGWorklist* item = (NCGWorklist*)malloc(sizeof(NCGWorklist));
     if(item == NULL) {
-        ALOGE("JIT_ERROR: Memory allocation failed at insertNCGWorklist");
+        ALOGI("JIT_INFO: Memory allocation failed at insertNCGWorklist");
         SET_JIT_ERROR(kJitErrorMallocFailed);
         return -1;
     }
@@ -857,7 +857,7 @@ int insertDataWorklist(s4 relativePC, char* codePtr1) {
     //insert according to offsetPC+relativePC, smallest at the head
     DataWorklist* item = (DataWorklist*)malloc(sizeof(DataWorklist));
     if(item == NULL) {
-        ALOGE("JIT_ERROR: Memory allocation failed at insertDataWorklist");
+        ALOGI("JIT_INFO: Memory allocation failed at insertDataWorklist");
         SET_JIT_ERROR(kJitErrorMallocFailed);
         return -1;
     }
diff --git a/vm/compiler/codegen/x86/NcgAot.cpp b/vm/compiler/codegen/x86/NcgAot.cpp
index 6e1f1df..c7112f1 100644
--- a/vm/compiler/codegen/x86/NcgAot.cpp
+++ b/vm/compiler/codegen/x86/NcgAot.cpp
@@ -172,7 +172,7 @@ int getGlobalDataAddr(const char* dataName) {
     else if(!strcmp(dataName, "strInstantiationError")) dataAddr = LstrInstantiationErrorPtr;
     else if(!strcmp(dataName, "gDvmInlineOpsTable")) dataAddr = (int)gDvmInlineOpsTable;
     else {
-        ALOGE("JIT_ERROR: global data %s not supported\n", dataName);
+        ALOGI("JIT_INFO: global data %s not supported\n", dataName);
         SET_JIT_ERROR(kJitErrorGlobalData);
     }
     return dataAddr;
diff --git a/vm/compiler/codegen/x86/Schedule.cpp b/vm/compiler/codegen/x86/Schedule.cpp
index 70e5c0e..44dd377 100644
--- a/vm/compiler/codegen/x86/Schedule.cpp
+++ b/vm/compiler/codegen/x86/Schedule.cpp
@@ -1487,7 +1487,7 @@ void Scheduler::generateAssembly(LowOp * op) {
     }
     if(gDvmJit.codeCacheByteUsed + (stream - streamStart) +
        CODE_CACHE_PADDING > gDvmJit.codeCacheSize) {
-        ALOGE("JIT_ERROR: Code cache full after Scheduler::generateAssembly (trace uses %uB)", (stream - streamStart));
+        ALOGI("JIT_INFO: Code cache full after Scheduler::generateAssembly (trace uses %uB)", (stream - streamStart));
         SET_JIT_ERROR(kJitErrorCodeCacheFull);
         gDvmJit.codeCacheFull = true;
     }
@@ -1809,7 +1809,7 @@ void Scheduler::schedule() {
 
     // Make sure that original and scheduled basic blocks are same size
     if (scheduledLIREntries.size() != queuedLIREntries.size()) {
-        ALOGE("JIT_ERROR: (Atom Scheduler) Original basic block is not same \
+        ALOGI("JIT_INFO: (Atom Scheduler) Original basic block is not same \
                 size as the scheduled basic block");
         SET_JIT_ERROR(kJitErrorInsScheduling);
         return;
@@ -1819,7 +1819,7 @@ void Scheduler::schedule() {
     // scheduled basic block
     if (isBasicBlockDelimiter(queuedLIREntries.back()->opCode)
             && !isBasicBlockDelimiter(scheduledLIREntries.back()->opCode)) {
-        ALOGE("JIT_ERROR: (Atom Scheduler) Sync point should be the last \
+        ALOGI("JIT_INFO: (Atom Scheduler) Sync point should be the last \
                 scheduled instruction.");
         SET_JIT_ERROR(kJitErrorInsScheduling);
         return;
-- 
1.7.4.1

