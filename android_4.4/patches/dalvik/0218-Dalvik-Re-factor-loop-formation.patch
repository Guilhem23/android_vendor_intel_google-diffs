From e5017a83b0ce0f153d06109fafa5b9273b37774d Mon Sep 17 00:00:00 2001
From: Serguei Katkov <serguei.i.katkov@intel.com>
Date: Wed, 5 Jun 2013 11:57:34 +0700
Subject: Dalvik: Re-factor loop formation

BZ: 110755

Overall description:
    LoopInformation is responsible for loop detection
    and filling the loop structures. Loop formation is responsible
    for transformation of top loops and adding the required BB
    (pre-header, exits and backwards).

The details:

BBOptimization.cpp
        Basing on built loop information tries to convert top loop to bottom one
        Adds pre-header, loop exits and loop backward branches to loop
IntermediateRep.cpp
        dvmCompilerInsertBasicBlockBetween works for parent representing switch opcode now
LoopInformation.cpp
        Now it is responsible for loop detection and generation of loop information.
        During generation of loop information re-uses the old loop information data
            structures if they exist
        Utility dump function is updated to dump more information
LoopInformation.h
        New way to keep nested and sibling loops allowing keeping
            even sibling loops on top level.
        Two iterators are added to iterate over loops.
        No postExitLoop member now, post exit loops are collected dynamically
LoopOpt.cpp:
        dvmCompilerCheckLoops is a first pass now responsible
            for detecting loops we accepts. It works on non-formed loops.
        kLoopStructureChange flag is responsible for rebuilding of loop information.
            It is used when we add/remove basic blocks
        Two checks are added to dvmCompilerCheckLoops to reject loops which
            Has sibling loops on top level
            Any loop has two different exit BB
AccumulationSinking.cpp
Dataflow.cpp
Loop.cpp
RegisterizationME.cpp
        Use a new loop iteration utility
Frontend.cpp
        Add cUnit to dumpInformationDotFormat invocation

Category: device-enablement
Domain: AOSP-Dalvik-Compiler-ME
Origin: internal
Upstream-Candidate: no, needs rework

Change-Id: I36c71876a138663f08023db0cb456f8a89f50f5e
Orig-MCG-Change-Id: I73e96a5f09c3da12e2e9c97e57dbcc63bde0d6f3
Signed-off-by: Serguei Katkov <serguei.i.katkov@intel.com>
Signed-off-by: Qiming Shi <qiming.shi@intel.com>
Signed-off-by: Serguei Katkov <serguei.i.katkov@intel.com>
---
 vm/compiler/AccumulationSinking.cpp |  103 ++---
 vm/compiler/BBOptimization.cpp      |  859 +++++++++-------------------------
 vm/compiler/BBOptimization.h        |   10 +-
 vm/compiler/Dataflow.cpp            |   26 +-
 vm/compiler/Frontend.cpp            |    2 +-
 vm/compiler/IntermediateRep.cpp     |   33 ++-
 vm/compiler/Loop.cpp                |   25 +-
 vm/compiler/LoopInformation.cpp     |  900 +++++++++++++++++++----------------
 vm/compiler/LoopInformation.h       |  165 ++++---
 vm/compiler/LoopOpt.cpp             |  100 ++--
 vm/compiler/LoopOpt.h               |    5 +-
 vm/compiler/RegisterizationME.cpp   |  116 ++----
 12 files changed, 965 insertions(+), 1379 deletions(-)

diff --git a/vm/compiler/AccumulationSinking.cpp b/vm/compiler/AccumulationSinking.cpp
index 33b7785..485454b 100644
--- a/vm/compiler/AccumulationSinking.cpp
+++ b/vm/compiler/AccumulationSinking.cpp
@@ -668,9 +668,17 @@ static void sinkAccumulations (CompilationUnit *cUnit, LoopInformation *info, co
  * @brief Handle a loop for the sinking of an accumulation
  * @param cUnit the CompilationUnit
  * @param info the LoopInformation
+ * @param data required by interface (not used)
+ * @return true to continue iteration over loops
  */
-static void handleLoop (CompilationUnit *cUnit, LoopInformation *info)
+static bool sinkAccumulation (CompilationUnit *cUnit, LoopInformation *info, void *data)
 {
+    // Only apply pass to innermost loop
+    if (info->getNested () != 0)
+    {
+        return true;
+    }
+
     //Step 1: Choose an IV: we want an IV that can count the iterations
     int increment;
     int chosenIV = chooseIV (cUnit, info, increment);
@@ -678,7 +686,7 @@ static void handleLoop (CompilationUnit *cUnit, LoopInformation *info)
     //If we didn't find one, bail
     if (chosenIV < 0)
     {
-        return;
+        return true;
     }
 
     //Step 2: Filter out the virtual registers: we only want PHI nodes that aren't IVs and are not used except for their own calculation
@@ -704,57 +712,21 @@ static void handleLoop (CompilationUnit *cUnit, LoopInformation *info)
 
     //Step 7: Remove MIRs no longer needed
     removeAccumulations (toRemove);
+
+    return true;
 }
 
 /**
- * @brief Wrapper around registerizing the loop, it handles loop nests as well
+ * @brief Check whether the sinking of an accumulation is applicable
  * @param cUnit the CompilationUnit
- * @param info the LoopInformation
+ * @param info the LoopInformation to check
+ * @param data required by interface (not used)
+ * @return false to reject optimization
  */
-static void sinkAccumulation (CompilationUnit *cUnit, LoopInformation *info)
-{
-    //If info is 0, there is nothing to do
-    if (info == 0)
-    {
-        return;
-    }
-
-    //Search in the children if anybody includes them
-    unsigned int nbr = info->getNestedNbr ();
-
-    //Is it the inner loop ?
-    if (nbr == 0)
-    {
-        //Actually perform the pass on the loop
-        handleLoop (cUnit, info);
-    }
-    else
-    {
-        //Go through each child and recursively call
-        for (unsigned int i = 0; i < nbr; i++)
-        {
-            LoopInformation *inner = info->getNested (i);
-
-            //Paranoid
-            assert (inner != 0);
-
-            sinkAccumulation (cUnit, inner);
-        }
-    }
-}
-
-static bool compilerSinkAccumulationsGateHelper(const CompilationUnit *cUnit, LoopInformation *info)
+static bool compilerSinkAccumulationsGateHelper(const CompilationUnit *cUnit, LoopInformation *info, void *data)
 {
-    //Info should be non null here
-    if (info == 0)
-    {
-        return false;
-    }
-
     //We are only interested in the innermost loops
-    unsigned int nbr = info->getNestedNbr ();
-
-    if (nbr == 0)
+    if (info->getNested () == 0)
     {
         //We don't want loops with multiple exit blocks
         if (dvmCountSetBits (info->getExitLoops ()) > 1)
@@ -769,34 +741,17 @@ static bool compilerSinkAccumulationsGateHelper(const CompilationUnit *cUnit, Lo
         }
 
         //Reject if we can throw an exception in our code
-        if (info->canThrow(cUnit) == true)
+        if (info->canThrow (cUnit) == true)
         {
             return false;
         }
 
         //We also don't want invokes in the loop
-        if (info->hasInvoke(cUnit) == true)
+        if (info->hasInvoke (cUnit) == true)
         {
             return false;
         }
     }
-    else
-    {
-        //Go through each child and recursively call
-        for (unsigned int i = 0; i < nbr; i++)
-        {
-            LoopInformation *inner = info->getNested (i);
-
-            //Paranoid
-            assert (inner != 0);
-
-            bool success = compilerSinkAccumulationsGateHelper (cUnit, inner);
-            if (success == false)
-            {
-                return false;
-            }
-        }
-    }
 
     //All good!
     return true;
@@ -812,13 +767,16 @@ bool dvmCompilerSinkAccumulationsGate(const CompilationUnit *cUnit, const Pass *
 
     LoopInformation *info = cUnit->loopInformation;
 
-    if (info == 0)
+    //Find the innermost loop and test it
+    if (info != 0)
     {
-        return false;
+        if (info->iterateWithConst (cUnit, compilerSinkAccumulationsGateHelper) == true)
+        {
+            // Optimization can be applicable
+            return true;
+        }
     }
-
-    //Find the innermost loop and test it
-    return compilerSinkAccumulationsGateHelper(cUnit, info);
+    return false;
 }
 
 void dvmCompilerAccumulationSinking (CompilationUnit *cUnit, Pass *currentPass)
@@ -827,7 +785,10 @@ void dvmCompilerAccumulationSinking (CompilationUnit *cUnit, Pass *currentPass)
     LoopInformation *info = cUnit->loopInformation;
 
     //Now try to sink accumulations
-    sinkAccumulation (cUnit, info);
+    if (info != 0)
+    {
+        info->iterate (cUnit, sinkAccumulation);
+    }
 
     //Unused argument
     (void) currentPass;
diff --git a/vm/compiler/BBOptimization.cpp b/vm/compiler/BBOptimization.cpp
index 5751d05..1cf99d7 100644
--- a/vm/compiler/BBOptimization.cpp
+++ b/vm/compiler/BBOptimization.cpp
@@ -163,439 +163,31 @@ void dvmCompilerUpdatePredecessors (BasicBlock *parent, BasicBlock *oldChild, Ba
     }
 }
 
-/**
- * @brief Handle the insertion of the pre-loop header
- * @param cUnit the CompilationUnit
- * @param newBlock the new block to be added
- * @param backward the current backward chaining cell
- * @return whether we succeeded or not
- */
-static bool handlePreLoopInsertion (CompilationUnit *cUnit, BasicBlock *newBlock, BasicBlock *backward)
-{
-    bool res = false;
-
-    BitVectorIterator bvIterator;
-
-    //Get its fall through
-    BasicBlock *bb = backward->fallThrough;
-
-    //Paranoid
-    if (bb == 0)
-    {
-        return false;
-    }
-
-    //Get predecessors
-    dvmBitVectorIteratorInit(bb->predecessors, &bvIterator);
-    while (true) {
-        //Get the next iterator
-        int blockIdx = dvmBitVectorIteratorNext(&bvIterator);
-
-        //If it is finished, exit
-        if (blockIdx == -1)
-        {
-            break;
-        }
-        BasicBlock *predBB = (BasicBlock*) (dvmGrowableListGetElement(&cUnit->blockList, blockIdx));
-
-        //Paranoid
-        if (predBB == 0)
-        {
-            break;
-        }
-
-        //If the type is a backward chaining cell, go to the next one
-        if (predBB->blockType == kChainingCellBackwardBranch)
-        {
-            continue;
-        }
-
-        //If we have a taken and it leads toward the bb and it is Dalvik bytecode
-        if (predBB->taken != 0 && predBB->taken == bb && ( (predBB->blockType == kDalvikByteCode) || (predBB->blockType == kEntryBlock)))
-
-        {
-            //Insert the new block between the two
-            if (dvmCompilerInsertBasicBlockBetween (newBlock, predBB, bb) == true)
-            {
-                //Found one, we can return true
-                res = true;
-            }
-        }
-        else
-        {
-            //If we have a fallthrough and it leads toward the bb and it is Dalvik bytecode
-            if (predBB->fallThrough != 0 && predBB->fallThrough == bb && ( (predBB->blockType == kDalvikByteCode) || (predBB->blockType == kEntryBlock)))
-            {
-                //Insert the new block between the two
-                if (dvmCompilerInsertBasicBlockBetween (newBlock, predBB, bb) == true)
-                {
-                    //Found one, we can return true
-                    res = true;
-                }
-            }
-        }
-    }
-
-    return res;
-}
 
 /**
  * @brief Insert the pre-loop header
  * @param cUnit the CompilationUnit
  * @param info the LoopInformation for the loop
- * @param backward the current backward branch
- * @return whether we succeeded
- */
-static bool insertPreLoopHeader (CompilationUnit *cUnit, LoopInformation *info, BasicBlock *backward)
-{
-    //Now, we have a little bit of work: we want to create a preheader
-    //Don't define its ID or add it yet, we might not use it
-    BasicBlock *preHeader = dvmCompilerNewBB(kDalvikByteCode, 0);
-    preHeader->startOffset = backward->startOffset;
-
-    //Set the links correctly
-    bool res = handlePreLoopInsertion (cUnit, preHeader, backward);
-
-    if (res == true)
-    {
-        //Set its ID
-        preHeader->id = cUnit->numBlocks;
-        cUnit->numBlocks++;
-
-        //Actually add it in, we've used it
-        dvmInsertGrowableList(&cUnit->blockList, (intptr_t) preHeader);
-
-        //Add to the information
-        info->setPreHeader (preHeader);
-
-        //Report success
-        return true;
-    }
-
-    //Report failure
-    return false;
-}
-
-/**
- * @brief Insert a loop exit block: this helps sink any code from the loop to before getting to the rest of the code
- * @param cUnit the CompilationUnit
- * @param info the LoopInformation
- * @param cur the current BasicBlock we are attaching the loop exit block to
- * @param exitBB the loop exit BasicBlock
- */
-static void insertLoopExitBlock (CompilationUnit *cUnit, LoopInformation *info, BasicBlock *cur, BasicBlock *exitBB)
-{
-    //Create and set up the loop exit block, it goes to the exit BasicBlock
-    BasicBlock *exitBlock = dvmCompilerNewBB(kDalvikByteCode, cUnit->numBlocks++);
-    dvmInsertGrowableList(&cUnit->blockList, (intptr_t) exitBlock);
-
-    exitBlock->startOffset = exitBB->startOffset;
-    exitBlock->fallThrough = exitBB;
-
-    //Now link it
-    if (cur->taken == exitBB)
-    {
-        cur->taken = exitBlock;
-        dvmCompilerUpdatePredecessors (cur, exitBB, exitBlock);
-    }
-    else
-    {
-        //Paranoid
-        assert (cur->fallThrough == exitBB);
-
-        cur->fallThrough = exitBlock;
-        dvmCompilerUpdatePredecessors (cur, exitBB, exitBlock);
-    }
-
-    //Finally add it to the loop information
-    info->addExitLoop (exitBlock);
-}
-/**
- * @brief Create and insert a loop backward block into compilation unit
- * @param cUnit the CompilationUnit
- * @param bb the BasicBlock that represents the head of the loop
- * @return inserted backward block
-*/
-static BasicBlock* insertLoopBackwardBlock (CompilationUnit *cUnit, BasicBlock *bb)
-{
-    //Paranoid
-    assert (bb != 0);
-
-    BasicBlock *backward = dvmCompilerNewBB(kChainingCellBackwardBranch, cUnit->numBlocks++);
-    dvmInsertGrowableList(&cUnit->blockList, (intptr_t) backward);
-
-    backward->startOffset = bb->startOffset;
-    //Backward will fall through to the current BasicBlock directly
-    backward->fallThrough = bb;
-
-    return backward;
-}
-
-/**
- * @brief Handle the top loop case and push down the test to make it a bottom loop
- * @param cUnit the CompilationUnit
- * @param info the LoopInformation
- * @param bb the BasicBlock that represents the head of the loop for the top formed loop
- * @param predBB the predecessor of bb currently being handled
- * @param ptrBackward pointer to the backward chaining cell
- * @return whether we succeeded or not
- */
-static bool handleTopLoop (CompilationUnit *cUnit, LoopInformation *info, BasicBlock *bb, BasicBlock *predBB, BasicBlock **ptrBackward)
-{
-    //Paranoid on bb
-    if (bb == 0)
-    {
-        //Make sure null will be returned
-        (*ptrBackward) = 0;
-        return false;
-    }
-
-    //Paranoid: we should have a branch
-    assert (bb->taken != 0 || bb->fallThrough != 0);
-
-    //First find if taken or fallthrough is the loop
-    //By default, let's suppose it is bb->taken
-    BasicBlock *notLoop = bb->taken;
-    BasicBlock *backward = 0;
-
-    if (notLoop == 0)
-    {
-        notLoop = bb->fallThrough;
-    }
-    else
-    {
-        //If notLoop is really that, it won't be dominating predBB
-        if (dvmIsBitSet (predBB->dominators, notLoop->id) != 0)
-        {
-            notLoop = bb->fallThrough;
-        }
-    }
-
-    //If there is a problem with notLoop, report failure
-    if (notLoop == 0)
-    {
-        //Make sure null will be returned
-        (*ptrBackward) = 0;
-        return false;
-    }
-
-    //Create and insert loop backward block into compilation unit
-    backward = insertLoopBackwardBlock (cUnit, bb);
-    //Add info about it
-    info->addBackwardBlock (backward);
-
-    //Inform loop information
-    info->setPostExitBlock (notLoop);
-
-    //Attach the current predBB to backward, it might be predBB->taken
-    if (predBB->taken == bb)
-    {
-        predBB->taken = backward;
-        dvmCompilerUpdatePredecessors (predBB, bb, backward);
-    }
-    else
-    {
-        //Is it fallThrough ?
-        if (predBB->fallThrough == bb)
-        {
-            predBB->fallThrough = backward;
-            dvmCompilerUpdatePredecessors (predBB, bb, backward);
-        }
-    }
-
-    //Does the predecessor go to notLoop?
-    //Insert a landing pad here if so
-    if ( (predBB->taken == notLoop) || (predBB->fallThrough == notLoop) )
-    {
-        insertLoopExitBlock (cUnit, info, predBB, notLoop);
-    }
-
-    //Now, we must copy the if statements for the loop
-    BasicBlock *cur = bb;
-
-    //Have work to do from bb all the way down:
-    //Until either cur is 0 (paranoid) and either branch leads to the loop exit
-    while (cur != 0 && (cur->taken == notLoop || cur->fallThrough == notLoop))
-    {
-        //Copy current
-        BasicBlock *newBB = dvmCompilerCopyBasicBlock (cUnit, cur);
-
-        //Attach predBB to newBB, between predBB and backward, it's our bottom test now
-        if (predBB->taken == backward)
-        {
-            predBB->taken = newBB;
-        }
-        else
-        {
-            predBB->fallThrough = newBB;
-        }
-
-        //Update the predecessor information
-        dvmCompilerUpdatePredecessors (predBB, backward, newBB);
-
-        //Now attach newBB to backward, we attach the not notLoop branch
-        if (newBB->taken != notLoop)
-        {
-            //Taken is thus going to the backward (OK if newBB is NULL)
-            dvmCompilerUpdatePredecessors (newBB, newBB->taken, backward);
-            newBB->taken = backward;
-        }
-        else
-        {
-            //FallThrough is thus going to the backward (OK if newBB is NULL)
-            dvmCompilerUpdatePredecessors (newBB, newBB->fallThrough, backward);
-            newBB->fallThrough = backward;
-        }
-
-        //Add an exit block here between newBB and notLoop
-        insertLoopExitBlock (cUnit, info, newBB, notLoop);
-
-        //If we only have one child, go there
-        if (
-            (cur->taken == 0 && cur->fallThrough != 0) ||
-            (cur->taken != 0 && cur->fallThrough == 0))
-        {
-            if (cur->taken != 0)
-            {
-                cur = cur->taken;
-            }
-            else
-            {
-                cur = cur->fallThrough;
-            }
-        }
-        else
-        {
-            //We have two children, so:
-            //Choose the right child, we want the one that is still in the loop
-            if (cur->taken == notLoop)
-            {
-                cur = cur->fallThrough;
-            }
-            else
-            {
-                cur = cur->taken;
-            }
-        }
-        //Update predBB to now be newBB
-        predBB = newBB;
-    }
-
-    //When we are done, we've copied the chain of BasicBlocks that form the continuation test
-    //Now redirect backward to cur, we don't want to do the tests twice each iteration
-    dvmCompilerUpdatePredecessors (backward, backward->fallThrough, cur);
-    backward->fallThrough = cur;
-
-    //Paranoid
-    if (cur == 0)
-    {
-        //Make sure null will be returned
-        (*ptrBackward) = 0;
-        return false;
-    }
-
-    //Also set its offset, it might have changed and the chaining cell needs this
-    backward->startOffset = cur->startOffset;
-
-    //Update the information for the entry
-    info->setEntryBlock (cur);
-
-    //Return backward block via argument
-    (*ptrBackward) = backward;
-
-    //Report success
-    return true;
-}
-
-/**
- * @brief Handle the bottom loop case
- * @param cUnit the CompilationUnit
- * @param info the LoopInformation
- * @param bb the BasicBlock that represents the head of the loop for the top formed loop
- * @param predBB the predecessor of bb currently being handled
- * @param ptrBackward the backward chaining cell
- * @return whether we succeeded or not
+ * @param entry the loop entry
  */
-static bool handleBottomLoop (CompilationUnit *cUnit, LoopInformation *info, BasicBlock *bb, BasicBlock *predBB, BasicBlock **ptrBackward)
+static void insertPreLoopHeader (CompilationUnit *cUnit, LoopInformation *info, BasicBlock *entry)
 {
-    //If we don't already have a BasicBlock for it, create it and insert into compilation unit
-    BasicBlock *backward = insertLoopBackwardBlock (cUnit, bb);
+    BasicBlock *preHeader = dvmCompilerNewBBinCunit(cUnit, kDalvikByteCode);
+    preHeader->startOffset = entry->startOffset;
 
-    //Add information about it
-    info->addBackwardBlock (backward);
+    assert (entry->predecessors);
 
-    BasicBlock *notLoop = 0;
-
-    //Handle links from predBB to bb
-    if (predBB->taken == bb)
-    {
-        //Link taken to backward, it will go to bb
-        predBB->taken = backward;
-        dvmCompilerUpdatePredecessors (predBB, bb, backward);
-        //The not loop is predBB->fallThrough, it is the exit
-        notLoop = predBB->fallThrough;
-    }
-    else
-    {
-        if (predBB->fallThrough == bb)
-        {
-            //Link FT to backward, it will go to bb
-            predBB->fallThrough = backward;
-            dvmCompilerUpdatePredecessors (predBB, bb, backward);
-            //The not loop is predBB->taken, it is the exit
-            notLoop = predBB->taken;
-        }
-    }
-
-    //There is a case where notLoop can be 0:
-    //  - If bb directly goes to itself and it's an infinite loop
-    if (notLoop != 0)
+    BitVectorIterator bvIterator;
+    dvmBitVectorIteratorInit(entry->predecessors, &bvIterator);
+    for (BasicBlock *predBB = getNextBasicBlockViaBitVector (bvIterator, cUnit); predBB != 0;
+                     predBB = getNextBasicBlockViaBitVector (bvIterator, cUnit))
     {
-        //Inform loop information
-        info->setPostExitBlock (notLoop);
-
-        //Insert a landing pad for predBB
-        insertLoopExitBlock (cUnit, info, predBB, notLoop);
-
-        //It may happen that other blocks are also leading to
-        //notLoop. All blocks should then lead to notLoop
-        if ( (bb->taken == notLoop) || (bb->fallThrough == notLoop) )
+        // If the type is a backward chaining cell or inserted pre-header, go to the next one
+        if ((predBB->blockType != kChainingCellBackwardBranch) && (predBB != preHeader))
         {
-            //Check every block down to predBB
-            BasicBlock *inLoop = bb;
-            while (inLoop != predBB)
-            {
-                if (inLoop->taken == notLoop)
-                {
-                    insertLoopExitBlock (cUnit, info, inLoop, notLoop);
-                    inLoop = inLoop->fallThrough;
-                }
-                else
-                {
-                    if (inLoop->fallThrough == notLoop)
-                    {
-                        insertLoopExitBlock (cUnit, info, inLoop, notLoop);
-                        inLoop = inLoop->taken;
-                    }
-                    else
-                    {
-                        ALOGI("LOOP_INFO: Too many exits of the loop");
-                        cUnit->quitLoopMode = true;
-
-                        //Make sure null will be returned
-                        (*ptrBackward) = 0;
-                        return false;
-                    }
-                }
-            }
+            dvmCompilerInsertBasicBlockBetween (preHeader, predBB, entry);
         }
     }
-
-    //Return backward block via argument
-    (*ptrBackward) = backward;
-
-    //Report success
-    return true;
 }
 
 /**
@@ -666,28 +258,18 @@ void dvmCompilerFormOldLoop (CompilationUnit *cUnit, Pass *pass)
  * @brief Helper to test if the loop has been formed properly
  * @param cUnit the CompilationUnit
  * @param info the LoopInformation
+ * @param data required by interface (not used)
  * @return whether the loop is formed properly
  */
-static bool testLoopHelper (CompilationUnit *cUnit, const LoopInformation *info)
+static bool testLoopHelper (CompilationUnit *cUnit, LoopInformation *info, void *data)
 {
-    static int depth = 0;
-    depth++;
-
     //Standard message to append in case of error
     char message[256];
     snprintf (message, sizeof(message), "LOOP_INFO: loop for trace  %s%s, offset %02x at depth %d",
             cUnit->method->clazz->descriptor, cUnit->method->name,
-            cUnit->traceDesc->trace[0].info.frag.startOffset, depth);
+            cUnit->traceDesc->trace[0].info.frag.startOffset, info->getDepth ());
 
 
-    //First, check all the information about this loop level
-    if (info == 0)
-    {
-        ALOGE ("%s - info is null at testLoop", message);
-        depth--;
-        return false;
-    }
-
     //Gather all the required information
     BitVector *backwardBlocks = const_cast<BitVector *>(info->getBackwardBranches());
     BitVector *exitLoopBlocks = const_cast<BitVector *>(info->getExitLoops());
@@ -700,7 +282,6 @@ static bool testLoopHelper (CompilationUnit *cUnit, const LoopInformation *info)
     if (dvmCountSetBits (allBlocks) == 0)
     {
         ALOGE ("%s - Not even a single basic block in info", message);
-        depth--;
         return false;
     }
 
@@ -708,7 +289,6 @@ static bool testLoopHelper (CompilationUnit *cUnit, const LoopInformation *info)
     if (preHeader == 0)
     {
         ALOGE ("%s - Loop has no pre-header", message);
-        depth--;
         return false;
     }
 
@@ -716,7 +296,6 @@ static bool testLoopHelper (CompilationUnit *cUnit, const LoopInformation *info)
     if (entry == 0)
     {
         ALOGE ("%s - Loop has no entry block", message);
-        depth--;
         return false;
     }
 
@@ -724,31 +303,15 @@ static bool testLoopHelper (CompilationUnit *cUnit, const LoopInformation *info)
     if (preHeader->fallThrough != entry)
     {
         ALOGE ("%s - PreHeader %d does not go to loop entry %d", message, preHeader->id, entry->id);
-        depth--;
         return false;
     }
 
     //Now check all the basic blocks in the loop
     BitVectorIterator bvIterator;
-
-    dvmBitVectorIteratorInit (const_cast < BitVector* >(allBlocks), &bvIterator);
-
-    while (true)
+    dvmBitVectorIteratorInit (allBlocks, &bvIterator);
+    for (BasicBlock *loopBB = getNextBasicBlockViaBitVector (bvIterator, cUnit); loopBB != 0;
+                     loopBB = getNextBasicBlockViaBitVector (bvIterator, cUnit))
     {
-        //Get the next iterator
-        int blockIdx = dvmBitVectorIteratorNext (&bvIterator);
-
-        //If it is finished, exit
-        if (blockIdx == -1)
-        {
-            break;
-        }
-
-        BasicBlock *loopBB = (BasicBlock*) (dvmGrowableListGetElement (&cUnit->blockList, blockIdx));
-
-        //Paranoid
-        assert (loopBB != 0);
-
         //Check if the block only connects to blocks in the loop, backward block, or loop exit block
         if ( (loopBB->taken != 0) &&
                 (info->contains (loopBB->taken) == false) &&
@@ -756,7 +319,6 @@ static bool testLoopHelper (CompilationUnit *cUnit, const LoopInformation *info)
                 (dvmIsBitSet (backwardBlocks, loopBB->taken->id) == false) )
         {
             ALOGE ("%s - Basic block %d exits loop through taken %d", message, loopBB->id, loopBB->taken->id);
-            depth--;
             return false;
         }
 
@@ -766,7 +328,6 @@ static bool testLoopHelper (CompilationUnit *cUnit, const LoopInformation *info)
                 (dvmIsBitSet (backwardBlocks, loopBB->fallThrough->id) == false) )
         {
             ALOGE ("%s - Basic block %d exits loop through fallThrough %d", message, loopBB->id, loopBB->fallThrough->id);
-            depth--;
             return false;
         }
 
@@ -774,44 +335,16 @@ static bool testLoopHelper (CompilationUnit *cUnit, const LoopInformation *info)
 
     //Check if all backward blocks go to the entry
     dvmBitVectorIteratorInit (const_cast < BitVector* > (backwardBlocks), &bvIterator);
-    while (true)
+    for (BasicBlock *backBB = getNextBasicBlockViaBitVector (bvIterator, cUnit); backBB != 0;
+                     backBB = getNextBasicBlockViaBitVector (bvIterator, cUnit))
     {
-        //Get the next iterator
-        int blockIdx = dvmBitVectorIteratorNext (&bvIterator);
-
-        //If it is finished, exit
-        if (blockIdx == -1)
-        {
-            break;
-        }
-
-        BasicBlock *backBB = (BasicBlock*) (dvmGrowableListGetElement(&cUnit->blockList, blockIdx));
-
-        //Paranoid
-        assert (backBB != 0);
-
         if (backBB->fallThrough != entry)
         {
             ALOGE ("%s - Backward block %d does not go to entry %d", message, backBB->id, entry->id);
-            depth--;
-            return false;
-        }
-    }
-
-    //Now get the nested loops and check them as well (recurse)
-    unsigned int numNested = info->getNestedNbr ();
-    while (numNested > 0)
-    {
-        if ( testLoopHelper (cUnit, info->getNested (numNested - 1) ) == false)
-        {
-            depth--;
             return false;
         }
-        numNested--;
     }
 
-    //All good!
-    depth--;
     return true;
 }
 
@@ -828,211 +361,245 @@ void dvmCompilerTestLoop (CompilationUnit *cUnit, Pass *pass)
         return;
     }
 
-    LoopInformation *info = cUnit->loopInformation;
-
-    //Then call loop information fill
     if (cUnit->loopInformation != 0)
     {
-        cUnit->loopInformation->fillLoopInformation ();
+        cUnit->loopInformation = LoopInformation::getLoopInformation (cUnit, cUnit->loopInformation);
     }
 
-    if ( testLoopHelper (cUnit, info) == false )
+    LoopInformation *info = cUnit->loopInformation;
+
+    if (info == 0)
     {
+        ALOGE ("LOOP_INFO: loop for trace  %s%s, offset %02x - info is null at testLoop",
+            cUnit->method->clazz->descriptor, cUnit->method->name,
+            cUnit->traceDesc->trace[0].info.frag.startOffset);
         cUnit->quitLoopMode = true;
     }
-
+    else
+    {
+        if (info->iterate (cUnit, testLoopHelper) == false)
+        {
+            cUnit->quitLoopMode = true;
+        }
+    }
     (void) pass;
 }
 
 /**
- * @brief Form a loop if bb is a loop head
- * @details If it is, make sure it is a bottom formed
- * loop (or make it so), add a preloop block and an exit block
+ * @brief Check whether loop should be tranformed
+ * @param notLoop outs of loop
+ * @param entry loop entry
+ * @return true if transormation is required
+ */
+static bool isTransformationRequired (const BitVector *notLoop, const BasicBlock *entry)
+{
+    // We do not want to transform complex top loop now
+    // So we will work with top loop in this case
+    if (entry->successorBlockList.blockListType != kNotUsed)
+    {
+        return false;
+    }
+
+    // Loop entry has a taken and it is not in our loop => we want to transform this top loop
+    if ((entry->taken != 0) && (dvmIsBitSet (notLoop, entry->taken->id) == 1))
+    {
+        return true;
+    }
+    // Loop entry has a fallThrough and it is not in our loop => we want to transform this top loop
+    if ((entry->fallThrough != 0) && (dvmIsBitSet (notLoop, entry->fallThrough->id) == 1))
+    {
+        return true;
+    }
+    // Loop entry does not lead to out of loop => so we consider this as bottom loop
+    // Note in the future it might be interesting to transform the following loop
+    //      BB1 (loop entry), BB2 (leads to out), BB3 (backward)
+    // to bottom loop
+    //      BB1, BB2 (leads to out), BB3 (new loop entry), BB1_copy, BB2_copy (new backward to BB4)
+    // But it is too complex for now
+    return false;
+}
+
+/**
+ * @brief Attempt to transform top loop to bottom if needed
  * @param cUnit the CompilationUnit
- * @param bb the basic block which is a loop head
- * @return whether we changed anything (always false)
+ * @param info loop information for current loop
+ * @return new loop entry
  */
-bool dvmCompilerFormLoop (CompilationUnit *cUnit, BasicBlock *bb)
+static BasicBlock *handleTopLoop (CompilationUnit *cUnit, LoopInformation *info)
 {
-    bool success = true;
-    BasicBlock *backward = 0;
-    LoopInformation *info = 0;
+    BasicBlock *entry = info->getEntryBlock ();
+    BitVector *bbInLoop = info->getBasicBlocks ();
+    BitVector *tailblocks = info->getBackwardBranches ();
+    BitVector *notLoop = info->getExitLoops ();
 
     BitVectorIterator bvIterator;
 
-    //Paranoid
-    assert (bb->predecessors != 0);
+    // No outs => nothing to do
+    if (dvmCountSetBits (notLoop) == 0)
+    {
+        return entry;
+    }
 
-    //Get predecessors
-    dvmBitVectorIteratorInit(bb->predecessors, &bvIterator);
-    while (true)
+    // entry is a tail block => we are not a top loop
+    if (dvmIsBitSet (tailblocks, entry->id) == true)
     {
-        //Get the next iterator
-        int blockIdx = dvmBitVectorIteratorNext(&bvIterator);
+        return entry;
+    }
 
-        //If it is finished, exit
-        if (blockIdx == -1)
-        {
-            break;
-        }
+    // entry does not link to out => we are not a top loop
+    if(isTransformationRequired (notLoop, entry) == false)
+    {
+        return entry;
+    }
 
-        BasicBlock *predBB = (BasicBlock*) (dvmGrowableListGetElement(&cUnit->blockList, blockIdx));
+    // All BB points to out => no need to transform because it would be infinite loop
+    BitVector *tmp = dvmCompilerAllocBitVector (1, true);
+    BitVector *tmp1 = dvmCompilerAllocBitVector (1, true);
+    dvmClearAllBits (tmp);
 
-        //Paranoid
-        if (predBB == 0)
-        {
-            break;
-        }
+    // Collect all out coming to all exit blocks
+    dvmBitVectorIteratorInit(notLoop, &bvIterator);
+    for (BasicBlock *bb = getNextBasicBlockViaBitVector (bvIterator, cUnit); bb != 0;
+                     bb = getNextBasicBlockViaBitVector (bvIterator, cUnit))
+    {
+        BitVector *swap = tmp;
+        tmp = tmp1;
+        tmp1 = swap;
 
-        //If we have no dominator information, we can skip it
-        if (predBB->dominators == 0)
-        {
-            continue;
-        }
+        assert (bb->predecessors != 0);
+        dvmUnifyBitVectors (tmp, tmp1, bb->predecessors);
+    }
 
-        //Check if predecessor still leads to bb:
-        //This can happen if other changes have happened in between
-        if (predBB->taken != bb && predBB->fallThrough != bb)
+    // Find BB in our loop coming to all exit blocks
+    dvmIntersectBitVectors (tmp1, tmp, bbInLoop);
+    // All BB coming to out ?
+    if (dvmCompareBitVectors (bbInLoop, tmp1) == false)
+    {
+        return entry;
+    }
+
+    // Let's transform top loop
+    while (isTransformationRequired (notLoop, entry) == true)
+    {
+        BasicBlock *inLoop = (dvmIsBitSet (notLoop, entry->taken->id) == 1) ? entry->fallThrough : entry->taken;
+        BasicBlock *notLoopBB = (dvmIsBitSet (notLoop, entry->taken->id) == 1) ? entry->taken : entry->fallThrough;
+        assert (inLoop != 0);
+        assert (notLoopBB != 0);
+
+        // If inLoop is an entry of other loop we do not want to make it an entry of our loop
+        // Instead of that we add empty basic block to be loop entry
+        if (info->getLoopInformationByEntry (inLoop) != 0)
         {
-            continue;
+            BasicBlock *empty = dvmCompilerNewBBinCunit (cUnit, kDalvikByteCode);
+            dvmCompilerInsertBasicBlockBetween (empty, entry, inLoop);
+            dvmSetBit (bbInLoop, empty->id);
+            inLoop = empty;
         }
 
-        //If the predecessor is dominated by this one, it is a backward branch
-        if (dvmIsBitSet (predBB->dominators, bb->id) != 0)
-        {
-            //First time we require info? Then, create it
-            if (info == 0)
-            {
-                //The loop information
-                info = static_cast<LoopInformation *> (dvmCompilerNew (sizeof (*info), true));
+        // Copy entry to make it a tail block
+        BasicBlock *newBB = dvmCompilerCopyBasicBlock (cUnit, entry);
 
-                //Call explicitly init
-                info->init ();
+        //Update the predecessor information
+        dvmSetBit (notLoopBB->predecessors, newBB->id);
+        dvmSetBit (inLoop->predecessors, newBB->id);
 
-                //Set entry
-                info->setEntryBlock (bb);
+        // Now all tail blocks should be re-directed to new loop tail block (old loop entry)
+        dvmBitVectorIteratorInit(tailblocks, &bvIterator);
+        for (BasicBlock *tailblock = getNextBasicBlockViaBitVector (bvIterator, cUnit); tailblock != 0;
+                         tailblock = getNextBasicBlockViaBitVector (bvIterator, cUnit))
+        {
+            // Attach backedge to newBB
+            if (tailblock->taken == entry)
+            {
+                tailblock->taken = newBB;
+            }
+            else
+            {
+                tailblock->fallThrough = newBB;
             }
 
-            //Is the loop a top loop or not? Suppose it is
-            bool topLoop = true;
+            //Update the predecessor information
+            dvmCompilerUpdatePredecessors (tailblock, entry, newBB);
+        }
 
-            BasicBlock *notLoop = 0;
+        // Old entry is not in a loop now, while new one it is
+        dvmClearBit (bbInLoop, entry->id);
+        dvmSetBit (bbInLoop, newBB->id);
+        entry = inLoop;
 
-            //If predBB has a taken it isn't the bb, it is a bottom loop
-            if (predBB->taken != 0 && predBB->taken != bb)
-            {
-                topLoop = false;
-                notLoop = predBB->taken;
-            }
+        // Now we have only one new block tail
+        dvmClearAllBits (tailblocks);
+        dvmSetBit (tailblocks, newBB->id);
+    }
 
-            //If predBB has a fallThrough it isn't the bb, it is a bottom loop
-            if (predBB->fallThrough != 0 && predBB->fallThrough != bb)
-            {
-                topLoop = false;
-                notLoop = predBB->fallThrough;
-            }
+    return entry;
+}
 
-            //There is a corner case where the bb might be also going to where we aren't
-            //It must be not hidden though
-            if (notLoop != 0 && (notLoop == bb->taken || notLoop == bb->fallThrough))
-            {
-                //Definitely a top loop if not going to a normal chaining cell
-                if (notLoop->blockType == kDalvikByteCode)
-                {
-                    topLoop = true;
-                }
-                else
-                {
-                    //Maybe all the BBs go to the notLoop. This is then both a bottom and
-                    // top loop. We then consider it as a bottom loop
-                    BasicBlock *inLoop = ( notLoop == bb->taken ? bb->fallThrough : bb->taken) ;
-
-                    //Paranoid
-                    assert(inLoop != 0);
-
-                    //Assume bottomLoop to begin with
-                    topLoop = false;
-                    while (inLoop != bb)
-                    {
-                        if (inLoop->taken == notLoop)
-                        {
-                            inLoop = inLoop->fallThrough;
-                        }
-                        else
-                        {
-                            if (inLoop->fallThrough == notLoop)
-                            {
-                                inLoop = inLoop->taken;
-                            }
-                            else
-                            {
-                                topLoop = true;
-                                break;
-                            }
-                        }
-                        assert (inLoop != 0);
-                    }
-                }
-            }
+bool dvmCompilerFormLoopWorker (CompilationUnit *cUnit, LoopInformation *info, void *data)
+{
+    BitVectorIterator bvIterator;
+    BitVectorIterator bvIterator2;
 
-            //Last case: if predBB is bb then it isn't a top loop at all
-            if (predBB == bb)
-            {
-                topLoop = false;
-            }
+    // First we'd like to ensure that some of back branches links to out.
+    // It might require loop transformation.
+    BasicBlock *entry = handleTopLoop (cUnit, info);
 
-            if (topLoop == true)
-            {
-                //We have a top loop case here
-                success = handleTopLoop (cUnit, info, bb, predBB, &backward);
-            }
-            else
-            {
-                //Otherwise, it is already a bottom loop
-                success = handleBottomLoop (cUnit, info, bb, predBB, &backward);
-            }
+    // Update loop information with new entry
+    info->setEntryBlock (entry);
 
-            if (success == false)
-            {
-                //Bail if failed
-                break;
-            }
+    // For each tail block we should add a Backward Branch
+    dvmBitVectorIteratorInit(info->getBackwardBranches (), &bvIterator);
+    for (BasicBlock *tailBlock = getNextBasicBlockViaBitVector (bvIterator, cUnit); tailBlock != 0;
+                     tailBlock = getNextBasicBlockViaBitVector (bvIterator, cUnit))
+    {
+        BasicBlock *backward = dvmCompilerNewBBinCunit(cUnit, kChainingCellBackwardBranch);
+        backward->startOffset = tailBlock->startOffset;
 
-            //We now have a new loop information
-            if (cUnit->loopInformation == 0)
-            {
-                cUnit->loopInformation = info;
-            }
-            else
-            {
-                //Add the current loop information
-                cUnit->loopInformation->add (info);
-            }
-        }
+        dvmCompilerInsertBasicBlockBetween (backward, tailBlock, entry);
     }
 
-    //If we have a backward chaining cell, insert the preheader now
-    //Only care if we succeeded previously
-    if (backward != 0 && success == true)
+    // For each exit we should add an Exit BB
+    BitVector *tmp = dvmCompilerAllocBitVector (1, true);
+    BitVector *basicBlocks = info->getBasicBlocks ();
+
+    dvmBitVectorIteratorInit(info->getExitLoops (), &bvIterator);
+    for (BasicBlock *notLoop = getNextBasicBlockViaBitVector (bvIterator, cUnit); notLoop != 0;
+                     notLoop = getNextBasicBlockViaBitVector (bvIterator, cUnit))
     {
-        //Now create a pre loop header
-        success = insertPreLoopHeader (cUnit, info, backward);
+        dvmIntersectBitVectors (tmp, notLoop->predecessors, basicBlocks);
+
+        // Add Exit BB for found specific exit
+        dvmBitVectorIteratorInit(tmp, &bvIterator2);
+        for (BasicBlock *out = getNextBasicBlockViaBitVector (bvIterator2, cUnit); out != 0;
+                         out = getNextBasicBlockViaBitVector (bvIterator2, cUnit))
+        {
+            BasicBlock *exitBlock = dvmCompilerNewBBinCunit(cUnit, kDalvikByteCode);
+            exitBlock->startOffset = out->startOffset;
+
+            dvmCompilerInsertBasicBlockBetween (exitBlock, out, notLoop);
+        }
     }
 
-    //If there was a failure, report it
-    if (success == false)
-    {
-        //This should never happen
-        ALOGD ("JIT_INFO: Problem when forming loop for %s%s and offset %x",
-                cUnit->method->clazz->descriptor, cUnit->method->name, bb->startOffset);
-        cUnit->quitLoopMode = true;
+    // Finally add a pre-loop header
+    insertPreLoopHeader (cUnit, info, entry);
 
-        //In the assert world, we'd prefer this never happens
-        assert (0);
-     }
+    return true;
+}
 
-    //We don't want to iterate on the changes
-    return false;
+/**
+ * @brief Form a loop
+ * @details make sure it is a bottom formed
+ * loop (or make it so), add a preloop block and an exit block
+ * @param cUnit the CompilationUnit
+ * @param pass the current pass
+ * @return whether we changed anything (always false)
+ */
+void dvmCompilerFormLoop (CompilationUnit *cUnit, Pass *pass)
+{
+    if (cUnit->loopInformation != 0)
+    {
+        cUnit->loopInformation->iterate (cUnit, dvmCompilerFormLoopWorker);
+    }
 }
 
 /**
diff --git a/vm/compiler/BBOptimization.h b/vm/compiler/BBOptimization.h
index 60954ae..abfa1da 100644
--- a/vm/compiler/BBOptimization.h
+++ b/vm/compiler/BBOptimization.h
@@ -32,12 +32,14 @@ class LoopInformation;
 bool dvmCompilerMergeBasicBlocks (CompilationUnit *cUnit, BasicBlock *bb);
 
 /**
- * @brief Form the loop by inserting pre/post blocks and backward branches for loops
+ * @brief Form a loop
+ * @details make sure it is a bottom formed
+ * loop (or make it so), add a preloop block and an exit block
  * @param cUnit the CompilationUnit
- * @param bb the BasicBlock
- * @return returns whether we changed anything in the BasicBlock
+ * @param pass the current pass
+ * @return whether we changed anything (always false)
  */
-bool dvmCompilerFormLoop (CompilationUnit *cUnit, BasicBlock *bb);
+void dvmCompilerFormLoop (CompilationUnit *cUnit, Pass *pass);
 
 /**
  * @brief Test if the loop has been formed properly
diff --git a/vm/compiler/Dataflow.cpp b/vm/compiler/Dataflow.cpp
index 113dadd..d1719c9 100644
--- a/vm/compiler/Dataflow.cpp
+++ b/vm/compiler/Dataflow.cpp
@@ -2455,9 +2455,11 @@ bool detectAndInitializeBasicIV(CompilationUnit *cUnit,
  * @brief Looks through loop structure to find induction variables.
  * @param cUnit The compilation unit
  * @param info The loop information for current loop.
+ * @param data required by interface (not used)
+ * @return true to continue iteration over loops
  */
-void dvmCompilerFindInductionVariablesHelper(CompilationUnit *cUnit,
-                                             LoopInformation *info)
+bool dvmCompilerFindInductionVariablesHelper(CompilationUnit *cUnit,
+                                             LoopInformation *info, void *data = 0)
 {
     //Get the loop entry BB
     BasicBlock *entry = info->getEntryBlock();
@@ -2465,7 +2467,7 @@ void dvmCompilerFindInductionVariablesHelper(CompilationUnit *cUnit,
     //Paranoid
     if (entry == 0)
     {
-        return;
+        return true;
     }
 
     //Clear the induction variable information and inter-iteration variables
@@ -2505,6 +2507,7 @@ void dvmCompilerFindInductionVariablesHelper(CompilationUnit *cUnit,
             }
         }
     }
+    return true;
 }
 
 /**
@@ -2521,22 +2524,7 @@ void dvmCompilerFindInductionVariables(CompilationUnit *cUnit,
         return;
     }
 
-    //Find the induction variables for this loop
-    dvmCompilerFindInductionVariablesHelper(cUnit, info);
-
-    //Find out how many nested loops we have
-    unsigned int nbr = info->getNestedNbr ();
-
-    // Find induction variables for each child as well
-    for (unsigned int i = 0; i < nbr; i++)
-    {
-        LoopInformation *inner = info->getNested (i);
-
-        //Paranoid
-        assert(inner != 0);
-
-        dvmCompilerFindInductionVariables (cUnit, inner);
-    }
+    info->iterate (cUnit, dvmCompilerFindInductionVariablesHelper);
 }
 #endif
 
diff --git a/vm/compiler/Frontend.cpp b/vm/compiler/Frontend.cpp
index 0a9d75f..f6675ae 100644
--- a/vm/compiler/Frontend.cpp
+++ b/vm/compiler/Frontend.cpp
@@ -998,7 +998,7 @@ void dvmCompilerDumpBasicBlocks (CompilationUnit *cUnit, const char *dirPrefix,
         {
             if (cUnit->loopInformation != 0)
             {
-                cUnit->loopInformation->dumpInformationDotFormat (dvmCreateGraphFile);
+                cUnit->loopInformation->dumpInformationDotFormat (cUnit, dvmCreateGraphFile);
             }
         }
 #endif
diff --git a/vm/compiler/IntermediateRep.cpp b/vm/compiler/IntermediateRep.cpp
index 7a98595..7e1a203 100644
--- a/vm/compiler/IntermediateRep.cpp
+++ b/vm/compiler/IntermediateRep.cpp
@@ -377,7 +377,7 @@ void dvmCompilerPrependInstructionsToBasicBlocks (CompilationUnit *cUnit, BitVec
 bool dvmCompilerInsertBasicBlockBetween (BasicBlock *newBlock, BasicBlock *parent, BasicBlock *child)
 {
     //Paranoid
-    if (parent == 0 || child == 0 || (parent->taken != child && parent->fallThrough != child))
+    if (parent == 0 || child == 0)
     {
         return false;
     }
@@ -394,6 +394,37 @@ bool dvmCompilerInsertBasicBlockBetween (BasicBlock *newBlock, BasicBlock *paren
         {
             parent->fallThrough = newBlock;
             dvmCompilerUpdatePredecessors (parent, child, newBlock);
+        } else {
+            // We probably have a switch, so we should find successor to child and update it
+            bool found = false;
+            if (parent->successorBlockList.blockListType != kNotUsed) {
+                GrowableListIterator iterator;
+                dvmGrowableListIteratorInit(&parent->successorBlockList.blocks,
+                                        &iterator);
+                while (true) {
+                    SuccessorBlockInfo *successorBlockInfo = (SuccessorBlockInfo *) dvmGrowableListIteratorNext(&iterator);
+                    if (successorBlockInfo == 0)
+                    {
+                        break;
+                    }
+
+                    BasicBlock *succBB = successorBlockInfo->block;
+                    assert (succBB != 0);
+                    if (succBB == child)
+                    {
+                        dvmGrowableListSetLastIterator (&iterator, (intptr_t)child);
+                        dvmCompilerUpdatePredecessors (parent, child, newBlock);
+                        found = true;
+                        break;
+                    }
+                }
+            }
+
+            // We did not find successor, so nothing to insert
+            if (found == false)
+            {
+                return false;
+            }
         }
     }
 
diff --git a/vm/compiler/Loop.cpp b/vm/compiler/Loop.cpp
index 37d58f4..695fc8e 100644
--- a/vm/compiler/Loop.cpp
+++ b/vm/compiler/Loop.cpp
@@ -1837,9 +1837,11 @@ static void insertBlockBeforeBackwardHelper (CompilationUnit *cUnit,
  * a block before each of them.
  * @param cUnit the Compilation Unit
  * @param info the information of Loop we are looking at
+ * @param data required by interface (not used)
+ * @return true to continue iteration over loops
  */
-static void insertBlockBeforeBackward (CompilationUnit *cUnit,
-        const LoopInformation *info)
+static bool insertBlockBeforeBackward (CompilationUnit *cUnit,
+        LoopInformation *info, void *data = 0)
 {
     //We want to look through all of the backward chaining cells
     const BitVector *backwards = info->getBackwardBranches ();
@@ -1875,6 +1877,7 @@ static void insertBlockBeforeBackward (CompilationUnit *cUnit,
 
         insertBlockBeforeBackwardHelper (cUnit, backward);
     }
+    return true;
 }
 
 /**
@@ -1882,7 +1885,7 @@ static void insertBlockBeforeBackward (CompilationUnit *cUnit,
  * @param cUnit the Compilation Unit
  * @param info the information of Loop we are looking at
  */
-static void insertPreBackwardWalker (CompilationUnit *cUnit, const LoopInformation *info)
+static void insertPreBackwardWalker (CompilationUnit *cUnit, LoopInformation *info)
 {
     //If info is 0, there is nothing to do
     if (info == 0)
@@ -1891,21 +1894,7 @@ static void insertPreBackwardWalker (CompilationUnit *cUnit, const LoopInformati
     }
 
     //Actually do the work
-    insertBlockBeforeBackward (cUnit, info);
-
-    //Search in the children if anybody includes them
-    unsigned int nestedNum = info->getNestedNbr ();
-
-    for (unsigned int i = 0; i < nestedNum; i++)
-    {
-        //Get the inner loop
-        LoopInformation *inner = info->getNested (i);
-
-        //Paranoid
-        assert(inner != 0);
-
-        insertPreBackwardWalker (cUnit, inner);
-    }
+    info->iterate (cUnit, insertBlockBeforeBackward);
 }
 
 /**
diff --git a/vm/compiler/LoopInformation.cpp b/vm/compiler/LoopInformation.cpp
index d0cd2c6..82af656 100644
--- a/vm/compiler/LoopInformation.cpp
+++ b/vm/compiler/LoopInformation.cpp
@@ -19,369 +19,532 @@
 #include "Dataflow.h"
 #include "LoopInformation.h"
 
-LoopInformation::LoopInformation (void)
-{
-    //Set BitVector to 0
-    interIterationVariables = 0;
+#include <map>
+#include <stack>
 
-    //Call initialization
-    init ();
-}
-
-LoopInformation::~LoopInformation (void)
+bool LoopInformation::iterateWithConst (const CompilationUnit *cUnit, bool (*func)(const CompilationUnit *, LoopInformation *, void *), void *data)
 {
+    LoopInformation *item = this;
+    while (item != 0)
+    {
+        if (func (cUnit, item, data) == false)
+        {
+            return false;
+        }
+        if (item->nested != 0)
+        {
+            if (item->nested->iterateWithConst (cUnit, func, data) == false)
+            {
+                return false;
+            }
+        }
+        item = item->siblingNext;
+    }
+    return true;
 }
 
-void LoopInformation::init (void)
+bool LoopInformation::iterate (CompilationUnit *cUnit, bool (*func)(CompilationUnit *, LoopInformation *, void *), void *data)
 {
-    variants = 0;
-    parent = 0;
-    depth = 0;
-    basicBlocks = 0;
-    backward = 0;
-    entry = 0;
-    preHeader = 0;
-    postExitLoop = 0;
-    scratchRegisters = 0;
-    peeledBlocks = 0;
-
-    if (interIterationVariables == 0)
+    LoopInformation *item = this;
+    while (item != 0)
     {
-        interIterationVariables = dvmCompilerAllocBitVector (1, true);
+        if (func (cUnit, item, data) == false)
+        {
+            return false;
+        }
+        if (item->nested != 0)
+        {
+            if (item->nested->iterate (cUnit, func, data) == false)
+            {
+                return false;
+            }
+        }
+        item = item->siblingNext;
     }
-    else
+    return true;
+}
+
+bool LoopInformation::iterate (bool (*func)(LoopInformation *, void *), void *data)
+{
+    LoopInformation *item = this;
+    while (item != 0)
     {
-        dvmClearAllBits (interIterationVariables);
+        if (func (item, data) == false)
+        {
+            return false;
+        }
+        if (item->nested != 0)
+        {
+            if (item->nested->iterate (func, data) == false)
+            {
+                return false;
+            }
+        }
+        item = item->siblingNext;
     }
-
-    // Initialize growable lists
-    dvmInitGrowableList (&nested, 1);
-    dvmInitGrowableList (&inductionVariableList, 1);
-
-
-    //Initialize the BitVectors:
-    exitLoop = dvmCompilerAllocBitVector (1, true);
+    return true;
 }
 
 /**
- * Add takes a new LoopInformation and add to nested list independent on nested correctness.
- * The correction of nest information will be done later with a special invocation of nestUpdate()
- * No need to worry about duplicates, nestUpdate will handle it.
+ * @brief helper function to collect all loop informations into map BB->LoopInformation
+ * @param cUnit the CompilationUnit
+ * @param info current Loop Information
+ * @param data map to fill
+ * @return always true, required by interface
  */
-void LoopInformation::add (LoopInformation *info)
+static bool collectAllNested (CompilationUnit *cUnit, LoopInformation *info, void *data)
 {
-    if (info != this)
-    {
-        dvmInsertGrowableList (&nested, (intptr_t) info);
-    }
-}
+    std::map<BasicBlock *, LoopInformation *> *container =
+        static_cast<std::map<BasicBlock *, LoopInformation *> *>(data);
+
+    (*container)[info->getEntryBlock()] = info;
+
+    return true;
+};
 
 /**
- * nestUpdate makes the nest information up to date
+ * @brief Find all tail blocks to specified basic block
+ * @param cUnit the CompilationUnit
+ * @param bb the basic block which is suggested to be a loop head
+ * @return tail blocks or 0 if there is no them
  */
-LoopInformation *LoopInformation::nestUpdate (void)
+static BitVector* getLoopTailBlocks (CompilationUnit *cUnit, BasicBlock *bb)
 {
-    GrowableList allInfo;
-    dvmInitGrowableList (&allInfo, 1);
-    collectAllNested (&allInfo);
+    BitVectorIterator bvIterator;
+    BitVector *tailblocks = 0;
 
-    LoopInformation *top = this;
-    dvmClearGrowableList (&(top->nested));
+    assert (bb->predecessors != 0);
 
-    GrowableListIterator iterator;
-    dvmGrowableListIteratorInit (&allInfo, &iterator);
-    while (true)
+    // If the predecessor is dominated by this entry, it is a backward branch
+    dvmBitVectorIteratorInit(bb->predecessors, &bvIterator);
+    for (BasicBlock *predBB = getNextBasicBlockViaBitVector (bvIterator, cUnit); predBB != 0;
+                     predBB = getNextBasicBlockViaBitVector (bvIterator, cUnit))
     {
-        LoopInformation *info = (LoopInformation*) dvmGrowableListIteratorNext (&iterator);
-        if (info == 0)
+        //If we have no dominator information, we can skip it
+        if (predBB->dominators == 0)
         {
-            return top;
+            continue;
         }
-        dvmClearGrowableList (&(info->nested));
-        LoopInformation *res = top->nest (info);
-        if (res == 0)
+
+        if (dvmIsBitSet (predBB->dominators, bb->id) != 0)
         {
-            return 0;
+            if (tailblocks == 0)
+            {
+                tailblocks = dvmCompilerAllocBitVector (1, true);
+                dvmClearAllBits (tailblocks);
+            }
+            dvmSetBit (tailblocks, predBB->id);
         }
-        top = res;
     }
+    return tailblocks;
 }
 
-
 /**
- * Nest takes a new LoopInformation and determines if info is nested with this instance or not.
- * If it is nested in this instance, we fill our nested information with it
- * Otherwise, we are nested in it and we request it to nest us
- * The function returns the outer nested loop, it can nest any level of a nested loop
+ * @brief Find All BB in a loop
+ * @param cUnit the CompilationUnit
+ * @param entry loop entry
+ * @param tailblocks tail blocks to loop entry
+ * @param basicBlocks bit vector to fill with blocks in a loop
+ * @return false if it is not a loop, namely there is a BB which entry does not dominate
  */
-LoopInformation *LoopInformation::nest (LoopInformation *info)
+static bool getAllBBInLoop (CompilationUnit *cUnit, BasicBlock *entry, BitVector *tailblocks, BitVector *basicBlocks)
 {
-    BasicBlock *entry = info->getEntryBlock ();
+    assert (tailblocks != 0);
+    assert (entry != 0);
+    assert (basicBlocks != 0);
 
-    //Paranoid
-    if (info == this)
+    dvmClearAllBits (basicBlocks);
+
+    // loop entry is in a loop
+    dvmSetBit (basicBlocks, entry->id);
+
+    std::stack<BasicBlock*> workStack;
+
+    // Start from tail blocks except entry loop if it is a tail block at the same time
+    BitVectorIterator bvIterator;
+    dvmBitVectorIteratorInit(tailblocks, &bvIterator);
+    for (BasicBlock *tailblock = getNextBasicBlockViaBitVector (bvIterator, cUnit); tailblock != 0;
+                     tailblock = getNextBasicBlockViaBitVector (bvIterator, cUnit))
     {
-        return this;
+        if (tailblock != entry)
+        {
+            workStack.push (tailblock);
+        }
     }
 
-    //Do we include the current loop ?
-    if (contains (entry) == true)
+    // Loop entry dominates us, so we are safe walking by predecessors stopping by loop entry
+    while (workStack.empty () != true)
     {
-        //We contain them, so they should not contain us
-        if (info->contains (getEntryBlock ()))
+        BasicBlock *cur = workStack.top ();
+        workStack.pop ();
+
+        if (dvmIsBitSet (cur->dominators, entry->id) == 0)
         {
-            //The two loops are overlapping. We need to select
-            //the outer one.
-            if (dvmIsBitSet (entry->dominators, getEntryBlock ()->id))
-            {
-                //We dominate the loop, so we are the outer loop
-                return this;
-            }
-            else
-            {
-                if (dvmIsBitSet (getEntryBlock ()->dominators, entry->id))
-                {
-                    //The loop dominates us
-                    return info;
-                }
-                else
-                {
-                    //Something is very wrong
-                    ALOGI ("LOOP_INFO: Invalid loop overlap detected while trying to nest");
-                    return 0;
-                }
-            }
+            // it is not a normal loop
+            return false;
         }
+        dvmSetBit (basicBlocks, cur->id);
 
-        //Search in the children if anybody includes them
-        GrowableListIterator iterator;
-        dvmGrowableListIteratorInit (&nested, &iterator);
-        while (true)
+        dvmBitVectorIteratorInit(cur->predecessors, &bvIterator);
+        for (BasicBlock *pred = getNextBasicBlockViaBitVector (bvIterator, cUnit); pred != 0;
+                         pred = getNextBasicBlockViaBitVector (bvIterator, cUnit))
         {
-            LoopInformation *inner = (LoopInformation*) dvmGrowableListIteratorNext(&iterator);
-            if (inner == 0)
+            if (dvmIsBitSet (basicBlocks, pred->id) == false)
             {
-                break;
+                workStack.push (pred);
             }
+        }
+    }
 
-            //Does inner contain it or does info contain inner?
-            if (inner->contains (entry) == true || info->contains (inner->getEntryBlock ()) == true)
-            {
-                //This loop goes there
-                inner = inner->nest (info);
-
-                //If something went wrong in the inner loops
-                if (inner == 0)
-                {
-                    return inner;
-                }
-
-                //Update entry
-                dvmGrowableListSetLastIterator (&iterator, (intptr_t) inner);
-
-                //Return this
-                return this;
-            }
+    return true;
+}
 
-            //We have to update the pointer in the growable list
-        }
+/**
+ * @brief Determine not in a loop's BB with link from loop body
+ * @param cUnit the CompilationUnit
+ * @param basicBlocks the basic block forming a loop
+ * @param exitBlocks not in a loop's BBs with link from loop body (to fill)
+ */
+static void getOutsFromLoop (CompilationUnit *cUnit, BitVector *basicBlocks, BitVector *exitBlocks)
+{
+    assert (basicBlocks != 0);
+    assert (exitBlocks != 0);
 
-        //No child contained it, add it there
-        //For the moment just add nest it in the first level
-        dvmInsertGrowableList (&nested, (intptr_t) info);
+    dvmClearAllBits (exitBlocks);
 
-        //Set depth
-        info->setDepth (getDepth () + 1);
-        //Set Parent
-        info->setParent (this);
-    }
-    else
+    // Iterate over BB in a loop and if its edge comes out of a loop => add it to bit vector
+    BitVectorIterator bvIterator;
+    dvmBitVectorIteratorInit(basicBlocks, &bvIterator);
+    for (BasicBlock *cur = getNextBasicBlockViaBitVector (bvIterator, cUnit); cur != 0;
+                     cur = getNextBasicBlockViaBitVector (bvIterator, cUnit))
     {
-        //Otherwise, info contains us
-        if (info->contains (getEntryBlock ()) == true)
+        if ((cur->taken != 0) && (dvmIsBitSet (basicBlocks, cur->taken->id) == false))
         {
-            return info->nest (this);
+            dvmSetBit (exitBlocks, cur->taken->id);
         }
-        else
+        if ((cur->fallThrough != 0) && (dvmIsBitSet (basicBlocks, cur->fallThrough->id) == false))
         {
-            //These are outer sibling loops, but this should not happen
-            ALOGD ("Outer sibling loops should not happen");
+            dvmSetBit (exitBlocks, cur->fallThrough->id);
         }
-    }
 
-    return this;
+        if (cur->successorBlockList.blockListType != kNotUsed) {
+            GrowableListIterator iterator;
+            dvmGrowableListIteratorInit(&cur->successorBlockList.blocks,
+                                    &iterator);
+            while (true) {
+                SuccessorBlockInfo *successorBlockInfo = (SuccessorBlockInfo *) dvmGrowableListIteratorNext(&iterator);
+                if (successorBlockInfo == 0)
+                {
+                    break;
+                }
+
+                BasicBlock *succBB = successorBlockInfo->block;
+                assert (succBB != 0);
+                if (dvmIsBitSet (basicBlocks, succBB->id) == false)
+                {
+                    dvmSetBit (exitBlocks, succBB->id);
+                }
+            }
+        }
+    }
 }
 
-void LoopInformation::addExitLoop (BasicBlock *bb)
+LoopInformation * LoopInformation::getLoopInformation (CompilationUnit *cUnit, LoopInformation *current)
 {
-    //Paranoid
-    assert (bb != 0);
 
-    //If not allocated yet
-    if (exitLoop == 0)
+    if (cUnit->quitLoopMode == true)
     {
-        exitLoop = dvmCompilerAllocBitVector (1, true);
+        return 0;
     }
 
-    dvmSetBit (exitLoop, bb->id);
-}
-
-/**
- * Return the LoopInformation that has entry as the entry BasicBlock
- */
-LoopInformation *LoopInformation::getLoopInformationByEntry (const BasicBlock *entry)
-{
-    //Is our entry this entry ?
-    if (this->entry == entry)
+    std::map<BasicBlock *, LoopInformation *> curBB2LI;
+    LoopInformation *result = 0;
+    if (current != 0)
     {
-        return this;
+        current->iterate (cUnit, collectAllNested, &curBB2LI);
     }
 
-    //Go through the nested iteration
+    // iterate over all BB
     GrowableListIterator iterator;
-
-    dvmGrowableListIteratorInit(&nested, &iterator);
-
+    dvmGrowableListIteratorInit(&cUnit->blockList, &iterator);
     while (true)
     {
-        LoopInformation *inner = (LoopInformation *) dvmGrowableListIteratorNext(&iterator);
-        if (inner == 0)
+        //Get next BasicBlock
+        BasicBlock *bb = (BasicBlock *) dvmGrowableListIteratorNext(&iterator);
+
+        //Have we finished
+        if (bb == 0)
         {
             break;
         }
 
-        LoopInformation *res = inner->getLoopInformationByEntry (entry);
+        if (bb->hidden == true)
+        {
+            continue;
+        }
+
+        // First find all tail blocks
+        BitVector *tailblocks = getLoopTailBlocks(cUnit, bb);
+
+        if (tailblocks == 0)
+        {
+            // bb is not a loop entry
+            continue;
+        }
+
+        // Do we have an old loop information for bb loop entry?
+        LoopInformation *info = curBB2LI[bb];
+        if (info == 0)
+        {
+            info = static_cast<LoopInformation *> (dvmCompilerNew (sizeof (*info), true));
+            info->init ();
+            info->setEntryBlock (bb);
+        }
+        else
+        {
+            info->parent = 0;
+            info->nested = 0;
+            info->siblingNext = 0;
+            info->siblingPrev = 0;
+            assert (info->getEntryBlock () == bb);
+        }
+
+        // Set backwards
+        info->backward = tailblocks;
+
+        // Now, Find all BB in a loop
+        if (getAllBBInLoop (cUnit, bb, tailblocks, info->basicBlocks) == false)
+        {
+            // It is not a normal loop
+            continue;
+        }
+
+        // Now, Find out from a loop
+        getOutsFromLoop (cUnit, info->basicBlocks, info->exitLoop);
+
+        // Now, check for pre-header
+        // We need to find a predecessor dominating us
+        // In correctly formed loop is will be alone
+        BitVector *tmp = dvmCompilerAllocBitVector (1, true);
+        dvmIntersectBitVectors (tmp, bb->predecessors, bb->dominators);
+        int idx = dvmHighestBitSet (tmp);
+        if (idx >= 0)
+        {
+            info->preHeader = ((BasicBlock*) (dvmGrowableListGetElement(&cUnit->blockList, idx)));
+        }
+        else
+        {
+            info->preHeader = 0;
+        }
 
-        //If found, we can leave
-        if (res != 0)
+        // Last thing, we do not want kPreBackwardBlock and kChainingCellBackwardBranch to be in our loop
+        BitVectorIterator bvIterator;
+        dvmBitVectorIteratorInit (info->backward, &bvIterator);
+        for (BasicBlock *current = getNextBasicBlockViaBitVector (bvIterator, cUnit); current != 0;
+                         current = getNextBasicBlockViaBitVector (bvIterator, cUnit))
         {
-            return res;
+            if (current->blockType == kChainingCellBackwardBranch)
+            {
+                dvmClearBit (info->basicBlocks, current->id);
+
+                // Also, let's check if there is a kPreBackwardBlock predecessor
+                BitVectorIterator bvIterator2;
+                dvmBitVectorIteratorInit (current->predecessors, &bvIterator2);
+                for (BasicBlock *predBB = getNextBasicBlockViaBitVector (bvIterator2, cUnit); predBB != 0;
+                                 predBB = getNextBasicBlockViaBitVector (bvIterator2, cUnit))
+                {
+                    if (predBB->blockType == kPreBackwardBlock)
+                    {
+                        dvmClearBit (info->basicBlocks, predBB->id);
+                    }
+                }
+            }
         }
+
+        // Nest loop information
+        result = (result == 0) ? info : result->add (info);
+
+        // We are done
     }
 
-    //Did not find it
-    return 0;
+    return result;
+}
+
+LoopInformation::LoopInformation (void)
+{
+    //Set BitVector to 0
+    interIterationVariables = 0;
+
+    //Call initialization
+    init ();
+}
+
+LoopInformation::~LoopInformation (void)
+{
 }
 
-void LoopInformation::fillBasicBlockVector (BasicBlock *current)
+void LoopInformation::init (void)
 {
+    variants = 0;
+    parent = 0;
+    siblingNext = 0;
+    siblingPrev = 0;
+    nested = 0;
+    depth = 0;
+    basicBlocks = 0;
+    backward = 0;
+    entry = 0;
+    preHeader = 0;
+    scratchRegisters = 0;
+    peeledBlocks = 0;
 
-    //If 0, exit, get out
-    if (current == 0 || current == postExitLoop)
+    if (interIterationVariables == 0)
     {
-        return;
+        interIterationVariables = dvmCompilerAllocBitVector (1, true);
     }
-
-    //If already in vector, we are done
-    if (dvmIsBitSet (basicBlocks, current->id) == true)
+    else
     {
-        return;
+        dvmClearAllBits (interIterationVariables);
     }
 
-    //Is it in the loop?
-    bool isInLoop = true;
+    // Initialize growable lists
+    dvmInitGrowableList (&inductionVariableList, 1);
+
+
+    //Initialize the BitVectors:
+    exitLoop = dvmCompilerAllocBitVector (1, true);
+    basicBlocks = dvmCompilerAllocBitVector (1, true);
+}
 
-    //Mark it as visited
-    dvmSetBit (basicBlocks, current->id);
+// update depth for loop and nested loops
+void LoopInformation::setDepth (int depth)
+{
+    LoopInformation *info = this;
+    while (info != 0)
+    {
+        info->depth = depth;
+        if (info->nested != 0)
+        {
+            info->nested->setDepth (depth + 1);
+        }
+        info = info->siblingNext;
+    }
+}
 
-    //If it's a prebackward block, it's not in the loop
-    if (current->blockType == kPreBackwardBlock)
+/**
+ * Add takes a new LoopInformation and determines if info is nested with this instance or not.
+ * If it is nested in this instance, we fill our nested information with it
+ * Otherwise, we are nested in it and we request it to nest us
+ * The function returns the outer nested loop, it can nest any level of a nested loop
+ */
+LoopInformation *LoopInformation::add (LoopInformation *info)
+{
+    // Simple case
+    if (info == this)
     {
-        isInLoop = false;
+        return this;
     }
 
-    //If we are going back to first, we should be backward
-    //But, we can also be a top loop with multiple backward branches
-    //coming into us, and we are not done processing all our
-    //predecessors. We fallthrough to the entry, and we still
-    //have links from the loop.
-    if (current->fallThrough == entry)
+    //Do we include the current loop ?
+    if (contains (info->getEntryBlock ()) == true)
     {
-        if (dvmIsBitSet (entry->dominators, current->id) == false)
-        {
-            //Normally backwards are only fallThrough
-            assert (current->taken == 0);
-            addBackwardBlock (current);
+        //We contain them, so they should not contain us
+        assert (info->contains (getEntryBlock ()) == false);
 
-            //Current is outside of the loop
-            isInLoop = false;
+        //Search in the children if anybody includes them
+        if (nested == 0)
+        {
+            nested = info;
+        }
+        else
+        {
+            nested = nested->add (info);
         }
+        nested->parent = this;
+        nested -> setDepth (getDepth () + 1);
+        return this;
     }
-    //Other question is anything that leads to exit is a exitLoop
     else
     {
-        if (current->fallThrough == postExitLoop)
+        //Otherwise, info contains us
+        if (info->contains (getEntryBlock ()) == true)
         {
-            //postExit is null for infinite loops
-            if (postExitLoop != 0)
-            {
-                assert (current->taken == 0);
-                addExitLoop (current);
-                //Post is not considered in the loop
-                isInLoop = false;
-            }
+            return info->add (this);
+        }
+        else
+        {
+            // it is sibling
+            info->depth = getDepth ();
+            info->parent = this->getParent ();
+            info->siblingNext = this;
+            this->siblingPrev = info;
+            return info;
         }
     }
+}
 
-    //Add it if it is in the loop
-    if (isInLoop == true)
-    {
-        //Look at children: taken first, then fallThrough
-        fillBasicBlockVector (current->taken);
-        fillBasicBlockVector (current->fallThrough);
-    }
-    else
+/**
+ * @brief Utility function to check whether the current loop corresponds to specified entry
+ * @param cUnit the CompilationUnit
+ * @param info loop information
+ * @param data std::pair where the first is key bb, the second is a place for result
+ * @return false is specified bb is an entry of this loop
+ */
+static bool getLoopInformationByEntryHelper (LoopInformation *info, void *data)
+{
+    std::pair<BasicBlock*, LoopInformation*> *pair =
+        static_cast<std::pair<BasicBlock*, LoopInformation*> *>(data);
+
+    if (info->getEntryBlock () == pair->first)
     {
-        //Remove it from the bitvector, we do it this way to make the system use basicBlocks as a visited BV at the same time
-        dvmClearBit (basicBlocks, current->id);
+        pair->second = info;
+        return false;
     }
+    return true;
 }
 
-void LoopInformation::fillLoopInformation (void)
+/**
+ * Return the LoopInformation that has entry as the entry BasicBlock
+ */
+LoopInformation *LoopInformation::getLoopInformationByEntry (const BasicBlock *entry)
 {
-    //Clear certain vectors
-    if (basicBlocks == 0)
+    // Fast check
+    if (this->entry == entry)
     {
-        basicBlocks = dvmCompilerAllocBitVector (1, true);
+        return this;
     }
 
-    dvmClearAllBits (basicBlocks);
+    // Iterate over all loops
+    std::pair<const BasicBlock*, LoopInformation*> pair(entry, 0);
 
-    if (backward != 0)
+    if (iterate (getLoopInformationByEntryHelper, &pair) == false)
     {
-        dvmClearAllBits (backward);
+        return pair.second;
     }
 
-    if (exitLoop != 0)
-    {
-        dvmClearAllBits (exitLoop);
-    }
+    return 0;
+}
 
-    //Start at the header
-    fillBasicBlockVector (entry);
+BitVector *LoopInformation::getPostExitLoops (const CompilationUnit *cUnit)
+{
+    BitVector *postExitLoop = dvmCompilerAllocBitVector (1, true);
+    dvmClearAllBits (postExitLoop);
 
-    //Call for the inner too
-    //Go through loop children
-    GrowableListIterator iterator;
-    dvmGrowableListIteratorInit(&nested, &iterator);
-    while (true)
+    // Iterate over all exit loops
+    BitVectorIterator bvIterator;
+    dvmBitVectorIteratorInit(exitLoop, &bvIterator);
+    BasicBlock *bb;
+    while ((bb = getNextBasicBlockViaBitVector (bvIterator, cUnit)) != 0)
     {
-        //Get next
-        LoopInformation *inner = (LoopInformation*) dvmGrowableListIteratorNext(&iterator);
+        assert (bb->taken == 0);
+        assert (bb->fallThrough != 0);
 
-        //Done ?
-        if (inner == 0)
+        if (bb->fallThrough != 0)
         {
-            break;
+            dvmSetBit (postExitLoop, bb->fallThrough->id);
         }
-
-        //Update parentage
-        inner->setParent (this);
-        inner->setDepth (getDepth () + 1);
-
-        //Fill information
-        inner->fillLoopInformation ();
     }
+    return postExitLoop;
 }
 
 bool LoopInformation::contains (const BasicBlock *bb) const
@@ -394,8 +557,10 @@ bool LoopInformation::contains (const BasicBlock *bb) const
     return dvmIsBitSet (basicBlocks, bb->id);
 }
 
-void LoopInformation::dumpInformation (unsigned int tab)
+static bool dumpInformationHelper (const CompilationUnit *cUnit, LoopInformation *info, void *data)
 {
+    unsigned int tab = *(static_cast<int*>(data)) + info->getDepth ();
+
     char buffer[256];
     char tabs[10];
     unsigned int i;
@@ -409,132 +574,89 @@ void LoopInformation::dumpInformation (unsigned int tab)
     tabs[i] = '\0';
 
     //Print out base information
-    snprintf (buffer, sizeof (buffer), "%sThis: %p", tabs, this);
+    snprintf (buffer, sizeof (buffer), "%sThis: %p", tabs, info);
     ALOGD ("%s", buffer);
-    snprintf (buffer, sizeof (buffer), "%sDepth: %d", tabs, depth);
+    snprintf (buffer, sizeof (buffer), "%sDepth: %d", tabs, info->getDepth ());
     ALOGD ("%s", buffer);
-    snprintf (buffer, sizeof (buffer), "%sEntry: %d", tabs, entry?entry->id:-1);
+    snprintf (buffer, sizeof (buffer), "%sEntry: %d", tabs, info->getEntryBlock () != 0 ? info->getEntryBlock ()->id : -1);
     ALOGD ("%s", buffer);
-    snprintf (buffer, sizeof (buffer), "%sExit: %d", tabs, postExitLoop?postExitLoop->id:-1);
+    snprintf (buffer, sizeof (buffer), "%sPreHeader: %d", tabs, info->getPreHeader () != 0 ? info->getPreHeader ()->id : -1);
     ALOGD ("%s", buffer);
 
-    //Print the BitVector
-    dvmDumpBitVector ("BasicBlocks: ", basicBlocks, true);
+    snprintf (buffer, sizeof (buffer), "%sPost Exit: ", tabs);
+    dvmDumpBitVector (buffer, info->getPostExitLoops (cUnit), true);
 
-    //Go through loop children
-    GrowableListIterator iterator;
-    dvmGrowableListIteratorInit(&nested, &iterator);
-    while (true)
-    {
-        //Get next
-        LoopInformation *inner = (LoopInformation*) dvmGrowableListIteratorNext(&iterator);
+    //Print the backward chaining blocks
+    snprintf (buffer, sizeof (buffer), "%sPost Loop: ", tabs);
+    dvmDumpBitVector (buffer, info->getExitLoops (), true);
 
-        //Done ?
-        if (inner == 0)
-        {
-            break;
-        }
+    //Print the backward chaining blocks
+    snprintf (buffer, sizeof (buffer), "%sBackward: ", tabs);
+    dvmDumpBitVector (buffer, info->getBackwardBranches (), true);
 
-        //Print it out with an extra tab
-        inner->dumpInformation (tab + 1);
-    }
+    //Print the BitVector
+    snprintf (buffer, sizeof (buffer), "%sBasicBlocks: ", tabs);
+    dvmDumpBitVector (buffer, info->getBasicBlocks (), true);
+
+    return true;
+}
+
+void LoopInformation::dumpInformation (const CompilationUnit *cUnit, unsigned int tab)
+{
+    iterateWithConst (cUnit, dumpInformationHelper, &tab);
 }
 
-void LoopInformation::dumpInformationDotFormat (FILE *file)
+static bool dumpInformationDotFormatHelper (const CompilationUnit *cUnit, LoopInformation *info, void *data)
 {
+    FILE *file = static_cast<FILE*>(data);
+
     char buffer[256];
 
     //Create a node
-    unsigned long uid = (unsigned long) (this);
+    unsigned long uid = (unsigned long) (info);
 
     fprintf (file, "%lu [shape=record, label =\"{ \\\n", uid);
 
     //Print out base information
     snprintf (buffer, sizeof (buffer), "{Loop:} | \\\n");
     fprintf (file, "%s", buffer);
-    snprintf (buffer, sizeof (buffer), "{Depth: %d} | \\\n", depth);
-    fprintf (file, "%s", buffer);
-    snprintf (buffer, sizeof (buffer), "{Entry: %d} | \\\n", entry?entry->id:-1);
+    snprintf (buffer, sizeof (buffer), "{Depth: %d} | \\\n", info->getDepth ());
     fprintf (file, "%s", buffer);
-    snprintf (buffer, sizeof (buffer), "{Post Exit: %d} | \\\n", postExitLoop?postExitLoop->id:-1);
+    snprintf (buffer, sizeof (buffer), "{Entry: %d} | \\\n", info->getEntryBlock () != 0 ? info->getEntryBlock ()->id : -1);
     fprintf (file, "%s", buffer);
-    snprintf (buffer, sizeof (buffer), "{PreHeader: %d} | \\\n", preHeader?preHeader->id:-1);
+    snprintf (buffer, sizeof (buffer), "{PreHeader: %d} | \\\n", info->getPreHeader () ? info->getPreHeader ()->id : -1);
     fprintf (file, "%s", buffer);
 
+    dvmDumpBitVectorDotFormat (file, "Post Exit: ", info->getPostExitLoops (cUnit), true);
+
     //Print the backward chaining blocks
-    dvmDumpBitVectorDotFormat (file, "Post Loop: ", exitLoop, true);
+    dvmDumpBitVectorDotFormat (file, "Post Loop: ", info->getExitLoops (), true);
 
     //Print the backward chaining blocks
-    dvmDumpBitVectorDotFormat (file, "Backward: ", backward, true);
+    dvmDumpBitVectorDotFormat (file, "Backward: ", info->getBackwardBranches (), true);
 
     //Print the BasicBlocks BitVector
-    dvmDumpBitVectorDotFormat (file, "BasicBlocks: ", basicBlocks, true, true);
+    dvmDumpBitVectorDotFormat (file, "BasicBlocks: ", info->getBasicBlocks (), true, true);
 
     //End the block
     fprintf (file, "}\"];\n\n");
 
-    //Go through loop children
-    GrowableListIterator iterator;
-    dvmGrowableListIteratorInit(&nested, &iterator);
-    while (true)
+    //Now make the link
+    unsigned long childUID = (unsigned long) (info->getNested ());
+    if (childUID != 0)
     {
-        //Get next
-        LoopInformation *inner = (LoopInformation*) dvmGrowableListIteratorNext(&iterator);
-
-        //Done ?
-        if (inner == 0)
-        {
-            break;
-        }
-
-        //Print it out with an extra tab
-        inner->dumpInformationDotFormat (file);
-
-        //Now make the link
-        unsigned long childUID = (unsigned long) (inner);
-
         fprintf (file, "%lu:s -> %lu:n\n", uid, childUID);
     }
-}
-
-void LoopInformation::addBackwardBlock (BasicBlock *bb)
-{
-    //Paranoid
-    assert (bb != 0);
-
-    //Do we have to initialize it ?
-    if (backward == 0)
-    {
-        backward = dvmCompilerAllocBitVector (1, true);
-    }
-
-    //Set it
-    dvmSetBit (backward, bb->id);
-}
-
-LoopInformation *LoopInformation::getNested (unsigned int i) const
-{
-    //Error checking
-    if (i >= dvmGrowableListSize(&nested))
-    {
-        return 0;
-    }
 
-    return (LoopInformation *) dvmGrowableListGetElement (&nested, i);
+    return true;
 }
 
-void LoopInformation::collectAllNested (GrowableList *container)
+void LoopInformation::dumpInformationDotFormat (const CompilationUnit *cUnit, FILE *file)
 {
-    unsigned int count = getNestedNbr ();
-    for (unsigned int i = 0; i < count; i++)
-    {
-        LoopInformation *info = getNested (i);
-        dvmInsertGrowableList (container, (intptr_t)info);
-        info->collectAllNested (container);
-    }
+    iterateWithConst (cUnit, dumpInformationDotFormatHelper, file);
 }
 
-bool LoopInformation::executedPerIteration (CompilationUnit *cUnit, const MIR *mir) const
+bool LoopInformation::executedPerIteration (const CompilationUnit *cUnit, MIR *mir) const
 {
     //Paranoid
     assert (mir != 0);
@@ -550,27 +672,10 @@ bool LoopInformation::executedPerIteration (CompilationUnit *cUnit, const MIR *m
 
     //Go through the backward chaining cells
     BitVectorIterator bvIterator;
-
-    //Get predecessors
     dvmBitVectorIteratorInit (backward, &bvIterator);
-    while (true) {
-        //Get the next iterator
-        int blockIdx = dvmBitVectorIteratorNext(&bvIterator);
-
-        //If it is finished, exit
-        if (blockIdx == -1)
-        {
-            break;
-        }
-
-        BasicBlock *bwcc = (BasicBlock*) (dvmGrowableListGetElement(&cUnit->blockList, blockIdx));
-
-        //Paranoid
-        if (bwcc == 0)
-        {
-            continue;
-        }
-
+    for (BasicBlock *bwcc = getNextBasicBlockViaBitVector (bvIterator, cUnit); bwcc != 0;
+                     bwcc = getNextBasicBlockViaBitVector (bvIterator, cUnit))
+    {
         //To prove that the mir is executed per iteration, it's block must dominate each backward chaining cell
         if (dvmIsBitSet (bwcc->dominators, current->id) == false)
         {
@@ -615,31 +720,14 @@ bool LoopInformation::isAnInductionVariable (CompilationUnit *cUnit, unsigned in
 MIR *LoopInformation::getPhiInstruction (CompilationUnit *cUnit, unsigned int vr) const
 {
     //Get the BasicBlock vector for this loop
-    BitVector *blocks = const_cast<BitVector *> (getBasicBlocks ());
+    BitVector *blocks = getBasicBlocks ();
 
     //Iterate through them
     BitVectorIterator bvIterator;
-
     dvmBitVectorIteratorInit (blocks, &bvIterator);
-    while (true)
+    for (BasicBlock *bb = getNextBasicBlockViaBitVector (bvIterator, cUnit); bb != 0;
+                     bb = getNextBasicBlockViaBitVector (bvIterator, cUnit))
     {
-        //Get block index
-        int blockIdx = dvmBitVectorIteratorNext (&bvIterator);
-
-        //If done, bail
-        if (blockIdx == -1)
-        {
-            break;
-        }
-
-        BasicBlock *bb = (BasicBlock*) (dvmGrowableListGetElement(&cUnit->blockList, blockIdx));
-
-        //Paranoid
-        if (bb == 0)
-        {
-            break;
-        }
-
         //Go through its instructions
         for (MIR *mir = bb->firstMIRInsn; mir != 0; mir = mir->next)
         {
@@ -772,19 +860,9 @@ static bool containsUnsupportedOpcodes (const CompilationUnit *cUnit, BitVector
     return false;
 }
 
-//The following gate accepts only very simple loops: one basicblock, no nesting
-bool dvmCompilerVerySimpleLoopGate (const CompilationUnit *cUnit, const Pass *curPass)
+bool dvmCompilerVerySimpleLoopGateHelper (const CompilationUnit *cUnit, LoopInformation *info, void *data)
 {
-    //Only do something if we have the loop information
-    LoopInformation *info = cUnit->loopInformation;
-
-    if (info == 0)
-    {
-        return false;
-    }
-
-    //Reject any nested loops
-    if (info->getNestedNbr () != 0)
+    if (info->getNested () != 0)
     {
         return false;
     }
@@ -803,10 +881,26 @@ bool dvmCompilerVerySimpleLoopGate (const CompilationUnit *cUnit, const Pass *cu
         return false;
     }
 
+    return true;
+}
+
+//The following gate accepts only very simple loops: one basicblock, no nesting
+bool dvmCompilerVerySimpleLoopGate (const CompilationUnit *cUnit, const Pass *curPass)
+{
+    //Only do something if we have the loop information
+    LoopInformation *info = cUnit->loopInformation;
+
     //Unused parameter
     (void) curPass;
 
-    return true;
+    if (info != 0)
+    {
+        if (info->iterateWithConst (cUnit, dvmCompilerVerySimpleLoopGateHelper) == true)
+        {
+            return true;
+        }
+    }
+    return false;
 }
 
 bool LoopInformation::isInvariant (unsigned int ssa) const
@@ -835,7 +929,7 @@ bool LoopInformation::isBasicBlockInLoop (const BasicBlock *bb) const
 bool LoopInformation::canThrow (const CompilationUnit *cUnit) const
 {
     //Get the BasicBlock vector for this loop
-    BitVector *blocks = const_cast<BitVector *> (getBasicBlocks ());
+    BitVector *blocks = getBasicBlocks ();
 
     //Iterate through them
     BitVectorIterator bvIterator;
@@ -889,7 +983,7 @@ bool LoopInformation::canThrow (const CompilationUnit *cUnit) const
 bool LoopInformation::hasInvoke (const CompilationUnit *cUnit) const
 {
     //Get the BasicBlock vector for this loop
-    BitVector *blocks = const_cast<BitVector *> (getBasicBlocks ());
+    BitVector *blocks = getBasicBlocks ();
 
     //Iterate through them
     BitVectorIterator bvIterator;
@@ -982,13 +1076,13 @@ void LoopInformation::sinkInstructions (CompilationUnit *cUnit, std::vector<MIR
     //We need to sink to the exit loops and the backward chaining cell
 
     //First, handle the exit loops
-    BitVector *bv = const_cast<BitVector *> (getExitLoops ());
+    BitVector *bv = getExitLoops ();
 
     //Add the instructions to the basic blocks defined by the vector
     dvmCompilerPrependInstructionsToBasicBlocks (cUnit, bv, insns);
 
     //Now get the backward chaining cells
-    bv = const_cast<BitVector *> (getBackwardBranches ());
+    bv = getBackwardBranches ();
 
     //Add the instructions to the basic blocks defined by the vector
     dvmCompilerPrependInstructionsToBasicBlocks (cUnit, bv, insns);
@@ -1101,7 +1195,7 @@ void LoopInformation::handleBWCC (std::map<BasicBlock*, BasicBlock *> &associati
 void LoopInformation::peelLoopHelper (CompilationUnit *cUnit)
 {
     //Get the BasicBlocks
-    const BitVector *blocks = getBasicBlocks ();
+    BitVector *blocks = getBasicBlocks ();
 
     //Go through each block
     BitVectorIterator bvIterator;
@@ -1215,7 +1309,7 @@ unsigned int LoopInformation::countInstructions (CompilationUnit *cUnit)
     unsigned int res = 0;
 
     //Get the BasicBlocks
-    const BitVector *blocks = getBasicBlocks ();
+    BitVector *blocks = getBasicBlocks ();
 
     //Iterate through the basic blocks
     BitVectorIterator bvIterator;
@@ -1251,9 +1345,7 @@ bool LoopInformation::peelLoop (CompilationUnit *cUnit)
     }
 
     //Only peel if innermost
-    unsigned int nbr = getNestedNbr ();
-
-    if (nbr != 0)
+    if (getNested () != 0)
     {
         return false;
     }
@@ -1276,20 +1368,18 @@ bool LoopInformation::peelLoop (CompilationUnit *cUnit)
 
 }
 
-//Invalidate all the peeling
-void LoopInformation::invalidatePeeling (void)
+static bool invalidatePeelingHelper (LoopInformation *info, void *data)
 {
-    if (peeledBlocks != 0)
+    BitVector *bv = info->getPeeledBlocks ();
+    if (bv != 0)
     {
-        dvmClearAllBits (peeledBlocks);
+        dvmClearAllBits (bv);
     }
+    return true;
+}
 
-    //Invalidate all the nested blocks also
-    unsigned int nbr = getNestedNbr ();
-
-    for (unsigned int i = 0 ; i < nbr ; i++)
-    {
-        LoopInformation *nested = getNested (i);
-        nested->invalidatePeeling ();
-    }
+//Invalidate all the peeling
+void LoopInformation::invalidatePeeling (void)
+{
+    iterate (invalidatePeelingHelper);
 }
diff --git a/vm/compiler/LoopInformation.h b/vm/compiler/LoopInformation.h
index 0d10cbe..0f1767b 100644
--- a/vm/compiler/LoopInformation.h
+++ b/vm/compiler/LoopInformation.h
@@ -32,12 +32,18 @@ class Pass;
 class LoopInformation
 {
     protected:
-        /** @brief Nested Loops */
-        GrowableList nested;
-
         /** @brief Parent loop, can be 0 */
         LoopInformation *parent;
 
+        /** @brief next sibling loop, can be 0 */
+        LoopInformation *siblingNext;
+
+        /** @brief previous sibling loop, can be 0 */
+        LoopInformation *siblingPrev;
+
+        /** @brief nested loop, can be 0 */
+        LoopInformation *nested;
+
         /** @brief Depth of the current loop */
         unsigned int depth;
 
@@ -56,9 +62,6 @@ class LoopInformation
         /** @brief Post loop basic block */
         BitVector *exitLoop;
 
-        /** @brief Exit Block */
-        BasicBlock *postExitLoop;
-
         /** @brief Peeled blocks */
         BitVector *peeledBlocks;
 
@@ -111,7 +114,21 @@ class LoopInformation
          */
         unsigned int countInstructions (CompilationUnit *cUnit);
 
+        /**
+         * @brief sets depth for this and nested loops
+         * @param depth depth to set
+         */
+        void setDepth (int depth);
+
     public:
+        /**
+         * @brief Build loop information for the trace
+         * @param cUnit the CompilationUnit
+         * @param current the previous loop information to re-use data structures, can be NULL
+         * @return built loop information or NULL if no loops
+         */
+        static LoopInformation* getLoopInformation (CompilationUnit *cUnit, LoopInformation *current);
+
         /** @brief Constructor */
         LoopInformation (void);
 
@@ -124,16 +141,28 @@ class LoopInformation
         void init (void);
 
         /**
-         * @brief Set Exit Loop Block
-         * @param bb the exit block
+         * @brief Get parent loop
+         * @return the parent loop
          */
-        void setPostExitBlock (BasicBlock *bb) {postExitLoop = bb;}
+        LoopInformation *getParent (void) const {return parent;}
 
         /**
-         * @brief Add a backward chaining cell
-         * @param bb the backward chaining cell block
+         * @brief Get next sibling loop
+         * @return the next sibling loop
          */
-        void addBackwardBlock (BasicBlock *bb);
+        LoopInformation *getNextSibling (void) const {return siblingNext;}
+
+        /**
+         * @brief Get previous sibling loop
+         * @return the previous sibling loop
+         */
+        LoopInformation *getPrevSibling (void) const {return siblingPrev;};
+
+        /**
+         * @brief Get nested loop
+         * @return the nested loop
+         */
+        LoopInformation *getNested (void) const {return nested;};
 
         /**
          * @brief Get entry block
@@ -148,53 +177,23 @@ class LoopInformation
         void setEntryBlock (BasicBlock *bb) {entry = bb;}
 
         /**
-         * @brief Set preheader block
-         * @param bb the preheader block
-         */
-        void setPreHeader (BasicBlock *bb) {preHeader = bb;}
-
-        /**
          * @brief Get preHeader block
          * @return the preHeader block
          */
         BasicBlock *getPreHeader (void) const {return preHeader;}
 
         /**
-         * @brief Set depth
-         * @param depth new depth value
-         */
-        void setDepth (int depth) {this->depth = depth;}
-
-        /**
-         * @brief Set Parent
-         * @param p new parent
-         */
-        void setParent (LoopInformation *p) {parent = p;}
-
-        /**
          * @brief Get Depth
          * @return the depth
          */
         int getDepth (void) const {return depth;}
 
         /**
-         * @brief Nest loop information
+         * @brief Add a loop information within nest correctness
          * @param info another LoopInformation to next
          * @return the overall LoopInformation
          */
-        LoopInformation *nest (LoopInformation *info);
-
-        /**
-         * @brief Update nest of loop information
-         * @return the overall LoopInformation
-         */
-        LoopInformation *nestUpdate (void);
-
-        /**
-         * @brief Add a loop information without nest correctness
-         * @param info another LoopInformation to next
-         */
-        void add (LoopInformation *info);
+        LoopInformation * add (LoopInformation *info);
 
         /**
          * @brief Get a LoopInformation, search in the nested and use entry as the ID
@@ -204,69 +203,50 @@ class LoopInformation
         LoopInformation *getLoopInformationByEntry (const BasicBlock *entry);
 
         /**
-         * @brief Add an exit loop BasicBlock
-         * @param bb the new exit loop BasicBlock
-         */
-        void addExitLoop (BasicBlock *bb);
-
-        /**
-         * @brief Fill the loop information details
-         */
-        void fillLoopInformation (void);
-
-        /**
          * @brief Does the Loop contain a given BasicBlock ?
          */
         bool contains (const BasicBlock *bb) const;
 
         /**
          * @brief Dump loop information
+         * @param cUnit Compilation Unit
          * @param tab number of tabs before outputting anything
          */
-        void dumpInformation (unsigned int tab = 0);
+        void dumpInformation (const CompilationUnit *cUnit, unsigned int tab = 0);
 
         /**
          * @brief Dump loop information
+         * @param cUnit Compilation Unit
          * @param file file in which to dump the information
          */
-        void dumpInformationDotFormat (FILE *file);
-
-        /**
-         * @brief Get all nested LoopInformation including children
-         * @param container to put data
-         */
-        void collectAllNested (GrowableList *container);
-
-        /**
-         * @brief Get a nested LoopInformation
-         * @param i the index
-         * @return the nested LoopInformation at index i
-         */
-        LoopInformation *getNested (unsigned int i) const;
+        void dumpInformationDotFormat (const CompilationUnit *cUnit, FILE *file);
 
         /**
-         * @brief Get the number of nested loops
-         * @return the number of nested loops
+         * @brief Get the exit loop BasicBlocks BitVector
+         * @return the exit loop BasicBlocks BitVector
          */
-        unsigned int getNestedNbr (void) const {return dvmGrowableListSize(&nested);}
+        BitVector *getExitLoops (void) const {return exitLoop;}
 
         /**
-         * @brief Get the exit loop BasicBlocks BitVector
-         * @return the exit loop BasicBlocks BitVector
+         * @brief Get the post exit loop BasicBlocks BitVector
+         * @details Be careful using this function before loop formation
+         *     It will return incorrect value and assert library may be aborted.
+         * @param cUnit compilation context
+         * @return the post exit loop BasicBlocks BitVector
          */
-        const BitVector *getExitLoops (void) const {return exitLoop;}
+        BitVector *getPostExitLoops (const CompilationUnit *cUnit);
 
         /**
          * @brief Get the BasicBlocks of the loop
          * @return the BitVector that represents the BasicBlocks of the loop
          */
-        const BitVector *getBasicBlocks (void) const {return basicBlocks;}
+        BitVector *getBasicBlocks (void) const {return basicBlocks;}
 
         /**
          * @brief Get the Backward branch BasicBlocks of the loop
          * @return the BitVector that represents the Backward branches
          */
-        const BitVector *getBackwardBranches (void) const {return backward;}
+        BitVector *getBackwardBranches (void) const {return backward;}
 
         /**
          * @brief Get the next scratch register
@@ -292,7 +272,7 @@ class LoopInformation
           * @param mir the MIR instruction
           * @return whether mir is executed every iteration
           */
-         bool executedPerIteration (CompilationUnit *cUnit, const MIR *mir) const;
+         bool executedPerIteration (const CompilationUnit *cUnit, MIR *mir) const;
 
          /**
           * @brief Is a VR an induction variable for the loop?
@@ -427,13 +407,38 @@ class LoopInformation
           * @brief Get the peeled blocks of the loop
           * @return the BitVector that represents the peeled BasicBlocks of the loop
           */
-         const BitVector *getPeeledBlocks (void) const {return peeledBlocks;}
+         BitVector *getPeeledBlocks (void) const {return peeledBlocks;}
 
          /**
           * @brief Invalidate the peeled blocks of this and nested loops
           */
          void invalidatePeeling (void);
 
+         /**
+          * @brief helper function to iterate over loop information
+          * @param cUnit the CompilationUnit
+          * @param func worker function
+          * @param data user data passed to worker
+          * @return false to stop iteration
+          */
+         bool iterate (CompilationUnit *cUnit, bool (*func) (CompilationUnit *cUnit, LoopInformation *info, void *data), void *data = 0);
+
+         /**
+          * @brief helper function to iterate over loop information with const cUnit
+          * @param cUnit the CompilationUnit
+          * @param func worker function
+          * @param data user data passed to worker
+          * @return false to stop iteration
+          */
+         bool iterateWithConst (const CompilationUnit *cUnit, bool (*func) (const CompilationUnit *cUnit, LoopInformation *info, void *data), void *data = 0);
+
+         /**
+          * @brief helper function to iterate over loop information
+          * @param func worker function
+          * @param data user data passed to worker
+          * @return false to stop iteration
+          */
+         bool iterate (bool (*func) (LoopInformation *info, void *data), void *data = 0);
 };
 
 /**
diff --git a/vm/compiler/LoopOpt.cpp b/vm/compiler/LoopOpt.cpp
index 763255b..4b190ed 100644
--- a/vm/compiler/LoopOpt.cpp
+++ b/vm/compiler/LoopOpt.cpp
@@ -50,15 +50,16 @@ static void clearPHIInformation (CompilationUnit *cUnit);
     };
 
 START_PASSES
+    //Check if the loops are like we want right now (nested or not, branches or not)
+    NEW_PASS ("Reject_Loops", kAllNodes, 0, dvmCompilerCheckLoops, 0, 0, 0, 0, 0),
     //This loop formation is used when the new loop filtering is active
-    NEW_PASS ("Form_Loop", kAllNodesAndNew, 0, dvmCompilerTraceIsLoopNewSystem,
-                0, dvmCompilerTestLoop, dvmCompilerFormLoop, 0, kOptimizationBasicBlockChange | kLoopStructureChange),
-    //Check if the formed loops are like we want right now (nested or not, branches or not)
-    NEW_PASS ("Reject_Loops", kAllNodes, 0, dvmCompilerCheckLoops,
-                            0, 0, 0, 0, 0),
+    NEW_PASS ("Form_Loop", kAllNodes, 0, dvmCompilerTraceIsLoopNewSystem,
+                dvmCompilerFormLoop, 0, 0, 0, kOptimizationBasicBlockChange | kLoopStructureChange),
+    NEW_PASS ("Test_Loop", kAllNodes, 0, dvmCompilerTraceIsLoopNewSystem,
+                dvmCompilerTestLoop, 0, 0, 0, 0),
     //This loop formation is used when the old loop filtering is active
     NEW_PASS ("Old_Loop_Formation", kAllNodesAndNew, 0, dvmCompilerTraceIsLoopOldSystem,
-                dvmCompilerFormOldLoop, 0, 0, 0, kOptimizationBasicBlockChange),
+                dvmCompilerFormOldLoop, 0, 0, 0, kOptimizationBasicBlockChange | kLoopStructureChange),
     NEW_PASS ("Check_Removal", kAllNodes, 0, 0,
                 dvmCompilerStartCheckRemoval, dvmCompilerEndCheckRemoval, dvmCompilerCheckRemoval, 0, kOptimizationDefUsesChange),
     //The 2addr pass should come before any pass that need register rewriting.
@@ -68,7 +69,7 @@ START_PASSES
     //For the moment, no pass will create new blocks, etc. so this is fine up here
     //Otherwise, we might want to duplicate the merge or make the gate for memory aliasing smarter
     NEW_PASS ("Merge_Blocks", kAllNodes, 0, 0,
-                0, 0, dvmCompilerMergeBasicBlocks, 0, kOptimizationBasicBlockChange),
+                0, 0, dvmCompilerMergeBasicBlocks, 0, kOptimizationBasicBlockChange | kLoopStructureChange),
     NEW_PASS ("Memory_Aliasing", kAllNodes, 0, dvmCompilerVerySimpleLoopGate,
               0, 0, dvmCompilerMemoryAliasing, 0, 0),
     NEW_PASS ("Local_Value_Numbering", kAllNodes, 0, dvmCompilerVerySimpleLoopGate,
@@ -90,11 +91,11 @@ START_PASSES
     NEW_PASS ("Registerization_ME", kAllNodes, 0, dvmCompilerRegisterizeGate,
                 0, dvmCompilerRegisterize, 0, 0, 0),
     NEW_PASS ("Fix_Chaining_Cells", kAllNodesAndNew, 0, 0,
-                0, 0, dvmCompilerFixChainingCellPredecessors, 0, kOptimizationBasicBlockChange),
+                0, 0, dvmCompilerFixChainingCellPredecessors, 0, kOptimizationBasicBlockChange | kLoopStructureChange),
     NEW_PASS ("Insert_Prebackward_Block", kAllNodesAndNew, 0, 0,
-                    0, dvmCompilerInsertPreBackward, 0, 0, kOptimizationBasicBlockChange),
+                    0, dvmCompilerInsertPreBackward, 0, 0, kOptimizationBasicBlockChange | kLoopStructureChange),
     NEW_PASS ("Reorder_Blocks", kBreadthFirstTraversal, 0, 0,
-                dvmCompilerReorder, 0, 0, 0, kOptimizationBasicBlockChange),
+                dvmCompilerReorder, 0, 0, 0, kOptimizationBasicBlockChange | kLoopStructureChange),
 
     /* Last element must have and be the only one to have a NULL name, it's our ending check */
     NEW_PASS ("",       /** Pass name */
@@ -142,7 +143,7 @@ void dvmCompilerBuildPassList (void)
     }
 }
 
-bool dvmCompilerCalculateBasicBlockInformation (CompilationUnit *cUnit, bool filter)
+bool dvmCompilerCalculateBasicBlockInformation (CompilationUnit *cUnit, bool filter, bool buildLoopInfo)
 {
     //Clear SSA information
     clearPHIInformation (cUnit);
@@ -160,9 +161,9 @@ bool dvmCompilerCalculateBasicBlockInformation (CompilationUnit *cUnit, bool fil
         if (res == true)
         {
             //Then call loop information fill
-            if (cUnit->loopInformation != 0)
+            if (buildLoopInfo == true)
             {
-                cUnit->loopInformation->fillLoopInformation ();
+                cUnit->loopInformation = LoopInformation::getLoopInformation (cUnit, cUnit->loopInformation);
             }
 
             //Clear the constants
@@ -201,24 +202,9 @@ void handlePassFlag (CompilationUnit *cUnit, Pass *pass)
     if ((pass->getFlag (kOptimizationBasicBlockChange) == true) ||
             (pass->getFlag (kOptimizationDefUsesChange) == true))
     {
-        dvmCompilerCalculateBasicBlockInformation (cUnit, false);
+        bool buildLoopInfo = pass->getFlag (kLoopStructureChange) == true;
+        dvmCompilerCalculateBasicBlockInformation (cUnit, false, buildLoopInfo);
     }
-    if (pass->getFlag (kLoopStructureChange) == true)
-    {
-        if (cUnit->loopInformation != 0)
-        {
-            LoopInformation *top = cUnit->loopInformation->nestUpdate ();
-            if (top == 0)
-            {
-                cUnit->quitLoopMode = true;
-            }
-            else
-            {
-                cUnit->loopInformation = top;
-            }
-        }
-    }
-
 }
 
  /**
@@ -425,16 +411,45 @@ void dvmCompilerPrintIgnorePasses (void)
     }
 }
 
+
+/**
+ * @brief Helper function to dvmCompilerCheckLoops to check number of exits for each loop
+ * @param info loop information to check
+ * @param data required by interface, not used.
+ */
+static bool exitLoopHelper (LoopInformation *info, void *data)
+{
+    return dvmCountSetBits (info->getExitLoops ()) <= 1;
+}
+
 bool dvmCompilerCheckLoops (const CompilationUnit *cUnit, const Pass *curPass)
 {
-    LoopInformation *loopInfo = cUnit->loopInformation;
+    // Build loop information
+    LoopInformation *loopInfo = LoopInformation::getLoopInformation (const_cast<CompilationUnit *>(cUnit), 0);
+    const_cast<CompilationUnit *>(cUnit)->loopInformation = loopInfo;
 
     if (loopInfo != 0)
     {
+        // we are rejecting sibling loops at top level
+        if (loopInfo->getNextSibling () !=0)
+        {
+            const_cast<CompilationUnit *>(cUnit)->quitLoopMode = true;
+            return false;
+        }
+
+        // Check that we have no more than one loop output
+        // Note we are working before loop formation, so exit block is real one
+        if (loopInfo->iterate (exitLoopHelper) == false)
+        {
+            const_cast<CompilationUnit *>(cUnit)->quitLoopMode = true;
+            return false;
+        }
+
         //If it is nested and option says no, bail
         if (gDvmJit.nestedLoops == false)
         {
-            if (loopInfo->getNestedNbr () != 0)
+            // We do not have sibling so it is enough to check first
+            if (loopInfo->getNested () != 0)
             {
                 const_cast<CompilationUnit *>(cUnit)->quitLoopMode = true;
                 return false;
@@ -477,26 +492,13 @@ bool dvmCompilerCheckLoops (const CompilationUnit *cUnit, const Pass *curPass)
                 }
 
                 //Now go through each BB and see if it dominates backward
-                BitVector *blocks = const_cast<BitVector*> (loopInfo->getBasicBlocks ());
+                BitVector *blocks = loopInfo->getBasicBlocks ();
 
                 BitVectorIterator bvIterator;
-
                 dvmBitVectorIteratorInit(blocks, &bvIterator);
-                while (true) {
-                    int blockIdx = dvmBitVectorIteratorNext(&bvIterator);
-                    //If done, bail
-                    if (blockIdx == -1)
-                    {
-                        break;
-                    }
-
-                    BasicBlock *bb = (BasicBlock *) dvmGrowableListGetElement(&cUnit->blockList, blockIdx);
-
-                    if (bb == 0)
-                    {
-                        break;
-                    }
-
+                for (BasicBlock *bb = getNextBasicBlockViaBitVector(bvIterator, cUnit); bb != 0;
+                                 bb = getNextBasicBlockViaBitVector(bvIterator, cUnit))
+                {
                     if (bb == backward)
                     {
                         continue;
diff --git a/vm/compiler/LoopOpt.h b/vm/compiler/LoopOpt.h
index 045b747..4e2d5ad 100644
--- a/vm/compiler/LoopOpt.h
+++ b/vm/compiler/LoopOpt.h
@@ -65,9 +65,10 @@ bool dvmCompilerTraceIsLoopOldSystem (const CompilationUnit *cUnit, const Pass *
  * @brief Calculate the BasicBlock information
  * @param cUnit the CompilationUnit
  * @param filter do we wish to filter the loop? (default: true)
+ * @param buildLoopInfo do we wish to build loop information (default: false)
  * @return whether the calculation succeeded or not
  */
-bool dvmCompilerCalculateBasicBlockInformation (CompilationUnit *cUnit, bool filter = true);
+bool dvmCompilerCalculateBasicBlockInformation (CompilationUnit *cUnit, bool filter = true, bool buildLoopInfo = false);
 
 /**
  * @brief Print the pass names
@@ -101,7 +102,7 @@ bool dvmCompilerDDDOGate (const CompilationUnit *cUnit, const Pass *curPass);
  * @param curPass the Pass
  * @return Whether to continue as a loop or bail
  */
-bool dvmCompilerCheckLoops ( const CompilationUnit *cUnit, const Pass *curPass);
+bool dvmCompilerCheckLoops (const CompilationUnit *cUnit, const Pass *curPass);
 
 /**
  * @brief Remove an optimization Pass
diff --git a/vm/compiler/RegisterizationME.cpp b/vm/compiler/RegisterizationME.cpp
index 1f95b30..76ceb7f 100644
--- a/vm/compiler/RegisterizationME.cpp
+++ b/vm/compiler/RegisterizationME.cpp
@@ -181,7 +181,7 @@ static void fillWriteBackRequests (BasicBlock *bb, BitVector *bv)
  * @param cUnit the CompilationUnit
  * @param info the LoopInformation
  */
-static void handleWriteBackRequestsPostLoop (const CompilationUnit *cUnit, const LoopInformation *info)
+static void handleWriteBackRequestsPostLoop (const CompilationUnit *cUnit, LoopInformation *info)
 {
     const BitVector *postBasicBlocks = info->getExitLoops ();
 
@@ -402,9 +402,17 @@ class RegisterSorter
  * @brief Regiseterize a given loop
  * @param cUnit the CompilationUnit
  * @param info the LoopInformation
+ * @param data required by interface (not used)
+ * @return true to continue iteration over loops
  */
-static void registerizeLoop (CompilationUnit *cUnit, const LoopInformation *info)
+static bool registerizeLoop (CompilationUnit *cUnit, LoopInformation *info, void *data = 0)
 {
+    // Works only for innermost loops
+    if (info->getNested () != 0)
+    {
+        return true;
+    }
+
     RegisterSorter sorter;
     std::vector<std::pair<int, RegisterClass> > registers;
     std::map<int, int> &registerCounts = sorter.getRegisterCounts ();
@@ -476,42 +484,8 @@ static void registerizeLoop (CompilationUnit *cUnit, const LoopInformation *info
 
     //Last handle the write backs of all live outs for the post loops
     handleWriteBackRequestsPostLoop (cUnit, info);
-}
-
-/**
- * @brief Wrapper around registerizing the loop, it handles loop nests as well
- * @param cUnit the CompilationUnit
- * @param info the LoopInformation
- */
-static void registerize (CompilationUnit *cUnit, const LoopInformation *info)
-{
-    //If info is 0, there is nothing to do
-    if (info == 0)
-    {
-        return;
-    }
-
-    //Search in the children if anybody includes them
-    unsigned int nbr = info->getNestedNbr ();
-
-    //Is it the inner loop ?
-    if (nbr == 0)
-    {
-        //Actually registerize the loop
-        registerizeLoop (cUnit, info);
-    }
-    else
-    {
-        for (unsigned int i = 0; i < nbr; i++)
-        {
-            LoopInformation *inner = info->getNested (i);
-
-            //Paranoid
-            assert (inner != 0);
 
-            registerize (cUnit, inner);
-        }
-    }
+    return true;
 }
 
 bool dvmCompilerWriteBackAll (CompilationUnit *cUnit, BasicBlock *bb)
@@ -538,7 +512,10 @@ void dvmCompilerRegisterize (CompilationUnit *cUnit, Pass *currentPass)
     LoopInformation *info = cUnit->loopInformation;
 
     //Now registerize it
-    registerize (cUnit, info);
+    if (info != 0)
+    {
+        info->iterate (cUnit, registerizeLoop);
+    }
 
     //Unused argument
     (void) currentPass;
@@ -757,10 +734,18 @@ static bool parseBlock (BasicBlock *bb)
  * @brief Check a loop: is it ok to registerize
  * @param cUnit the CompilationUnit
  * @param info the LoopInformation
+ * @param data required by interface (not used)
  * @return whether it is acceptable for registerization
  */
-static bool checkLoop (const CompilationUnit *cUnit, const LoopInformation *info)
+static bool checkLoop (const CompilationUnit *cUnit, LoopInformation *info, void * data)
 {
+    // Consider only innermost loops
+    if (info->getNested () != 0)
+    {
+        //Only accept perfectly nested loops
+        return info->getNested ()->getNextSibling () == 0;
+    }
+
     const BitVector *blocks = info->getBasicBlocks ();
 
     //Go through each block
@@ -797,46 +782,6 @@ static bool checkLoop (const CompilationUnit *cUnit, const LoopInformation *info
 }
 
 /**
- * @brief Wrapper around testing if we want to registerize the loop, it handles loop nests as well
- * @param cUnit the CompilationUnit
- * @param info the LoopInformation
- * @return whether or not to registerize
- */
-static bool wouldRegisterize (const CompilationUnit *cUnit, const LoopInformation *info)
-{
-    //If info is 0, there is nothing to do
-    if (info == 0)
-    {
-        return false;
-    }
-
-    //Search in the children if anybody includes them
-    unsigned int nbr = info->getNestedNbr ();
-
-    //Is it the inner loop ?
-    if (nbr == 0)
-    {
-        //Check if we would registerize the loop
-        return checkLoop (cUnit, info);
-    }
-    else
-    {
-        //Only accept perfectly nested loops
-        if (nbr > 1)
-        {
-            return false;
-        }
-
-        LoopInformation *inner = info->getNested (0);
-
-        //Paranoid
-        assert (inner != 0);
-
-        return wouldRegisterize (cUnit, inner);
-    }
-}
-
-/**
  * @brief Should we registerize ?
  * @param cUnit the CompilationUnit
  * @param currentPass the Pass
@@ -853,12 +798,17 @@ bool dvmCompilerRegisterizeGate (const CompilationUnit *cUnit, const Pass *curre
     //Now let's go through the loop information
     LoopInformation *info = cUnit->loopInformation;
 
-    //Now registerize it
-    bool res = wouldRegisterize (cUnit, info);
-
     //Unused argument
     (void) currentPass;
 
+    if (info != 0)
+    {
+        if (info->iterateWithConst (cUnit, checkLoop) == true)
+        {
+            return true;
+        }
+    }
+
     //Return result
-    return res;
+    return false;
 }
-- 
1.7.4.1

