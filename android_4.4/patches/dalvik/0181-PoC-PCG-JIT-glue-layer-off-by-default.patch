From 0c689ff4f2bc667a8c28151b2f5a8e925cbe5398 Mon Sep 17 00:00:00 2001
From: Tim Hartley <timothy.d.hartley@intel.com>
Date: Wed, 29 May 2013 09:55:30 +0000
Subject: PoC PCG JIT glue layer (off by default)

BZ: 111968

This commit is one of the last PoC PCG JIT glue layer versions,
allowing us to refer back to it via git. The commit of the PCG JIT
we are integrating is significantly refactored.

Category: device-enablement
Domain: AOSP-Dalvik-Compiler-CG
Origin: internal
Upstream-Candidate: no, needs rework

Change-Id: Ie6cbbd25c0a3f376f2aef7643bcacf5b07893feb
Orig-MCG-Change-Id: I3cf44636fc53020b22551fe970caca2fff183f9e
Reviewed-by: Hartley, Timothy D <timothy.d.hartley@intel.com>
Signed-off-by: Qiming Shi <qiming.shi@intel.com>
Signed-off-by: Serguei Katkov <serguei.i.katkov@intel.com>
---
 vm/compiler/codegen/x86/pcg/PcgInterface.cpp | 6995 ++++++++++++++++++++++++++
 vm/compiler/codegen/x86/pcg/PcgInterface.h   |   60 +
 2 files changed, 7055 insertions(+), 0 deletions(-)
 create mode 100644 vm/compiler/codegen/x86/pcg/PcgInterface.cpp
 create mode 100644 vm/compiler/codegen/x86/pcg/PcgInterface.h

diff --git a/vm/compiler/codegen/x86/pcg/PcgInterface.cpp b/vm/compiler/codegen/x86/pcg/PcgInterface.cpp
new file mode 100644
index 0000000..9dd12d4
--- /dev/null
+++ b/vm/compiler/codegen/x86/pcg/PcgInterface.cpp
@@ -0,0 +1,6995 @@
+/*
+ * Copyright (C) 2012-2012 Intel Corporation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#include <map>
+#include <list>
+#include <set>
+#include "PcgInterface.h"
+#include "Lower.h"
+#include "interp/InterpState.h"
+#include "NcgHelper.h"
+#include "compiler/Dataflow.h"
+
+// These are declarations for PCG-internal variables.
+// TODO: We need to create real interfaces to set these if we need to keep
+//       them.
+extern int P3OPT_pcg_experimental;
+extern int CG_bnl_expand_idivs;
+
+#define offChainingCell_clazz 8
+#define offChainingCell_method 12
+#define offChainingCell_counter 16
+
+//
+// Index into array descriptors.
+//
+#define offArrayObject_length   8
+
+// Self PTR from ebp (pcgFramePtr)
+#define offEBP_self 8
+
+//
+// Values off of self ptr
+//
+#define offMethod_clazz 0
+#define offThread_curFrame 4
+#define offGlue_method 16
+
+//
+// Values off of class objects
+//
+#define offClassObject_vtable 116
+#define offClassObject_pDvmDex 40
+#define offClassObject_super 72
+#define offClassObject_vtableCount 112
+
+
+#define mir_vA(mir) (mir->dalvikInsn.vA)
+#define mir_vB(mir) (mir->dalvikInsn.vB)
+#define mir_vC(mir) (mir->dalvikInsn.vC)
+
+static bool speculative_null_checks = false;
+static CGInst pcgVmPtr;
+static CGInst pcgFramePtr;
+static CGLabel pcgLoopHeadLabel;
+static int pcgExceptionBlockId;
+static bool pcgExceptionBlockReferenced;
+static BasicBlock *pcgCurrentBB;
+static Method* pcgCurrentMethod;
+static CompilationUnit *pcgCurrentCompilationUnit;
+static CGTemp pcgNextTemp;
+static ChainCellCounts pcgChainCellCounts;
+typedef std::set<int> VRSet;
+static VRSet pcgReferencedVRs;
+static CGInsertionPoint pcgEntryInsertionPoint;
+static GrowableList chainingListByType[kChainingCellLast];
+static uint32_t pcgTraceCounter;
+static uint32_t pcgDebugLevel;
+
+#define DUMP_PIL() ((pcgDebugLevel & 0x1) != 0)
+#define DUMP_ASM() ((pcgDebugLevel & 0x2) != 0)
+#define DUMP_TRACE() ((pcgDebugLevel & 0x4) != 0)
+#define DUMP_BYTECODE() ((pcgDebugLevel & 0x8) != 0)
+#define DUMP_DISASM() ((pcgDebugLevel & 0x10) != 0)
+#define DEBUG_REGISTERIZE_VRS() ((pcgDebugLevel & 0x20) != 0)
+#undef DEBUG_HOOK
+
+typedef enum {
+    NOreg = 0,
+    INTreg,
+    LLreg,
+    VXreg32,
+    DPVXreg64,
+    Any,
+    Any4,
+    Any8
+} pcgDtype;
+
+static pcgDtype pcgMergeDtypes(pcgDtype dtype1, pcgDtype dtype2);
+static const char* dtypeName(pcgDtype dtype);
+
+typedef struct SSANumInfo {
+    pcgDtype dtype;
+    MIR *mir;  // defining MIR
+    int parentSSANum;
+    int numUses;
+    bool registerize;
+    bool needsNullCheck;
+    bool checkedForNull;
+    bool deferWriteback;
+} SSANumInfo;
+typedef std::map<int, SSANumInfo> SSANumInfoMap;
+static SSANumInfoMap pcgSSANumInfo;
+typedef std::map<BasicBlock*, BitVector*> ModSSANumMap;
+static ModSSANumMap pcgModSSAIns;
+static ModSSANumMap pcgModSSAOuts;
+static ModSSANumMap pcgModSSAKills;
+typedef std::map<u2, BitVector*> VRtoSSANumSetMap;
+static VRtoSSANumSetMap pcgVRtoSSANumSet;
+static BitVector *tempBV;
+static BitVector *currModBV;
+
+static void pcgGenerateWritebacks(CompilationUnit *cUnit, BitVector *bv);
+static void doWritebacksOnEdge(CompilationUnit *cUnit,
+                               BasicBlock *from, BasicBlock *to);
+static void subtractBVs(BitVector *r, BitVector *s1, BitVector *s2);
+static void dumpBitVector(CompilationUnit *cUnit, BitVector *bv, int n);
+static char* pcgGetBlockName(int id, CGLabel cg_label = CGLabelInvalid);
+static void pcgDirectJumpToBlock(int target_block_id);
+
+typedef struct {
+    // A CGLabel that can be used to branch to the block.
+    CGLabel cg_label;
+
+    // A CGLabel used for the block containing any possible writeback code
+    // on a taken branch.  It basically represents the block resulting from
+    // splitting the taken edge.
+    //
+    CGLabel taken_label;
+
+    // A CGSymbol that represents the address for the start of the actual
+    // chaining cell.  The cg_symbol for a chaining cell block actually
+    // refers to the start address of the exit trampoline into that chaining
+    // cell.
+    //
+    CGSymbol chaining_cell_cg_symbol;
+
+    // A CGSymbol & CGLabel for the block containing the writeback code for a
+    // backward branch chaining cell.
+    //
+    CGLabel writeback_target_label;
+    CGSymbol writeback_target_symbol;
+
+    // The dalvik block type
+    BBType block_type;
+
+    // Has this block been bound?  This information is needed to determine
+    // whether we can query for the block address.
+    //
+    bool block_bound;
+
+    // This boolean exists so that we can avoid binding block labels, if
+    // possible to maximize block local optimization opportunities.
+    bool possibly_referenced;
+} BlockInfo;
+static BlockInfo *pcgBlockInfo;
+
+typedef struct {
+    // Name of the symbol
+    const char *name;
+
+    // Address of the symbol
+    void *address;
+
+    // CGSymbol of the symbol
+    CGSymbol cg_symbol;
+} ClientSymbolInfo;
+
+typedef struct {
+    // The symbol that needs to be referenced.
+    ClientSymbolInfo *target_symbol;
+
+    // A constant offset to be added to &target_symbol in the calculation
+    // of the symbol reference.
+    //
+    int32_t addend;
+
+    // The offset from the start of the routine where the reference is needed.
+    uint32_t code_offset;
+
+    // The type of relocation (absolute vs. PC-relative).
+    CGRelocationType relocation_type;
+} Relocation;
+
+//
+// Pair used to track labels to symbols to bind the two together
+// after compilation.
+//
+typedef struct {
+    CGLabel  cg_label;
+    CGSymbol cg_symbol;
+} LabelSymbol;
+
+typedef std::map<CGSymbol, ClientSymbolInfo*> SymbolMap;
+typedef std::map<std::string, CGSymbol> NameToSymbolMap;
+typedef std::list<Relocation> RelocationList;
+typedef std::list<LabelSymbol> LabelSymbolList;
+static SymbolMap pcgSymbolMap;
+static NameToSymbolMap pcgNameToSymbolMap;
+static RelocationList pcgRelocationList;
+static LabelSymbolList pcgLabelSymbolList;
+static CGSymbol pcgJitToInterpPuntSymbol;
+static CGSymbol dvmJitToInterpNoChainNoProfileSymbol;
+static CGSymbol common_errNullObjectSymbol;
+static CGSymbol dvmJitToPatchPredictedChainSymbol;
+static CGSymbol dvmFindInterfaceMethodInCacheSymbol;
+static CGSymbol dvmJitToExceptionThrownSymbol;
+static CGSymbol dvmLockObjectSymbol;
+static CGSymbol dvmUnlockObjectSymbol;
+static CGSymbol dvmInstanceofNonTrivialSymbol;
+//ZZZ DEBUG
+//  CGCreateNewInst("call", "n", zzz_debug_symbol);
+CGSymbol zzz_debug_symbol;
+CGTemp pcgVmPtrTemp;
+CGTemp pcgFramePtrTemp;
+
+extern "C" int64_t __divdi3(int64_t, int64_t);
+extern "C" int64_t __moddi3(int64_t, int64_t);
+extern "C" int64_t __muldi3(int64_t, int64_t);
+extern "C" int64_t __ashldi3(int64_t, int);
+extern "C" int64_t __lshrdi3(int64_t, int);
+extern "C" int64_t __ashrdi3(int64_t, int);
+
+extern void dumpMIR(CompilationUnit *cUnit, MIR *mir)
+{
+    const u4 c_buf_len = 2048;
+    char mybuf[c_buf_len];
+
+    dvmCompilerExtendedDisassembler(cUnit, mir,
+                                    &mir->dalvikInsn, mybuf,
+                                    c_buf_len);
+    printf("%s\n", mybuf);
+}
+
+static u2 pcgGetVRFromSSANum(int ssaNum)
+{
+    int dalvikReg = dvmConvertSSARegToDalvik(pcgCurrentCompilationUnit,
+                                             ssaNum);
+    return DECODE_REG(dalvikReg);
+}
+
+// Returns the SSA number for the specified use.
+static int mirUse(MIR *mir, int n)
+{
+    if (!mir || !(mir->ssaRep) || mir->ssaRep->numUses <= n) {
+        printf("Invalid use query\n");
+        exit(-1);
+    }
+    return mir->ssaRep->uses[n];
+}
+
+// Returns the SSA number for the specified def.
+static int mirDef(MIR *mir, int n)
+{
+    if (!mir || !(mir->ssaRep) || mir->ssaRep->numDefs <= n) {
+        printf("Invalid def query\n");
+        exit(-1);
+    }
+    return mir->ssaRep->defs[n];
+}
+
+static int32_t getOpcodeAndSizeForDtype(pcgDtype dtype, const char **opc_ptr)
+{
+    int32_t size;
+    const char *pcgOpcode;
+
+    switch (dtype) {
+        case INTreg:
+            pcgOpcode = "mov";
+            size = 4;
+            break;
+
+        case LLreg:
+            pcgOpcode = "lmov";
+            size = 8;
+            break;
+
+        case VXreg32:
+            pcgOpcode = "movss1";
+            size = 4;
+            break;
+
+        case DPVXreg64:
+            pcgOpcode = "movsd1";
+            size = 8;
+            break;
+
+        default:
+            ALOGE("\n+++ PCG ERROR +++ Unexpected data type seen : %d.",
+                  dtype);
+            assert(0);
+            exit(-1);
+    }
+
+    *opc_ptr = pcgOpcode;
+    return size;
+}
+
+//
+// Create a move of pcgVmPtr, and set the hard register.
+// This is used before jsr/jmp/call to ensure pcgVmPtr
+// is in the right place.
+//
+static CGInst pcg_gen_vmptr_mov(void)
+{
+  CGInst mov = CGCreateNewInst("mov", "r", pcgVmPtr);
+  CGSetRreg(mov, "edi");
+  return mov;
+
+}
+
+//
+// Create a move of pcgFramePtr, and set the hard register.
+// This is used before jsr/jmp/call to ensure pcgFramePtr
+// is in the right place.
+//
+static CGInst pcg_gen_frameptr_mov(void)
+{
+  CGInst mov = CGCreateNewInst("mov", "r", pcgFramePtr);
+  CGSetRreg(mov, "ebp");
+  return mov;
+
+}
+
+// create_symbol creates a new CGSymbol with the specified name and address.
+// The symbol is created and returned, and a ClientSymbolInfo structure is
+// created and inserted into the pcgSymbolMap.
+//
+extern CGSymbol pcgCreateSymbol(const char *name, void *address)
+{
+    CGSymbol cg_symbol = CGCreateSymbol("");
+    // TODO - This call to malloc needs to be changed.
+    ClientSymbolInfo *client_symbol_info_p =
+        (ClientSymbolInfo*)malloc(sizeof(ClientSymbolInfo));
+
+    client_symbol_info_p->name = name;
+    client_symbol_info_p->address = address;
+    client_symbol_info_p->cg_symbol = cg_symbol;
+
+    pcgSymbolMap[cg_symbol] = client_symbol_info_p;
+    pcgNameToSymbolMap[name] = cg_symbol;
+
+    return cg_symbol;
+}
+
+//
+// Create pairs of label <-> symbol to bind at the end of compilation.
+//
+static void pcgAddLabelSymbolPair(CGLabel cg_label, CGSymbol cg_symbol)
+{
+    LabelSymbol ls;
+
+    ls.cg_label = cg_label;
+    ls.cg_symbol = cg_symbol;
+
+    pcgLabelSymbolList.push_front(ls);
+}
+
+//
+// Attempt to find a symbol associated to a block, and return it.
+// If one doesn't exist, create a new one and return it.
+//
+CGSymbol pcgGetBlockSymbol(CGLabel blockLabel)
+{
+    LabelSymbolList::iterator it;
+    LabelSymbol ls;
+
+    for (it = pcgLabelSymbolList.begin();
+         it != pcgLabelSymbolList.end(); ++it) {
+        ls = *it;
+
+        if (ls.cg_label == blockLabel) {
+            return ls.cg_symbol;
+        }
+    }
+    CGSymbol cg_symbol = pcgCreateSymbol(pcgGetBlockName(-1, blockLabel), 0);
+    pcgAddLabelSymbolPair(blockLabel, cg_symbol);
+    return cg_symbol;
+}
+
+static void pcgBindBlockLabel(int block_id)
+{
+    CGBindLabel(pcgBlockInfo[block_id].cg_label);
+    pcgBlockInfo[block_id].block_bound = true;
+}
+
+static void pcgBindSymbolAddress(CGSymbol cg_symbol, void *address)
+{
+    ClientSymbolInfo *client_symbol_info_p = pcgSymbolMap[cg_symbol];
+    client_symbol_info_p->address = address;
+}
+
+static void* pcgGetSymbolAddress(CGSymbol cg_symbol)
+{
+    ClientSymbolInfo *client_symbol_info_p = pcgSymbolMap[cg_symbol];
+    return client_symbol_info_p->address;
+}
+
+static void pcgInitForTrace(CompilationUnit *cUnit)
+{
+    // This needs to be initialized to some value larger than the highest
+    // SSA number, because we use the SSA number as the
+    // temp number when we registerize VRs.
+    //
+    pcgNextTemp = 1000000;
+    pcgVmPtrTemp = pcgNextTemp++;
+    pcgFramePtrTemp = pcgNextTemp++;
+    pcgRelocationList.clear();
+    pcgLabelSymbolList.clear();
+    pcgExceptionBlockReferenced = false;
+    pcgExceptionBlockId = -1;
+    pcgReferencedVRs.clear();
+    pcgCurrentMethod = (Method *)cUnit->method;
+    pcgCurrentCompilationUnit = cUnit;
+
+    // We might want to define CGLabelInvalid to make this loop nicer.
+    pcgLoopHeadLabel = 0;
+    pcgTraceCounter++;
+}
+
+static void pcgConfigureTrace(void)
+{
+    CGConfigureRoutine("esp_frame", "on", (void*)0);
+    if (DUMP_PIL()) {
+        CGConfigureRoutine("debug_level", "1", (void*)0);
+    }
+    CGConfigureRoutine("target_arch", "atom_ssse3", (void*)0);
+    CGConfigureRoutine("eliminate_frame_pointer", "off", (void*)0);
+    if (DUMP_ASM()) {
+        CGSetAsmOutputFile(stderr);
+    }
+}
+
+#ifdef DEBUG_HOOK
+static void pcgDebugHook(void)
+{
+    CGCreateNewInst("call", "n", pcgNameToSymbolMap["debugHook"]);
+}
+#endif // DEBUG_HOOK
+
+// Generate PCGil for the entry idiom.  The only thing unique about this
+// entry sequence is that we also model the virtual machine state pointer as
+// an incoming argument in EDI.
+//
+static void pcgGenEntryIl(void)
+{
+    CGInst inst, entry_inst;
+
+    entry_inst = CGCreateEntryInst();
+    // Use an esp frame so that we can spill to the stack.
+    CGSetRreg(entry_inst, "esp");
+    inst = entry_inst;
+    inst = CGCreateNewInst("spsubi", "ri", inst, 0);
+    CGSetRreg(inst, "esp");
+    inst = CGCreateNewInst("idef", "a", entry_inst);
+    CGSetRreg(inst, "edi");
+    inst = CGCreateNewInst("mov", "r", inst);
+    CGAddTempDef(pcgVmPtrTemp, inst);
+    pcgVmPtr = CGGetTempUseInst(pcgVmPtrTemp);
+    inst = CGCreateNewInst("idef", "a", entry_inst);
+    CGSetRreg(inst, "ebp");
+    inst = CGCreateNewInst("mov", "r", inst);
+    CGAddTempDef(pcgFramePtrTemp, inst);
+    pcgFramePtr = CGGetTempUseInst(pcgFramePtrTemp);
+
+    pcgEntryInsertionPoint = CGGetCurrentInsertionPoint();
+}
+
+static void* pcgGetVRHandle(u2 virtual_reg, uint32_t size)
+{
+    // Start with a non-zero handle, because PCG assigns a special meaning
+    // to a null handle.
+    //
+    intptr_t handle = 0x2;
+
+    if (size == 8) {
+        handle |= 0x4;
+    }
+    handle |= virtual_reg << 3;
+
+    return (void*)handle;
+}
+
+static pcgDtype pcgGetDtypeForSSANum(int ssaNum)
+{
+    SSANumInfoMap::iterator it = pcgSSANumInfo.find(ssaNum);
+    int parentSSANum = it->second.parentSSANum;
+
+    if (ssaNum != parentSSANum) {
+        it = pcgSSANumInfo.find(parentSSANum);
+    }
+    
+    return it->second.dtype;
+}
+
+static void pcgSetDtypeForSSANum(int ssaNum, pcgDtype dtype)
+{
+    SSANumInfoMap::iterator it = pcgSSANumInfo.find(ssaNum);
+    int parentSSANum = it->second.parentSSANum;
+
+    if (ssaNum != parentSSANum) {
+        it = pcgSSANumInfo.find(parentSSANum);
+    }
+    it->second.dtype = dtype;
+}
+
+static CGInst pcgGetVirtualReg(int ssaNum, const char *pcg_opcode,
+                               uint32_t load_size)
+{
+    ssaNum = pcgSSANumInfo[ssaNum].parentSSANum;
+
+    int dalvikReg = dvmConvertSSARegToDalvik(pcgCurrentCompilationUnit,
+                                             ssaNum);
+
+    if (pcgSSANumInfo[ssaNum].registerize) {
+        return CGGetTempUseInst(pcgSSANumInfo[ssaNum].parentSSANum);
+    }
+
+    u2 virtual_reg = DECODE_REG(dalvikReg);
+
+    void *handle = pcgGetVRHandle(virtual_reg, load_size);
+    CGAddr addr = CGCreateAddr(pcgVmPtr, CGInstInvalid, 0, CGSymbolInvalid,
+                               virtual_reg * 4);
+
+    return CGCreateNewInst(pcg_opcode, "m", addr, load_size, handle);
+}
+
+static void pcgSetVirtualReg(int ssaNum, const char *pcg_opcode,
+                             uint32_t store_size, CGInst store_val)
+{
+    ssaNum = pcgSSANumInfo[ssaNum].parentSSANum;
+    if (pcgSSANumInfo[ssaNum].registerize) {
+        pcgDtype regDtype = pcgGetDtypeForSSANum(ssaNum);
+        getOpcodeAndSizeForDtype(regDtype, &pcg_opcode);
+        CGInst copy = CGCreateNewInst(pcg_opcode, "r", store_val);
+        CGAddTempDef(pcgSSANumInfo[ssaNum].parentSSANum, copy);
+
+        if (pcgSSANumInfo[ssaNum].deferWriteback) {
+            return;
+        }
+    }
+
+    u2 virtual_reg = pcgGetVRFromSSANum(ssaNum);
+
+    void *handle = pcgGetVRHandle(virtual_reg, store_size);
+    CGAddr addr = CGCreateAddr(pcgVmPtr, CGInstInvalid, 0, CGSymbolInvalid,
+                               virtual_reg * 4);
+
+    CGCreateNewInst(pcg_opcode, "mr", addr, store_size, handle, store_val);
+}
+
+//
+// Create a JSR and add an spaddi.
+//
+static CGInst CGCreateJsr(CGSymbol symbol, CGInst *parms = 0,
+                          CGInst reg = CGInstInvalid)
+{
+    if (symbol != CGSymbolInvalid && reg != CGInstInvalid) {
+        printf("\nPCG : huh?\n");
+        exit (-1);
+    }
+
+    CGInst spadd = CGCreateNewInst("spaddi", "ri",
+                                   CGGetStackPointerDef(), 0);
+    CGSetRreg(spadd, "esp");
+
+    if (parms) {
+        if (reg != CGInstInvalid) {
+            return CGCreateNewInst("jsr", "rl", reg, parms);
+        }
+        else  {
+            return CGCreateNewInst("jsr", "nl", symbol, parms);
+        }
+    }
+    else {
+        if (reg) {
+            return CGCreateNewInst("jsr", "r", reg);
+        }
+        else {
+            return CGCreateNewInst("jsr", "n", symbol);
+        }
+    }    
+}
+
+// Alternative interface to CGCreateJsr that specifies the target by name
+// instead of symbol.
+static CGInst CGCreateJsrName(const char *name, CGInst *parms = 0,
+                              CGInst reg = CGInstInvalid)
+{
+    return CGCreateJsr(pcgNameToSymbolMap[name], parms, reg);
+}
+
+//
+// Create a 4B load with base and offset only
+//
+static CGInst CGCreateSimpleLoad(CGInst base, int32_t offset)
+{
+  CGAddr addr = CGCreateAddr(base, CGInstInvalid, 0, CGSymbolInvalid, offset);
+  return CGCreateNewInst("mov", "m", addr, 4, (void*)1);
+}
+
+// Create a store of an arbitrarily typed value.
+//
+static CGInst CGCreateTypedStore(CGInst base, CGInst index, uint32_t scale,
+                                 CGSymbol ltbase, int32_t offset,
+                                 pcgDtype dtype, CGInst r)
+{
+    const char *opc;
+    int32_t size = getOpcodeAndSizeForDtype(dtype, &opc);
+
+    CGAddr addr = CGCreateAddr(base, index, scale, ltbase, offset);
+    return CGCreateNewInst(opc, "mr", addr, size, (void*)1, r);
+}
+
+//
+// Create a 4B store of a "r" parameter
+//
+static CGInst CGCreateStore(CGInst base, CGInst index, uint32_t scale,
+                            CGSymbol ltbase, int32_t offset, CGInst r)
+{
+    CGAddr addr = CGCreateAddr(base, index, scale, ltbase, offset);
+    return CGCreateNewInst("mov", "mr", addr, 4, (void*)1, r);
+}
+
+//
+// Create a 4B store of a "r" parameter passed in with base and offset only
+//
+static CGInst CGCreateSimpleStore(CGInst base, int32_t offset, CGInst r)
+{
+  CGAddr addr = CGCreateAddr(base, CGInstInvalid, 0, CGSymbolInvalid, offset);
+  return CGCreateNewInst("mov", "mr", addr, 4, (void*)1, r);
+}
+
+static CGInst pcg_get_self_pointer(void)
+{
+    CGAddr addr = CGCreateAddr(pcgFramePtr, CGInstInvalid, 0, CGSymbolInvalid,
+                               offEBP_self);
+    return CGCreateNewInst("mov", "m", addr, 4, (void*)1);
+}
+
+static void pcgExportPC(void)
+{
+    // export_pc
+    CGAddr pc_addr = CGCreateAddr(pcgVmPtr, CGInstInvalid, 0, CGSymbolInvalid,
+                                  (offStackSaveArea_localRefTop -
+                                   sizeofStackSaveArea));
+    CGCreateNewInst("mov", "mi", pc_addr, 4, (void*)1, (int32_t)rPC);
+}
+
+// Utility routine to jump to the exception block, which then punts to the
+// interpreter.  This routine should be called if the PC has already been
+// saved.
+static void pcgRaiseExceptionSimple(void)
+{
+    pcgGenerateWritebacks(pcgCurrentCompilationUnit, currModBV);
+    CGCreateNewInst("jmp", "b", pcgBlockInfo[pcgExceptionBlockId].cg_label);
+    pcgExceptionBlockReferenced = true;
+}
+
+// Utility routine to export the PC and jump to the exception block, which
+// then punts to the interpreter.
+static void pcgRaiseException(void)
+{
+    pcgExportPC();
+    pcgRaiseExceptionSimple();
+}
+
+static void pcgSimpleNullCheck(CGInst inst)
+{
+    CGLabel not_null = CGCreateLabel();
+    CGInst zero = CGCreateNewInst("mov", "i", 0);
+    CGCreateNewInst("cjcc", "rcrbp", inst, "ne", zero, not_null, 100);
+    CGCreateJsr(common_errNullObjectSymbol);
+    CGBindLabel(not_null);
+}
+
+static const char* pcgGetCallOpcodeAndRreg(pcgDtype dtype,
+                                           const char **rreg_ptr)
+{
+    switch (dtype) {
+        case INTreg:
+            *rreg_ptr = "eax";
+            return "icall";
+
+        case LLreg:
+            *rreg_ptr = "eax";
+            return "lcall";
+
+        case NOreg:
+            *rreg_ptr = "";
+            return "call";
+
+        default:
+            break;
+    }
+
+    // We can add support for FP results, but they aren't currently needed,
+    // so just give an error here.
+    //
+    printf("PCG Error: Unsupported call dtype");
+    exit(-1);
+}
+
+static int32_t pcgAlignUp(int32_t amount, int32_t boundary)
+{
+    int32_t remainder = amount % boundary;
+
+    if (remainder == 0) {
+        return amount;
+    }
+
+    return amount + (boundary - remainder);
+}
+
+// Create a call to a routine that uses the standard X86 calling convention,
+// i.e. arguments on the stack.  The number of arguments is specified by
+// n_args, and the actual arguments are specified in a variable argument list.
+// Each argument is specified by two arguments: pcgDtype, CGInst.
+// The result data type is given by result_dtype, which can be NOreg.  All
+// result types are supported.
+//
+// This routine currently assumes that EDI and EBP are needed by the callee.
+// That may not be necessary.
+//
+static CGInst pcgGenX86Call(const char *target_name, pcgDtype result_dtype,
+                            int n_args, ...)
+{
+    CGSymbol target = pcgNameToSymbolMap[target_name];
+    const char *rreg;
+    const char *call_opc = pcgGetCallOpcodeAndRreg(result_dtype, &rreg);
+    const char *copy_opc;
+    int32_t stack_size, offset, i;
+    va_list args;
+    CGInst sp_il;
+    CGInst parms[3];
+
+    // Compute the required stack size to hold outgoing arguments.
+    stack_size = 0;
+    va_start(args, n_args);
+    for (i = 0; i < n_args; i++) {
+        pcgDtype arg_dtype = (pcgDtype)va_arg(args, int);
+
+        // Advance past the actual argument.  It isn't needed here.
+        va_arg(args, CGInst);
+
+        stack_size += getOpcodeAndSizeForDtype(arg_dtype, &copy_opc);
+    }
+    va_end(args);
+    stack_size = pcgAlignUp(stack_size, 16);
+
+    sp_il = CGCreateNewInst("sub", "ri", CGGetStackPointerDef(), stack_size);
+    CGSetRreg(sp_il, "esp");
+
+    // Store the outgoing arguments to the stack.
+    offset = 0;
+    va_start(args, n_args);
+    for (i = 0; i < n_args; i++) {
+        pcgDtype arg_dtype = (pcgDtype)va_arg(args, int);
+        CGInst arg = va_arg(args, CGInst);
+
+        int32_t arg_size = getOpcodeAndSizeForDtype(arg_dtype, &copy_opc);
+        CGCreateTypedStore(sp_il, CGInstInvalid, 0, CGSymbolInvalid, offset,
+                           arg_dtype, arg);
+        offset += arg_size;
+    }
+    va_end(args);
+
+    parms[0] = pcg_gen_vmptr_mov();
+    parms[1] = pcg_gen_frameptr_mov();
+    parms[2] = CGInstInvalid;
+    CGInst the_call = CGCreateNewInst(call_opc, "nl", target, parms);
+    CGSetRreg(the_call, rreg);
+    sp_il = CGCreateNewInst("add", "ri", CGGetStackPointerDef(), stack_size);
+    CGSetRreg(sp_il, "esp");
+
+    if (result_dtype != NOreg) {
+        getOpcodeAndSizeForDtype(result_dtype, &copy_opc);
+        the_call = CGCreateNewInst(copy_opc, "r", the_call);
+    }
+
+    return the_call;
+}
+
+// Store the outgoing arguments for an invoke.
+void pcgStoreInvokeArgs(MIR *mir)
+{
+    int i;
+    int offset = -sizeofStackSaveArea - (4 * mir->ssaRep->numUses);
+
+    for (i = 0; i < mir->ssaRep->numUses; ) {
+        const char *pcgOpcode;
+        int32_t dtypeSize;
+        int ssaNum = mirUse(mir, i);
+        dtypeSize = getOpcodeAndSizeForDtype(pcgGetDtypeForSSANum(ssaNum),
+                                             &pcgOpcode);
+        CGInst load = pcgGetVirtualReg(ssaNum, pcgOpcode, dtypeSize);
+        CGAddr addr = CGCreateAddr(pcgVmPtr, CGInstInvalid, 0, CGSymbolInvalid,
+                                   offset);
+        CGCreateNewInst(pcgOpcode, "mr", addr, dtypeSize, (void*)1, load);
+        offset += dtypeSize;
+        i += dtypeSize / 4;
+    }
+}
+
+CGSymbol pcgGetInvokeTarget(int blockId, bool *needs_cfg_arc = NULL)
+{
+    CGSymbol sym;
+    BBType block_type = pcgBlockInfo[blockId].block_type;
+
+    if (needs_cfg_arc) {
+        *needs_cfg_arc = true;
+    }
+
+    if (block_type < kChainingCellLast) {
+        sym = pcgBlockInfo[blockId].chaining_cell_cg_symbol;
+        if (needs_cfg_arc) {
+            *needs_cfg_arc = false;
+        }
+    }
+    else {
+        sym = pcgGetBlockSymbol(pcgBlockInfo[blockId].cg_label);
+    }
+
+    return sym;
+}
+
+void pcgAddPostInvokeEntryCode(void)
+{
+    CGInst entry_inst = CGCreateNewInst("entry", "");
+    CGSetRreg(entry_inst, "esp");
+    CGInst inst = entry_inst;
+    inst = CGCreateNewInst("spsubi", "ri", inst, 0);
+    CGSetRreg(inst, "esp");
+    inst = CGCreateNewInst("idef", "a", entry_inst);
+    CGSetRreg(inst, "edi");
+    inst = CGCreateNewInst("mov", "r", inst);
+    CGAddTempDef(pcgVmPtrTemp, inst);
+    pcgVmPtr = CGGetTempUseInst(pcgVmPtrTemp);
+    inst = CGCreateNewInst("idef", "a", entry_inst);
+    CGSetRreg(inst, "ebp");
+    inst = CGCreateNewInst("mov", "r", inst);
+    CGAddTempDef(pcgFramePtrTemp, inst);
+    pcgFramePtr = CGGetTempUseInst(pcgFramePtrTemp);
+}
+
+void pcg_common_invoke_method_jmp(ArgsDoneType form, CGInst method_to_call)
+{
+    //  arguments needed in ArgsDone:
+    //      start of HotChainingCell for next bytecode: eax
+    //      start of InvokeSingletonChainingCell for callee: ebx
+
+    CGSymbol taken_target_sym, fallthrough_target_sym;
+    bool taken_needs_cfg_edge, fallthrough_needs_cfg_edge;
+    CGLabel newTakenLabel, newFallThroughLabel;
+
+    if (pcgCurrentBB->taken) {
+        taken_target_sym = pcgGetInvokeTarget(pcgCurrentBB->taken->id,
+                                              &taken_needs_cfg_edge);
+    }
+    else {
+        taken_needs_cfg_edge = false;
+    }
+    fallthrough_target_sym = pcgGetInvokeTarget(pcgCurrentBB->fallThrough->id,
+                                                &fallthrough_needs_cfg_edge);
+
+    //
+    // Change the taken/fallthrough blocks to point to our new
+    // intermediary block (see below where we bind it).
+    //
+    if (fallthrough_needs_cfg_edge) {
+        newFallThroughLabel = CGCreateLabel();
+        fallthrough_target_sym = pcgGetBlockSymbol(newFallThroughLabel);
+    }
+    if (taken_needs_cfg_edge) {
+        newTakenLabel = CGCreateLabel();
+        taken_target_sym = pcgGetBlockSymbol(newTakenLabel);
+    }
+
+    pcgGenerateWritebacks(pcgCurrentCompilationUnit, currModBV);
+
+    // sets up parameters in eax, ebx, ecx, and edx
+    CGInst fallthrough_target =
+        CGCreateNewInst("movltc", "n", fallthrough_target_sym);
+    CGSetRreg(fallthrough_target, "ebx");
+    CGInst taken_target;
+    if (pcgCurrentBB->taken) {
+        taken_target = CGCreateNewInst("movltc", "n", taken_target_sym);
+    }
+    else {
+        taken_target = CGCreateNewInst("mov", "i", 0);
+    }
+    CGSetRreg(taken_target, "eax");
+    CGInst parm_edx = CGCreateNewInst("mov", "i", (int32_t)rPC);
+    CGSetRreg(parm_edx, "edx");
+    CGInst parm_ecx = CGCreateNewInst("mov", "r", method_to_call);
+    CGSetRreg(parm_ecx, "ecx");
+    CGInst parm_edi = pcg_gen_vmptr_mov();
+    CGInst parm_ebp = pcg_gen_frameptr_mov();
+
+    CGInst parms[7] = {parm_edx, parm_ecx, parm_edi, parm_ebp,
+                       fallthrough_target, taken_target,
+                       CGInstInvalid};
+
+    const char *target_name;
+
+    if (form == ArgsDone_Full) {
+        target_name = ".invokeArgsDone_jit_airthunk";
+    }
+    else if (form == ArgsDone_Native) {
+        target_name = ".invokeArgsDone_native_airthunk";
+    }
+    else {
+        target_name = ".invokeArgsDone_normal_airthunk";
+    }
+    CGSymbol target = pcgNameToSymbolMap[target_name];
+    CGInst call = CGCreateJsr(target, parms);
+
+    //
+    // If the taken/fallthrough path have real code following them,
+    // we need to insert an intermediary block to add new entry code.
+    // This is because we were required to clean up the stack before
+    // the invoke, and we may need a new stack for the code
+    // following the invoke.
+    //
+    if (fallthrough_needs_cfg_edge) {
+        CGBindLabel(newFallThroughLabel);
+        CGAddIndirectBranchTarget(call, newFallThroughLabel);
+        pcgAddPostInvokeEntryCode();
+        pcgDirectJumpToBlock(pcgCurrentBB->fallThrough->id);
+    }
+
+    if (taken_needs_cfg_edge) {
+        CGBindLabel(newTakenLabel);
+        CGAddIndirectBranchTarget(call, newTakenLabel);
+        pcgAddPostInvokeEntryCode();
+        pcgDirectJumpToBlock(pcgCurrentBB->taken->id);
+    }
+}
+
+static void pcgCalldvmJitToExceptionThrown(void)
+{
+    pcgGenerateWritebacks(pcgCurrentCompilationUnit, currModBV);
+
+    CGInst parm_edi = pcg_gen_vmptr_mov();
+    CGInst parm_ebp = pcg_gen_frameptr_mov();
+    CGInst parms[3] = {parm_edi, parm_ebp, CGInstInvalid};
+    CGCreateNewInst("call", "nl", dvmJitToExceptionThrownSymbol, parms);
+}
+
+static void pcgJsrdvmJitToExceptionThrown(void)
+{
+    pcgGenerateWritebacks(pcgCurrentCompilationUnit, currModBV);
+
+    CGInst parm_edi = pcg_gen_vmptr_mov();
+    CGInst parm_ebp = pcg_gen_frameptr_mov();
+    CGInst parms[3] = {parm_edi, parm_ebp, CGInstInvalid};
+    CGCreateNewInst("jsr", "nl", dvmJitToExceptionThrownSymbol, parms);
+}
+
+static void pcg_gen_predicted_chain(
+    u2 tmp,
+    int IMMC,
+    bool isInterface,
+    CGInst inputReg, // thisPtr
+    MIR *mir)
+{
+    int traceTakenId = pcgCurrentBB->taken ? pcgCurrentBB->taken->id : 0;
+
+    assert(traceTakenId != 0); // don't think this can happen.
+
+    pcgStoreInvokeArgs(mir);
+    CGInst taken_target =
+        CGCreateNewInst("movltc", "n", pcgGetInvokeTarget(traceTakenId));
+
+    CGInst predicted_clazz = CGCreateSimpleLoad(taken_target,
+                                                offChainingCell_clazz);
+    CGInst predicted_method = CGCreateSimpleLoad(taken_target,
+                                                 offChainingCell_method); 
+
+    //
+    // Compare current class object against predicted clazz
+    // if equal, prediction is still valid, jump to .invokeChain
+    //
+    CGLabel invoke_chain_label = CGCreateLabel();
+
+    // get thisPtr->clazz
+    CGInst clazz = CGCreateSimpleLoad(inputReg, offObject_clazz);
+
+    CGCreateNewInst("cjcc", "rcrb", clazz, "eq", predicted_clazz,
+                    invoke_chain_label);
+
+    CGTemp methodTemp = ++pcgNextTemp;
+
+    // get callee method and update predicted method if necessary
+    if (isInterface) {
+        // predicted_chain_interface_O1(tmp);
+
+        // set up arguments to dvmFindInterfaceMethodInCache
+        // ESP = ESP - 12
+        CGInst sp_il =
+            CGCreateNewInst("sub", "ri", CGGetStackPointerDef(), 16);
+        CGSetRreg(sp_il, "esp");
+
+        CGInst imm_il;
+        CGCreateSimpleStore(sp_il, 0, clazz);
+
+        imm_il = CGCreateNewInst("mov", "i", tmp);
+        CGCreateSimpleStore(sp_il, 4, imm_il);
+
+        imm_il = CGCreateNewInst("mov", "i", (int) pcgCurrentMethod);
+        CGCreateSimpleStore(sp_il, 8, imm_il);
+
+        imm_il = CGCreateNewInst("mov", "i",
+                                 (int) pcgCurrentMethod->clazz->pDvmDex);
+        CGCreateSimpleStore(sp_il, 12, imm_il);
+
+        CGInst parm_edi = pcg_gen_vmptr_mov();
+        CGInst parm_ebp = pcg_gen_frameptr_mov();
+        CGInst parms_2[3] = {parm_edi, parm_ebp, CGInstInvalid};
+        CGInst the_call = CGCreateNewInst("icall", "nl",
+                                          dvmFindInterfaceMethodInCacheSymbol,
+                                          parms_2);
+        CGSetRreg(the_call, "eax");
+
+        sp_il = CGCreateNewInst("add", "ri", CGGetStackPointerDef(), 16);
+        CGSetRreg(sp_il, "esp");
+
+        CGInst ret_val = CGCreateNewInst("mov", "r", the_call);
+        CGAddTempDef(methodTemp, ret_val);
+
+        //
+        // if dvmFindInterfaceMethodInCache returns NULL, throw exception
+        // otherwise, jump to .find_interface_done
+        //
+        CGLabel find_interface_done_label = CGCreateLabel();
+        CGInst zero = CGCreateNewInst("mov", "i", 0);
+        CGCreateNewInst("cjcc", "rcrb", ret_val, "ne", zero,
+                        find_interface_done_label);
+
+        pcgExportPC();
+        pcgJsrdvmJitToExceptionThrown();
+
+        CGBindLabel(find_interface_done_label);
+
+        taken_target =
+            CGCreateNewInst("movltc", "n", pcgGetInvokeTarget(traceTakenId));
+        CGInst predicted_method = CGCreateSimpleLoad(taken_target,
+                                              offChainingCell_method);
+        CGInst chaining_cell = CGCreateSimpleLoad(taken_target,
+                                                  offChainingCell_clazz);
+        zero = CGCreateNewInst("mov", "i", 0);
+        CGInst self_pointer = pcg_get_self_pointer();
+        CGInst rechain_count_il =
+            CGCreateSimpleLoad(self_pointer,
+                               offsetof(Thread, icRechainCount));
+        CGInst count_minus_one =
+            CGCreateNewInst("sub", "ri", rechain_count_il, 1);
+
+        CGInst select_1 = CGCreateNewInst("islcc", "rcrrr", zero, "ne",
+                                          chaining_cell,
+                                          count_minus_one, zero);
+        CGInst select_2 = CGCreateNewInst("islcc", "rcrrr", zero, "ne",
+                                          chaining_cell,
+                                          count_minus_one, rechain_count_il);
+
+        CGCreateSimpleStore(self_pointer, offsetof(Thread, icRechainCount),
+                            select_2);
+
+        CGLabel skip_prediction_label = CGCreateLabel();
+        zero = CGCreateNewInst("mov", "i", 0);
+        CGCreateNewInst("cjcc", "rcrb", select_1, "sgt", zero,
+                        skip_prediction_label);
+
+        //
+        // call dvmJitToPatchPredictedChain to update predicted method.
+        // set up arguments for dvmJitToPatchPredictedChain.
+        //
+        // ESP = ESP - 16
+        //
+        // get thisPtr->clazz
+        sp_il = CGCreateNewInst("sub", "ri", CGGetStackPointerDef(), 16);
+        CGSetRreg(sp_il, "esp");
+        CGCreateSimpleStore(sp_il, 0, ret_val);
+        CGCreateSimpleStore(sp_il, 4, self_pointer);
+        CGCreateSimpleStore(sp_il, 8, taken_target);
+        CGCreateSimpleStore(sp_il, 12, clazz);
+        parm_edi = pcg_gen_vmptr_mov();
+        parm_ebp = pcg_gen_frameptr_mov();
+        CGInst parms[3] = {parm_edi, parm_ebp, CGInstInvalid};
+        the_call = CGCreateNewInst("icall", "nl",
+                                   dvmJitToPatchPredictedChainSymbol,
+                                   parms);
+        CGSetRreg(the_call, "eax");
+
+        // ESP = ESP + 16
+        sp_il = CGCreateNewInst("add", "ri", CGGetStackPointerDef(), 16);
+        CGSetRreg(sp_il, "esp");
+
+        // callee method in %ecx for invoke virtual
+        ret_val = CGCreateNewInst("mov", "r", the_call);
+        CGAddTempDef(methodTemp, ret_val);
+
+        CGBindLabel(skip_prediction_label);
+
+        pcg_common_invoke_method_jmp(ArgsDone_Full,
+                                     CGGetTempUseInst(methodTemp));
+    } //     if(isInterface) {
+    else { 
+        // predicted_chain_virtual_O1(IMMC);
+        CGInst self_pointer = pcg_get_self_pointer();
+        CGInst zero = CGCreateNewInst("mov", "i", 0);
+        CGInst rechain_count =
+            CGCreateSimpleLoad(self_pointer, offsetof(Thread, icRechainCount));
+        CGInst rechain_count_copy = CGCreateNewInst("mov", "r", rechain_count);
+        rechain_count = CGCreateNewInst("sub", "ri", rechain_count, 1);
+
+        CGInst select_1 = CGCreateNewInst("islcc", "rcrrr", zero, "ne",
+                                          predicted_clazz,
+                                          rechain_count, zero);
+        CGInst select_2 = CGCreateNewInst("islcc", "rcrrr", zero, "ne",
+                                          predicted_clazz,
+                                          rechain_count, rechain_count_copy);
+
+        // get thisPtr->clazz
+        CGInst clazz = CGCreateSimpleLoad(inputReg, offObject_clazz);
+        CGInst vtable =
+            CGCreateSimpleLoad(clazz, offClassObject_vtable);
+
+        CGInst immc  = CGCreateSimpleLoad(vtable, IMMC);
+        CGAddTempDef(methodTemp, immc);
+
+        CGCreateSimpleStore(self_pointer, offsetof(Thread, icRechainCount),
+                            select_2);
+
+        CGLabel skip_prediction_label = CGCreateLabel();
+        CGCreateNewInst("cjcc", "rcrb", select_1, "sgt", zero,
+                        skip_prediction_label);
+
+        //
+        // call dvmJitToPatchPredictedChain to update predicted method.
+        // set up arguments for dvmJitToPatchPredictedChain.
+        //
+        // ESP = ESP - 16
+        //
+        CGInst taken_target =
+            CGCreateNewInst("movltc", "n", pcgGetInvokeTarget(traceTakenId));
+
+        CGInst sp_il =
+            CGCreateNewInst("sub", "ri", CGGetStackPointerDef(), 16);
+        CGSetRreg(sp_il, "esp");
+        CGCreateSimpleStore(sp_il, 0, immc);
+        CGCreateSimpleStore(sp_il, 4, self_pointer);
+        CGCreateSimpleStore(sp_il, 8, taken_target);
+        CGCreateSimpleStore(sp_il, 12, clazz);
+        CGInst parm_edi = pcg_gen_vmptr_mov();
+        CGInst parm_ebp = pcg_gen_frameptr_mov();
+        CGInst parms[3] = {parm_edi, parm_ebp, CGInstInvalid};
+        CGInst the_call = CGCreateNewInst("icall", "nl",
+                                          dvmJitToPatchPredictedChainSymbol,
+                                          parms);
+        CGSetRreg(the_call, "eax");
+
+        // ESP = ESP + 16
+        sp_il = CGCreateNewInst("add", "ri", CGGetStackPointerDef(), 16);
+        CGSetRreg(sp_il, "esp");
+
+        // callee method in %ecx for invoke virtual
+        CGInst ret_val = CGCreateNewInst("mov", "r", the_call);
+
+        CGAddTempDef(methodTemp, ret_val);
+
+        CGBindLabel(skip_prediction_label);
+
+        pcg_common_invoke_method_jmp(ArgsDone_Full,
+                                     CGGetTempUseInst(methodTemp));
+    }
+
+    CGBindLabel(invoke_chain_label);
+
+    taken_target =
+        CGCreateNewInst("movltc", "n", pcgGetInvokeTarget(traceTakenId));
+
+    pcg_common_invoke_method_jmp(ArgsDone_Normal, predicted_method);
+}
+
+static void pcgTranslateInvokeVirtualQuick(MIR *mir)
+{
+    if (mir->OptimizationFlags & MIR_INLINED) {
+        return;
+    }
+
+    pcgExportPC();
+
+    CGInst C = pcgGetVirtualReg(mirUse(mir, 0), "mov", 4);
+    CGInst zero = CGCreateNewInst("mov", "i", 0);
+    CGLabel not_null = CGCreateLabel();
+    CGCreateNewInst("cjcc", "rcrb", C, "ne", zero,
+                    not_null);
+    CGInst parm_edi = pcg_gen_vmptr_mov();
+    CGInst parm_ebp = pcg_gen_frameptr_mov();
+    CGInst parms[3] = {parm_edi, parm_ebp, CGInstInvalid};
+    CGCreateJsr(common_errNullObjectSymbol, parms);
+    CGBindLabel(not_null);
+    
+    //
+    // constVREndOfBB
+    // beforeCall
+    // ZZZ:JIT does the above. I believe these are just internal RA
+    // optimizations. Temporarily writing these down in case we
+    // see problems with this.
+    //
+    pcg_gen_predicted_chain(-1, (mir_vB(mir) * 4), false, C, mir);
+}
+
+ArgsDoneType pcgConvertCalleeToType(const Method* calleeMethod)
+{
+    if (calleeMethod == NULL) {
+        return ArgsDone_Full;
+    }
+
+    if (dvmIsNativeMethod(calleeMethod)) {
+        return ArgsDone_Native;
+    }
+
+    return ArgsDone_Normal;
+}
+
+static void pcgTranslateInvokeStaticSuperQuick(MIR *mir, Opcode dalvikOpCode)
+{
+    const Method *calleeMethod;
+
+    if (mir->OptimizationFlags & MIR_INLINED) {
+        return;
+    }
+
+    pcgExportPC();
+
+    if (dalvikOpCode == OP_INVOKE_STATIC ||
+        dalvikOpCode == OP_INVOKE_STATIC_RANGE) {
+        u2 tmp = mir_vB(mir);
+
+        // method is already resolved in trace-based JIT
+        calleeMethod =
+            pcgCurrentMethod->clazz->pDvmDex->pResMethods[tmp];
+    }
+    else {
+        //
+        // ZZZ TODO : hmmm. do you really need this? Original code has this,
+        // but vC is never used.. Leaving it out, for now.
+        //
+        // C = pcgGetVirtualReg(mir_vC(mir), "mov", 4);
+        // pcgSimpleNullCheck(C);
+
+        // for trace-based JIT, callee is already resolved
+        u2 IMMC = 4 * mir_vB(mir);
+        int mIndex = IMMC/4;
+        calleeMethod =
+            pcgCurrentMethod->clazz->super->vtable[mIndex];
+    }
+
+    CGInst method_il = CGCreateNewInst("mov", "i", (int) calleeMethod);
+
+    ArgsDoneType method_type = pcgConvertCalleeToType(calleeMethod);
+
+    pcgStoreInvokeArgs(mir);
+    pcg_common_invoke_method_jmp(method_type, method_il);
+}
+
+static void pcgTranslateInvokeInterface(MIR *mir)
+{
+    int ssaNum = mirUse(mir, 0);
+    u2 tmp = mir->dalvikInsn.vB;
+
+    if (mir->OptimizationFlags & MIR_INLINED) {
+        return;
+    }
+
+    pcgExportPC();
+    CGInst C = pcgGetVirtualReg(ssaNum, "mov", 4);
+    pcgSimpleNullCheck(C);
+    pcg_gen_predicted_chain(tmp, -1, true, C, mir);
+}
+
+static void pcgTranslateInvokeDirect(MIR *mir)
+{
+    u2 tmp = mir_vB(mir);
+    int vC = mirUse(mir, 0);
+
+    pcgExportPC();
+    CGInst C = pcgGetVirtualReg(vC, "mov", 4);
+    pcgSimpleNullCheck(C);
+
+    const Method *calleeMethod =
+        pcgCurrentMethod->clazz->pDvmDex->pResMethods[tmp];
+
+    // TODO - This is an optimization opportunity.  We know the address of the
+    //        target.  We should be able to branch to it directly.
+    CGInst method_il = CGCreateNewInst("mov", "i", calleeMethod);
+    ArgsDoneType method_type = pcgConvertCalleeToType(calleeMethod);
+
+    pcgStoreInvokeArgs(mir);
+    pcg_common_invoke_method_jmp(method_type, method_il);
+}
+
+static void pcgTranslateReturn(MIR *mir, bool is_void)
+{
+    CGInst self_il = pcg_get_self_pointer();
+
+    if (!is_void) {
+        int ssaNum = mirUse(mir, 0);
+        pcgDtype resDtype = pcgGetDtypeForSSANum(ssaNum);
+        const char *pcgOpcode;
+        int32_t dtypeSize = getOpcodeAndSizeForDtype(resDtype, &pcgOpcode);
+
+        //
+        // self->interpSave.retval = vA
+        //
+        int32_t offset = offsetof(Thread, interpSave.retval);
+
+        CGInst A = pcgGetVirtualReg(ssaNum, pcgOpcode, dtypeSize);
+        CGAddr addr = CGCreateAddr(self_il, CGInstInvalid, 0,
+                                   CGSymbolInvalid, offset);
+        CGCreateNewInst(pcgOpcode, "mr", addr, dtypeSize, (void*)1, A);
+    }
+
+    CGInst save_area_il = CGCreateNewInst("mov", "r", pcgVmPtr);
+    save_area_il = CGCreateNewInst("add", "ri", save_area_il,
+                                       -sizeofStackSaveArea);
+    CGSetRreg(save_area_il, "edx");
+
+    CGInst prev_frame_il =
+        CGCreateSimpleLoad(pcgVmPtr,
+                           offStackSaveArea_prevFrame -
+                           sizeofStackSaveArea);
+    CGSetRreg(prev_frame_il, "edi");
+
+    self_il = pcg_get_self_pointer();
+    CGSetRreg(self_il, "ecx");
+
+    CGInst parm_ebp = pcg_gen_frameptr_mov();
+
+    CGInst parms[5] = {parm_ebp, self_il, save_area_il, prev_frame_il,
+                       CGInstInvalid};
+    CGSymbol target = pcgNameToSymbolMap["dvmJitHelper_returnFromMethod"];
+    CGCreateJsr(target, parms);
+    return;
+}
+
+static void pcgTranslateMove(MIR *mir)
+{
+    bool srcIsFloat = false;
+    bool dstIsFloat = false;
+    const char *srcOpcode = "mov";
+    const char *dstOpcode = "mov";
+
+    if (pcgGetDtypeForSSANum(mirUse(mir, 0)) == VXreg32) {
+        srcIsFloat = true;
+        srcOpcode = "movss1";
+    }
+
+    CGInst B = pcgGetVirtualReg(mirUse(mir, 0), srcOpcode, 4);
+
+    if (pcgGetDtypeForSSANum(mirDef(mir, 0)) == VXreg32) {
+        dstIsFloat = true;
+        dstOpcode = "movss1";
+    }
+
+    // Do a conversion if the types mismatch.
+    if (!dstIsFloat && srcIsFloat) {
+        B = CGCreateNewInst("movss1dti", "r", B);
+    }
+    if (dstIsFloat && !srcIsFloat) {
+        B = CGCreateNewInst("emovdfi", "r", B);
+        B = CGCreateNewInst("movss2ss1", "r", B);
+    }
+
+    pcgSetVirtualReg(mirDef(mir, 0), dstOpcode, 4, B);
+}
+
+static void pcgTranslateMoveWide(MIR *mir)
+{
+    bool srcIsDouble = false;
+    bool dstIsDouble = false;
+    const char *srcOpcode = "lmov";
+    const char *dstOpcode = "lmov";
+
+    if (pcgGetDtypeForSSANum(mirUse(mir, 0)) == DPVXreg64) {
+        srcIsDouble = true;
+        srcOpcode = "movsd1";
+    }
+
+    CGInst B = pcgGetVirtualReg(mirUse(mir, 0), srcOpcode, 8);
+
+    if (pcgGetDtypeForSSANum(mirDef(mir, 0)) == DPVXreg64) {
+        dstIsDouble = true;
+        dstOpcode = "movsd1";
+    }
+
+    // Do a conversion if the types mismatch.
+    if (!dstIsDouble && srcIsDouble) {
+        B = CGCreateNewInst("movsd1dtl", "r", B);
+    }
+    if (dstIsDouble && !srcIsDouble) {
+        B = CGCreateNewInst("emovdfi", "r", B);
+        B = CGCreateNewInst("movsd2sd1", "r", B);
+    }
+
+    pcgSetVirtualReg(mirDef(mir, 0), dstOpcode, 8, B);
+}
+
+static void pcgMoveException(MIR *mir)
+{
+    CGInst self = pcg_get_self_pointer();
+    CGInst exception = CGCreateSimpleLoad(self, offThread_exception);
+    CGCreateSimpleStore(self, offThread_exception,
+                        CGCreateNewInst("mov", "i", 0));
+    pcgSetVirtualReg(mirDef(mir, 0), "mov", 4, exception);
+}
+
+static void pcgThrow(MIR *mir)
+{
+    // For now, just punt to interpreter
+    CGInst parm_edi = pcg_gen_vmptr_mov();
+    CGInst parm_ebp = pcg_gen_frameptr_mov();
+    CGInst parms[3] = {parm_edi, parm_ebp, CGInstInvalid};
+    CGCreateJsr(pcgJitToInterpPuntSymbol, parms);
+}
+
+static void pcgTranslateConstHelper(MIR *mir, u4 val)
+{
+    bool isFloat = false;
+
+    if (pcgGetDtypeForSSANum(mirDef(mir, 0)) == VXreg32) {
+        isFloat = true;
+    }
+
+    if (isFloat) {
+        // TODO: We need to use a more "official" method for creating the
+        // FP constant in memory.
+        //
+        u4 *myConstPtr = (u4*)malloc(sizeof(u4));
+        *myConstPtr = val;
+        CGAddr addr = CGCreateAddr(CGInstInvalid, CGInstInvalid, 0,
+                                   CGSymbolInvalid, (int32_t)myConstPtr);
+        CGInst const_mov = CGCreateNewInst("movss1", "m", addr, 4,
+                                           (void*)1);
+        pcgSetVirtualReg(mirDef(mir, 0), "movss1", 4, const_mov);
+        return;
+    }
+
+    CGInst movi = CGCreateNewInst("mov", "i", val);
+    pcgSetVirtualReg(mirDef(mir, 0), "mov", 4, movi);
+}
+
+static void pcgTranslateConst(MIR *mir)
+{
+    pcgTranslateConstHelper(mir, mir_vB(mir));
+}
+
+static void pcgTranslateConst16(MIR *mir)
+{
+    pcgTranslateConstHelper(mir, (s2)mir_vB(mir));
+}
+
+static void pcgTranslateConst4(MIR *mir)
+{
+    pcgTranslateConstHelper(mir, mir_vB(mir));
+}
+
+static void pcgTranslateConstHigh16(MIR *mir)
+{
+    pcgTranslateConstHelper(mir, ((s4)mir_vB(mir)) << 16);
+}
+
+static void pcgTranslateConstWideHelper(MIR *mir, u8 val)
+{
+    bool isDouble = false;
+
+    if (pcgGetDtypeForSSANum(mirDef(mir, 0)) == DPVXreg64) {
+        isDouble = true;
+    }
+
+    if (isDouble) {
+        // TODO: We need to use a more "official" method for creating the
+        // FP constant in memory.
+        //
+        u8 *myConstPtr = (u8*)malloc(sizeof(u8));
+        *myConstPtr = val;
+        CGAddr addr = CGCreateAddr(CGInstInvalid, CGInstInvalid, 0,
+                                   CGSymbolInvalid, (int32_t)myConstPtr);
+        CGInst const_mov = CGCreateNewInst("movsd1", "m", addr, 8,
+                                           (void*)1);
+        pcgSetVirtualReg(mirDef(mir, 0), "movsd1", 8, const_mov);
+        return;
+    }
+
+    CGInst movi = CGCreateNewInst("lmov", "j", val);
+    pcgSetVirtualReg(mirDef(mir, 0), "lmov", 8, movi);
+}
+
+static void pcgTranslateConstString(MIR *mir)
+{
+    u4 tmp = mir_vB(mir);
+    void *strPtr = (void*)(pcgCurrentMethod->clazz->pDvmDex->pResStrings[tmp]);
+    assert(strPtr != NULL);
+
+    CGInst str_inst = CGCreateNewInst("mov", "i", (int32_t)strPtr);
+    pcgSetVirtualReg(mirDef(mir, 0), "mov", 4, str_inst);
+}
+
+static void pcgTranslate2addrLLreg(MIR *mir, const char *pcg_opcode)
+{
+    CGInst A = pcgGetVirtualReg(mirUse(mir, 0), "lmov", 8);
+    CGInst B = pcgGetVirtualReg(mirUse(mir, 2), "lmov", 8);
+    CGInst op = CGCreateNewInst(pcg_opcode, "rr", A, B);
+    pcgSetVirtualReg(mirDef(mir, 0), "lmov", 8, op);
+}
+
+static void pcgTranslate3addrLLreg(MIR *mir, const char *pcg_opcode)
+{
+    CGInst B = pcgGetVirtualReg(mirUse(mir, 0), "lmov", 8);
+    CGInst C = pcgGetVirtualReg(mirUse(mir, 2), "lmov", 8);
+    CGInst op = CGCreateNewInst(pcg_opcode, "rr", B, C);
+    pcgSetVirtualReg(mirDef(mir, 0), "lmov", 8, op);
+}
+
+static void pcgLLregOp(const char *pcgOpcode, int ssaA, int ssaB)
+{
+    CGInst B = pcgGetVirtualReg(ssaB, "lmov", 8);
+    CGInst op = CGCreateNewInst(pcgOpcode, "r", B);
+    pcgSetVirtualReg(ssaA, "lmov", 8, op);
+}
+
+static void pcgTranslateLLregShift(MIR *mir, const char *pcg_opcode)
+{
+    CGInst B = pcgGetVirtualReg(mirUse(mir, 0), "lmov", 8);
+    CGInst C = pcgGetVirtualReg(mirUse(mir, 2), "mov", 4);
+    CGInst op = CGCreateNewInst(pcg_opcode, "rr", B, C);
+    pcgSetVirtualReg(mirDef(mir, 0), "lmov", 8, op);
+}
+
+static void pcgTranslate2addrFloat(MIR *mir, const char *pcg_opcode)
+{
+    CGInst A = pcgGetVirtualReg(mirUse(mir, 0), "movss1", 4);
+    CGInst B = pcgGetVirtualReg(mirUse(mir, 1), "movss1", 4);
+    CGInst op = CGCreateNewInst(pcg_opcode, "rr", A, B);
+    pcgSetVirtualReg(mirDef(mir, 0), "movss1", 4, op);
+}
+
+static void pcgTranslate3addrFloat(MIR *mir, const char *pcg_opcode)
+{
+    CGInst B = pcgGetVirtualReg(mirUse(mir, 0), "movss1", 4);
+    CGInst C = pcgGetVirtualReg(mirUse(mir, 1), "movss1", 4);
+    CGInst op = CGCreateNewInst(pcg_opcode, "rr", B, C);
+    pcgSetVirtualReg(mirDef(mir, 0), "movss1", 4, op);
+}
+
+static void pcgTranslate2addrDouble(MIR *mir, const char *pcg_opcode)
+{
+    CGInst A = pcgGetVirtualReg(mirUse(mir, 0), "movsd1", 8);
+    CGInst B = pcgGetVirtualReg(mirUse(mir, 2), "movsd1", 8);
+    CGInst op = CGCreateNewInst(pcg_opcode, "rr", A, B);
+    pcgSetVirtualReg(mirDef(mir, 0), "movsd1", 8, op);
+}
+
+static void pcgTranslate3addrDouble(MIR *mir, const char *pcg_opcode)
+{
+    CGInst B = pcgGetVirtualReg(mirUse(mir, 0), "movsd1", 8);
+    CGInst C = pcgGetVirtualReg(mirUse(mir, 2), "movsd1", 8);
+    CGInst op = CGCreateNewInst(pcg_opcode, "rr", B, C);
+    pcgSetVirtualReg(mirDef(mir, 0), "movsd1", 8, op);
+}
+
+static void pcgTranslateIntToFP(MIR *mir, int32_t size)
+{
+    const char *pcg_cvt_opcode;
+    const char *pcg_mov_opcode;
+
+    if (size == 8) {
+        pcg_cvt_opcode = "cvtsi2sd1";
+        pcg_mov_opcode = "movsd1";
+    }
+    else {
+        pcg_cvt_opcode = "cvtsi2ss1";
+        pcg_mov_opcode = "movss1";
+    }
+
+    CGInst B = pcgGetVirtualReg(mirUse(mir, 0), "mov", 4);
+    CGInst cvt = CGCreateNewInst(pcg_cvt_opcode, "r", B);
+    pcgSetVirtualReg(mirDef(mir, 0), pcg_mov_opcode, size, cvt);
+}
+
+static void pcgTranslateLongToFP(MIR *mir, int32_t size)
+{
+    const char *pcg_cvt1_opcode;
+    const char *pcg_cvt2_opcode;
+    const char *pcg_mov_opcode;
+
+    // We have to use x87 for the conversions, because on IA-32, there are no
+    // SSE/SSE2 conversions involving 64-bit integers.
+    //
+    if (size == 8) {
+        pcg_cvt1_opcode = "f64ild64";
+        pcg_cvt2_opcode = "movf2sd1";
+        pcg_mov_opcode = "movsd1";
+    }
+    else {
+        pcg_cvt1_opcode = "f32ild64";
+        pcg_cvt2_opcode = "movf2ss1";
+        pcg_mov_opcode = "movss1";
+    }
+
+    CGInst B = pcgGetVirtualReg(mirUse(mir, 0), "lmov", 8);
+    CGInst cvt1 = CGCreateNewInst(pcg_cvt1_opcode, "r", B);
+    CGInst cvt2 = CGCreateNewInst(pcg_cvt2_opcode, "r", cvt1);
+    pcgSetVirtualReg(mirDef(mir, 0), pcg_mov_opcode, size, cvt2);
+}
+
+// The semantics of the FP to integer conversions are as follows.  For input
+// value x, there are 4 possibilities:
+//
+// (1) For NaN values of x, the result is 0
+// (2) For x > 0x7fffffff, the result is 0x7fffffff
+// (3) For x < 0x80000000, the result is 0x80000000.
+// (4) For other values of x, the result is rounded toward zero.
+//
+static void pcgTranslateFPToInt(MIR *mir, int32_t size)
+{
+    static double double_max_int32 = (double)0x7fffffff;
+    static float float_max_int32 = (float)0x7fffffff;
+    CGLabel end_label = CGCreateLabel();
+    CGLabel nan_or_max_label = CGCreateLabel();
+    const char *pcg_mov_opcode;
+    const char *pcg_cvt_opcode;
+    int32_t max_int32_addr;
+
+    if (size == 8) {
+        pcg_mov_opcode = "movsd1";
+        pcg_cvt_opcode = "cvttsd2si";
+        max_int32_addr = (int32_t)&double_max_int32;
+    }
+    else {
+        pcg_mov_opcode = "movss1";
+        pcg_cvt_opcode = "cvttss2si";
+        max_int32_addr = (int32_t)&float_max_int32;
+    }
+
+    // If the input value is <= 0x7fffffff, we can use a simple cvttsd2si
+    // instruction to do the conversion.  Note that cvttsd2si has the desired
+    // behavior if the input value is < 0x80000000.  It sets the result to
+    // 0x80000000 in that case.  (It does signal invalid, though.  Do we care?)
+    //
+    CGInst B = pcgGetVirtualReg(mirUse(mir, 0), pcg_mov_opcode, size);
+    CGAddr addr = CGCreateAddr(CGInstInvalid, CGInstInvalid, 0,
+                               CGSymbolInvalid, max_int32_addr);
+    CGInst max_int32_inst = CGCreateNewInst(pcg_mov_opcode, "m", addr,
+                                            size, (void*)1);
+    CGCreateNewInst("cjcc", "rcrb", B, "ufnle", max_int32_inst,
+                    nan_or_max_label);
+    CGInst cvt = CGCreateNewInst(pcg_cvt_opcode, "r", B);
+    pcgSetVirtualReg(mirDef(mir, 0), "mov", 4, cvt);
+    CGCreateNewInst("jmp", "b", end_label);
+
+    // Handle large positive values and NaN values here.
+    CGBindLabel(nan_or_max_label);
+    CGInst nan_result = CGCreateNewInst("mov", "i", 0);
+    CGInst max_result = CGCreateNewInst("mov", "i", 0x7fffffff);
+    CGInst result = CGCreateNewInst("islcc", "rcrrr", B, "ufgt",
+                                    max_int32_inst, max_result, nan_result);
+    pcgSetVirtualReg(mirDef(mir, 0), "mov", 4, result);
+
+    CGBindLabel(end_label);
+}
+
+static void pcgTranslateFloatToDouble(MIR *mir)
+{
+    CGInst B = pcgGetVirtualReg(mirUse(mir, 0), "movss1", 4);
+    CGInst cvt = CGCreateNewInst("cvtss2sd1", "r", B);
+    pcgSetVirtualReg(mirDef(mir, 0), "movsd1", 8, cvt);
+}
+
+static void pcgTranslateDoubleToFloat(MIR *mir)
+{
+    CGInst B = pcgGetVirtualReg(mirUse(mir, 0), "movsd1", 8);
+    CGInst cvt = CGCreateNewInst("cvtsd2ss1", "r", B);
+    pcgSetVirtualReg(mirDef(mir, 0), "movss1", 4, cvt);
+}
+
+static void pcgTranslateNegDouble(MIR *mir)
+{
+    __attribute__((aligned(16))) static u8 sign[2] = {0x8000000000000000, 0};
+
+    // This method of just reading sign from the above static variable is
+    // probably not the best idea, but it should work for now.
+    // TODO Revisit this implementation.
+    //
+    CGInst B = pcgGetVirtualReg(mirUse(mir, 0), "movsd1", 8);
+    CGAddr sign_addr = CGCreateAddr(CGInstInvalid, CGInstInvalid, 0,
+                                    CGSymbolInvalid, (int32_t)&sign);
+    CGInst neg = CGCreateNewInst("xorpd1", "rm", B, sign_addr, 16, (void*)1);
+    pcgSetVirtualReg(mirDef(mir, 0), "movsd1", 8, neg);
+}
+
+//
+// vA = vB <op> vC
+//
+static void pcgIntOpOp(const char *pcg_opcode, int vA, int vB, int vC)
+{
+    CGInst B = pcgGetVirtualReg(vB, "mov", 4);
+    CGInst C = pcgGetVirtualReg(vC, "mov", 4);
+
+    CGInst op = CGCreateNewInst(pcg_opcode, "rr", B, C);
+
+    pcgSetVirtualReg(vA, "mov", 4, op);
+}
+
+static void pcgIntOpLit(const char *pcg_opcode, int vA, int vB, s2 literal)
+{
+    CGInst B = pcgGetVirtualReg(vB, "mov", 4);
+    CGInst op = CGCreateNewInst(pcg_opcode, "ri", B, literal);
+    pcgSetVirtualReg(vA, "mov", 4, op);
+}
+
+static void pcgTranslateRsubIntLit8(MIR *mir)
+{
+    s4 literal = (s1)mir_vC(mir);
+    CGInst A = CGCreateNewInst("mov", "i", literal);
+    CGInst B = pcgGetVirtualReg(mirUse(mir, 0), "mov", 4);
+    CGInst sub = CGCreateNewInst("sub", "rr", A, B);
+    pcgSetVirtualReg(mirDef(mir, 0), "mov", 4, sub);
+}
+
+static void pcgIntOp(const char *pcg_opcode, int vA, int vB)
+{
+    CGInst B = pcgGetVirtualReg(vB, "mov", 4);
+    CGInst op = CGCreateNewInst(pcg_opcode, "r", B);
+    pcgSetVirtualReg(vA, "mov", 4, op);
+}
+
+static void pcgConditionalJump(CGInst a, const char *cond, CGInst b)
+{
+    CGLabel target_label =  pcgBlockInfo[pcgCurrentBB->id].taken_label;
+    int branch_prob = 50;
+
+    if (pcgBlockInfo[pcgCurrentBB->taken->id].block_type ==
+        kChainingCellBackwardBranch) {
+        branch_prob = 90;
+    }
+    else if (pcgBlockInfo[pcgCurrentBB->fallThrough->id].block_type ==
+        kChainingCellBackwardBranch) {
+        branch_prob = 10;
+    }
+
+    CGCreateNewInst("cjcc", "rcrbp", a, cond, b, target_label, branch_prob);
+}
+
+static void pcgTranslateIf(MIR *mir, const char *cond)
+{
+    CGInst A = pcgGetVirtualReg(mirUse(mir, 0), "mov", 4);
+    CGInst B = pcgGetVirtualReg(mirUse(mir, 1), "mov", 4);
+    pcgConditionalJump(A, cond, B);
+}
+
+static void pcgTranslateIfZero(MIR *mir, const char *cond)
+{
+    // HACK! We currently set this flag when we combine an FP compare with a
+    // subsequent ifz.  We need a real flag or some other better mechanism.
+    //
+    if (mir->OptimizationFlags & MIR_IGNORE_NULL_CHECK) {
+        return;
+    }
+
+    CGInst A = pcgGetVirtualReg(mirUse(mir, 0), "mov", 4);
+    CGInst zero = CGCreateNewInst("mov", "i", 0);
+    pcgConditionalJump(A, cond, zero);
+}
+
+static void pcgTranslateIntExtend(MIR *mir, const char *pcg_opcode, int imm)
+{
+    CGInst B = pcgGetVirtualReg(mirUse(mir, 0), "mov", 4);
+    CGInst sext = CGCreateNewInst(pcg_opcode, "ri", B, imm);
+    pcgSetVirtualReg(mirDef(mir, 0), "mov", 4, sext);
+}
+
+static void pcgTranslateIntToLong(MIR *mir)
+{
+    CGInst B = pcgGetVirtualReg(mirUse(mir, 0), "mov", 4);
+    CGInst lsext = CGCreateNewInst("lsext", "ri", B, 32);
+    pcgSetVirtualReg(mirDef(mir, 0), "lmov", 8, lsext);
+}
+
+static void pcgTranslateLongToInt(MIR *mir)
+{
+    CGInst B = pcgGetVirtualReg(mirUse(mir, 0), "lmov", 8);
+    CGInst xtract = CGCreateNewInst("xtract", "r", B);
+    pcgSetVirtualReg(mirDef(mir, 0), "mov", 4, xtract);
+}
+
+static void pcgTranslateCmpLong(MIR *mir)
+{
+    CGLabel neg_one_label = CGCreateLabel();
+    CGLabel one_label = CGCreateLabel();
+    CGLabel end_label = CGCreateLabel();
+    CGTemp result_temp = pcgNextTemp++;
+
+    CGInst B = pcgGetVirtualReg(mirUse(mir, 0), "lmov", 8);
+    CGInst C = pcgGetVirtualReg(mirUse(mir, 2), "lmov", 8);
+    CGCreateNewInst("lcjcc", "rcrbp", B, "slt", C, neg_one_label, 40);
+    CGCreateNewInst("lcjcc", "rcrbp", B, "sgt", C, one_label, 60);
+    CGInst zero = CGCreateNewInst("mov", "i", 0);
+    CGAddTempDef(result_temp, zero);
+    CGCreateNewInst("jmp", "b", end_label);
+    CGBindLabel(one_label);
+    CGInst one = CGCreateNewInst("mov", "i", 1);
+    CGAddTempDef(result_temp, one);
+    CGCreateNewInst("jmp", "b", end_label);
+    CGBindLabel(neg_one_label);
+    CGInst neg_one = CGCreateNewInst("mov", "i", -1);
+    CGAddTempDef(result_temp, neg_one);
+    CGBindLabel(end_label);
+    pcgSetVirtualReg(mirDef(mir, 0), "mov", 4, CGGetTempUseInst(result_temp));
+}
+
+static void pcgTranslateDivRemInt(MIR *mir, Opcode dalvikOpCode, u2 vA, u2 vB,
+                                  u2 vC)
+{
+    const char *pcg_opcode;
+    const char *pcg_opcode_b;
+    const char *divb_res;
+    u4 special_result;  // This is the defined result for 0x80000000 / -1
+
+    if (dalvikOpCode == OP_DIV_INT ||
+        dalvikOpCode == OP_DIV_INT_2ADDR) {
+        pcg_opcode = "idiv";
+        pcg_opcode_b = "divb";
+        divb_res = "al";
+        special_result = 0x80000000;
+    }
+    else {
+        pcg_opcode = "irem";
+        pcg_opcode_b = "remb";
+        divb_res = "ah";
+        special_result = 0;
+    }
+
+    // The division expansion is fairly complex.  It implements the following
+    // logic.
+    // if (C == 0) {
+    //     throw_divide_by_zero();
+    // }
+    // else if (((B | C) & 0xffffff00) == 0) {
+    //     r = B [byte /] C
+    // }
+    // else if (C == -1 && B == 0x80000000) {
+    //     r = special_result;
+    // }
+    // else {
+    //     r = B / C;
+    // }
+    //
+
+    CGLabel zero_check_ok = CGCreateLabel();
+    CGInst B = pcgGetVirtualReg(mirUse(mir, 0), "mov", 4);
+    CGInst C = pcgGetVirtualReg(mirUse(mir, 1), "mov", 4);
+    CGInst zero = CGCreateNewInst("mov", "i", 0);
+    CGCreateNewInst("cjcc", "rcrbp", C, "ne", zero, zero_check_ok, 100);
+
+    // Divide by zero.  Issue an error.
+    pcgRaiseException();
+
+    CGBindLabel(zero_check_ok);
+
+    CGLabel code_end = CGCreateLabel();
+    CGLabel special_label_1 = CGCreateLabel();
+    CGLabel special_label_2 = CGCreateLabel();
+    CGLabel div_label = CGCreateLabel();
+    CGTemp result_temp = pcgNextTemp++;
+
+    CGInst or_val = CGCreateNewInst("or", "rr", B, C);
+    CGInst and_val = CGCreateNewInst("and", "ri", or_val, 0xffffff00);
+    CGCreateNewInst("cjcc", "rcrb", and_val, "ne", zero, special_label_1);
+
+    // Do byte div/rem
+    CGInst bext = CGCreateNewInst("bxtract", "r", C);
+    CGInst mov_eax = CGCreateNewInst("mov", "r", B);
+    CGSetRreg(mov_eax, "eax");
+    CGInst divb = CGCreateNewInst(pcg_opcode_b, "rr", mov_eax, bext);
+    CGSetRreg(divb, divb_res);
+    divb = CGCreateNewInst("zext", "ri", divb, 24);
+    CGAddTempDef(result_temp, divb);
+    CGCreateNewInst("jmp", "b", code_end);
+
+    CGBindLabel(special_label_1);
+    CGInst neg_one = CGCreateNewInst("mov", "i", -1);
+    CGCreateNewInst("cjcc", "rcrb", C, "eq", neg_one, special_label_2);
+
+    CGBindLabel(div_label);
+    CGInst div = CGCreateNewInst(pcg_opcode, "rr", B, C);
+    CGAddTempDef(result_temp, div);
+    CGCreateNewInst("jmp", "b", code_end);
+
+    CGBindLabel(special_label_2);
+    CGInst min_int = CGCreateNewInst("mov", "i", 0x80000000);
+    CGCreateNewInst("cjcc", "rcrb", B, "ne", min_int, div_label);
+    CGInst special_val = CGCreateNewInst("mov", "i", special_result);
+    CGAddTempDef(result_temp, special_val);
+
+    CGBindLabel(code_end);
+    pcgSetVirtualReg(mirDef(mir, 0), "mov", 4, CGGetTempUseInst(result_temp));
+}
+
+static void pcgTranslateDivRemIntLit(MIR *mir, Opcode dalvikOpCode, u2 vA,
+                                     u2 vB,
+                                     s2 divisor)
+{
+    const char *pcg_opcode;
+    u4 special_result;  // This is the defined result for 0x80000000 / -1
+
+    if (dalvikOpCode == OP_DIV_INT_LIT8 ||
+        dalvikOpCode == OP_DIV_INT_LIT16) {
+        pcg_opcode = "idiv";
+        special_result = 0x80000000;
+    }
+    else {
+        pcg_opcode = "irem";
+        special_result = 0;
+    }
+
+    if (divisor == 0) {
+        // This needs to raise a divide-by-zero exception.
+        assert(0);
+    }
+
+    CGInst B = pcgGetVirtualReg(mirUse(mir, 0), "mov", 4);
+    CGLabel code_end, special_label, div_label;
+    CGTemp result_temp;
+
+    if (divisor == -1) {
+        // The labels and temp are only needed for the divisor == -1 case.
+        // The generated code implements this logic:
+        // if (B == 0x8000000) {
+        //     r = special_result;
+        // }
+        // else {
+        //     r = B / divisor;
+        // }
+        //
+        special_label = CGCreateLabel();
+        div_label = CGCreateLabel();
+        code_end = CGCreateLabel();
+        result_temp = pcgNextTemp++;
+
+        CGInst min_int = CGCreateNewInst("mov", "i", 0x80000000);
+        CGCreateNewInst("cjcc", "rcrb", B, "eq", min_int, special_label);
+        CGBindLabel(div_label);
+    }
+
+    CGInst C = CGCreateNewInst("mov", "i", divisor);
+    CGInst divrem = CGCreateNewInst(pcg_opcode, "rr", B, C);
+
+    if (divisor == -1) {
+       CGAddTempDef(result_temp, divrem);
+       CGCreateNewInst("jmp", "b", code_end);
+
+       CGBindLabel(special_label);
+       CGInst special_val = CGCreateNewInst("mov", "i", special_result);
+       CGAddTempDef(result_temp, special_val);
+
+       divrem = CGGetTempUseInst(result_temp);
+
+       CGBindLabel(code_end);
+    }
+
+    pcgSetVirtualReg(mirDef(mir, 0), "mov", 4, divrem);
+}
+
+static void pcgTranslateDivRemLong(MIR *mir, Opcode dalvikOpCode,
+                                   u2 vA, u2 vB, u2 vC)
+{
+    const char *pcg_opcode;
+
+    if (dalvikOpCode == OP_DIV_LONG ||
+        dalvikOpCode == OP_DIV_LONG_2ADDR) {
+        pcg_opcode = "lidiv";
+    }
+    else {
+        pcg_opcode = "lirem";
+    }
+
+    // The long division expansion is simpler than the int one.  I suspect
+    // that is because the library routines handle the special denominator
+    // value of -1.  This is the logic:
+    //
+    // if (C == 0) {
+    //     throw_divide_by_zero();
+    // }
+    // else {
+    //     r = B / C;
+    // }
+    //
+
+    CGLabel zero_check_ok = CGCreateLabel();
+    CGInst B = pcgGetVirtualReg(mirUse(mir, 0), "lmov", 8);
+    CGInst C = pcgGetVirtualReg(mirUse(mir, 2), "lmov", 8);
+    CGInst zero = CGCreateNewInst("lmov", "i", 0);
+    CGCreateNewInst("lcjcc", "rcrbp", C, "ne", zero, zero_check_ok, 100);
+
+    // Divide by zero.  Issue an error.
+    pcgRaiseException();
+
+    CGBindLabel(zero_check_ok);
+    CGInst div = CGCreateNewInst(pcg_opcode, "rr", B, C);
+    pcgSetVirtualReg(mirDef(mir, 0), "lmov", 8, div);
+}
+
+static void pcgTranslateIfFp(MIR *mir, uint32_t op_size, int nan_val)
+{
+    const char *pcg_load_opcode;
+    const char *cond1, *cond2;
+
+    if (op_size == 4) {
+        pcg_load_opcode = "movss1";
+    }
+    else {
+        assert(op_size == 8);
+        pcg_load_opcode = "movsd1";
+    }
+
+    if (nan_val == 1) {
+        cond1 = "flt";
+        cond2 = "feq";
+    }
+    else if (nan_val == -1) {
+        cond1 = "fnge";
+        cond2 = "feq";
+    }
+    else {
+        // Currently, this case is never hit.  I am not sure whether there is
+        // an opcode that gives a 0 result for an unordered compare.
+        //
+        assert(nan_val == 0);
+        cond1 = "flt";
+        cond2 = "fequ";
+    }
+
+    // Try to find the branch target.  If the next MIR is an integer compare
+    // and jump, we can short circuit it.
+    MIR *next_mir = mir->next;
+    CGLabel neg_one_label = CGCreateLabel();
+    CGLabel end_label;
+    CGLabel zero_and_one_target;
+    bool short_circuit = false;
+
+    if (next_mir && next_mir->dalvikInsn.opcode == OP_IF_GEZ) {
+        zero_and_one_target = pcgBlockInfo[pcgCurrentBB->id].taken_label;
+        short_circuit = true;
+        // HACK!  We need a real flag for this.
+        next_mir->OptimizationFlags |= MIR_IGNORE_NULL_CHECK;
+    }
+    else {
+        end_label = CGCreateLabel();
+        zero_and_one_target = end_label;
+    }
+
+    int cn = (op_size == 8) ? 2 : 1;
+    CGInst B = pcgGetVirtualReg(mirUse(mir, 0), pcg_load_opcode, op_size);
+    CGInst C = pcgGetVirtualReg(mirUse(mir, cn), pcg_load_opcode, op_size);
+    CGTemp result_temp = pcgNextTemp++;
+
+    CGCreateNewInst("cjcc", "rcrbp", B, cond1, C, neg_one_label, 95);
+    CGInst zero = CGCreateNewInst("mov", "i", 0);
+    CGInst one = CGCreateNewInst("mov", "i", 1);
+    CGInst slcc = CGCreateNewInst("islcc", "rcrrr", B, cond2, C,
+                                  zero, one);
+    CGAddTempDef(result_temp, slcc);
+
+    if (short_circuit) {
+        pcgSetVirtualReg(mirDef(mir, 0), "mov", 4,
+                         CGGetTempUseInst(result_temp));
+    }
+    CGCreateNewInst("jmp", "b", zero_and_one_target);
+
+    CGBindLabel(neg_one_label);
+    CGInst neg_one = CGCreateNewInst("mov", "i", -1);
+    CGAddTempDef(result_temp, neg_one);
+
+    if (short_circuit) {
+        pcgSetVirtualReg(mirDef(mir, 0), "mov", 4,
+                         CGGetTempUseInst(result_temp));
+
+        // At this point, we need a control flow transfer to the fallThrough
+        // block.  That will get added automatically in pcgTranslateBB.
+        //
+    }
+    else {
+        CGBindLabel(end_label);
+        pcgSetVirtualReg(mirDef(mir, 0), "mov", 4,
+                         CGGetTempUseInst(result_temp));
+    }
+}
+
+static void pcgDirectJumpToBlock(int target_block_id)
+{
+    CGCreateNewInst("jmp", "b", pcgBlockInfo[target_block_id].cg_label);
+}
+
+static void pcgTranslateGoto(MIR *mir)
+{
+    CGCreateNewInst("jmp", "b", pcgBlockInfo[pcgCurrentBB->id].taken_label);
+}
+
+static void pcgGenNullCheck(CGInst base, MIR *mir, int ssaNum = -1)
+{
+    if ((mir->OptimizationFlags & MIR_IGNORE_NULL_CHECK) ||
+        (ssaNum != -1 && pcgSSANumInfo[ssaNum].checkedForNull)) {
+        if (DEBUG_REGISTERIZE_VRS()) {
+            printf("    avoiding null check..\n");
+        }
+        return;
+    }
+
+    CGInst zero = CGCreateNewInst("mov", "i", 0);
+    CGLabel null_check_passed_label = CGCreateLabel();
+
+    CGCreateNewInst("cjcc", "rcrbp", base, "ne", zero,
+                    null_check_passed_label, 100);
+
+    // Save the current bytecode PC and jump to the exception block.
+    pcgRaiseException();
+
+    CGBindLabel(null_check_passed_label);
+}
+
+//
+// Null check done in entry block so that it's out of line. Here,
+// we're simply checking to see if we may run into a null pointer,
+// in which case we'll transfer control back to the interpreter
+// to handle.
+//
+static void pcgGenSpeculativeNullCheck(CGInst base)
+{
+    CGInst zero = CGCreateNewInst("mov", "i", 0);
+    CGLabel null_check_passed_label = CGCreateLabel();
+
+    CGCreateNewInst("cjcc", "rcrbp", base, "ne", zero,
+                    null_check_passed_label, 100);
+
+    CGInst parm_edi = pcg_gen_vmptr_mov();
+    CGInst parm_ebp = pcg_gen_frameptr_mov();
+    CGInst parms[3] = {parm_edi, parm_ebp, CGInstInvalid};
+    CGCreateJsr(pcgJitToInterpPuntSymbol, parms);
+
+    CGBindLabel(null_check_passed_label);
+}
+
+//
+// Check to see if "index" is <= base[offArrayObject_length]
+// which holds the length of the array at "base".
+//
+static void pcgGenRangeCheck(CGInst base, CGInst index, MIR *mir)
+{
+    if ((mir->OptimizationFlags & MIR_IGNORE_RANGE_CHECK)) {
+        return;
+    }
+
+    CGLabel range_check_passed_label = CGCreateLabel();
+
+    CGInst length = CGCreateSimpleLoad(base, offArrayObject_length);
+
+    CGCreateNewInst("cjcc", "rcrbp", index, "sle", length,
+                    range_check_passed_label, 100);
+
+    pcgGenerateWritebacks(pcgCurrentCompilationUnit, currModBV);
+
+    CGInst parm_edi = pcg_gen_vmptr_mov();
+    CGInst parm_ebp = pcg_gen_frameptr_mov();
+    CGInst parms_3[3] = {parm_edi, parm_ebp, CGInstInvalid};
+    CGSymbol target = pcgNameToSymbolMap["common_errArrayIndex"];
+    CGCreateJsr(target, parms_3);
+
+    CGBindLabel(range_check_passed_label);
+}
+
+static void pcgTranslateExecuteInline(MIR *mir)
+{
+    int ssaNum;
+    u2 tmp = mir_vB(mir);
+    CGInst self;
+
+    pcgExportPC();
+    
+    switch (tmp) {
+        case INLINE_EMPTYINLINEMETHOD:
+            return;  // NOP
+
+        case INLINE_STRING_LENGTH:
+        case INLINE_STRING_IS_EMPTY:
+        {
+            CGInst C = pcgGetVirtualReg(mirUse(mir, 0), "mov", 4);
+            pcgGenNullCheck(C, mir);
+            CGInst length = CGCreateSimpleLoad(C, 0x14);
+            CGInst result;
+
+            self = pcg_get_self_pointer();
+            if (tmp == INLINE_STRING_LENGTH) {
+                result = length;
+            }
+            else {
+                CGInst zero = CGCreateNewInst("mov", "i", 0);
+                CGInst one = CGCreateNewInst("mov", "i", 1);
+                result = CGCreateNewInst("islcc", "rcrrr", length, "eq", zero,
+                                         one, zero);
+            }
+
+            CGCreateSimpleStore(self, offsetof(Thread, interpSave.retval),
+                                result);
+            return;
+        }
+
+        case INLINE_STRING_CHARAT:
+        {
+            CGInst C = pcgGetVirtualReg(mirUse(mir, 0), "mov", 4);
+            CGInst D = pcgGetVirtualReg(mirUse(mir, 1), "mov", 4);
+            CGInst length = CGCreateSimpleLoad(C, 0x14);
+            CGInst self = pcg_get_self_pointer();
+            CGLabel offsetOkLabel = CGCreateLabel();
+            CGLabel exceptionLabel = CGCreateLabel();
+            pcgGenNullCheck(C, mir);
+            CGCreateNewInst("cjcc", "rcrbp", D, "slt", length, offsetOkLabel,
+                            100);
+            CGBindLabel(exceptionLabel);
+            pcgRaiseException();
+            CGBindLabel(offsetOkLabel);
+            CGInst zero = CGCreateNewInst("mov", "i", 0);
+            CGCreateNewInst("cjcc", "rcrbp", D, "slt", zero,
+                            exceptionLabel, 0);
+            CGInst offset_bias = CGCreateSimpleLoad(C, 0x10);
+            CGInst offset_inst = CGCreateNewInst("add", "rr", offset_bias, D);
+            CGInst string_ptr = CGCreateSimpleLoad(C, 0x8);
+            CGAddr addr = CGCreateAddr(string_ptr, offset_inst, 2,
+                                       CGSymbolInvalid,
+                                       offsetof(ArrayObject, contents));
+            CGInst result = CGCreateNewInst("hldz", "m", addr, 2, (void*)1);
+
+            self = pcg_get_self_pointer();
+            CGCreateSimpleStore(self, offsetof(Thread, interpSave.retval),
+                                result);
+            return;
+        }
+
+        case INLINE_MATH_ABS_INT:
+            printf("\nunimplemented : INLINE_MATH_ABS_INT.\n");
+            exit (-1);
+            break;
+        case INLINE_MATH_ABS_LONG:
+            printf("\nunimplemented : INLINE_MATH_ABS_LONG.\n");
+            exit (-1);
+            break;
+
+        case INLINE_MATH_MAX_INT:
+        case INLINE_MATH_MIN_INT:
+        {
+            const char *cond = (tmp == INLINE_MATH_MAX_INT) ? "sgt" : "slt";
+            CGInst C = pcgGetVirtualReg(mirUse(mir, 0), "mov", 4);
+            CGInst D = pcgGetVirtualReg(mirUse(mir, 1), "mov", 4);
+            CGInst result =
+                CGCreateNewInst("islcc", "rcrrr", C, cond, D, C, D);
+
+            self = pcg_get_self_pointer();
+            CGCreateSimpleStore(self, offsetof(Thread, interpSave.retval),
+                                result);
+            return;
+        }
+
+        case INLINE_MATH_ABS_FLOAT:
+            printf("\nunimplemented : INLINE_MATH_ABS_FLOAT.\n");
+            exit (-1);
+            break;
+        case INLINE_MATH_ABS_DOUBLE:
+            printf("\nunimplemented : INLINE_MATH_ABS_DOUBLE.\n");
+            exit (-1);
+            break;
+        case INLINE_STRING_FASTINDEXOF_II:
+            printf("\nunimplemented : INLINE_STRING_FASTINDEXOF_II.\n");
+            exit (-1);
+            break;
+        case INLINE_INT_BITS_TO_FLOAT:
+            printf("\nunimplemented : INLINE_INT_BITS_TO_FLOAT.\n");
+            exit (-1);
+            break;
+
+        case INLINE_DOUBLE_TO_RAW_LONG_BITS:
+        case INLINE_FLOAT_TO_RAW_INT_BITS:
+        {
+            const char *pcgOpcode;
+            int32_t dtypeSize;
+            ssaNum = mirUse(mir, 0);
+            dtypeSize = getOpcodeAndSizeForDtype(pcgGetDtypeForSSANum(ssaNum),
+                                                 &pcgOpcode);
+            CGInst load = pcgGetVirtualReg(ssaNum, pcgOpcode, dtypeSize);
+            self = pcg_get_self_pointer();
+            CGAddr addr = CGCreateAddr(self, CGInstInvalid, 0, CGSymbolInvalid,
+                                       offsetof(Thread, interpSave.retval));
+            CGCreateNewInst(pcgOpcode, "mr", addr, dtypeSize, (void*)1, load);
+            return;
+        }
+
+        case INLINE_LONG_BITS_TO_DOUBLE:
+            printf("\nunimplemented : INLINE_LONG_BITS_TO_DOUBLE.\n");
+            exit (-1);
+            break;
+        default:
+            break;
+    }
+
+    CGInst self_plus_retval = pcg_get_self_pointer();
+    self_plus_retval = CGCreateNewInst("add", "ri", self_plus_retval,
+                                       offsetof(Thread, interpSave.retval));
+
+    CGInst sp_il = CGCreateNewInst("sub", "ri", CGGetStackPointerDef(), 32);
+    CGSetRreg(sp_il, "esp");
+
+    CGCreateSimpleStore(sp_il, 16, self_plus_retval);
+    int i;
+
+    // Store the outgoing arguments to the stack.  The SSA information gives
+    // us the dtypes to use.
+    //
+    for (i = 0; i < mir->ssaRep->numUses; ) {
+        const char *pcgOpcode;
+        int32_t dtypeSize;
+        int ssaNum = mirUse(mir, i);
+
+        dtypeSize = getOpcodeAndSizeForDtype(pcgGetDtypeForSSANum(ssaNum),
+                                             &pcgOpcode);
+        CGInst load = pcgGetVirtualReg(mirUse(mir, i), pcgOpcode, dtypeSize);
+        CGAddr addr = CGCreateAddr(sp_il, CGInstInvalid, 0, CGSymbolInvalid,
+                                   i * 4);
+        CGCreateNewInst(pcgOpcode, "mr", addr, dtypeSize, (void*)1, load);
+
+        i += dtypeSize / 4;
+    }
+
+    CGInst table_addr_base =
+        CGCreateSimpleLoad(CGInstInvalid,
+                           (int)gDvmInlineOpsTable + (tmp * 16));
+
+    // Create new moves for edi & ebp.
+    CGInst parm_edi = pcg_gen_vmptr_mov();
+    CGInst parm_ebp = pcg_gen_frameptr_mov();
+    CGInst parms[3] = {parm_edi, parm_ebp, CGInstInvalid};
+
+    CGInst the_call = CGCreateNewInst("icall", "rl", table_addr_base, parms);
+    CGSetRreg(the_call, "eax");
+    sp_il = CGCreateNewInst("add", "ri", CGGetStackPointerDef(), 32);
+    CGSetRreg(sp_il, "esp");
+    the_call = CGCreateNewInst("mov", "r", the_call);
+
+    CGLabel done_label = CGCreateLabel();
+    CGCreateNewInst("cjcc", "rcrb", the_call, "ne",
+                    CGCreateNewInst("mov", "i", 0), done_label);
+
+    pcgCalldvmJitToExceptionThrown(); // ZZZ TODO : exception number = 1
+
+    CGBindLabel(done_label);
+}
+
+static void pcgTranslateMonitorExit(MIR *mir)
+{
+    CGInst A = pcgGetVirtualReg(mirUse(mir, 0), "mov", 4);
+    pcgGenNullCheck(A, mir, mirUse(mir, 0));
+
+    CGInst self = pcg_get_self_pointer();
+
+    // call dvmUnlockObject, inputs: object reference and self
+    CGInst parm_edi = pcg_gen_vmptr_mov();
+    CGInst parm_ebp = pcg_gen_frameptr_mov();
+    CGInst parms[3] = {parm_edi, parm_ebp, CGInstInvalid};
+
+    CGInst sp_il = CGCreateNewInst("sub", "ri", CGGetStackPointerDef(), 16);
+    CGSetRreg(sp_il, "esp");
+    CGCreateSimpleStore(sp_il, 0, self);
+    CGCreateSimpleStore(sp_il, 4, A);
+
+    CGInst the_call =
+        CGCreateNewInst("icall", "nl", dvmUnlockObjectSymbol, parms);
+    sp_il = CGCreateNewInst("add", "ri", CGGetStackPointerDef(), 16);
+    CGSetRreg(sp_il, "esp");
+    the_call = CGCreateNewInst("mov", "r", the_call);
+
+    CGLabel done_label = CGCreateLabel();
+    CGCreateNewInst("cjcc", "rcrb", the_call, "ne",
+                    CGCreateNewInst("mov", "i", 0), done_label);
+
+    pcgCalldvmJitToExceptionThrown(); // ZZZ TODO : exception number = 2
+
+    CGBindLabel(done_label);
+}
+
+static void pcgTranslateMonitorEnter(MIR *mir)
+{
+    pcgExportPC();
+
+    CGInst A = pcgGetVirtualReg(mirUse(mir, 0), "mov", 4);
+
+    pcgGenNullCheck(A, mir, mirUse(mir, 0));
+
+    CGInst self = pcg_get_self_pointer();
+
+    // call dvmLockObject, inputs: object reference and self
+    CGInst parm_edi = pcg_gen_vmptr_mov();
+    CGInst parm_ebp = pcg_gen_frameptr_mov();
+    CGInst parms[3] = {parm_edi, parm_ebp, CGInstInvalid};
+
+    CGInst sp_il = CGCreateNewInst("sub", "ri", CGGetStackPointerDef(), 16);
+    CGSetRreg(sp_il, "esp");
+    CGCreateSimpleStore(sp_il, 0, self);
+    CGCreateSimpleStore(sp_il, 4, A);
+
+    CGCreateNewInst("call", "nl", dvmLockObjectSymbol, parms);
+    sp_il = CGCreateNewInst("add", "ri", CGGetStackPointerDef(), 16);
+    CGSetRreg(sp_il, "esp");
+}
+
+static void pcgMarkCard(CGInst val, CGInst target_addr)
+{
+    CGInst self = pcg_get_self_pointer();
+    CGInst card_table = CGCreateSimpleLoad(self, offsetof(Thread, cardTable));
+    CGLabel skip_mark_card;
+
+    skip_mark_card = CGCreateLabel();
+    CGCreateNewInst("cjcc", "rcrb", val, "eq",
+                    CGCreateNewInst("mov", "i", 0),
+                    skip_mark_card);
+
+    target_addr = CGCreateNewInst("shr", "ri", target_addr, GC_CARD_SHIFT);
+
+    // store card_table in (card_table, target_addr, 1)
+    CGAddr addr = CGCreateAddr(card_table, target_addr, 1, CGSymbolInvalid, 0);
+    CGCreateNewInst("mov", "mr", addr, 1, (void*)1, card_table);
+
+    CGBindLabel(skip_mark_card);
+}
+
+static void pcgMarkCardNotNull(CGInst target_addr)
+{
+    CGInst self = pcg_get_self_pointer();
+    CGInst card_table = CGCreateSimpleLoad(self, offsetof(Thread, cardTable));
+
+    target_addr = CGCreateNewInst("shr", "ri", target_addr, GC_CARD_SHIFT);
+
+    // store card_table in (card_table, target_addr, 1)
+    CGAddr addr = CGCreateAddr(card_table, target_addr, 1, CGSymbolInvalid, 0);
+    CGCreateNewInst("mov", "mr", addr, 1, (void*)1, card_table);
+}
+
+static void pcgTranslateIput(MIR *mir, Opcode dalvikOpCode)
+{
+    u2 fieldByteOffset = mir_vC(mir);
+    pcgDtype dtype = pcgGetDtypeForSSANum(mirUse(mir, 0));
+    const char *pcgOpcode;
+    int32_t dtypeSize = getOpcodeAndSizeForDtype(dtype, &pcgOpcode);
+
+    int base_n = (dalvikOpCode == OP_IPUT_WIDE_QUICK) ? 2 : 1;
+    CGInst base = pcgGetVirtualReg(mirUse(mir, base_n), "mov", 4);
+    
+    pcgGenNullCheck(base, mir, mirUse(mir, base_n));
+
+    CGInst A = pcgGetVirtualReg(mirUse(mir, 0), pcgOpcode, dtypeSize);
+    CGAddr addr = CGCreateAddr(base, CGInstInvalid, 0,
+                               CGSymbolInvalid, fieldByteOffset);
+    CGCreateNewInst(pcgOpcode, "mr", addr, dtypeSize, (void*)1, A);
+
+    if (dalvikOpCode == OP_IPUT_OBJECT_QUICK) {
+        pcgMarkCard(A, base);
+    }
+}
+
+//
+// vA = vB[vC]
+//
+static void pcgTranslateAget(MIR *mir, Opcode dalvikOpCode)
+{
+    CGInst base = pcgGetVirtualReg(mirUse(mir, 0), "mov", 4);
+    int ssaNum = mirDef(mir, 0);
+    pcgDtype dtype = pcgGetDtypeForSSANum(ssaNum);
+    const char *pcgOpcode;
+    int objectSize;
+
+    objectSize = getOpcodeAndSizeForDtype(dtype, &pcgOpcode);
+    pcgGenNullCheck(base, mir, mirUse(mir, 0));
+
+    CGInst index = pcgGetVirtualReg(mirUse(mir, 1), "mov", 4);
+
+    if(!(mir->OptimizationFlags & MIR_IGNORE_RANGE_CHECK)) {
+        pcgGenRangeCheck(base, index, mir);
+    }
+
+    if (dalvikOpCode == OP_AGET || dalvikOpCode == OP_AGET_OBJECT ||
+        dalvikOpCode == OP_AGET_WIDE) {
+        CGAddr addr = CGCreateAddr(base, index, objectSize, CGSymbolInvalid,
+                                   offArrayObject_contents);
+        CGInst object_load =
+            CGCreateNewInst(pcgOpcode, "m", addr, objectSize, (void*)1);
+        pcgSetVirtualReg(ssaNum, pcgOpcode, objectSize, object_load);
+    }
+    else if (dalvikOpCode == OP_AGET_BYTE) {
+        CGAddr addr = CGCreateAddr(base, index, 1, CGSymbolInvalid,
+                                   offArrayObject_contents);
+        CGInst object_load = CGCreateNewInst("blds", "m", addr, 1, (void*)1);
+        pcgSetVirtualReg(ssaNum, "mov", 4, object_load);
+    }
+    else if (dalvikOpCode == OP_AGET_BOOLEAN) {
+        CGAddr addr = CGCreateAddr(base, index, 1, CGSymbolInvalid,
+                                   offArrayObject_contents);
+        CGInst object_load = CGCreateNewInst("bldz", "m", addr, 1, (void*)1);
+        pcgSetVirtualReg(ssaNum, "mov", 4, object_load);
+    }
+    else if (dalvikOpCode == OP_AGET_CHAR) {
+        CGAddr addr = CGCreateAddr(base, index, 2, CGSymbolInvalid,
+                                   offArrayObject_contents);
+        CGInst object_load = CGCreateNewInst("hldz", "m", addr, 2, (void*)1);
+        pcgSetVirtualReg(ssaNum, "mov", 4, object_load);
+    }
+    else if (dalvikOpCode == OP_AGET_SHORT) {
+        CGAddr addr = CGCreateAddr(base, index, 2, CGSymbolInvalid,
+                                   offArrayObject_contents);
+        CGInst object_load = CGCreateNewInst("hlds", "m", addr, 2, (void*)1);
+        pcgSetVirtualReg(ssaNum, "mov", 4, object_load);
+    }
+    else {
+        printf("\nNOT REACHED\n");
+        exit(-1);
+    }
+}
+
+//
+// vB[vC] = vA
+//
+static void pcgTranslateAput(MIR *mir, Opcode dalvikOpCode)
+{
+    int base_n = (dalvikOpCode == OP_APUT_WIDE) ? 2 : 1;
+    CGInst base = pcgGetVirtualReg(mirUse(mir, base_n), "mov", 4);
+    int ssaNum = mirUse(mir, 0);
+    const char *pcgOpcode;
+    int objectSize;
+
+    objectSize = getOpcodeAndSizeForDtype(pcgGetDtypeForSSANum(ssaNum),
+                                          &pcgOpcode);
+
+    pcgGenNullCheck(base, mir, mirUse(mir, base_n));
+
+    CGInst index = pcgGetVirtualReg(mirUse(mir, base_n + 1), "mov", 4);
+
+    if(!(mir->OptimizationFlags & MIR_IGNORE_RANGE_CHECK)) {
+        pcgGenRangeCheck(base, index, mir);
+    }
+
+    if (dalvikOpCode == OP_APUT || dalvikOpCode == OP_APUT_WIDE) {
+        CGInst A = pcgGetVirtualReg(ssaNum, pcgOpcode, objectSize);
+
+        CGAddr addr = CGCreateAddr(base, index, objectSize, CGSymbolInvalid,
+                                   offArrayObject_contents);
+        CGCreateNewInst(pcgOpcode, "mr", addr, objectSize, (void*)1, A);
+    }
+    else if (dalvikOpCode == OP_APUT_BYTE || dalvikOpCode == OP_APUT_BOOLEAN) {
+        CGInst A = pcgGetVirtualReg(mirUse(mir, 0), "mov", 4);
+        CGAddr addr =
+            CGCreateAddr(base, index, 1, CGSymbolInvalid,
+                         offArrayObject_contents);
+        CGCreateNewInst("mov", "mr", addr, 1, (void*)1, A);
+    }
+    else if (dalvikOpCode == OP_APUT_CHAR ||
+             dalvikOpCode == OP_APUT_SHORT) {
+        CGInst A = pcgGetVirtualReg(mirUse(mir, 0), "mov", 4);
+        CGAddr addr =
+            CGCreateAddr(base, index, 2, CGSymbolInvalid,
+                         offArrayObject_contents);
+        CGCreateNewInst("mov", "mr", addr, 2, (void*)1, A);
+    }
+    else {
+        printf("\nNOT REACHED\n");
+        exit(-1);
+    }
+}
+
+static void pcgTranslateAputObject(MIR *mir)
+{
+    CGLabel endLabel = CGCreateLabel();
+    CGLabel skipCheckLabel = CGCreateLabel();
+    CGLabel okLabel = CGCreateLabel();
+
+    CGInst base = pcgGetVirtualReg(mirUse(mir, 1), "mov", 4);
+    pcgExportPC();
+
+    pcgGenNullCheck(base, mir, mirUse(mir, 1));
+
+    CGInst index = pcgGetVirtualReg(mirUse(mir, 2), "mov", 4);
+    pcgGenRangeCheck(base, index, mir);
+
+    CGInst A = pcgGetVirtualReg(mirUse(mir, 0), "mov", 4);
+    CGInst zero = CGCreateNewInst("mov", "i", 0);
+    CGCreateNewInst("cjcc", "rcrbp", A, "eq", zero, skipCheckLabel, 5);
+
+    CGInst t0 = CGCreateSimpleLoad(A, offObject_clazz);
+    CGInst t1 = CGCreateSimpleLoad(base, offObject_clazz);
+
+    CGSymbol target = pcgNameToSymbolMap["dvmCanPutArrayElement"];
+    CGInst sp_il = CGCreateNewInst("sub", "ri", CGGetStackPointerDef(), 16);
+    CGInst parms[3];
+    CGSetRreg(sp_il, "esp");
+    CGCreateSimpleStore(sp_il, 0, t0);
+    CGCreateSimpleStore(sp_il, 4, t1);
+
+    parms[0] = pcg_gen_vmptr_mov();
+    parms[1] = pcg_gen_frameptr_mov();
+    parms[2] = CGInstInvalid;
+    CGInst call = CGCreateNewInst("icall", "nl", target, parms);
+    CGSetRreg(call, "eax");
+    sp_il = CGCreateNewInst("add", "ri", CGGetStackPointerDef(), 16);
+    CGSetRreg(sp_il, "esp");
+    call = CGCreateNewInst("mov", "r", call);
+
+    CGInst zero2 = CGCreateNewInst("mov", "i", 0);
+    CGCreateNewInst("cjcc", "rcrbp", call, "ne", zero2, okLabel);
+    pcgRaiseException();
+    CGBindLabel(okLabel);
+
+    CGCreateStore(base, index, 4, CGSymbolInvalid,
+                  offArrayObject_contents, A);
+    pcgMarkCardNotNull(base);
+    CGCreateNewInst("jmp", "b", endLabel);
+
+    CGBindLabel(skipCheckLabel);
+    CGCreateStore(base, index, 4, CGSymbolInvalid,
+                  offArrayObject_contents, A);
+
+    CGBindLabel(endLabel);
+}
+
+static bool pcgTranslateSgetSput(MIR *mir, bool is_wide, bool is_get,
+                                 bool is_obj)
+{
+    u2 referenceIndex = mir_vB(mir);
+    const Method *method = (mir->OptimizationFlags & MIR_CALLEE) ?
+        mir->meta.calleeMethod : pcgCurrentMethod;
+    void *fieldPtr =
+      (void*)(method->clazz->pDvmDex->pResFields[referenceIndex]);
+    int ssaNum = (is_get) ? mirDef(mir, 0) : mirUse(mir, 0);
+    pcgDtype dtype = pcgGetDtypeForSSANum(ssaNum);
+    const char *pcgOpcode;
+    int objectSize;
+
+    objectSize = getOpcodeAndSizeForDtype(dtype, &pcgOpcode);
+
+    // This comment is from LowerGetPut.cpp.  We need to figure out how to
+    // handle this.  In general, having a mechanism for PCG to report a
+    // failure is a nice improvement anyhow.
+    //
+    // Usually, fieldPtr should not be null. The interpreter should resolve
+    // it before we come here, or not allow this opcode in a trace. However,
+    // we can be in a loop trace and this opcode might have been picked up
+    // by exhaustTrace. Sending a -1 here will terminate the loop formation
+    // and fall back to normal trace, which will not have this opcode.
+    //
+    if (!fieldPtr) {
+        return false;
+    }
+
+    CGInst field_ptr_inst = CGCreateNewInst("mov", "i", (int32_t)fieldPtr);
+    CGAddr addr = CGCreateAddr(field_ptr_inst, CGInstInvalid, 0,
+                               CGSymbolInvalid, offStaticField_value);
+
+    if (is_get) {
+        CGInst load = CGCreateNewInst(pcgOpcode, "m", addr,
+                                      objectSize, (void*)1);
+        pcgSetVirtualReg(ssaNum, pcgOpcode, objectSize, load);
+    }
+    else {
+        CGInst A = pcgGetVirtualReg(ssaNum, pcgOpcode, objectSize);
+        CGCreateNewInst(pcgOpcode, "mr", addr, objectSize, (void*)1, A);
+
+        if (is_obj) {
+            CGInst clazz_inst = CGCreateSimpleLoad(field_ptr_inst,
+                                                   offField_clazz);
+            pcgMarkCard(A, clazz_inst);
+        }
+    }
+
+    return true;
+}
+
+static void pcgTranslateIgetObjectQuick(MIR *mir)
+{
+    u2 fieldOffset = mir_vC(mir);
+    int ssaNum = mirDef(mir, 0);
+    const char *pcgOpcode;
+
+    getOpcodeAndSizeForDtype(pcgGetDtypeForSSANum(ssaNum), &pcgOpcode);
+
+    CGInst B = pcgGetVirtualReg(mirUse(mir, 0), "mov", 4);
+
+    pcgGenNullCheck(B, mir, mirUse(mir, 0));
+
+    CGAddr addr = CGCreateAddr(B, CGInstInvalid, 0, CGSymbolInvalid,
+                               fieldOffset);
+    CGInst object_load = CGCreateNewInst(pcgOpcode, "m", addr, 4, (void*)1);
+
+    pcgSetVirtualReg(ssaNum, pcgOpcode, 4, object_load);
+}
+
+static void pcgTranslateIgetWideQuick(MIR *mir)
+{
+    // Now that this routine has been revised to be ssaNum based, it can
+    // probably be consolidated with other iget/iput routines.
+    //
+    u2 fieldOffset = mir_vC(mir);
+    const char *pcgOpcode;
+
+    getOpcodeAndSizeForDtype(pcgGetDtypeForSSANum(mirDef(mir, 0)), &pcgOpcode);
+
+    CGInst B = pcgGetVirtualReg(mirUse(mir, 0), "mov", 4);
+
+    pcgGenNullCheck(B, mir, mirUse(mir, 0));
+
+    // (TODO) The memory disambiguation information needs to be improved.
+    CGAddr addr =
+        CGCreateAddr(B, CGInstInvalid, 0,
+                     CGSymbolInvalid, fieldOffset);
+    CGInst object_load = CGCreateNewInst(pcgOpcode, "m", addr, 8, (void*)1);
+
+    pcgSetVirtualReg(mirDef(mir, 0), pcgOpcode, 8, object_load);
+}
+
+static void pcgTranslateIgetIput(MIR *mir, bool is_get, bool is_obj,
+                                 bool is_wide, bool is_volatile)
+{
+    u2 referenceIndex = mir_vC(mir);
+    const Method *method = (mir->OptimizationFlags & MIR_CALLEE) ?
+        mir->meta.calleeMethod : pcgCurrentMethod;
+    InstField *pInstField =
+        (InstField *)method->clazz->pDvmDex->pResFields[referenceIndex];
+    int fieldOffset;
+    CGInst parms[3];
+    const char *pcgOpcode;
+    int memSize;
+
+    assert(pInstField != NULL);
+    fieldOffset = pInstField->byteOffset;
+
+    int b_index = (is_get) ? 0 : ((is_wide) ? 2 : 1);
+    CGInst field_offset_inst = CGCreateNewInst("mov", "i", fieldOffset);
+    CGInst B = pcgGetVirtualReg(mirUse(mir, b_index), "mov", 4);
+    pcgGenNullCheck(B, mir, mirUse(mir, b_index));
+
+    if (is_get) {
+        pcgDtype dtype = pcgGetDtypeForSSANum(mirDef(mir, 0));
+        memSize = getOpcodeAndSizeForDtype(dtype, &pcgOpcode);
+
+        if (is_wide && is_volatile) {
+            CGSymbol target = pcgNameToSymbolMap["dvmQuasiAtomicRead64"];
+            CGInst add = CGCreateNewInst("add", "rr", B, field_offset_inst);
+            CGInst sp_il = CGCreateNewInst("sub", "ri",
+                                           CGGetStackPointerDef(), 16);
+            CGSetRreg(sp_il, "esp");
+            CGCreateSimpleStore(sp_il, 0, add);
+            parms[0] = pcg_gen_vmptr_mov();
+            parms[1] = pcg_gen_frameptr_mov();
+            parms[2] = CGInstInvalid;
+            CGInst call = CGCreateNewInst("lcall", "nl", target, parms);
+            CGSetRreg(call, "eax");
+            sp_il = CGCreateNewInst("add", "ri", CGGetStackPointerDef(), 16);
+            CGSetRreg(sp_il, "esp");
+            call = CGCreateNewInst("lmov", "r", call);
+
+            if (dtype == DPVXreg64) {
+                call = CGCreateNewInst("emovdfi", "r", call);
+                call = CGCreateNewInst("movsd2sd1", "r", call);
+            }
+
+            pcgSetVirtualReg(mirDef(mir, 0), pcgOpcode, 8, call);
+        }
+        else {
+            CGAddr addr = CGCreateAddr(B, field_offset_inst, 1,
+                                       CGSymbolInvalid, 0);
+            CGInst load = CGCreateNewInst(pcgOpcode, "m", addr, memSize,
+                                          (void*)1);
+            pcgSetVirtualReg(mirDef(mir, 0), pcgOpcode, memSize, load);
+        }
+    }
+    else {
+        pcgDtype dtype = pcgGetDtypeForSSANum(mirUse(mir, 0));
+        memSize = getOpcodeAndSizeForDtype(dtype, &pcgOpcode);
+
+        CGInst A = pcgGetVirtualReg(mirUse(mir, 0), pcgOpcode, memSize);
+        CGAddr addr = CGCreateAddr(B, field_offset_inst, 1,
+                                   CGSymbolInvalid, 0);
+        CGCreateNewInst(pcgOpcode, "mr", addr, memSize, (void*)1, A);
+        if (is_obj) {
+          pcgMarkCard(A, B);
+        }
+    }
+}
+
+static void pcgTranslateMoveResult(MIR *mir)
+{
+    if (mir->OptimizationFlags & MIR_INLINED) {
+        return;
+    }
+
+    int ssaNum = mirDef(mir, 0);
+    pcgDtype dtype = pcgGetDtypeForSSANum(ssaNum);
+    const char *pcgOpcode;
+    int objectSize;
+
+    objectSize = getOpcodeAndSizeForDtype(dtype, &pcgOpcode);
+
+    CGInst self_pointer = pcg_get_self_pointer();
+    CGAddr addr = CGCreateAddr(self_pointer, CGInstInvalid, 0,
+                               CGSymbolInvalid,
+                               offsetof(Thread, interpSave.retval));
+    CGInst ret_val = CGCreateNewInst(pcgOpcode, "m", addr, objectSize,
+                                     (void*)1);
+
+    pcgSetVirtualReg(ssaNum, pcgOpcode, objectSize, ret_val);
+}
+
+#if 0
+// This function is currently only referenced for the not-yet-enabled
+// filled-new-array implementation.
+//
+static CGInst pcgGetGlueMethodClass(CGInst self_ptr)
+{
+    CGInst ret =
+        CGCreateSimpleLoad(self_ptr, offsetof(Thread, interpSave.method));
+    ret = CGCreateSimpleLoad(ret, offMethod_clazz);
+    return ret;
+}
+#endif
+
+static CGInst pcgGetResClasses(CGInst self_ptr)
+{
+    CGInst ret = CGCreateSimpleLoad(self_ptr,
+                                  offsetof(Thread, interpSave.methodClassDex));
+    ret = CGCreateSimpleLoad(ret, offDvmDex_pResClasses);
+    return ret;
+}
+
+static void pcgTranslateNewArray(MIR *mir)
+{
+    u4 tmp = mir_vC(mir);
+
+    void *classPtr = (void*)
+        (pcgCurrentMethod->clazz->pDvmDex->pResClasses[tmp]);
+    assert(classPtr != NULL);
+
+    pcgExportPC();
+
+    CGInst length = pcgGetVirtualReg(mirUse(mir, 0), "mov", 4);
+
+    //
+    // check size of the array, if negative, throw exception.
+    // PCG : We just punt to the interpreter in this case, because it's
+    // easier.
+    //
+    CGLabel no_exception = CGCreateLabel();
+
+    CGCreateNewInst("cjcc", "rcrbp", length, "sge",
+                    CGCreateNewInst("mov", "i", 0),
+                    no_exception, 100);
+
+    pcgRaiseExceptionSimple();
+
+    CGBindLabel(no_exception);
+
+    //
+    // call dvmAllocArrayByClass with inputs:
+    // classObject, length, flag ALLOC_DONT_TRACK
+    //
+    CGInst the_call = pcgGenX86Call("dvmAllocArrayByClass", INTreg, 3,
+                INTreg, CGCreateNewInst("mov", "i", (int)classPtr),
+                INTreg, CGCreateNewInst("mov", "r", length),
+                INTreg, CGCreateNewInst("mov", "i", ALLOC_DONT_TRACK));
+
+    CGLabel not_null = CGCreateLabel();
+    CGInst zero = CGCreateNewInst("mov", "i", 0);
+    CGCreateNewInst("cjcc", "rcrbp", the_call, "ne", zero, not_null, 100);
+    pcgCalldvmJitToExceptionThrown();
+
+    CGBindLabel(not_null);
+
+    pcgSetVirtualReg(mirDef(mir, 0), "mov", 4, the_call);
+}
+
+#if 0
+static CGInst pcg_common_filled_new_array(u2 length, u4 tmp, bool has_range)
+{
+  exit(-1);
+    CGAddr addr;
+    CGLabel b_filled_new_array_impl = CGCreateLabel();
+    CGInst class_object_descriptor;
+
+    ClassObject *classPtr =
+              (pcgCurrentMethod->clazz->pDvmDex->pResClasses[tmp]);
+    if (DUMP_BYTECODE()) {
+        if (classPtr != NULL) {
+            printf("\nFILLED_NEW_ARRAY class %s", classPtr->descriptor);
+        }
+    }
+
+    //
+    // check whether class is resolved, if yes, jump to resolved
+    // if not, call class_resolve
+    //
+    CGInst self_ptr = pcg_get_self_ptr();
+    CGInst method_class_dex =
+        CGCreateSimpleLoad(self_ptr, offsetof(Thread, interpSave.methodClassDex));
+    CGInst res_classes =
+      CGCreateSimpleLoad(method_class_dex, offDvmDex_pResClasses); // 3
+    CGInst resolved_class = CGCreateSimpleLoad(res_classes, tmp * 4); // EAX
+
+    pcgExportPC();
+
+    CGLabel b_filled_new_array_resolved = CGCreateLabel();
+    CGInst zero = CGCreateNewInst("mov", "i", 0);
+    CGCreateNewInst("cjcc", "rcrb", resolved_class, "ne", zero,
+                    b_filled_new_array_resolved);
+
+    resolved_class = CGCreateNewInst("mov", "i", tmp); 
+
+    //
+    // call .class_resolve (inlined here)
+    //
+    CGInst parm_edi = pcg_gen_vmptr_mov();
+    CGInst parm_ebp = pcg_gen_frameptr_mov();
+    CGInst parms[3] = {parm_edi, parm_ebp, CGInstInvalid};
+
+    CGInst glue_method_class = pcgGetGlueMethodClass(self_ptr);
+
+    sp_il = CGCreateNewInst("sub", "ri", CGGetStackPointerDef(), 16);
+    CGSetRreg(sp_il, "esp");
+    CGCreateSimpleStore(sp_il, 0, glue_method_class);
+    CGCreateSimpleStore(sp_il, 4, resolved_class);
+    CGCreateSimpleStore(sp_il, 8, CGCreateNewInst("mov", "i", 0));
+    CGInst the_call =
+        CGCreateNewInst("icall", "nl", dvmResolveClassSymbol, parms);
+    CGSetRreg(the_call, "eax");
+    sp_il = CGCreateNewInst("add", "ri", CGGetStackPointerDef(), 16);
+    CGSetRreg(sp_il, "esp");
+    the_call = CGCreateNewInst("mov", "r", the_call); // eax
+    pcgSimpleNullCheck(the_call);
+
+    // ZZZ START OF COMMON CODE THAT CAN BE UNDER A MERGE
+    class_object_descriptor = CGCreateSimpleLoad(the_call, 24);
+    //load a single byte of the descriptor
+    addr = CGCreateAddr(class_object_descriptor, CGInstInvalid, 0,
+                        CGSymbolInvalid, 1);
+    class_object_descriptor = CGCreateNewInst("mov", "m", addr, 1, (void*)1);
+    CGCreateNewInst("cjcc", "rcrb", class_object_descriptor, "eq",
+                    CGCreateNewInst("mov", "i", 'I'), b_filled_new_array_impl);
+    CGCreateNewInst("cjcc", "rcrb", class_object_descriptor, "eq",
+                    CGCreateNewInst("mov", "i", 'L'), b_filled_new_array_impl);
+    CGCreateNewInst("cjcc", "rcrb", class_object_descriptor, "eq",
+                    CGCreateNewInst("mov", "i", '['), b_filled_new_array_impl);
+
+    //
+    // ZZZ TODO : Real call goes through "common_throw" with a couple of int
+    // params, then ends up calling dvmJitToExceptionThrown.. Just going to
+    // call the latter as a short cut, for now.
+    //
+    pcgCalldvmJitToExceptionThrown();
+    // ZZZ END OF COMMON CODE THAT CAN BE UNDER A MERGE
+
+    // here, class is already resolved
+    CGBindLabel(b_filled_new_array_resolved);
+
+    // ZZZ START OF COMMON CODE THAT CAN BE UNDER A MERGE
+    class_object_descriptor = CGCreateSimpleLoad(the_call, 24);
+    //load a single byte of the descriptor
+    addr = CGCreateAddr(class_object_descriptor, CGInstInvalid, 0,
+                        CGSymbolInvalid, 1);
+    class_object_descriptor = CGCreateNewInst("mov", "m", addr, 1, (void*)1);
+    CGCreateNewInst("cjcc", "rcrb", class_object_descriptor, "eq",
+                    CGCreateNewInst("mov", "i", 'I'), b_filled_new_array_impl);
+    CGCreateNewInst("cjcc", "rcrb", class_object_descriptor, "eq",
+                    CGCreateNewInst("mov", "i", 'L'), b_filled_new_array_impl);
+    CGCreateNewInst("cjcc", "rcrb", class_object_descriptor, "eq",
+                    CGCreateNewInst("mov", "i", '['), b_filled_new_array_impl);
+
+    //
+    // ZZZ TODO : Real call goes through "common_throw" with a couple of int
+    // params, then ends up calling dvmJitToExceptionThrown.. Just going to
+    // call the latter as a short cut, for now.
+    //
+    pcgCalldvmJitToExceptionThrown();
+    // ZZZ END OF COMMON CODE THAT CAN BE UNDER A MERGE
+
+    CGBindLabel(b_filled_new_array_impl);
+
+    //
+    // call dvmAllocArrayByClass with inputs:
+    // classObject, length, flag ALLOC_DONT_TRACK
+    //
+    parm_edi = pcg_gen_vmptr_mov();
+    parm_ebp = pcg_gen_frameptr_mov();
+    CGInst parms_3[3] = {parm_edi, parm_ebp, CGInstInvalid};
+
+    sp_il = CGCreateNewInst("sub", "ri", CGGetStackPointerDef(), 16);
+    CGSetRreg(sp_il, "esp");
+    CGCreateSimpleStore(sp_il, 0, CGCreateNewInst("mov", "i", (int)classPtr));
+    CGCreateSimpleStore(sp_il, 4, CGCreateNewInst("mov", "i", length));
+    CGCreateSimpleStore(sp_il, 8, CGCreateNewInst("mov", "i",
+                                                  ALLOC_DONT_TRACK));
+    the_call =
+        CGCreateNewInst("icall", "nl", dvmAllocArrayByClassSymbol, parms_3);
+    CGSetRreg(the_call, "eax");
+    sp_il = CGCreateNewInst("add", "ri", CGGetStackPointerDef(), 16);
+    CGSetRreg(sp_il, "esp");
+    the_call = CGCreateNewInst("mov", "r", the_call); // eax
+    pcgSimpleNullCheck(the_call);
+
+
+    // ZZZ ARGH! 6 is a merged reg here.
+    /* we need to mark the card of the new array, if it's not an int */
+    compare_imm_reg(OpndSize_32, 'I', 6, false);
+    conditional_jump(Condition_E, ".dont_mark_filled_new_array", true);
+
+    // Need to make copy of EAX, because it's used later in op_filled_new_array()
+    move_reg_to_reg(OpndSize_32, PhysicalReg_EAX, true, 6, false);
+
+    markCard_filled(6, false, PhysicalReg_SCRATCH_4, false);
+
+    insertLabel(".dont_mark_filled_new_array", true);
+
+    //return value of bytecode FILLED_NEW_ARRAY is in GLUE structure
+    scratchRegs[0] = PhysicalReg_SCRATCH_4; scratchRegs[1] = PhysicalReg_Null;
+    set_return_value(OpndSize_32, PhysicalReg_EAX, true);
+    return 0;
+}
+
+static void pcgTranslateFilledNewArray(MIR *mir)
+{
+    CGInst il;
+    u2 length = mir->dalvikInsn.vA;
+    u4 tmp = mir->dalvikInsn.vB;
+    u2 v1, v2, v3, v4, v5;
+
+    v5 = mir->dalvikInsn.arg[4];
+    v4 = mir->dalvikInsn.arg[3];
+    v3 = mir->dalvikInsn.arg[2];
+    v2 = mir->dalvikInsn.arg[1];
+    v1 = mir->dalvikInsn.arg[0];
+
+    CGInst base = pcg_common_filled_new_array(length, tmp, false);
+
+    if(length >= 1) {
+        il = pcgGetVirtualReg(v1, "mov", 4);
+        CGCreateSimpleStore(base, offArrayObject_contents, il);
+    }
+    if(length >= 2) {
+        il = pcgGetVirtualReg(v2, "mov", 4);
+        CGCreateSimpleStore(base, offArrayObject_contents + 4, il);
+    }
+    if(length >= 3) {
+        il = pcgGetVirtualReg(v3, "mov", 4);
+        CGCreateSimpleStore(base, offArrayObject_contents + 8, il);
+    }
+    if(length >= 4) {
+        il = pcgGetVirtualReg(v4, "mov", 4);
+        CGCreateSimpleStore(base, offArrayObject_contents + 12, il);
+    }
+    if(length >= 5) {
+        il = pcgGetVirtualReg(v5, "mov", 4);
+        CGCreateSimpleStore(base, offArrayObject_contents + 16, il);
+    }
+}
+#endif
+
+static void pcgTranslateFillArrayData(MIR *mir)
+{
+    u4 tmp = mir_vB(mir);
+    CGLabel doneLabel = CGCreateLabel();
+
+    CGInst A = pcgGetVirtualReg(mirUse(mir, 0), "mov", 4);
+    CGInst pc = CGCreateNewInst("mov", "i", (int32_t)(rPC + tmp));
+
+    CGInst call_result = pcgGenX86Call("dvmInterpHandleFillArrayData",
+                                       INTreg, 2, INTreg, A, INTreg, pc);
+
+    CGInst zero = CGCreateNewInst("mov", "i", 0);
+    CGCreateNewInst("cjcc", "rcrbp", call_result, "ne", zero, doneLabel, 100);
+    pcgRaiseException();
+    CGBindLabel(doneLabel);
+}
+
+static void pcgCommonCheckCastInstanceOf(MIR *mir, u2 vA, u4 tmp,
+                                         bool is_instance_of,
+                                         u2 vDest)
+{
+    CGLabel nullLabel;
+    CGLabel equalLabel;
+    CGLabel endLabel = CGCreateLabel();
+    ClassObject *classPtr =
+                (pcgCurrentMethod->clazz->pDvmDex->pResClasses[tmp]);
+    CGTemp result_temp = pcgNextTemp++;
+    CGInst class_ptr_inst;
+    CGInst call, call_result;
+    CGInst parms[4];
+
+    if (is_instance_of) {
+        nullLabel = CGCreateLabel();
+        equalLabel = CGCreateLabel();
+    }
+    else {
+        // Check cast effectively is finished when it jumps to these labels.
+        // So just jump directly to endLabel;
+        nullLabel = endLabel;
+        equalLabel = endLabel;
+    }
+
+    CGInst A = pcgGetVirtualReg(mirUse(mir, 0), "mov", 4);
+    CGInst zero = CGCreateNewInst("mov", "i", 0);
+    CGCreateNewInst("cjcc", "rcrbp", A, "eq", zero, nullLabel, 0);
+
+    if (classPtr != NULL) {
+        class_ptr_inst = CGCreateNewInst("mov", "i", (int32_t)classPtr);
+    }
+    else {
+        // The class needs to be resolved.
+        CGLabel classResolvedLabel = CGCreateLabel();
+        CGTemp class_ptr_temp = pcgNextTemp++;
+        CGInst res_classes = pcgGetResClasses(pcg_get_self_pointer());
+        CGInst res_class = CGCreateSimpleLoad(res_classes, tmp * 4);
+        CGAddTempDef(class_ptr_temp, res_class);
+
+        // I am just guessing that the common case is that the class is
+        // already resolved.
+        CGCreateNewInst("cjcc", "rcrbp", res_class, "ne", zero,
+                        classResolvedLabel, 95);
+
+        pcgExportPC();
+        CGInst tmp_inst = CGCreateNewInst("mov", "i", tmp);
+        parms[0] = pcg_gen_vmptr_mov();
+        parms[1] = pcg_gen_frameptr_mov();
+        parms[2] = CGCreateNewInst("mov", "r", tmp_inst);
+        parms[3] = CGInstInvalid;
+        CGSetRreg(parms[2], "eax");
+        CGSymbol target =  pcgNameToSymbolMap[".class_resolve"];
+
+        call = CGCreateNewInst("icall", "nl", target, parms);
+        CGSetRreg(call, "eax");
+        call_result = CGCreateNewInst("mov", "r", call);
+        CGAddTempDef(class_ptr_temp, call_result);
+
+        CGBindLabel(classResolvedLabel);
+        class_ptr_inst = CGGetTempUseInst(class_ptr_temp);
+    }
+
+    CGInst clazz_inst = CGCreateSimpleLoad(A, offObject_clazz);
+    CGCreateNewInst("cjcc", "rcrbp", clazz_inst, "eq", class_ptr_inst,
+                    equalLabel, 50);
+
+    CGInst sp_il = CGCreateNewInst("sub", "ri", CGGetStackPointerDef(), 16);
+    CGSetRreg(sp_il, "esp");
+    CGCreateSimpleStore(sp_il, 0, clazz_inst);
+    CGCreateSimpleStore(sp_il, 4, class_ptr_inst);
+    parms[0] = pcg_gen_vmptr_mov();
+    parms[1] = pcg_gen_frameptr_mov();
+    parms[2] = CGInstInvalid;
+    call = CGCreateNewInst("icall", "nl", dvmInstanceofNonTrivialSymbol,
+                           parms);
+    CGSetRreg(call, "eax");
+    sp_il = CGCreateNewInst("add", "ri", CGGetStackPointerDef(), 16);
+    CGSetRreg(sp_il, "esp");
+    call_result = CGCreateNewInst("mov", "r", call);
+
+    if (is_instance_of) {
+        CGAddTempDef(result_temp, call_result);
+        CGCreateNewInst("jmp", "b", endLabel);
+
+        CGBindLabel(nullLabel);
+        CGInst zero_result = CGCreateNewInst("mov", "i", 0);
+        CGAddTempDef(result_temp, zero_result);
+        CGCreateNewInst("jmp", "b", endLabel);
+
+        CGBindLabel(equalLabel);
+        CGInst one_result = CGCreateNewInst("mov", "i", 1);
+        CGAddTempDef(result_temp, one_result);
+    }
+    else {
+        CGCreateNewInst("cjcc", "rcrbp", call_result, "eq",
+                        CGCreateNewInst("mov", "i", 0), endLabel, 95);
+        pcgRaiseException();
+    }
+
+    CGBindLabel(endLabel);
+    if (is_instance_of) {
+        pcgSetVirtualReg(mirDef(mir, 0), "mov", 4,
+                         CGGetTempUseInst(result_temp));
+    }
+}
+
+static void pcgTranslateInstanceOf(MIR *mir)
+{
+    pcgCommonCheckCastInstanceOf(mir, mir_vB(mir), mir_vC(mir), true,
+                                 mir_vA(mir));
+}
+
+static void pcgTranslateCheckCast(MIR *mir)
+{
+    pcgCommonCheckCastInstanceOf(mir, mir_vA(mir), mir_vB(mir), false, 0);
+}
+
+static void pcgTranslateArrayLength(MIR *mir)
+{
+    CGInst B = pcgGetVirtualReg(mirUse(mir, 0), "mov", 4);
+
+    pcgGenNullCheck(B, mir);
+    CGInst length_inst = CGCreateSimpleLoad(B, offArrayObject_length);
+    pcgSetVirtualReg(mirDef(mir, 0), "mov", 4, length_inst);
+}
+
+static void pcgTranslateNewInstance(MIR *mir)
+{
+    u4 tmp = mir->dalvikInsn.vB;
+    ClassObject *classPtr = pcgCurrentMethod->clazz->pDvmDex->pResClasses[tmp];
+
+    // These assertions were copied from LowerObject.cpp
+    assert(classPtr != NULL);
+    assert(classPtr->status & CLASS_INITIALIZED);
+
+    // If it is going to throw, it should not make to the trace to begin
+    // with.  However, Alloc might throw, so we need to genExportPC()
+    //
+    assert((classPtr->accessFlags & (ACC_INTERFACE|ACC_ABSTRACT)) == 0);
+
+    pcgExportPC();
+
+    // We are calling dvmAllocObject(classPtr, ALLOC_DONT_TRACK)
+    // The original code only subtracted 8 from ESP, but we really ought to
+    // do our part to keep the stack aligned.
+    //
+    CGInst class_ptr_il = CGCreateNewInst("mov", "i", classPtr);
+    CGInst dont_track_il = CGCreateNewInst("mov", "i", ALLOC_DONT_TRACK);
+    CGInst call_result = pcgGenX86Call("dvmAllocObject", INTreg, 2,
+                                       INTreg, class_ptr_il,
+                                       INTreg, dont_track_il);
+
+    // Test for null.
+    CGLabel done_label = CGCreateLabel();
+    CGInst zero = CGCreateNewInst("mov", "i", 0);
+    CGCreateNewInst("cjcc", "rcrb", call_result, "ne", zero, done_label);
+
+    pcgCalldvmJitToExceptionThrown();
+
+    CGBindLabel(done_label);
+    pcgSetVirtualReg(mirDef(mir, 0), "mov", 4, call_result);
+}
+
+static void pcgTranslatePackedSwitch(MIR *mir)
+{
+    u4 tmp = mir_vB(mir);
+    u2* switchData = const_cast<u2 *>(rPC) + (s4)tmp;
+
+    if (*switchData++ != kPackedSwitchSignature) {
+        // should have been caught by verifier
+        dvmThrowInternalError("bad packed switch magic");
+        return;
+    }
+
+    u2 tSize = *switchData++;
+    assert(tSize > 0);
+    s4 firstKey = *((s4*)switchData);
+    switchData += 2;
+    s4* entries = (s4*) switchData;
+    assert(((u4)entries & 0x3) == 0);
+
+    CGInst A = pcgGetVirtualReg(mirUse(mir, 0), "mov", 4);
+    CGInst entries_inst = CGCreateNewInst("mov", "i", (int32_t)entries);
+    CGInst first_key_inst = CGCreateNewInst("mov", "i", firstKey);
+    CGInst tsize_inst = CGCreateNewInst("mov", "i", (int32_t)tSize);
+    CGInst call_res =  pcgGenX86Call("dvmJitHandlePackedSwitch", INTreg, 4,
+                                     INTreg, entries_inst,
+                                     INTreg, first_key_inst,
+                                     INTreg, tsize_inst,
+                                     INTreg, A);
+    CGInst targetPC = CGCreateNewInst("add", "ri", call_res, (int32_t)rPC);
+    CGInst parm_edi = pcg_gen_vmptr_mov();
+    CGInst parm_ebp = pcg_gen_frameptr_mov();
+    CGInst parms[4] = {targetPC, parm_edi, parm_ebp, CGInstInvalid};
+    CGCreateJsrName("dvmJitToInterpNoChain", parms);
+}
+
+static bool pcgTranslateInsn(CompilationUnit *cUnit, MIR *mir)
+{
+    bool success = true;
+    Opcode dalvikOpCode = mir->dalvikInsn.opcode;
+    rPC = (u2*)(cUnit->method->insns) + mir->offset;
+
+    if (DUMP_BYTECODE()) {
+        const u4 c_buf_len = 2048;
+        char mybuf[c_buf_len];
+        dvmCompilerExtendedDisassembler(cUnit, mir, &mir->dalvikInsn, mybuf,
+                                        c_buf_len);
+        printf("%s\n", mybuf);
+    }
+
+    if (dalvikOpCode >= kNumPackedOpcodes) {
+        switch ((ExtendedMIROpcode)dalvikOpCode) {
+            case kMirOpPhi:
+            case kMirOpPunt:
+            case kMirOpRegisterize:
+                break;
+
+            default:
+                LOGE("Jit(PCG): unsupported externded MIR opcode");
+                assert(0);
+        }
+        return true;
+    }
+
+    switch (dalvikOpCode) {
+        case OP_NOP:
+            break;
+
+        case OP_MOVE:
+        case OP_MOVE_OBJECT:
+        case OP_MOVE_FROM16:
+        case OP_MOVE_OBJECT_FROM16:
+        case OP_MOVE_16:
+        case OP_MOVE_OBJECT_16:
+            pcgTranslateMove(mir);
+            break;
+
+        case OP_MOVE_WIDE:
+        case OP_MOVE_WIDE_FROM16:
+        case OP_MOVE_WIDE_16:
+            // It is a bit odd that OP_MOVE_WIDE_FROM16 is implemented in
+            // exactly the same way as OP_MOVE_WIDE, but this matches the
+            // existing Dalvik implementation.
+            // TODO - Check on this.  It might be a bug.
+            //
+            pcgTranslateMoveWide(mir);
+            break;
+
+        case OP_MOVE_EXCEPTION:
+            pcgMoveException(mir);
+            break;
+
+        case OP_THROW:
+            pcgThrow(mir);
+            break;
+
+        case OP_CONST:
+            pcgTranslateConst(mir);
+            break;
+
+        case OP_CONST_4:
+            pcgTranslateConst4(mir);
+            break;
+
+        case OP_CONST_16:
+            pcgTranslateConst16(mir);
+            break;
+
+        case OP_CONST_HIGH16:
+            pcgTranslateConstHigh16(mir);
+            break;
+
+        case OP_CONST_CLASS:
+            pcgTranslateConstHelper(mir,
+             (u4)(pcgCurrentMethod->clazz->pDvmDex->pResClasses[mir_vB(mir)]));
+            break;
+
+        case OP_CONST_WIDE:
+            pcgTranslateConstWideHelper(mir, mir->dalvikInsn.vB_wide);
+            break;
+
+        case OP_CONST_WIDE_16:
+            pcgTranslateConstWideHelper(mir, (s2)mir_vB(mir));
+            break;
+
+        case OP_CONST_WIDE_HIGH16:
+            pcgTranslateConstWideHelper(mir, ((u8)mir_vB(mir)) << 48);
+            break;
+
+        case OP_CONST_WIDE_32:
+            pcgTranslateConstWideHelper(mir, (s4)mir_vB(mir));
+            break;
+
+        case OP_CONST_STRING:
+        case OP_CONST_STRING_JUMBO:
+            pcgTranslateConstString(mir);
+            break;
+
+        case OP_IF_EQ:
+            pcgTranslateIf(mir, "eq");
+            break;
+
+        case OP_IF_NE:
+            pcgTranslateIf(mir, "ne");
+            break;
+
+        case OP_IF_LT:
+            pcgTranslateIf(mir, "slt");
+            break;
+
+        case OP_IF_GE:
+            pcgTranslateIf(mir, "sge");
+            break;
+
+        case OP_IF_GT:
+            pcgTranslateIf(mir, "sgt");
+            break;
+
+        case OP_IF_LE:
+            pcgTranslateIf(mir, "sle");
+            break;
+
+        case OP_IF_GEZ:
+            pcgTranslateIfZero(mir, "sge");
+            break;
+
+        case OP_IF_NEZ:
+            pcgTranslateIfZero(mir, "ne");
+            break;
+
+        case OP_IF_EQZ:
+            pcgTranslateIfZero(mir, "eq");
+            break;
+
+        case OP_IF_LTZ:
+            pcgTranslateIfZero(mir, "slt");
+            break;
+
+        case OP_IF_GTZ:
+            pcgTranslateIfZero(mir, "sgt");
+            break;
+
+        case OP_IF_LEZ:
+            pcgTranslateIfZero(mir, "sle");
+            break;
+
+        case OP_GOTO:
+        case OP_GOTO_16:
+        case OP_GOTO_32:
+            pcgTranslateGoto(mir);
+            break;
+
+        case OP_NEG_INT:
+            pcgIntOp("neg", mirDef(mir, 0), mirUse(mir, 0));
+            break;
+
+        case OP_NOT_INT:
+            pcgIntOp("not", mirDef(mir, 0), mirUse(mir, 0));
+            break;
+
+        case OP_SUB_INT:
+            pcgIntOpOp("sub", mirDef(mir, 0), mirUse(mir, 0), mirUse(mir, 1));
+            break;
+
+        case OP_RSUB_INT:
+            pcgIntOpOp("sub", mirDef(mir, 0), mirUse(mir, 1), mirUse(mir, 0));
+            break;
+
+        case OP_SUB_INT_2ADDR:
+            pcgIntOpOp("sub", mirDef(mir, 0), mirUse(mir, 0), mirUse(mir, 1));
+            break;
+
+        case OP_ADD_INT:
+            pcgIntOpOp("add", mirDef(mir, 0), mirUse(mir, 0), mirUse(mir, 1));
+            break;
+
+        case OP_OR_INT:
+            pcgIntOpOp("or", mirDef(mir, 0), mirUse(mir, 0), mirUse(mir, 1));
+            break;
+
+        case OP_AND_INT:
+            pcgIntOpOp("and", mirDef(mir, 0), mirUse(mir, 0), mirUse(mir, 1));
+            break;
+
+        case OP_XOR_INT:
+            pcgIntOpOp("xor", mirDef(mir, 0), mirUse(mir, 0), mirUse(mir, 1));
+            break;
+
+        case OP_SHL_INT:
+            pcgIntOpOp("shl", mirDef(mir, 0), mirUse(mir, 0), mirUse(mir, 1));
+            break;
+
+        case OP_SHR_INT:
+            pcgIntOpOp("sar", mirDef(mir, 0), mirUse(mir, 0), mirUse(mir, 1));
+            break;
+
+        case OP_USHR_INT:
+            pcgIntOpOp("shr", mirDef(mir, 0), mirUse(mir, 0), mirUse(mir, 1));
+            break;
+
+        case OP_ADD_INT_2ADDR:
+            pcgIntOpOp("add", mirDef(mir, 0), mirUse(mir, 0), mirUse(mir, 1));
+            break;
+
+        case OP_AND_INT_2ADDR:
+            pcgIntOpOp("and", mirDef(mir, 0), mirUse(mir, 0), mirUse(mir, 1));
+            break;
+
+        case OP_XOR_INT_2ADDR:
+            pcgIntOpOp("xor", mirDef(mir, 0), mirUse(mir, 0), mirUse(mir, 1));
+            break;
+
+        case OP_OR_INT_2ADDR:
+            pcgIntOpOp("or", mirDef(mir, 0), mirUse(mir, 0), mirUse(mir, 1));
+            break;
+
+        case OP_MUL_INT_2ADDR:
+            pcgIntOpOp("imul", mirDef(mir, 0), mirUse(mir, 0), mirUse(mir, 1));
+            break;
+
+        case OP_SHL_INT_2ADDR:
+            pcgIntOpOp("shl", mirDef(mir, 0), mirUse(mir, 0), mirUse(mir, 1));
+            break;
+
+        case OP_SHR_INT_2ADDR:
+            pcgIntOpOp("sar", mirDef(mir, 0), mirUse(mir, 0), mirUse(mir, 1));
+            break;
+
+        case OP_USHR_INT_2ADDR:
+            pcgIntOpOp("shr", mirDef(mir, 0), mirUse(mir, 0), mirUse(mir, 1));
+            break;
+
+        case OP_ADD_INT_LIT8:
+            pcgIntOpLit("add", mirDef(mir, 0), mirUse(mir, 0),
+                        (s1)mir_vC(mir));
+            break;
+
+        case OP_RSUB_INT_LIT8:
+            pcgTranslateRsubIntLit8(mir);
+            break;
+
+        case OP_OR_INT_LIT8:
+            pcgIntOpLit("or", mirDef(mir, 0), mirUse(mir, 0),
+                        (s1)mir_vC(mir));
+            break;
+
+        case OP_XOR_INT_LIT8:
+            pcgIntOpLit("xor", mirDef(mir, 0), mirUse(mir, 0),
+                        (s1)mir_vC(mir));
+            break;
+
+        case OP_AND_INT_LIT8:
+            pcgIntOpLit("and", mirDef(mir, 0), mirUse(mir, 0),
+                        (s1)mir_vC(mir));
+            break;
+
+        case OP_SHL_INT_LIT8:
+            pcgIntOpLit("shl", mirDef(mir, 0), mirUse(mir, 0),
+                        (s1)mir_vC(mir));
+            break;
+
+        case OP_SHR_INT_LIT8:
+            pcgIntOpLit("sar", mirDef(mir, 0), mirUse(mir, 0),
+                        (s1)mir_vC(mir));
+            break;
+
+        case OP_USHR_INT_LIT8:
+            pcgIntOpLit("shr", mirDef(mir, 0), mirUse(mir, 0),
+                        (s1)mir_vC(mir));
+            break;
+
+        case OP_ADD_INT_LIT16:
+            pcgIntOpLit("add", mirDef(mir, 0), mirUse(mir, 0),
+                        (s2)mir_vC(mir));
+            break;
+
+        case OP_OR_INT_LIT16:
+            pcgIntOpLit("or", mirDef(mir, 0), mirUse(mir, 0), (s2)mir_vC(mir));
+            break;
+
+        case OP_AND_INT_LIT16:
+            pcgIntOpLit("and", mirDef(mir, 0), mirUse(mir, 0),
+                        (s2)mir_vC(mir));
+            break;
+
+        case OP_XOR_INT_LIT16:
+            pcgIntOpLit("xor", mirDef(mir, 0), mirUse(mir, 0),
+                        (s2)mir_vC(mir));
+            break;
+
+        case OP_MUL_INT:
+            pcgIntOpOp("imul", mirDef(mir, 0), mirUse(mir, 0), mirUse(mir, 1));
+            break;
+
+        case OP_MUL_INT_LIT8:
+            pcgIntOpLit("imul", mirDef(mir, 0), mirUse(mir, 0),
+                        (s1)mir_vC(mir));
+            break;
+
+        case OP_MUL_INT_LIT16:
+            pcgIntOpLit("imul", mirDef(mir, 0), mirUse(mir, 0),
+                        (s2)mir_vC(mir));
+            break;
+
+        case OP_INT_TO_LONG:
+            pcgTranslateIntToLong(mir);
+            break;
+
+        case OP_INT_TO_SHORT:
+            pcgTranslateIntExtend(mir, "sext", 16);
+            break;
+
+        case OP_INT_TO_BYTE:
+            pcgTranslateIntExtend(mir, "sext", 24);
+            break;
+
+        case OP_LONG_TO_INT:
+            pcgTranslateLongToInt(mir);
+            break;
+
+        case OP_INT_TO_CHAR:
+            pcgTranslateIntExtend(mir, "zext", 16);
+            break;
+
+        case OP_CMP_LONG:
+            pcgTranslateCmpLong(mir);
+            break;
+
+        case OP_ADD_LONG_2ADDR:
+            pcgTranslate2addrLLreg(mir, "ladd");
+            break;
+
+        case OP_SUB_LONG_2ADDR:
+            pcgTranslate2addrLLreg(mir, "lsub");
+            break;
+
+        case OP_MUL_LONG_2ADDR:
+            pcgTranslate2addrLLreg(mir, "limul");
+            break;
+
+        case OP_MUL_LONG:
+            pcgTranslate3addrLLreg(mir, "limul");
+            break;
+
+        case OP_ADD_LONG:
+            pcgTranslate3addrLLreg(mir, "ladd");
+            break;
+
+        case OP_SUB_LONG:
+            pcgTranslate3addrLLreg(mir, "lsub");
+            break;
+
+        case OP_AND_LONG:
+        case OP_AND_LONG_2ADDR:
+            pcgTranslate3addrLLreg(mir, "land");
+            break;
+
+        case OP_OR_LONG:
+        case OP_OR_LONG_2ADDR:
+            pcgTranslate3addrLLreg(mir, "lor");
+            break;
+
+        case OP_XOR_LONG:
+        case OP_XOR_LONG_2ADDR:
+            pcgTranslate3addrLLreg(mir, "lxor");
+            break;
+
+        case OP_NEG_LONG:
+            pcgLLregOp("lneg", mirDef(mir, 0), mirUse(mir, 0));
+            break;
+
+        case OP_NOT_LONG:
+            pcgLLregOp("lnot", mirDef(mir, 0), mirUse(mir, 0));
+            break;
+
+        case OP_SHL_LONG:
+        case OP_SHL_LONG_2ADDR:
+            pcgTranslateLLregShift(mir, "lshl");
+            break;
+
+        case OP_SHR_LONG:
+        case OP_SHR_LONG_2ADDR:
+            pcgTranslateLLregShift(mir, "lsar");
+            break;
+
+        case OP_USHR_LONG:
+        case OP_USHR_LONG_2ADDR:
+            pcgTranslateLLregShift(mir, "lshr");
+            break;
+
+        case OP_DIV_LONG:
+        case OP_REM_LONG:
+            pcgTranslateDivRemLong(mir, dalvikOpCode, mir_vA(mir), mir_vB(mir),
+                                   mir_vC(mir));
+            break;
+
+        case OP_DIV_INT:
+        case OP_REM_INT:
+            pcgTranslateDivRemInt(mir, dalvikOpCode, mir_vA(mir), mir_vB(mir),
+                                  mir_vC(mir));
+            break;
+
+        case OP_DIV_INT_2ADDR:
+        case OP_REM_INT_2ADDR:
+            pcgTranslateDivRemInt(mir, dalvikOpCode, mir_vA(mir), mir_vA(mir),
+                                  mir_vB(mir));
+            break;
+
+        case OP_DIV_LONG_2ADDR:
+        case OP_REM_LONG_2ADDR:
+            pcgTranslateDivRemLong(mir, dalvikOpCode, mir_vA(mir), mir_vA(mir),
+                                   mir_vB(mir));
+            break;
+
+        case OP_DIV_INT_LIT8:
+        case OP_REM_INT_LIT8:
+            pcgTranslateDivRemIntLit(mir, dalvikOpCode, mir_vA(mir),
+                                     mir_vB(mir),
+                                     (s1)mir_vC(mir));
+            break;
+
+        case OP_DIV_INT_LIT16:
+        case OP_REM_INT_LIT16:
+            pcgTranslateDivRemIntLit(mir, dalvikOpCode, mir_vA(mir),
+                                     mir_vB(mir),
+                                     (s2)mir_vC(mir));
+            break;
+
+        case OP_ADD_FLOAT_2ADDR:
+            pcgTranslate2addrFloat(mir, "addss1");
+            break;
+
+        case OP_SUB_FLOAT_2ADDR:
+            pcgTranslate2addrFloat(mir, "subss1");
+            break;
+
+        case OP_MUL_FLOAT_2ADDR:
+            pcgTranslate2addrFloat(mir, "mulss1");
+            break;
+
+        case OP_DIV_FLOAT_2ADDR:
+            pcgTranslate2addrFloat(mir, "divss1");
+            break;
+
+        case OP_ADD_FLOAT:
+            pcgTranslate3addrFloat(mir, "addss1");
+            break;
+
+        case OP_SUB_FLOAT:
+            pcgTranslate3addrFloat(mir, "subss1");
+            break;
+
+        case OP_MUL_FLOAT:
+            pcgTranslate3addrFloat(mir, "mulss1");
+            break;
+
+        case OP_DIV_FLOAT:
+            pcgTranslate3addrFloat(mir, "divss1");
+            break;
+
+        case OP_ADD_DOUBLE_2ADDR:
+            pcgTranslate2addrDouble(mir, "addsd1");
+            break;
+
+        case OP_SUB_DOUBLE_2ADDR:
+            pcgTranslate2addrDouble(mir, "subsd1");
+            break;
+
+        case OP_MUL_DOUBLE_2ADDR:
+            pcgTranslate2addrDouble(mir, "mulsd1");
+            break;
+
+        case OP_DIV_DOUBLE_2ADDR:
+            pcgTranslate2addrDouble(mir, "divsd1");
+            break;
+
+        case OP_ADD_DOUBLE:
+            pcgTranslate3addrDouble(mir, "addsd1");
+            break;
+
+        case OP_SUB_DOUBLE:
+            pcgTranslate3addrDouble(mir, "subsd1");
+            break;
+
+        case OP_MUL_DOUBLE:
+            pcgTranslate3addrDouble(mir, "mulsd1");
+            break;
+
+        case OP_DIV_DOUBLE:
+            pcgTranslate3addrDouble(mir, "divsd1");
+            break;
+
+        case OP_INT_TO_DOUBLE:
+            pcgTranslateIntToFP(mir, 8);
+            break;
+
+        case OP_INT_TO_FLOAT:
+            pcgTranslateIntToFP(mir, 4);
+            break;
+
+        case OP_LONG_TO_DOUBLE:
+            pcgTranslateLongToFP(mir, 8);
+            break;
+
+        case OP_LONG_TO_FLOAT:
+            pcgTranslateLongToFP(mir, 4);
+            break;
+
+        case OP_DOUBLE_TO_INT:
+            pcgTranslateFPToInt(mir, 8);
+            break;
+
+        case OP_FLOAT_TO_INT:
+            pcgTranslateFPToInt(mir, 4);
+            break;
+
+        case OP_FLOAT_TO_DOUBLE:
+            pcgTranslateFloatToDouble(mir);
+            break;
+
+        case OP_DOUBLE_TO_FLOAT:
+            pcgTranslateDoubleToFloat(mir);
+            break;
+
+        case OP_NEG_DOUBLE:
+            pcgTranslateNegDouble(mir);
+            break;
+
+        case OP_CMPG_FLOAT:
+            pcgTranslateIfFp(mir, 4, 1);
+            break;
+
+        case OP_CMPL_FLOAT:
+            pcgTranslateIfFp(mir, 4, -1);
+            break;
+
+        case OP_CMPG_DOUBLE:
+            pcgTranslateIfFp(mir, 8, 1);
+            break;
+
+        case OP_CMPL_DOUBLE:
+            pcgTranslateIfFp(mir, 8, -1);
+            break;
+
+        case OP_IGET_WIDE_QUICK:
+            pcgTranslateIgetWideQuick(mir);
+            break;
+
+        case OP_IGET_OBJECT_QUICK:
+        case OP_IGET_QUICK:
+            pcgTranslateIgetObjectQuick(mir);
+            break;
+
+        case OP_IGET:
+        case OP_IGET_BOOLEAN:
+        case OP_IGET_BYTE:
+        case OP_IGET_CHAR:
+        case OP_IGET_SHORT:
+            pcgTranslateIgetIput(mir, true, false, false, false);
+            break;
+
+        case OP_IGET_VOLATILE:
+            pcgTranslateIgetIput(mir, true, false, false, true);
+            break;
+
+        case OP_IGET_WIDE:
+            pcgTranslateIgetIput(mir, true, false, true, false);
+            break;
+
+        case OP_IGET_WIDE_VOLATILE:
+            pcgTranslateIgetIput(mir, true, false, true, true);
+            break;
+
+        case OP_IGET_OBJECT:
+            pcgTranslateIgetIput(mir, true, true, false, false);
+            break;
+
+        case OP_IGET_OBJECT_VOLATILE:
+            pcgTranslateIgetIput(mir, true, true, false, true);
+            break;
+
+        case OP_IPUT:
+        case OP_IPUT_BOOLEAN:
+        case OP_IPUT_BYTE:
+        case OP_IPUT_CHAR:
+        case OP_IPUT_SHORT:
+            pcgTranslateIgetIput(mir, false, false, false, false);
+            break;
+
+        case OP_IPUT_VOLATILE:
+            pcgTranslateIgetIput(mir, false, false, false, true);
+            break;
+
+        case OP_IPUT_OBJECT:
+            pcgTranslateIgetIput(mir, false, true, false, false);
+            break;
+
+        case OP_IPUT_OBJECT_VOLATILE:
+            pcgTranslateIgetIput(mir, false, true, false, true);
+            break;
+
+        case OP_IPUT_WIDE:
+            pcgTranslateIgetIput(mir, false, false, true, false);
+            break;
+
+        case OP_EXECUTE_INLINE:
+        case OP_EXECUTE_INLINE_RANGE:
+            pcgTranslateExecuteInline(mir);
+            break;
+
+        case OP_MONITOR_ENTER:
+            pcgTranslateMonitorEnter(mir);
+            break;
+ 
+        case OP_MONITOR_EXIT:
+            pcgTranslateMonitorExit(mir);
+            break;
+
+        case OP_IPUT_QUICK:
+        case OP_IPUT_OBJECT_QUICK:
+        case OP_IPUT_WIDE_QUICK:
+            pcgTranslateIput(mir, dalvikOpCode);
+            break;
+
+        case OP_AGET:
+        case OP_AGET_OBJECT:
+        case OP_AGET_WIDE:
+        case OP_AGET_BYTE:
+        case OP_AGET_BOOLEAN:
+        case OP_AGET_CHAR:
+        case OP_AGET_SHORT:
+            pcgTranslateAget(mir, dalvikOpCode);
+            break;
+
+        case OP_APUT:
+        case OP_APUT_CHAR:
+        case OP_APUT_BYTE:
+        case OP_APUT_BOOLEAN:
+        case OP_APUT_SHORT:
+        case OP_APUT_WIDE:
+            pcgTranslateAput(mir, dalvikOpCode);
+            break;
+
+        case OP_APUT_OBJECT:
+            pcgTranslateAputObject(mir);
+            break;
+
+        case OP_SGET:
+        case OP_SGET_BOOLEAN:
+        case OP_SGET_CHAR:
+        case OP_SGET_BYTE:
+        case OP_SGET_SHORT:
+        case OP_SGET_VOLATILE:
+            success = pcgTranslateSgetSput(mir, false, true, false);
+            break;
+
+        case OP_SGET_OBJECT:
+        case OP_SGET_OBJECT_VOLATILE:
+            success = pcgTranslateSgetSput(mir, false, true, true);
+            break;
+
+        case OP_SGET_WIDE:
+            success = pcgTranslateSgetSput(mir, true, true, false);
+            break;
+
+        case OP_SPUT:
+        case OP_SPUT_BYTE:
+        case OP_SPUT_CHAR:
+        case OP_SPUT_SHORT:
+        case OP_SPUT_VOLATILE:
+        case OP_SPUT_BOOLEAN:
+            success = pcgTranslateSgetSput(mir, false, false, false);
+            break;
+
+        case OP_SPUT_OBJECT:
+        case OP_SPUT_OBJECT_VOLATILE:
+            success = pcgTranslateSgetSput(mir, false, false, true);
+            break;
+
+        case OP_SPUT_WIDE:
+            success = pcgTranslateSgetSput(mir, true, false, false);
+            break;
+
+        case OP_PACKED_SWITCH:
+            pcgTranslatePackedSwitch(mir);
+            break;
+
+        case OP_RETURN:
+        case OP_RETURN_OBJECT:
+        case OP_RETURN_WIDE:
+            pcgTranslateReturn(mir, false);
+            break;
+
+        case OP_RETURN_VOID:
+        case OP_RETURN_VOID_BARRIER:
+            pcgTranslateReturn(mir, true);
+            break;
+
+        case OP_INVOKE_VIRTUAL_QUICK:
+        case OP_INVOKE_VIRTUAL_QUICK_RANGE:
+            pcgTranslateInvokeVirtualQuick(mir);
+            break;
+
+        case OP_INVOKE_STATIC:
+        case OP_INVOKE_STATIC_RANGE:
+        case OP_INVOKE_SUPER_QUICK:
+        case OP_INVOKE_SUPER_QUICK_RANGE:
+            pcgTranslateInvokeStaticSuperQuick(mir, dalvikOpCode);
+            break;
+
+        case OP_INVOKE_INTERFACE:
+            pcgTranslateInvokeInterface(mir);
+            break;
+
+        case OP_INVOKE_DIRECT:
+        case OP_INVOKE_DIRECT_RANGE:
+            pcgTranslateInvokeDirect(mir);
+            break;
+
+        case OP_MOVE_RESULT:
+        case OP_MOVE_RESULT_OBJECT:
+        case OP_MOVE_RESULT_WIDE:
+            pcgTranslateMoveResult(mir);
+            break;
+
+        case OP_NEW_INSTANCE:
+            pcgTranslateNewInstance(mir);
+            break;
+
+        case OP_NEW_ARRAY:
+            pcgTranslateNewArray(mir);
+            break;
+#if 0
+        case OP_FILLED_NEW_ARRAY:
+            pcgTranslateFilledNewArray(mir);
+            break;
+#endif
+
+        case OP_FILL_ARRAY_DATA:
+            pcgTranslateFillArrayData(mir);
+            break;
+
+        case OP_INSTANCE_OF:
+            pcgTranslateInstanceOf(mir);
+            break;
+
+        case OP_CHECK_CAST:
+            pcgTranslateCheckCast(mir);
+            break;
+
+        case OP_ARRAY_LENGTH:
+            pcgTranslateArrayLength(mir);
+            break;
+
+        default:
+            printf("XXXXXXXXXXXXXX Insn: %s(%d)\n",
+                   dexGetOpcodeName(dalvikOpCode), dalvikOpCode);
+            LOGE("Jit(PCG): unsupported MIR opcode");
+            assert(0);
+            exit(-1);
+    }
+
+    return success;
+}
+
+// pcgFindSymbolRef attempts to find a reference to the specified symbol
+// in the code.  This routine is specifically used to find references to the
+// chaining cells so that the addresses of the references may be recorded in
+// the chaining cell for fixup by the VM.
+//
+// The routine returns a Relocation with all the information about the
+// reference if at least one reference is found.  (In theory, the chaining
+// cell structure expects there to be exactly one reference, but currently
+// there may be more than one.)
+//
+// If no reference is found, we return a dummy relocation at code offset 0.
+// This situation should only be possible if all references to the chaining
+// cell were optimized away (such as can happen if a branch direction may be
+// computed at compile time).
+//
+static Relocation pcgFindSymbolRef(CGSymbol symbol)
+{
+    RelocationList::iterator it;
+    Relocation relocation;
+    bool found = false;
+
+    for (it = pcgRelocationList.begin(); it != pcgRelocationList.end(); ++it) {
+        if (it->target_symbol->cg_symbol == symbol) {
+            relocation = *it;
+            found = true;
+        }
+    }
+
+    if (!found) {
+        relocation.code_offset = 0;
+        relocation.target_symbol = 0;
+        relocation.addend = 0;
+        relocation.relocation_type = CGRelocationTypePC32;
+    }
+
+    return relocation;
+}
+
+static uint8_t* pcgEmitSingletonChainingCell(const uint8_t *start_addr,
+                                             const void *bytecode_target_addr,
+                                             CGSymbol block_symbol,
+                                             uint8_t *curr_cache_ptr,
+                                             size_t free_space)
+{
+    const uint8_t *cell_begin = curr_cache_ptr;
+    const size_t c_chaining_cell_size = 13;
+
+    if (free_space < c_chaining_cell_size) {
+        return NULL;
+    }
+
+    if (DUMP_BYTECODE()) {
+        printf("LOWER InvokeSingletonChainingCell at @%p\n", curr_cache_ptr);
+    }
+
+    // This is the "real" beginning of the chaining cell.  Any branches to this
+    // block should land here, so bind the symbol to this address.
+    pcgBindSymbolAddress(block_symbol, curr_cache_ptr);
+
+    // Now lay down the call instruction.  This is
+    // "call dvmJitToInterpTraceSelect".
+    *curr_cache_ptr++ = 0xe8;
+    *((int32_t*)curr_cache_ptr) =
+      (int32_t)dvmJitToInterpTraceSelect - ((int32_t)curr_cache_ptr + 4);
+    if (DUMP_BYTECODE()) {
+        printf("    call dvmJitToInterpTraceSelect: 0xe8 0x%08x\n",
+               *((int32_t*)curr_cache_ptr));
+    }
+    curr_cache_ptr += 4;
+    
+    // Lay down the bytecode target address.
+    *((const void**)curr_cache_ptr) = bytecode_target_addr;
+    if (DUMP_BYTECODE()) {
+        printf("    rPC: 0x%p\n", *((const void**)curr_cache_ptr));
+    }
+    curr_cache_ptr += 4;
+
+    // Finally, lay down the address in the code where this chaining cell is
+    // referenced.
+    *((const uint8_t**)curr_cache_ptr) =
+        start_addr + pcgFindSymbolRef(block_symbol).code_offset;
+    if (DUMP_BYTECODE()) {
+        printf("    codePtr: 0x%p\n", *((const uint8_t**)curr_cache_ptr));
+    }
+    curr_cache_ptr += 4;
+
+    if ((size_t)(curr_cache_ptr - cell_begin) != c_chaining_cell_size) {
+        ALOGE("\n+++ PCG ERROR +++ Singleton chaining cell size "
+              "inconsistency");
+        exit(-1);
+    }
+
+    return curr_cache_ptr;
+}
+
+//
+// Init values when a predicted chain is initially assembled.
+// E7FE is branch to self.
+//
+#define PREDICTED_CHAIN_BX_PAIR_INIT     0xe7fe
+//
+// Chaining cell for monomorphic method invocations.
+// This "block" contains only data. The data within this block will
+// get patched again, later.
+// This block will be referenced via the stored cg_symbol, and
+// dereferenced during predicted chaining execution.
+//
+static uint8_t* pcgEmitPredictedChainingCell(CGSymbol block_symbol,
+                                             uint8_t *curr_cache_ptr,
+                                             size_t free_space)
+{
+    const uint8_t *cell_begin = curr_cache_ptr;
+    const size_t c_chaining_cell_size = 20;
+
+    if (free_space < c_chaining_cell_size) {
+        return NULL;
+    }
+
+    if (DUMP_BYTECODE()) {
+        printf("LOWER InvokePredictedChainingCell at @%p\n", curr_cache_ptr);
+    }
+
+    //
+    // This is the beginning of the chaining cell. All symbol referenced
+    // will be made to this location.
+    //
+    pcgBindSymbolAddress(block_symbol, curr_cache_ptr);
+    int *int_stream = (int *)curr_cache_ptr;
+
+    int_stream[0] = PREDICTED_CHAIN_BX_PAIR_INIT;
+    int_stream[1] = 0;
+    // To be filled: class
+    int_stream[2] = PREDICTED_CHAIN_CLAZZ_INIT;
+    // To be filled: method
+    int_stream[3] = PREDICTED_CHAIN_METHOD_INIT;
+    //
+    // Rechain count. The initial value of 0 here will trigger chaining upon
+    // the first invocation of this callsite.
+    //
+    int_stream[4] = PREDICTED_CHAIN_COUNTER_INIT;
+    curr_cache_ptr += 20;
+
+    if (DUMP_BYTECODE()) {
+        printf("    0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x\n",
+               int_stream[0], int_stream[1], int_stream[2], int_stream[3],
+               int_stream[4]);
+    }
+
+    if ((size_t)(curr_cache_ptr - cell_begin) != c_chaining_cell_size) {
+        ALOGE("\n+++ PCG ERROR +++ Predicted chaining cell size "
+              "inconsistency");
+        exit(-1);
+    }
+
+    return curr_cache_ptr;
+}
+
+static uint8_t* pcgEmitHotChainingCell(const uint8_t *start_addr,
+                                       const void *bytecode_target_addr,
+                                       CGSymbol block_symbol,
+                                       uint8_t *curr_cache_ptr,
+                                       size_t free_space)
+{
+    const uint8_t *cell_begin = curr_cache_ptr;
+    const size_t c_chaining_cell_size = 17;
+
+    if (free_space < c_chaining_cell_size) {
+        return NULL;
+    }
+
+    if (DUMP_BYTECODE()) {
+        printf("LOWER HotChainingCell at @%p.\n", curr_cache_ptr);
+    }
+
+    // This is the "real" beginning of the chaining cell.  Any branches to this
+    // block should land here, so bind the symbol to this address.
+    pcgBindSymbolAddress(block_symbol, curr_cache_ptr);
+
+    Relocation relocation = pcgFindSymbolRef(block_symbol);
+    int is_relative = 0;
+
+    // Now lay down the call instruction.  The call instruction differs
+    // depending on whether the reference is absolute or PC-relative.
+    //
+    *curr_cache_ptr++ = 0xe8;
+    if (relocation.relocation_type == CGRelocationTypePC32) {
+        *((int32_t*)curr_cache_ptr) =
+            (int32_t)dvmJitToInterpNormal - ((int32_t)curr_cache_ptr + 4);
+        is_relative = 1;
+        if (DUMP_BYTECODE()) {
+            printf("    call dvmJitToInterpNormal: 0xe8 0x%08x\n",
+                   *((int32_t*)curr_cache_ptr));
+        }
+    }
+    else {
+        *((int32_t*)curr_cache_ptr) =
+            (int32_t)dvmJitToInterpTraceSelect - ((int32_t)curr_cache_ptr + 4);
+
+        if (DUMP_BYTECODE()) {
+            printf("    call dvmJitToInterpTraceSelect: 0xe8 0x%08x\n",
+                   *((int32_t*)curr_cache_ptr));
+        }
+    }
+    curr_cache_ptr += 4;
+    
+    // Lay down the bytecode target address.
+    *((const void**)curr_cache_ptr) = bytecode_target_addr;
+    if (DUMP_BYTECODE()) {
+        printf("    rPC: 0x%p\n", *((const void**)curr_cache_ptr));
+    }
+    curr_cache_ptr += 4;
+
+    // Lay down the address in the code where this chaining cell is referenced.
+    *((const uint8_t**)curr_cache_ptr) = start_addr + relocation.code_offset;
+    if (DUMP_BYTECODE()) {
+        printf("    codePtr: 0x%p\n", *((const uint8_t**)curr_cache_ptr));
+    }
+    curr_cache_ptr += 4;
+
+    // Finally, lay out a flag to signal whether the reference is absolute or
+    // PC-relative.
+    *((int *)curr_cache_ptr) = is_relative;
+    if (DUMP_BYTECODE()) {
+        printf("    flag: 0x%08x\n", *((int *)curr_cache_ptr));
+    }
+    curr_cache_ptr += 4;
+
+    if ((size_t)(curr_cache_ptr - cell_begin) != c_chaining_cell_size) {
+        ALOGE("\n+++ PCG ERROR +++ Hot chaining cell size inconsistency");
+        exit(-1);
+    }
+
+    return curr_cache_ptr;
+}
+
+static uint8_t* pcgEmitNormalChainingCell(const uint8_t *start_addr,
+                                          const void *bytecode_target_addr,
+                                          CGSymbol block_symbol,
+                                          uint8_t *curr_cache_ptr,
+                                          size_t free_space)
+{
+    const uint8_t *cell_begin = curr_cache_ptr;
+    const size_t c_chaining_cell_size = 13;
+
+    if (free_space < c_chaining_cell_size) {
+        return NULL;
+    }
+
+    if (DUMP_BYTECODE()) {
+        printf("LOWER NormalChainingCell at @%p\n", curr_cache_ptr);
+    }
+    // Lay down a normal chaining cell in memory.  Given that the VM relies on
+    // the exact length of the code sequence, we emit the code bytes directly
+    // without implicitly relying on the behavior of the encoder, which might
+    // encode an instruction in an unexpected way when multiple choices are
+    // available.
+    //
+
+    // This is the "real" beginning of the chaining cell.  Any branches to this
+    // block should land here, so bind the symbol to this address.
+    pcgBindSymbolAddress(block_symbol, curr_cache_ptr);
+
+    // Now lay down the call instruction.  This is "call dvmJitToInterpNormal".
+    *curr_cache_ptr++ = 0xe8;
+    *((int32_t*)curr_cache_ptr) =
+      (int32_t)dvmJitToInterpNormal - ((int32_t)curr_cache_ptr + 4);
+    if (DUMP_BYTECODE()) {
+        printf("    call dvmJitToInterpNormal: 0xe8 0x%08x\n",
+               *((int32_t*)curr_cache_ptr));
+    }
+    curr_cache_ptr += 4;
+    
+    // Lay down the bytecode target address.
+    *((const void**)curr_cache_ptr) = bytecode_target_addr;
+    if (DUMP_BYTECODE()) {
+        printf("    rPC: 0x%p\n", *((const void**)curr_cache_ptr));
+    }
+    curr_cache_ptr += 4;
+
+    // Finally, lay down the address in the code where this chaining cell is
+    // referenced.
+    *((const uint8_t**)curr_cache_ptr) =
+        start_addr + pcgFindSymbolRef(block_symbol).code_offset;
+    if (DUMP_BYTECODE()) {
+        printf("    codePtr: 0x%p\n", *((const uint8_t**)curr_cache_ptr));
+    }
+    curr_cache_ptr += 4;
+
+    if ((size_t)(curr_cache_ptr - cell_begin) != c_chaining_cell_size) {
+        ALOGE("\n+++ PCG ERROR +++ Normal chaining cell size inconsistency");
+        exit(-1);
+    }
+
+    return curr_cache_ptr;
+}
+
+static uint8_t* pcgEmitBackwardBranchChainingCell(
+    const uint8_t *start_addr,
+    const void *bytecode_target_addr,
+    int blockId,
+    uint8_t *curr_cache_ptr,
+    size_t free_space
+)
+{
+    const uint8_t *cell_begin = curr_cache_ptr;
+    const size_t c_chaining_cell_size = 25;
+
+    if (free_space < c_chaining_cell_size) {
+        return NULL;
+    }
+
+    if (DUMP_BYTECODE()) {
+        printf("LOWER BackwardBranchChainingCell at @%p\n", curr_cache_ptr);
+    }
+    // Lay down a backward branch chaining cell in memory.  Given that the VM
+    // relies on the exact length of the code sequence, we emit the code bytes
+    // directly without implicitly relying on the behavior of the encoder,
+    // which might encode an instruction in an unexpected way when multiple
+    // choices are available.
+    //
+
+    CGSymbol block_symbol = pcgBlockInfo[blockId].chaining_cell_cg_symbol;
+    CGSymbol writeback_symbol = pcgBlockInfo[blockId].writeback_target_symbol;
+
+    // This is the "real" beginning of the chaining cell.  Any branches to this
+    // block should land here, so bind the symbol to this address.
+    pcgBindSymbolAddress(block_symbol, curr_cache_ptr);
+
+    // Lay down the call instruction.
+    // This is "call dvmJitToInterpBackwardBranch".
+    *curr_cache_ptr++ = 0xe8;
+    *((int32_t*)curr_cache_ptr) = (int32_t)dvmJitToInterpBackwardBranch -
+        ((int32_t)curr_cache_ptr + 4);
+    if (DUMP_BYTECODE()) {
+        printf("    call dvmJitToInterpBackwardBranch: 0xe8 0x%08x\n",
+               *((int32_t*)curr_cache_ptr));
+    }
+    curr_cache_ptr += 4;
+    
+    // Lay down the bytecode target address, i.e. the head of the loop.
+    *((const void**)curr_cache_ptr) = bytecode_target_addr;
+    if (DUMP_BYTECODE()) {
+        printf("    rPC: 0x%p\n", *((const void**)curr_cache_ptr));
+    }
+    curr_cache_ptr += 4;
+
+    // Lay down the address in the code where this chaining cell is referenced.
+    *((const uint8_t**)curr_cache_ptr) =
+        start_addr + pcgFindSymbolRef(writeback_symbol).code_offset;
+    if (DUMP_BYTECODE()) {
+        printf("    codePtr: 0x%p\n", *((const uint8_t**)curr_cache_ptr));
+    }
+    curr_cache_ptr += 4;
+
+    // Lay down the code address of the loop header.
+    int64_t loop_header_offset;
+    CGGetLabelNameAndOffset(pcgLoopHeadLabel, &loop_header_offset);
+    *((const uint8_t**)curr_cache_ptr) =
+        start_addr + (int32_t)loop_header_offset;
+    if (DUMP_BYTECODE()) {
+        printf("    loopHeader: 0x%p\n", *((const uint8_t**)curr_cache_ptr));
+    }
+    curr_cache_ptr += 4;
+
+    // Lay down the code address of the jump target that must be used in the
+    // event of unchaining.  This must be the address of the writeback block
+    // for this chaining cell.
+    //
+    *((const void**)curr_cache_ptr) = pcgGetSymbolAddress(writeback_symbol);
+    if (DUMP_BYTECODE()) {
+        printf("    unchainTarget: 0x%p\n",
+               *((const uint8_t**)curr_cache_ptr));
+    }
+    curr_cache_ptr += 4;
+
+    // Lay down the code address for the start of the trace.  This is the
+    // address to which dvmJitToInterpBackwardBranch transfers control after
+    // patching the backward branch.
+    *((const uint8_t**)curr_cache_ptr) = start_addr;
+    if (DUMP_BYTECODE()) {
+        printf("    traceBegin: 0x%p\n", *((const uint8_t**)curr_cache_ptr));
+    }
+    curr_cache_ptr += 4;
+
+    if ((size_t)(curr_cache_ptr - cell_begin) != c_chaining_cell_size) {
+        ALOGE("\n+++ PCG ERROR +++ Backward chaining cell size inconsistency");
+        exit(-1);
+    }
+
+    return curr_cache_ptr;
+}
+
+static const char *pcgBlockDumpString(BasicBlock *bb)
+{
+    if (bb == 0) {
+        return "";
+    }
+    switch (bb->blockType) {
+        case kExceptionHandling:
+            return "[EH]";
+        case kExitBlock :
+            return "[EXIT]";
+        case kEntryBlock:
+            return "[ENTRY]";
+        case kPCReconstruction:
+            return "[RECON]";
+        case kDalvikByteCode:
+            return "[BYTECODE]";
+        case kChainingCellNormal:
+            return "[normal_CC]";
+        case kChainingCellInvokePredicted:
+            return "[predicted_CC]";
+        case kChainingCellInvokeSingleton:
+            return "[singleton_CC]";
+        case kChainingCellHot:
+            return "[hot_CC]";
+        case kChainingCellBackwardBranch:
+            return "[backward_CC]";
+        default:
+            return "[unknown]";
+    }
+}
+
+static bool pcgOpcodeIsInvoke(Opcode opcode)
+{
+    switch (opcode) {
+        case OP_INVOKE_VIRTUAL_QUICK:
+        case OP_INVOKE_VIRTUAL_QUICK_RANGE:
+        case OP_INVOKE_STATIC:
+        case OP_INVOKE_STATIC_RANGE:
+        case OP_INVOKE_SUPER_QUICK:
+        case OP_INVOKE_SUPER_QUICK_RANGE:
+        case OP_INVOKE_INTERFACE:
+        case OP_INVOKE_DIRECT:
+        case OP_INVOKE_DIRECT_RANGE:
+            return true;
+
+        default:
+            break;
+    }
+
+    return false;
+}
+
+static bool pcgBlockEndsInInvoke(BasicBlock *bb)
+{
+    MIR *mir = bb->lastMIRInsn;
+
+    if (mir) {
+        return pcgOpcodeIsInvoke(mir->dalvikInsn.opcode);
+    }
+
+    return false;
+}
+
+static bool pcgTranslateBB(CompilationUnit *cUnit, BasicBlock *bb,
+                           int block_id)
+{
+    MIR *mir;
+
+    pcgCurrentBB = bb;
+
+    if (DUMP_BYTECODE()) {
+        printf("\nStarting %s Translation (BB:%d, FallThrough:%d%s, "
+               "Taken:%d%s)\n",
+               pcgBlockDumpString(bb),
+               bb->id,
+               bb->fallThrough ? bb->fallThrough->id : -1,
+               pcgBlockDumpString(bb->fallThrough),
+               bb->taken ? bb->taken->id : -1,
+               pcgBlockDumpString(bb->taken));
+        printf("------------------------------\n");
+    }
+
+    switch (bb->blockType) {
+        case kEntryBlock:
+            // The entry block is a nop.  It is like first_block in PCG.
+            return true;
+
+        case kExceptionHandling:
+            // ZZZ TODO : this needs to be lowered properly. Also, check to see
+            // why we hit this. Comment for jumpToInterpPunt (which this calls
+            // in Dalvik) says "jump from JIT'ed code to interpreter becaues of
+            // exception"... need to understand why we might hit this.
+            //
+            // * grumble, grumble, grumble *
+            //
+
+            if (pcgExceptionBlockReferenced &&
+                bb->id == cUnit->exceptionBlockId) {
+                pcgBindBlockLabel(block_id);
+
+                CGInst parm_edi = pcg_gen_vmptr_mov();
+                CGInst parm_ebp = pcg_gen_frameptr_mov();
+                CGInst parms[3] = {parm_edi, parm_ebp, CGInstInvalid};
+                CGCreateJsr(pcgJitToInterpPuntSymbol, parms);
+            }
+            else if (DUMP_BYTECODE()) {
+                printf("\nNot binding exception block #%d.\n",bb->id);
+            }
+            return true;
+
+        case kPCReconstruction:
+            return true;
+
+        case kExitBlock:
+        case kDalvikByteCode:
+            break;
+
+        default:
+            ALOGE("\n+++ PCG ERROR +++ Unknown block type seen : %d.",
+                  (int)bb->blockType);
+            exit(-1);
+    }
+
+    if (pcgBlockInfo[block_id].possibly_referenced) {
+        pcgBindBlockLabel(block_id);
+    }
+    else {
+        if (DUMP_BYTECODE()) {
+            printf("XXXXXX block [%d] is not referenced. "
+                   "skipping any IL.\n", block_id);
+        }
+
+        return true;
+    }
+
+    // Track the modified SSANums so that we can do the proper writebacks at
+    // side exits.
+    //
+    dvmCopyBitVector(currModBV, pcgModSSAIns[bb]);
+
+    for (mir = bb->firstMIRInsn; mir; mir = mir->next) {
+        if (!pcgTranslateInsn(cUnit, mir)) {
+            return false;
+        }
+
+        // Update the mod SSANum set.
+        for (int i = 0; i < mir->ssaRep->numDefs; i++) {
+            int ssaNum = mir->ssaRep->defs[i];
+            u2 vr_num = pcgGetVRFromSSANum(ssaNum);
+
+            // Remove any defs of this VR from the mod set
+            subtractBVs(currModBV, currModBV, pcgVRtoSSANumSet[vr_num]);
+
+            // Add this def.
+            if (pcgSSANumInfo[ssaNum].registerize) {
+                dvmSetBit(currModBV, ssaNum);
+            }
+        }
+    }
+    if (bb->fallThrough && bb->fallThrough->blockType != kExitBlock &&
+        bb->fallThrough->blockType != kPCReconstruction) {
+        if (!pcgBlockEndsInInvoke(bb)) {
+            doWritebacksOnEdge(cUnit, bb, bb->fallThrough);
+            pcgDirectJumpToBlock(bb->fallThrough->id);
+        }
+    }
+
+    if (bb->taken && !pcgBlockEndsInInvoke(bb)) {
+        CGBindLabel(pcgBlockInfo[bb->id].taken_label);
+        doWritebacksOnEdge(cUnit, bb, bb->taken);
+        pcgDirectJumpToBlock(bb->taken->id);
+    }
+
+    return true;
+}
+
+// We need a better way to create the unique block_name here.  This is
+// just a hack.  The unique name is useful for debugging.
+static char* pcgGetBlockName(int id, CGLabel cg_label)
+{
+    char *block_name;
+    const char *base_name;
+    static int id_to_emit = 0;
+    const char *trampoline = "";
+
+    if (id != -1) {
+        id_to_emit = (int)pcgBlockInfo[id].cg_label;
+        switch (pcgBlockInfo[id].block_type) {
+            case kChainingCellNormal:
+                base_name = "normal_chaining_cell";
+                break;
+
+            case kChainingCellInvokePredicted:
+                base_name = "invoke_predicted_chaining_cell";
+                break;
+
+            case kChainingCellInvokeSingleton:
+                base_name = "invoke_singleton_chaining_cell";
+                break;
+
+            case kChainingCellHot:
+                base_name = "hot_chaining_cell";
+                break;
+
+            case kChainingCellBackwardBranch:
+                base_name = "backward_branch_chaining_cell";
+                trampoline = "_trampoline";
+                break;
+
+            default:
+                base_name = "dalvik_block_CL";
+                break;
+        }
+    }
+    else {
+        if (cg_label == CGLabelInvalid) {
+            printf("\n!!!!! id and cg_label can't both be unspecified in "
+                   "pcgGetBlockName.\n");
+            exit(-1);
+        }
+        base_name = "dalvik_block_CL";
+        id_to_emit = (int)cg_label;
+        trampoline = "";
+    }
+
+    size_t name_len = strlen(base_name) + strlen(trampoline) + 10;
+    block_name = (char*)malloc(name_len);
+    snprintf(block_name, name_len, "%s%s%d", base_name, trampoline,
+             id_to_emit++);
+
+    return block_name;
+}
+
+#if 0
+// This code was mostly copied from CodegenInterface.cpp.  It was disabled
+// when we updated to ww11, because it is believed to be out-of-date/invalid.
+//
+static bool pcgMergeBlock(BasicBlock *bb, CompilationUnit *cUnit)
+{
+    if (bb->blockType == kDalvikByteCode &&
+        bb->firstMIRInsn != NULL &&
+        (bb->lastMIRInsn->dalvikInsn.opcode == OP_GOTO_16 ||
+         bb->lastMIRInsn->dalvikInsn.opcode == OP_GOTO ||
+         bb->lastMIRInsn->dalvikInsn.opcode == OP_GOTO_32) &&
+        bb->taken != NULL &&
+        bb->fallThrough == NULL) {
+        MIR* prevInsn = bb->lastMIRInsn->prev;
+
+        // Presumably, this check ensures that there are no additional branches
+        // to the target block (bb->taken).  Otherwise, I don't see any code
+        // to do that here.
+        //
+        if (cUnit->jitMode == kJitLoop &&
+            bb->taken == cUnit->entryBlock->fallThrough) {
+            return false;
+        }
+        MIR* mergeInsn = bb->taken->firstMIRInsn;
+        if (mergeInsn == NULL) {
+            return false;
+        }
+        if (prevInsn == NULL) {
+            // the block has a single instruction (i.e. the goto)
+            bb->firstMIRInsn = mergeInsn;
+        }
+        else {
+            prevInsn->next = mergeInsn; // remove goto from the chain
+        }
+        mergeInsn->prev = prevInsn;
+        bb->lastMIRInsn = bb->taken->lastMIRInsn;
+        bb->taken->firstMIRInsn = NULL; //block being merged in
+        bb->taken->lastMIRInsn = NULL; //block being merged in
+        bb->fallThrough = bb->taken->fallThrough;
+        bb->taken = bb->taken->taken;
+
+        return true;
+    }
+    return false;
+}
+#endif
+
+static void pcg_mark_possibly_referenced(BasicBlock *bb)
+{
+    bool is_chaining_cell;
+
+    if (bb == 0 || pcgBlockInfo[bb->id].possibly_referenced) {
+        return;
+    }
+
+    pcgBlockInfo[bb->id].possibly_referenced = true;
+
+    // Any reference to a normal code block should cause us to bind the
+    // label for it, even if it is only referenced by an invoke.
+    // Chaining cells are different, because we use "possibly referenced"
+    // to mean "saw a branch to the exit trampoline for the cell".
+    // References to chaining cells at invokes refer to the chaining cell
+    // itself and not to the exit trampoline.  So do not set
+    // possibly_referenced for chaining cell blocks referenced by invokes.
+    //
+
+    if (bb->fallThrough) {
+        is_chaining_cell = bb->fallThrough->blockType < kChainingCellLast;
+        if (!is_chaining_cell || !pcgBlockEndsInInvoke(bb)) {
+            pcg_mark_possibly_referenced(bb->fallThrough);
+        }
+    }
+
+    if (bb->taken) {
+        is_chaining_cell = bb->taken->blockType < kChainingCellLast;
+        if (!is_chaining_cell || !pcgBlockEndsInInvoke(bb)) {
+            pcg_mark_possibly_referenced(bb->taken);
+        }
+    }
+}
+
+static void pcgStoreVirtualReg(int ssaNum, int store_mask)
+{
+    CGInst store_val = CGGetTempUseInst(pcgSSANumInfo[ssaNum].parentSSANum);
+    pcgDtype dtype = pcgGetDtypeForSSANum(ssaNum);
+    const char *pcg_opcode;
+    u2 virtual_reg = pcgGetVRFromSSANum(ssaNum);
+    int32_t store_size = getOpcodeAndSizeForDtype(dtype, &pcg_opcode);
+
+    if (store_size == 8 && store_mask == 1) {
+        // This is a case where are only writing back the lower 4 bytes
+        // of an 8 byte value.  In this case, we need to convert the input
+        // value (which might either be DPVXreg64 or LLreg) and adjust the
+        // store size.
+        //
+        if (dtype == LLreg) {
+            pcg_opcode = "st";
+        }
+        else {
+            store_val = CGCreateNewInst("movsd12sd", "r", store_val);
+            pcg_opcode = "stss";
+        }
+        store_size = 4;
+    }
+    else if (store_size == 8 && store_mask == 2) {
+        // This is the ugly case!  We are only writing back the upper 4 bytes
+        // of an 8 byte value.  In this case, we need to somehow shift &
+        // convert the input value and adjust the store size.  We also need
+        // to adjust the VR by 1.
+        //
+        if (dtype == LLreg) {
+            store_val = CGCreateNewInst("lshri", "ri", store_val, 32);
+            pcg_opcode = "st";
+        }
+        else {
+            store_val = CGCreateNewInst("movsd12sd", "r", store_val);
+            store_val = CGCreateNewInst("shufps", "rri", store_val, store_val,
+                                        0x1);
+            pcg_opcode = "stss";
+        }
+        store_size = 4;
+        virtual_reg += 1;
+    }
+
+    void *handle = pcgGetVRHandle(virtual_reg, store_size);
+    CGAddr addr = CGCreateAddr(pcgVmPtr, CGInstInvalid, 0, CGSymbolInvalid,
+                               virtual_reg * 4);
+
+    CGCreateNewInst(pcg_opcode, "mr", addr, store_size, handle, store_val);
+}
+
+// Generate code for writing back all members of the set, bv, to their home
+// virtual registers.  This routine modifies tempBV.  Callers may use tempBV
+// to pass the input set but must be aware that its contents will change.
+//
+static void pcgGenerateWritebacks(CompilationUnit *cUnit, BitVector *bv)
+{
+    BitVectorIterator it;
+    int ssaNum;
+
+    dvmCopyBitVector(tempBV, bv);
+
+    dvmBitVectorIteratorInit(bv, &it);
+    while ((ssaNum = dvmBitVectorIteratorNext(&it)) != -1) {
+        if (dvmIsBitSet(tempBV, ssaNum) &&
+            pcgSSANumInfo[ssaNum].deferWriteback) {
+            MIR *mir = pcgSSANumInfo[ssaNum].mir;
+            int store_mask = 1;
+
+            // For 8-byte stores, we have to distinguish between cases where
+            // we need to write back all 8 bytes vs. just the upper or lower
+            // halves.  This may be improved somewhat.  It is inefficient to
+            // store JUST the upper half of a DPVXreg64, because we need a
+            // shufps to do it.  In many cases, we could write the full
+            // 8-bytes as long as we order the writebacks properly.  For
+            // example, if we have an INTreg writeback to v8, and an upper
+            // 4-bytes of DPVXreg64 writeback to v9, we can do a DPVXreg64
+            // store to v8-v9 followed by an INTreg store to v8.
+            //
+            if (mir->ssaRep->numDefs == 2) {
+                if (dvmIsBitSet(tempBV, mir->ssaRep->defs[0]) &&
+                    dvmIsBitSet(tempBV, mir->ssaRep->defs[1])) {
+                    store_mask = 3;
+                    dvmClearBit(tempBV, mir->ssaRep->defs[0]);
+                    dvmClearBit(tempBV, mir->ssaRep->defs[1]);
+                }
+                else if (ssaNum == mir->ssaRep->defs[1]) {
+                    store_mask = 2;
+                }
+            }
+            pcgStoreVirtualReg(mir->ssaRep->defs[0], store_mask);
+            dvmClearBit(tempBV, ssaNum);
+        }
+    }
+}
+
+static void doWritebacksOnEdge(CompilationUnit *cUnit,
+                               BasicBlock *from, BasicBlock *to)
+{
+    // We have to write back any register that is live out of "from" but not
+    // live into "to".  If "to" is a backward branch chaining cell, the
+    // edge is really to the loop header.
+    //
+
+    if (to->blockType == kChainingCellBackwardBranch) {
+        LoopInformation *loop_info = cUnit->loopInformation;
+        to = loop_info->getEntryBlock();
+    }
+
+    dvmCopyBitVector(tempBV, pcgModSSAOuts[from]);
+    subtractBVs(tempBV, tempBV, pcgModSSAIns[to]);
+    pcgGenerateWritebacks(cUnit, tempBV);
+}
+
+static bool pcgTranslateMIR(CompilationUnit *cUnit, JitTranslationInfo* info)
+{
+    unsigned int i;
+    GrowableList *blockList = &cUnit->blockList;
+    BasicBlock *bb;
+
+    pcgBlockInfo = (BlockInfo*)dvmCompilerNew(sizeof(BlockInfo) *
+                                              cUnit->numBlocks,
+                                              true);
+
+    // Initialize various types chaining lists.
+    for (i = 0; i < kChainingCellLast; i++) {
+        dvmInitGrowableList(&chainingListByType[i], 2);
+    }
+
+    // do a cfg reaching walk to figure out if blocks are referenced, or not.
+    for (i = 0; i < blockList->numUsed; i++) {
+        bb = (BasicBlock *)blockList->elemList[i];
+        if (bb->blockType == kEntryBlock) {
+            cUnit->entryBlock = bb;
+            pcg_mark_possibly_referenced(bb);
+            break;
+        }
+    }
+
+    for (i = 0; i < blockList->numUsed; i++) {
+        bb = (BasicBlock *)blockList->elemList[i];
+
+        // Chaining cells and exception handling blocks need to be processed
+        // regardless of whether possibly_referenced is true.  For exception
+        // handling blocks, we need to capture pcgExceptionBlockId, because
+        // there can be implicit references to the exception block, e.g. via
+        // bytecodes whose expansion includes a null check.  Chaining cells
+        // need to be processed, because we must lay down the chaining cell
+        // regardless of whether it is referenced in the code, and we need
+        // its chaining_cell_cg_symbol in order to do that.
+        //
+        if (!pcgBlockInfo[i].possibly_referenced &&
+            bb->blockType != kExceptionHandling &&
+            bb->blockType >= kChainingCellLast) {
+            continue;
+        }
+
+        // Define a label and symbol for each basic block.  We might or might
+        // not need them depending on the contents of the MIR.  Also capture
+        // any other necessary information about the block.  For symbols, use
+        // 0 as the address for now.  It cannot be resolved until later.
+        //
+        pcgBlockInfo[i].cg_label = CGCreateLabel();
+        pcgBlockInfo[i].taken_label = CGCreateLabel();
+        pcgBlockInfo[i].block_type = bb->blockType;
+        pcgBlockInfo[i].block_bound = false;
+
+        // TODO: We might want to define a CGLabelInvalid to use here.
+        pcgBlockInfo[i].writeback_target_label = 0;
+        pcgBlockInfo[i].writeback_target_symbol = CGSymbolInvalid;
+
+        char *block_name;
+        if (bb->blockType < kChainingCellLast) { 
+            block_name = pcgGetBlockName(i);
+            pcgBlockInfo[i].chaining_cell_cg_symbol =
+                pcgCreateSymbol(block_name, 0);
+
+            if (bb->blockType == kChainingCellBackwardBranch) {
+                block_name = pcgGetBlockName(i);
+                pcgBlockInfo[i].writeback_target_label = CGCreateLabel();
+                pcgBlockInfo[i].writeback_target_symbol =
+                    pcgCreateSymbol(block_name, 0);
+                pcgAddLabelSymbolPair(
+                    pcgBlockInfo[i].writeback_target_label,
+                    pcgBlockInfo[i].writeback_target_symbol);
+            }
+        }
+
+        //
+        // Attempt to merge all the exception handling blocks
+        // into the first one that we see.
+        //
+
+        if (bb->taken && bb->taken->blockType == kExceptionHandling) {
+            if (pcgExceptionBlockId == -1) {
+                cUnit->exceptionBlockId = bb->taken->id;
+                pcgExceptionBlockId = bb->taken->id;
+            }
+            else {
+                bb->taken =
+                    (BasicBlock *)blockList->elemList[cUnit->exceptionBlockId];
+            }
+            pcgExceptionBlockReferenced = true;
+        }
+
+        if (bb->fallThrough && bb->fallThrough->blockType ==
+            kExceptionHandling) {
+            if (pcgExceptionBlockId == -1) {
+                cUnit->exceptionBlockId = bb->fallThrough->id;
+                pcgExceptionBlockId = bb->fallThrough->id;
+            }
+            else {
+                bb->fallThrough =
+                    (BasicBlock *)blockList->elemList[cUnit->exceptionBlockId];
+            }
+            pcgExceptionBlockReferenced = true;
+        }
+
+        if (bb->blockType == kExceptionHandling) {
+            if (pcgExceptionBlockId == -1) {
+                cUnit->exceptionBlockId = i;
+                pcgExceptionBlockId = i;
+            }
+        }
+    }
+
+    // Walk the list of blocks and translate the non-chaining blocks.
+    if (DUMP_BYTECODE()) {
+        printf("Starting translation for trace %d\n", pcgTraceCounter);
+        printf("=====================================\n");
+    }
+
+    // Find the loop header block, if applicable.  This block is the target
+    // of the back edge of the loop in loop traces.
+    //
+    BasicBlock *loop_header = NULL;
+    LoopInformation *loop_info = cUnit->loopInformation;
+    if (loop_info) {
+        loop_header = loop_info->getEntryBlock();
+    }
+    if (loop_header) {
+        if (DUMP_BYTECODE()) {
+            printf("Loop entry block id = %d\n", loop_header->id);
+        }
+        pcgLoopHeadLabel = pcgBlockInfo[loop_header->id].cg_label;
+    }
+
+    for (i = 0; i < blockList->numUsed; i++) {
+        bb = (BasicBlock *)blockList->elemList[i];
+
+        if (bb->blockType < kChainingCellLast) {
+            dvmInsertGrowableList(&chainingListByType[bb->blockType], i);
+        }
+        else {
+            if (!pcgTranslateBB(cUnit, bb, i)) {
+                return false;
+            }
+        }
+    }
+
+    // Insert a trace-exit trampoline for every exit from the trace.
+    // Basically, the idea is to bind the label for the chaining call and
+    // have it serve as the branch target for all the other blocks that branch
+    // to the chaining cell.  We'll insert all the necessary exit code in
+    // the trampoline, and then the trampoline will jump to the "real"
+    // chaining cell.
+    //
+    // Note that we do not consider kChainingCellInvokePredicted chaining cells
+    // here.  Those are not real code blocks.  Rather, they hold data that is
+    // loaded in the predicted chaining code.  For some reason, they model this
+    // as a taken branch to the kChainingCellInvokePredicted chaining cell from
+    // the invoke block in the MIR.
+    //
+    for (i = 0; i < kChainingCellGap; i++) {
+        if (i == kChainingCellNormal || i == kChainingCellBackwardBranch ||
+            i == kChainingCellHot) {
+            unsigned int j;
+            for (j = 0; j < chainingListByType[i].numUsed; j++) {
+                int *blockIdList = (int *)chainingListByType[i].elemList;
+                int blockId = blockIdList[j];
+
+                if (!pcgBlockInfo[blockId].possibly_referenced) {
+                    continue;
+                }
+
+                pcgBindBlockLabel(blockId);
+
+                if (i == kChainingCellBackwardBranch) {
+                    CGSymbol writeback_symbol =
+                        pcgBlockInfo[blockId].writeback_target_symbol;
+                    CGLabel writeback_label =
+                        pcgBlockInfo[blockId].writeback_target_label;
+
+                    CGInst jsr = CGCreateNewInst("jsr", "n",
+                                                 writeback_symbol);
+                    CGAddIndirectBranchTarget(jsr, pcgLoopHeadLabel);
+                    CGAddIndirectBranchTarget(jsr, writeback_label);
+
+                    // Create the block for the writeback code.
+                    CGBindLabel(writeback_label);
+                }
+
+                BasicBlock * bb =
+                    (BasicBlock*)cUnit->blockList.elemList[blockId];
+                pcgGenerateWritebacks(cUnit, pcgModSSAIns[bb]);
+
+                // Define the parms for the jsr here.
+                //
+                CGInst parm_edi = pcg_gen_vmptr_mov();
+                CGInst parm_ebp = pcg_gen_frameptr_mov();
+                CGInst parms[3] = {parm_edi, parm_ebp, CGInstInvalid};
+
+                CGInst spadd = CGCreateNewInst("spaddi", "ri",
+                                               CGGetStackPointerDef(), 0);
+                CGSetRreg(spadd, "esp");
+                CGSymbol chaining_cell_sym =
+                    pcgBlockInfo[blockId].chaining_cell_cg_symbol;
+                CGCreateNewInst("jsr", "nl", chaining_cell_sym, parms);
+            }
+        }
+    }
+
+    return true;
+}
+
+static void pcgGenSpeculativeNullChecks(void)
+{
+    const char *pcgOpcode;
+    int32_t size;
+    CGTemp temp;
+    u2 virtual_reg;
+    pcgDtype dtype;
+    VRSet::iterator it;
+
+    for (it = pcgReferencedVRs.begin(); it != pcgReferencedVRs.end(); ++it) {
+        temp = *it;
+        virtual_reg = pcgGetVRFromSSANum(temp);
+        dtype = pcgGetDtypeForSSANum(temp);
+
+        if (pcgSSANumInfo[temp].needsNullCheck &&
+            !pcgSSANumInfo[temp].checkedForNull) {
+            if (DEBUG_REGISTERIZE_VRS()) {
+                printf("\n--------- generating speculative null check for "
+                       "SSA:%d.\n", temp);
+            }
+
+            CGAddr addr = CGCreateAddr(pcgVmPtr, CGInstInvalid, 0,
+                                       CGSymbolInvalid,
+                                       virtual_reg * 4);
+
+            size = getOpcodeAndSizeForDtype(dtype, &pcgOpcode);
+
+            void *handle = pcgGetVRHandle(virtual_reg, size);
+            CGInst load = CGCreateNewInst(pcgOpcode, "m", addr, size, handle);
+            CGAddTempDef(temp, load);
+
+            pcgGenSpeculativeNullCheck(load);
+
+            pcgSSANumInfo[temp].checkedForNull = true;
+        }
+    }
+}
+
+static void pcgAddVRInterfaceCode(void)
+{
+    VRSet::iterator it;
+    const char *pcgOpcode;
+    int32_t size;
+
+    if (DEBUG_REGISTERIZE_VRS()) {
+        printf("    BEGIN Generating Entry Loads.\n"
+               "    =============================\n");
+    }
+    // First insert loads at the entry to the trace.
+    CGSetCurrentInsertionPoint(pcgEntryInsertionPoint);
+    for (it = pcgReferencedVRs.begin(); it != pcgReferencedVRs.end(); ++it) {
+        int ssaNum;
+        u2 virtual_reg;
+        pcgDtype dtype;
+
+        ssaNum = *it;
+
+        virtual_reg = pcgGetVRFromSSANum(ssaNum);
+        dtype = pcgGetDtypeForSSANum(ssaNum);
+
+        if (pcgSSANumInfo[ssaNum].checkedForNull == true) {
+            // speculative null check has already loaded this ssa
+            if (DEBUG_REGISTERIZE_VRS()) {
+                printf("    Not generating entry load for v%d_%d."
+                       " Already null checked.\n",
+                       virtual_reg,
+                       DECODE_SUB(dvmConvertSSARegToDalvik(
+                                      pcgCurrentCompilationUnit, ssaNum)));
+            }
+            continue;
+        }
+
+        if (DEBUG_REGISTERIZE_VRS()) {
+            printf("    Generating entry load for v%d_%d.\n",
+                   virtual_reg,
+                   DECODE_SUB(dvmConvertSSARegToDalvik(
+                                  pcgCurrentCompilationUnit, ssaNum)));
+        }
+
+        CGAddr addr = CGCreateAddr(pcgVmPtr, CGInstInvalid, 0, CGSymbolInvalid,
+                                   virtual_reg * 4);
+
+        size = getOpcodeAndSizeForDtype(dtype, &pcgOpcode);
+
+        void *handle = pcgGetVRHandle(virtual_reg, size);
+        CGInst load = CGCreateNewInst(pcgOpcode, "m", addr, size, handle);
+        CGAddTempDef(pcgSSANumInfo[ssaNum].parentSSANum, load);
+    }
+    if (DEBUG_REGISTERIZE_VRS()) {
+        printf("    END Generating Entry Loads.\n"
+               "    ===========================\n");
+    }
+}
+
+static bool pcgGenIlForTrace(CompilationUnit *cUnit, JitTranslationInfo* info)
+{
+    pcgGenEntryIl();
+    pcgGenSpeculativeNullChecks();
+    if (!pcgTranslateMIR(cUnit, info)) {
+        return false;
+    }
+
+    pcgAddVRInterfaceCode();
+
+    return true;
+}
+
+// start_addr is the routine start address.  curr_cache_ptr is a pointer to the
+// next available byte in the code cache.  This routine returns the next
+// available byte in the code cache, or NULL if there isn't enough available
+// space to lay down the chaining cells.
+// 
+//
+static uint8_t *pcgEmitChainingCells(CompilationUnit *cUnit,
+                                     uint8_t *start_addr,
+                                     uint8_t *cache_ptr,
+                                     size_t free_space)
+{
+    u4 padding, i;
+    uint8_t *first_chain_cell_addr;
+
+    first_chain_cell_addr = cache_ptr;
+
+    // First emit the code for the chaining cells.
+    for (i = 0; i < kChainingCellGap; i++) {
+        int *blockIdList = (int *)chainingListByType[i].elemList;
+        cUnit->numChainingCells[i] = chainingListByType[i].numUsed;
+        pcgChainCellCounts.u.count[i] = cUnit->numChainingCells[i];
+
+        unsigned int j;
+        for (j = 0; j < chainingListByType[i].numUsed; j++) {
+            uint8_t *new_cache_ptr;
+            int blockId = blockIdList[j];
+            BasicBlock *chainingBlock =
+                (BasicBlock *) dvmGrowableListGetElement(&cUnit->blockList,
+                                                         blockId);
+
+            if (DUMP_BYTECODE()) {
+                printf("Starting translation for block %d\n", blockId);
+                printf("---------------------------------\n");
+            }
+            switch (chainingBlock->blockType) {
+                case kChainingCellNormal:
+                    new_cache_ptr = pcgEmitNormalChainingCell(
+                            start_addr,
+                            cUnit->method->insns + chainingBlock->startOffset,
+                            pcgBlockInfo[blockId].chaining_cell_cg_symbol,
+                            cache_ptr,
+                            free_space);
+                    break;
+
+                case kChainingCellBackwardBranch:
+                    new_cache_ptr = pcgEmitBackwardBranchChainingCell(
+                            start_addr,
+                            cUnit->method->insns + chainingBlock->startOffset,
+                            blockId,
+                            cache_ptr,
+                            free_space);
+                    break;
+
+                case kChainingCellInvokePredicted:
+                    new_cache_ptr = pcgEmitPredictedChainingCell(
+                            pcgBlockInfo[blockId].chaining_cell_cg_symbol,
+                            cache_ptr,
+                            free_space);
+                    break;
+
+                case kChainingCellInvokeSingleton:
+                    new_cache_ptr = pcgEmitSingletonChainingCell(
+                            start_addr,
+                            chainingBlock->containingMethod->insns,
+                            pcgBlockInfo[blockId].chaining_cell_cg_symbol,
+                            cache_ptr,
+                            free_space);
+                    break;
+
+                case kChainingCellHot:
+                    new_cache_ptr = pcgEmitHotChainingCell(
+                            start_addr,
+                            cUnit->method->insns + chainingBlock->startOffset,
+                            pcgBlockInfo[blockId].chaining_cell_cg_symbol,
+                            cache_ptr,
+                            free_space);
+                    break;
+
+                default:
+                    ALOGE("\n+++ PCG ERROR +++ Unknown chaining block type "
+                          "seen : %d.", (int)chainingBlock->blockType);
+                    exit(-1);
+            }
+
+            if (!new_cache_ptr) {
+                // The code cache is full.  Return NULL to indicate this.
+                return NULL;
+            }
+            free_space -= (new_cache_ptr - cache_ptr);
+            cache_ptr = new_cache_ptr;
+        }
+    }
+
+    // Dump section for chaining cell counts, make sure it is 4-byte aligned
+    padding = (4 - ((u4)cache_ptr % 4)) % 4;
+
+    // make sure there is enough space for the chaining cell counts and
+    // padding.  Return NULL if not.
+    if (free_space < padding + sizeof(pcgChainCellCounts)) {
+        return NULL;
+    }
+    free_space -= padding + sizeof(pcgChainCellCounts);
+    cache_ptr += padding;
+
+    // Install the chaining information.  There are two u2 values that
+    // immediately precede start_addr:
+    // u2 chainingCellCountOffset: This is the offset from start_addr where
+    //     the chaining cell count information is located.
+    // u2 chainingCellCount: This is the offset from start_addr where the
+    //     actual chaining cells are located.
+    //
+    *((u2*)start_addr - 2) = cache_ptr - start_addr;
+    *((u2*)start_addr - 1) = (u2)(first_chain_cell_addr - start_addr);
+
+    if (DUMP_BYTECODE()) {
+        printf("Routine header at 0x%p\n", (u2*)start_addr - 2);
+        printf("    Chaining cell counts offset: 0x%04x\n",
+               *((u2*)start_addr - 2));
+        printf("    Chaining cells offset: 0x%04x\n",
+               *((u2*)start_addr - 1));
+    }
+
+    memcpy(cache_ptr, &pcgChainCellCounts, sizeof(pcgChainCellCounts));
+    if (DUMP_BYTECODE()) {
+        printf("Chaining cell counts contents @0x%p\n   ", cache_ptr);
+        for (i = 0; i < sizeof(pcgChainCellCounts); i++) {
+            printf(" 0x%02x", cache_ptr[i]);
+        }
+        printf("\n");
+    }
+
+    return cache_ptr + sizeof(pcgChainCellCounts);
+}
+
+void printEmittedCodeBlock(unsigned char *startAddr, unsigned char *endAddr);
+
+// Some block address might have been referenced by the block's CGSymbol.
+// Now that the code has been laid down, we can compute the addresses of those
+// symbols.  This needs to be done before we attempt to resolve references
+// to these symbols in pcgResolveSymbolReferences.
+//
+static void pcgBindBlockSymbolAddresses(CompilationUnit *cUnit,
+                                        uint8_t *start_addr)
+{
+    LabelSymbolList::iterator it;
+    LabelSymbol ls;
+
+    for (it = pcgLabelSymbolList.begin();
+         it != pcgLabelSymbolList.end(); ++it) {
+        ls = *it;
+
+        int64_t label_offset;
+        uint8_t *label_addr;
+        CGLabel cg_label = ls.cg_label;
+        CGGetLabelNameAndOffset(cg_label, &label_offset);
+        label_addr = start_addr + label_offset;
+        pcgBindSymbolAddress(ls.cg_symbol, label_addr);
+    }
+}
+
+// Perform symbol relocation.  The input argument is the address of the start
+// of the routine.
+//
+static void pcgResolveSymbolReferences(uint8_t *code_ptr)
+{
+    RelocationList::iterator it;
+    Relocation relocation;
+
+    for (it = pcgRelocationList.begin(); it != pcgRelocationList.end(); ++it) {
+        relocation = *it;
+
+        uint8_t *symbol_address = (uint8_t*)relocation.target_symbol->address;
+        uint8_t *ip = code_ptr + relocation.code_offset;
+
+        switch (relocation.relocation_type) {
+           case CGRelocationType32:
+               *((uint32_t*)ip) =
+                   (uint32_t)(symbol_address + relocation.addend);
+               break;
+
+           case CGRelocationTypePC32:
+               *((uint32_t*)ip) =
+                   (uint32_t)(symbol_address - ip + relocation.addend);
+               break;
+
+           default:
+               // Unsupported relocation type.
+               assert(0);
+        }
+    }
+}
+
+static void pcgEmitCode(CompilationUnit *cUnit, JitTranslationInfo* info)
+{
+    uint8_t *start_addr, *end_addr;
+    uint32_t required_align;
+    uint8_t *cache_start_ptr =
+      (uint8_t*)gDvmJit.codeCache + gDvmJit.codeCacheByteUsed;
+    uint8_t *curr_cache_ptr = cache_start_ptr;
+    size_t free_space;
+    const uint32_t c_extra_bytes_for_chaining = 4;
+
+    free_space = gDvmJit.codeCacheSize - gDvmJit.codeCacheByteUsed;
+
+    // Allocate space for the chaining information.
+    if (free_space < c_extra_bytes_for_chaining) {
+        gDvmJit.codeCacheFull = true;
+        return;
+    }
+    curr_cache_ptr += c_extra_bytes_for_chaining;
+    free_space -= c_extra_bytes_for_chaining;
+
+    // The code buffer is fixed in memory, so we know the exact alignment.
+    // Use 0x80000000 to indicate this.  Given that we know the alignment,
+    // the only reason CGGetBinaryCode should fail is due to insufficient
+    // space in the code cache.
+    //
+    if (!CGGetBinaryCode(curr_cache_ptr, free_space, 0x80000000,
+                         &start_addr, &end_addr, &required_align)) {
+        gDvmJit.codeCacheFull = true;
+        return;
+    }
+    free_space -= (end_addr + 1) - curr_cache_ptr;
+
+    pcgBindBlockSymbolAddresses(cUnit, start_addr);
+
+    curr_cache_ptr = pcgEmitChainingCells(cUnit, start_addr, end_addr + 1,
+                                          free_space);
+    if (!curr_cache_ptr) {
+        gDvmJit.codeCacheFull = true;
+        return;
+    }
+
+    pcgResolveSymbolReferences(start_addr);
+
+    // Update the necessary state following the successful compilation.
+    // cUint->baseAddr is the function entry point.  So is info->codeAddress.
+    // cUnit->totalSize gives the total size, including initial padding.  We
+    // also increment gDvmJit.codeCacheByteUsed by this amount.
+    // Increment gDvmJit.numCompilations to indicate successful compilation.
+    //
+    cUnit->baseAddr = start_addr;
+    info->codeAddress = start_addr;
+    cUnit->totalSize = curr_cache_ptr - cache_start_ptr + 1;
+    gDvmJit.codeCacheByteUsed += cUnit->totalSize;
+    gDvmJit.numCompilations++;
+
+    if (DUMP_DISASM()) {
+        printf("Disassembly for trace %d\n", pcgTraceCounter);
+        printf("=========================\n");
+        printEmittedCodeBlock(start_addr, end_addr + 1);
+    }
+
+    // TODO (DLK): stream needs to be updated here for the time being, because
+    //     the call that patches instruction immediates (presumably jump
+    //     offsets) asserts that the address being patched is less than stream.
+    //
+    stream = (char*)curr_cache_ptr;
+
+    if (DUMP_DISASM()) {
+        printf("Code cache range for trace %d [0x%p, 0x%p)\n", pcgTraceCounter,
+               cache_start_ptr, stream);
+    }
+}
+
+extern void pcgModuleBegin(void)
+{
+    // Set CG_gcc_alignment_compatibility to 0 so that PCG doesn't complain
+    // about outgoing calls that do not preserve 16-byte alignment.  This is
+    // a hacky method of doing this and should be cleaned up.
+    //
+    extern int CG_gcc_alignment_compatibility;
+    CG_gcc_alignment_compatibility = 0;
+
+    CGCreateModule(0);
+
+    pcgJitToInterpPuntSymbol =
+        pcgCreateSymbol("dvmJitToInterpPunt", (void*)dvmJitToInterpPunt);
+
+    dvmJitToInterpNoChainNoProfileSymbol =
+        pcgCreateSymbol("dvmJitToInterpNoChainNoProfile",
+                        (void*)dvmJitToInterpNoChainNoProfile);
+
+    common_errNullObjectSymbol =
+        pcgCreateSymbol("common_errNullObject",
+                        (void*)common_errNullObject);
+
+    dvmJitToPatchPredictedChainSymbol =
+        pcgCreateSymbol("dvmJitToPatchPredictedChain",
+                        (void*)dvmJitToPatchPredictedChain);
+
+    dvmFindInterfaceMethodInCacheSymbol =
+        pcgCreateSymbol("dvmFindInterfaceMethodInCache",
+                        (void*)dvmFindInterfaceMethodInCache);
+
+    dvmJitToExceptionThrownSymbol =
+        pcgCreateSymbol("dvmJitToExceptionThrown",
+                        (void*)dvmJitToExceptionThrown);
+
+    dvmLockObjectSymbol =
+        pcgCreateSymbol("dvmLockObject", (void*)dvmLockObject);
+
+    dvmUnlockObjectSymbol =
+        pcgCreateSymbol("dvmUnlockObject", (void*)dvmUnlockObject);
+
+    dvmInstanceofNonTrivialSymbol =
+        pcgCreateSymbol("dvmInstanceofNonTrivial",
+                        (void*)dvmInstanceofNonTrivial);
+
+    pcgCreateSymbol("dvmAllocArrayByClass", (void*)dvmAllocArrayByClass);
+    pcgCreateSymbol("dvmAllocObject", (void*)dvmAllocObject);
+    pcgCreateSymbol("dvmQuasiAtomicRead64", (void*)dvmQuasiAtomicRead64);
+    pcgCreateSymbol("dvmCanPutArrayElement", (void*)dvmCanPutArrayElement);
+    pcgCreateSymbol("dvmInterpHandleFillArrayData",
+                    (void*)dvmInterpHandleFillArrayData);
+    pcgCreateSymbol("dvmJitHandlePackedSwitch",
+                    (void*)dvmJitHandlePackedSwitch);
+    pcgCreateSymbol("dvmJitToInterpNoChain", (void*)dvmJitToInterpNoChain);
+    pcgCreateSymbol("dvmJitHelper_returnFromMethod", (void*)dvmJitHelper_returnFromMethod);
+
+    pcgCreateSymbol("__divdi3", (void*)__divdi3);
+    pcgCreateSymbol("__moddi3", (void*)__moddi3);
+    pcgCreateSymbol("__muldi3", (void*)__muldi3);
+    pcgCreateSymbol("__ashldi3", (void*)__ashldi3);
+    pcgCreateSymbol("__lshrdi3", (void*)__lshrdi3);
+    pcgCreateSymbol("__ashrdi3", (void*)__ashrdi3);
+
+#ifdef DEBUG_HOOK
+    uint8_t *debug_hook_ptr = (uint8_t *)stream;
+    *debug_hook_ptr = 0xcc;
+    *(debug_hook_ptr + 1) = 0xc3;
+    stream += 2;
+    pcgCreateSymbol("debugHook", (void*)debug_hook_ptr);
+#endif
+}
+
+extern void pcgModuleEnd(void)
+{
+    CGEndModule(0);
+}
+
+static void pcgDefRef(int ssaNum, pcgDtype dtype)
+{
+    SSANumInfoMap::iterator it = pcgSSANumInfo.find(ssaNum);
+
+    if (it == pcgSSANumInfo.end()) {
+        pcgSSANumInfo[ssaNum].dtype = dtype;
+        pcgSSANumInfo[ssaNum].parentSSANum = ssaNum;
+        pcgSSANumInfo[ssaNum].numUses = 0;
+        pcgSSANumInfo[ssaNum].mir = 0;
+        pcgSSANumInfo[ssaNum].registerize = true;
+        pcgSSANumInfo[ssaNum].needsNullCheck = false;
+        pcgSSANumInfo[ssaNum].checkedForNull = false;
+        pcgSSANumInfo[ssaNum].deferWriteback = true;
+    }
+    else {
+        // Update the data type for the temp.
+        if (ssaNum != it->second.parentSSANum) {
+            it = pcgSSANumInfo.find(it->second.parentSSANum);
+        }
+        it->second.dtype = pcgMergeDtypes(dtype, it->second.dtype);
+    }
+}
+
+static void pcgRef(int ssaNum, pcgDtype dtype, bool needs_null_check = false)
+{
+    pcgDefRef(ssaNum, dtype);
+
+    pcgSSANumInfo[ssaNum].numUses++;
+    if (speculative_null_checks) {
+        pcgSSANumInfo[ssaNum].needsNullCheck = needs_null_check;
+    }
+}
+
+static void pcgDef(int ssaNum, pcgDtype dtype)
+{
+    pcgDefRef(ssaNum, dtype);
+}
+
+static void pcgMergeSSANums(int childNum, int parentNum)
+{
+    SSANumInfoMap::iterator childIt = pcgSSANumInfo.find(childNum);
+    SSANumInfoMap::iterator parentIt = pcgSSANumInfo.find(parentNum);
+
+    childIt->second.parentSSANum = parentNum;
+    parentIt->second.dtype = pcgMergeDtypes(parentIt->second.dtype,
+                                            childIt->second.dtype);
+}
+
+static void pcgAnalyzeExecuteInline(MIR *mir)
+{
+    NativeInlineOps op = (NativeInlineOps)mir_vB(mir);
+
+    // For OP_EXECUTE_INLINE[_RANGE], the UD information depends on which
+    // operation is being executed.
+    //
+    switch (op) {
+        case INLINE_STRING_LENGTH:
+        case INLINE_STRING_IS_EMPTY:
+            pcgRef(mirUse(mir, 0), INTreg);
+            break;
+
+        case INLINE_STRING_CHARAT:
+        case INLINE_MATH_MAX_INT:
+        case INLINE_MATH_MIN_INT:
+            pcgRef(mirUse(mir, 0), INTreg);
+            pcgRef(mirUse(mir, 1), INTreg);
+            break;
+
+        case INLINE_STRING_EQUALS:
+        case INLINE_STRING_COMPARETO:
+            pcgRef(mirUse(mir, 0), Any4);
+            pcgRef(mirUse(mir, 1), Any4);
+            break;
+
+        case INLINE_DOUBLE_TO_RAW_LONG_BITS:
+        case INLINE_MATH_SIN:
+        case INLINE_MATH_COS:
+            pcgRef(mirUse(mir, 0), Any8);
+            pcgRef(mirUse(mir, 1), Any8);
+            break;
+
+        case INLINE_FLOAT_TO_RAW_INT_BITS:
+            pcgRef(mirUse(mir, 0), Any4);
+            break;
+
+        default:
+            printf("+++ PCG Error +++ Unsupported execute inline routine\n");
+            exit(-1);
+            break;
+    }
+}
+
+static void pcgAnalyzeInvokeArgs(MIR *mir, int first_arg_use)
+{
+    // The invoke itself has no information about the types
+    // of its arguments.  So just allow references of any type.
+    //
+    int i;
+    for (i = first_arg_use; i < mir->ssaRep->numUses; i++) {
+        pcgRef(mirUse(mir, i), Any);
+    }
+}
+
+static void pcgNewRegisterizeVRAnalysis(CompilationUnit *cUnit)
+{
+    GrowableList *blockList = &cUnit->blockList;
+
+    pcgSSANumInfo.clear();
+
+    for (unsigned int i = 0; i < blockList->numUsed; i++) {
+        BasicBlock *bb = (BasicBlock *)blockList->elemList[i];
+        for (MIR *mir = bb->firstMIRInsn; mir; mir = mir->next) {
+            Opcode dalvikOpCode = mir->dalvikInsn.opcode;
+
+            switch (dalvikOpCode) {
+                case OP_NOP:
+                case OP_GOTO:
+                case OP_GOTO_16:
+                case OP_GOTO_32:
+                    // Nothing to do.
+                    break;
+
+                case OP_MOVE:
+                case OP_MOVE_OBJECT:
+                case OP_MOVE_FROM16:
+                case OP_MOVE_OBJECT_FROM16:
+                case OP_MOVE_16:
+                case OP_MOVE_OBJECT_16:
+                    pcgRef(mirUse(mir, 0), Any4);
+                    pcgDef(mirDef(mir, 0), Any4);
+                    break;
+
+                case OP_ADD_INT_LIT16:
+                case OP_AND_INT_LIT16:
+                case OP_OR_INT_LIT16:
+                case OP_XOR_INT_LIT16:
+                case OP_ADD_INT_LIT8:
+                case OP_RSUB_INT_LIT8:
+                case OP_AND_INT_LIT8:
+                case OP_SHL_INT_LIT8:
+                case OP_SHR_INT_LIT8:
+                case OP_USHR_INT_LIT8:
+                case OP_OR_INT_LIT8:
+                case OP_XOR_INT_LIT8:
+                case OP_MUL_INT_LIT8:
+                case OP_MUL_INT_LIT16:
+                case OP_INT_TO_CHAR:
+                case OP_INT_TO_SHORT:
+                case OP_INT_TO_BYTE:
+                case OP_NEG_INT:
+                case OP_NOT_INT:
+                case OP_INSTANCE_OF:
+                case OP_DIV_INT_LIT8:
+                case OP_REM_INT_LIT8:
+                case OP_DIV_INT_LIT16:
+                case OP_REM_INT_LIT16:
+                case OP_ARRAY_LENGTH:
+                    pcgRef(mirUse(mir, 0), INTreg);
+                    pcgDef(mirDef(mir, 0), INTreg);
+                    break;
+
+                case OP_IGET:
+                case OP_IGET_BOOLEAN:
+                case OP_IGET_BYTE:
+                case OP_IGET_CHAR:
+                case OP_IGET_SHORT:
+                case OP_IGET_VOLATILE:
+                    pcgRef(mirUse(mir, 0), INTreg, true);
+                    pcgDef(mirDef(mir, 0), Any4);
+                    break;
+
+                case OP_IGET_OBJECT:
+                case OP_IGET_OBJECT_VOLATILE:
+                    pcgRef(mirUse(mir, 0), INTreg, true);
+                    pcgDef(mirDef(mir, 0), INTreg);
+                    break;
+
+                case OP_INT_TO_LONG:
+                    pcgRef(mirUse(mir, 0), INTreg);
+                    pcgDef(mirDef(mir, 0), LLreg);
+                    pcgDef(mirDef(mir, 1), LLreg);
+                    break;
+
+                case OP_IGET_WIDE:
+                case OP_IGET_WIDE_VOLATILE:
+                    pcgRef(mirUse(mir, 0), INTreg, true);
+                    pcgDef(mirDef(mir, 0), Any8);
+                    pcgDef(mirDef(mir, 1), Any8);
+                    break;
+
+                case OP_LONG_TO_INT:
+                    pcgRef(mirUse(mir, 0), LLreg);
+                    pcgRef(mirUse(mir, 1), LLreg);
+                    pcgDef(mirDef(mir, 0), INTreg);
+                    break;
+
+                case OP_CMP_LONG:
+                    pcgRef(mirUse(mir, 0), LLreg);
+                    pcgRef(mirUse(mir, 1), LLreg);
+                    pcgRef(mirUse(mir, 2), LLreg);
+                    pcgRef(mirUse(mir, 3), LLreg);
+                    pcgDef(mirDef(mir, 0), INTreg);
+                    break;
+
+                case OP_MOVE_WIDE:
+                case OP_MOVE_WIDE_FROM16:
+                case OP_MOVE_WIDE_16:
+                    pcgRef(mirUse(mir, 0), Any8);
+                    pcgRef(mirUse(mir, 1), Any8);
+                    pcgDef(mirDef(mir, 0), Any8);
+                    pcgDef(mirDef(mir, 1), Any8);
+                    break;
+
+                case OP_CONST:
+                case OP_CONST_4:
+                case OP_CONST_16:
+                case OP_CONST_HIGH16:
+                    pcgDef(mirDef(mir, 0), Any4);
+                    break;
+
+                case OP_CONST_STRING:
+                case OP_CONST_STRING_JUMBO:
+                    pcgDef(mirDef(mir, 0), INTreg);
+                    break;
+
+                case OP_CONST_WIDE:
+                case OP_CONST_WIDE_16:
+                case OP_CONST_WIDE_HIGH16:
+                case OP_CONST_WIDE_32:
+                    pcgDef(mirDef(mir, 0), Any8);
+                    pcgDef(mirDef(mir, 1), Any8);
+                    break;
+
+                case OP_IF_EQ:
+                case OP_IF_NE:
+                case OP_IF_LT:
+                case OP_IF_GE:
+                case OP_IF_GT:
+                case OP_IF_LE:
+                    pcgRef(mirUse(mir, 0), INTreg);
+                    pcgRef(mirUse(mir, 1), INTreg);
+                    break;
+
+                case OP_IPUT:
+                case OP_IPUT_BOOLEAN:
+                case OP_IPUT_BYTE:
+                case OP_IPUT_CHAR:
+                case OP_IPUT_SHORT:
+                case OP_IPUT_VOLATILE:
+                    pcgRef(mirUse(mir, 0), Any4);
+                    pcgRef(mirUse(mir, 1), INTreg, true);
+                    break;
+
+                case OP_IPUT_OBJECT:
+                case OP_IPUT_OBJECT_VOLATILE:
+                    pcgRef(mirUse(mir, 0), INTreg);
+                    pcgRef(mirUse(mir, 1), INTreg, true);
+                    break;
+
+                case OP_IF_GEZ:
+                case OP_IF_NEZ:
+                case OP_IF_EQZ:
+                case OP_IF_LTZ:
+                case OP_IF_GTZ:
+                case OP_IF_LEZ:
+                    pcgRef(mirUse(mir, 0), INTreg);
+                    break;
+
+                case OP_SPUT:
+                case OP_SPUT_BYTE:
+                case OP_SPUT_CHAR:
+                case OP_SPUT_SHORT:
+                case OP_SPUT_BOOLEAN:
+                case OP_SPUT_VOLATILE:
+                    pcgRef(mirUse(mir, 0), Any4);
+                    break;
+
+                case OP_SPUT_OBJECT:
+                case OP_SPUT_OBJECT_VOLATILE:
+                    pcgRef(mirUse(mir, 0), INTreg);
+                    break;
+
+                case OP_SPUT_WIDE:
+                    pcgRef(mirUse(mir, 0), Any8);
+                    break;
+
+                case OP_CHECK_CAST:
+                case OP_PACKED_SWITCH:
+                    pcgRef(mirUse(mir, 0), INTreg);
+                    break;
+
+                case OP_MUL_INT:
+                case OP_SUB_INT:
+                case OP_RSUB_INT:
+                case OP_ADD_INT:
+                case OP_OR_INT:
+                case OP_AND_INT:
+                case OP_XOR_INT:
+                case OP_SHL_INT:
+                case OP_SHR_INT:
+                case OP_USHR_INT:
+                case OP_DIV_INT:
+                case OP_REM_INT:
+                    pcgRef(mirUse(mir, 0), INTreg);
+                    pcgRef(mirUse(mir, 1), INTreg);
+                    pcgDef(mirDef(mir, 0), INTreg);
+                    break;
+
+                case OP_MUL_LONG:
+                case OP_ADD_LONG:
+                case OP_SUB_LONG:
+                case OP_AND_LONG:
+                case OP_OR_LONG:
+                case OP_XOR_LONG:
+                case OP_DIV_LONG:
+                case OP_REM_LONG:
+                case OP_ADD_LONG_2ADDR:
+                case OP_SUB_LONG_2ADDR:
+                case OP_MUL_LONG_2ADDR:
+                case OP_DIV_LONG_2ADDR:
+                case OP_REM_LONG_2ADDR:
+                case OP_OR_LONG_2ADDR:
+                case OP_AND_LONG_2ADDR:
+                case OP_XOR_LONG_2ADDR:
+                    pcgRef(mirUse(mir, 0), LLreg);
+                    pcgRef(mirUse(mir, 1), LLreg);
+                    pcgRef(mirUse(mir, 2), LLreg);
+                    pcgRef(mirUse(mir, 3), LLreg);
+                    pcgDef(mirDef(mir, 0), LLreg);
+                    pcgDef(mirDef(mir, 1), LLreg);
+                    break;
+
+                case OP_NEG_LONG:
+                case OP_NOT_LONG:
+                    pcgRef(mirUse(mir, 0), LLreg);
+                    pcgRef(mirUse(mir, 1), LLreg);
+                    pcgDef(mirDef(mir, 0), LLreg);
+                    pcgDef(mirDef(mir, 1), LLreg);
+                    break;
+
+                case OP_SHL_LONG:
+                case OP_SHR_LONG:
+                case OP_USHR_LONG:
+                case OP_SHL_LONG_2ADDR:
+                case OP_SHR_LONG_2ADDR:
+                case OP_USHR_LONG_2ADDR:
+                    pcgRef(mirUse(mir, 0), LLreg);
+                    pcgRef(mirUse(mir, 1), LLreg);
+                    pcgRef(mirUse(mir, 2), INTreg);
+                    pcgDef(mirDef(mir, 0), LLreg);
+                    pcgDef(mirDef(mir, 1), LLreg);
+                    break;
+
+                case OP_MONITOR_ENTER:
+                case OP_MONITOR_EXIT:
+                case OP_FILL_ARRAY_DATA:
+                    pcgRef(mirUse(mir, 0), INTreg, true);
+                    break;
+
+                case OP_IPUT_QUICK:
+                    pcgRef(mirUse(mir, 0), Any4);
+                    pcgRef(mirUse(mir, 1), INTreg, true);
+                    break;
+                  
+                case OP_IPUT_OBJECT_QUICK:
+                    pcgRef(mirUse(mir, 0), INTreg);
+                    pcgRef(mirUse(mir, 1), INTreg, true);
+                    break;
+
+                case OP_IPUT_WIDE:
+                case OP_IPUT_WIDE_QUICK:
+                    pcgRef(mirUse(mir, 0), Any8);
+                    pcgRef(mirUse(mir, 1), Any8);
+                    pcgRef(mirUse(mir, 2), INTreg, true);
+                    break;
+
+                case OP_AGET:
+                    pcgRef(mirUse(mir, 0), INTreg, true);
+                    pcgRef(mirUse(mir, 1), INTreg);
+                    pcgDef(mirDef(mir, 0), Any4);
+                    break;
+
+                case OP_AGET_OBJECT:
+                case OP_AGET_BYTE:
+                case OP_AGET_BOOLEAN:
+                case OP_AGET_CHAR:
+                case OP_AGET_SHORT:
+                    pcgRef(mirUse(mir, 0), INTreg, true);
+                    pcgRef(mirUse(mir, 1), INTreg);
+                    pcgDef(mirDef(mir, 0), INTreg);
+                    break;
+
+                case OP_AGET_WIDE:
+                    pcgRef(mirUse(mir, 0), INTreg, true);
+                    pcgRef(mirUse(mir, 1), INTreg);
+                    pcgDef(mirDef(mir, 0), Any8);
+                    pcgDef(mirDef(mir, 1), Any8);
+                    break;
+
+                case OP_SGET:
+                case OP_SGET_VOLATILE:
+                    pcgDef(mirDef(mir, 0), Any4);
+                    break;
+
+                case OP_SGET_OBJECT:
+                case OP_SGET_OBJECT_VOLATILE:
+                case OP_SGET_BOOLEAN:
+                case OP_SGET_CHAR:
+                case OP_SGET_BYTE:
+                case OP_SGET_SHORT:
+                    pcgDef(mirDef(mir, 0), INTreg);
+                    break;
+
+                case OP_CONST_CLASS:
+                    pcgDef(mirDef(mir, 0), INTreg);
+                    break;
+
+                case OP_SGET_WIDE:
+                    pcgDef(mirDef(mir, 0), Any8);
+                    pcgDef(mirDef(mir, 1), Any8);
+                    break;
+
+                case OP_ADD_INT_2ADDR:
+                case OP_SUB_INT_2ADDR:
+                case OP_AND_INT_2ADDR:
+                case OP_XOR_INT_2ADDR:
+                case OP_OR_INT_2ADDR:
+                case OP_MUL_INT_2ADDR:
+                case OP_SHL_INT_2ADDR:
+                case OP_SHR_INT_2ADDR:
+                case OP_USHR_INT_2ADDR:
+                case OP_DIV_INT_2ADDR:
+                case OP_REM_INT_2ADDR:
+                    pcgRef(mirUse(mir, 0), INTreg);
+                    pcgRef(mirUse(mir, 1), INTreg);
+                    pcgDef(mirDef(mir, 0), INTreg);
+                    break;
+
+                case OP_APUT:
+                    pcgRef(mirUse(mir, 0), Any4);
+                    pcgRef(mirUse(mir, 1), INTreg, true);
+                    pcgRef(mirUse(mir, 2), INTreg);
+                    break;
+
+                case OP_APUT_OBJECT:
+                case OP_APUT_CHAR:
+                case OP_APUT_BYTE:
+                case OP_APUT_BOOLEAN:
+                case OP_APUT_SHORT:
+                    pcgRef(mirUse(mir, 0), INTreg);
+                    pcgRef(mirUse(mir, 1), INTreg, true);
+                    pcgRef(mirUse(mir, 2), INTreg);
+                    break;
+
+                case OP_APUT_WIDE:
+                    pcgRef(mirUse(mir, 0), Any8);
+                    pcgRef(mirUse(mir, 1), Any8);
+                    pcgRef(mirUse(mir, 2), INTreg, true);
+                    pcgRef(mirUse(mir, 3), INTreg);
+                    break;
+
+                case OP_ADD_FLOAT:
+                case OP_SUB_FLOAT:
+                case OP_MUL_FLOAT:
+                case OP_DIV_FLOAT:
+                case OP_ADD_FLOAT_2ADDR:
+                case OP_SUB_FLOAT_2ADDR:
+                case OP_MUL_FLOAT_2ADDR:
+                case OP_DIV_FLOAT_2ADDR:
+                    pcgRef(mirUse(mir, 0), VXreg32);
+                    pcgRef(mirUse(mir, 1), VXreg32);
+                    pcgDef(mirDef(mir, 0), VXreg32);
+                    break;
+
+                case OP_ADD_DOUBLE:
+                case OP_SUB_DOUBLE:
+                case OP_MUL_DOUBLE:
+                case OP_DIV_DOUBLE:
+                case OP_ADD_DOUBLE_2ADDR:
+                case OP_SUB_DOUBLE_2ADDR:
+                case OP_MUL_DOUBLE_2ADDR:
+                case OP_DIV_DOUBLE_2ADDR:
+                    pcgRef(mirUse(mir, 0), DPVXreg64);
+                    pcgRef(mirUse(mir, 1), DPVXreg64);
+                    pcgRef(mirUse(mir, 2), DPVXreg64);
+                    pcgRef(mirUse(mir, 3), DPVXreg64);
+                    pcgDef(mirDef(mir, 0), DPVXreg64);
+                    pcgDef(mirDef(mir, 1), DPVXreg64);
+                    break;
+
+                case OP_CMPG_FLOAT:
+                case OP_CMPL_FLOAT:
+                    pcgRef(mirUse(mir, 0), VXreg32);
+                    pcgRef(mirUse(mir, 1), VXreg32);
+                    pcgDef(mirDef(mir, 0), INTreg);
+                    break;
+
+                case OP_CMPG_DOUBLE:
+                case OP_CMPL_DOUBLE:
+                    pcgRef(mirUse(mir, 0), DPVXreg64);
+                    pcgRef(mirUse(mir, 1), DPVXreg64);
+                    pcgRef(mirUse(mir, 2), DPVXreg64);
+                    pcgRef(mirUse(mir, 3), DPVXreg64);
+                    pcgDef(mirDef(mir, 0), INTreg);
+                    break;
+
+                case OP_INT_TO_DOUBLE:
+                    pcgRef(mirUse(mir, 0), INTreg);
+                    pcgDef(mirDef(mir, 0), DPVXreg64);
+                    pcgDef(mirDef(mir, 1), DPVXreg64);
+                    break;
+
+                case OP_LONG_TO_DOUBLE:
+                    pcgRef(mirUse(mir, 0), LLreg);
+                    pcgRef(mirUse(mir, 1), LLreg);
+                    pcgDef(mirDef(mir, 0), DPVXreg64);
+                    pcgDef(mirDef(mir, 1), DPVXreg64);
+                    break;
+
+                case OP_INT_TO_FLOAT:
+                    pcgRef(mirUse(mir, 0), INTreg);
+                    pcgDef(mirDef(mir, 0), VXreg32);
+                    break;
+
+                case OP_LONG_TO_FLOAT:
+                    pcgRef(mirUse(mir, 0), LLreg);
+                    pcgRef(mirUse(mir, 1), LLreg);
+                    pcgDef(mirDef(mir, 0), VXreg32);
+                    break;
+
+                case OP_DOUBLE_TO_INT:
+                    pcgRef(mirUse(mir, 0), DPVXreg64);
+                    pcgRef(mirUse(mir, 1), DPVXreg64);
+                    pcgDef(mirDef(mir, 0), INTreg);
+                    break;
+
+                case OP_FLOAT_TO_INT:
+                    pcgRef(mirUse(mir, 0), VXreg32);
+                    pcgDef(mirDef(mir, 0), INTreg);
+                    break;
+
+                case OP_FLOAT_TO_DOUBLE:
+                    pcgRef(mirUse(mir, 0), VXreg32);
+                    pcgDef(mirDef(mir, 0), DPVXreg64);
+                    pcgDef(mirDef(mir, 1), DPVXreg64);
+                    break;
+
+                case OP_DOUBLE_TO_FLOAT:
+                    pcgRef(mirUse(mir, 0), DPVXreg64);
+                    pcgRef(mirUse(mir, 1), DPVXreg64);
+                    pcgDef(mirDef(mir, 0), VXreg32);
+                    break;
+
+                case OP_NEW_ARRAY:
+                    pcgRef(mirUse(mir, 0), INTreg);
+                    pcgDef(mirDef(mir, 0), INTreg);
+                    break;
+
+                case OP_IGET_OBJECT_QUICK:
+                    pcgRef(mirUse(mir, 0), INTreg, true);
+                    pcgDef(mirDef(mir, 0), INTreg);
+                    break;
+
+                case OP_IGET_QUICK:
+                    pcgRef(mirUse(mir, 0), INTreg, true);
+                    pcgDef(mirDef(mir, 0), Any4);
+                    break;
+
+                case OP_IGET_WIDE_QUICK:
+                    pcgRef(mirUse(mir, 0), INTreg, true);
+                    pcgDef(mirDef(mir, 0), Any8);
+                    pcgDef(mirDef(mir, 1), Any8);
+                    break;
+
+                case OP_MOVE_RESULT:
+                case OP_MOVE_RESULT_OBJECT:
+                    pcgDef(mirDef(mir, 0), Any4);
+                    break;
+
+                case OP_NEG_DOUBLE:
+                    pcgRef(mirUse(mir, 0), DPVXreg64);
+                    pcgRef(mirUse(mir, 1), DPVXreg64);
+                    pcgDef(mirDef(mir, 0), DPVXreg64);
+                    pcgDef(mirDef(mir, 1), DPVXreg64);
+                    break;
+
+                case OP_RETURN_VOID:
+                case OP_RETURN_VOID_BARRIER:
+                    break;
+
+                case OP_RETURN:
+                case OP_RETURN_OBJECT:
+                    pcgRef(mirUse(mir, 0), Any4);
+                    break;
+
+                case OP_RETURN_WIDE:
+                    pcgRef(mirUse(mir, 0), Any8);
+                    pcgRef(mirUse(mir, 1), Any8);
+                    break;
+
+                case OP_MOVE_RESULT_WIDE:
+                    pcgDef(mirDef(mir, 0), Any8);
+                    pcgDef(mirDef(mir, 1), Any8);
+                    break;
+
+                case OP_NEW_INSTANCE:
+                    pcgDef(mirDef(mir, 0), INTreg);
+                    break;
+
+                case OP_EXECUTE_INLINE:
+                case OP_EXECUTE_INLINE_RANGE:
+                    pcgAnalyzeExecuteInline(mir);
+                    break;
+
+                case OP_INVOKE_DIRECT:
+                case OP_INVOKE_DIRECT_RANGE:
+                case OP_INVOKE_VIRTUAL_QUICK:
+                case OP_INVOKE_VIRTUAL_QUICK_RANGE:
+                case OP_INVOKE_INTERFACE:
+                    // The first arg must be treated as INTreg, because it
+                    // gets NULL checked.
+                    //
+                    pcgRef(mirUse(mir, 0), INTreg);  // "this" pointer
+                    pcgAnalyzeInvokeArgs(mir, 1);
+                    break;
+
+                case OP_INVOKE_STATIC:
+                case OP_INVOKE_STATIC_RANGE:
+                case OP_INVOKE_SUPER_QUICK:
+                case OP_INVOKE_SUPER_QUICK_RANGE:
+                    pcgAnalyzeInvokeArgs(mir, 0);
+                    break;
+
+                default:
+                    if ((ExtendedMIROpcode)dalvikOpCode == kMirOpRegisterize) {
+                        break;
+                    }
+                    else if ((ExtendedMIROpcode)dalvikOpCode == kMirOpPhi) {
+                        // Use the result's SSA Num for all operands of the
+                        // phi.
+                        //
+                        int ssaNum = mirDef(mir, 0);
+                        pcgDef(ssaNum, Any);
+
+                        int i;
+                        for (i = 0; i < mir->ssaRep->numUses; i++) {
+                            pcgRef(mirUse(mir, i), Any);
+                            pcgMergeSSANums(mirUse(mir, i), ssaNum);
+                        }
+                        break;
+                    }
+
+                    printf("Unsupported instruction in trace for new "
+                           "registerization:");
+                    dumpMIR(cUnit, mir);
+                    exit(-1);
+            }
+
+            // Any uses of "version 0" of a virtual register indicates a value
+            // that is live on entry to the trace.  Currently, we generate a
+            // load in the entry block for this.  Inserting the ssaNum into
+            // the pcgReferencedVRs triggers this.
+            //
+            // TODO: This isn't quite right for wide uses.  We only want to
+            //       generate a load of the first use in that case.
+            for (int j = 0; j < mir->ssaRep->numUses; j++) {
+                int ssaNum = mir->ssaRep->uses[j];
+                int dalvikReg = dvmConvertSSARegToDalvik(cUnit, ssaNum);
+                if (DECODE_SUB(dalvikReg) == 0) {
+                    int parentSSANum = pcgSSANumInfo[ssaNum].parentSSANum;
+                    pcgReferencedVRs.insert(parentSSANum);
+                }
+            }
+
+            // initialize the mir field of pcgSSANumInfo
+            for (int i = 0; i < mir->ssaRep->numDefs; i++) {
+                int ssaNum = mir->ssaRep->defs[i];
+                pcgSSANumInfo[ssaNum].mir = mir;
+            }
+        }
+    }
+
+    // Walk through the MIR again looking for copies.  This will avoid type
+    // mismatches that may be costly in runtime performance.  This isn't
+    // perfect.  In theory, we might need to iterate multiple times until
+    // there are no more changes.  If we decide to do that, we should probably
+    // keep track of the moves and then iterate over only the moves.
+    //
+    for (unsigned int i = 0; i < blockList->numUsed; i++) {
+        BasicBlock *bb = (BasicBlock *)blockList->elemList[i];
+        for (MIR *mir = bb->firstMIRInsn; mir; mir = mir->next) {
+            pcgDtype srcDtype, dstDtype, mergedDtype;
+            pcgDtype src2Dtype, dst2Dtype;
+            Opcode dalvikOpCode = mir->dalvikInsn.opcode;
+
+            switch (dalvikOpCode) {
+                case OP_MOVE:
+                case OP_MOVE_OBJECT:
+                case OP_MOVE_FROM16:
+                case OP_MOVE_OBJECT_FROM16:
+                case OP_MOVE_16:
+                case OP_MOVE_OBJECT_16:
+                    srcDtype = pcgGetDtypeForSSANum(mirUse(mir, 0));
+                    dstDtype = pcgGetDtypeForSSANum(mirDef(mir, 0));
+                    mergedDtype = pcgMergeDtypes(srcDtype, dstDtype);
+                    if (mergedDtype != NOreg) {
+                        pcgSetDtypeForSSANum(mirUse(mir, 0), mergedDtype);
+                        pcgSetDtypeForSSANum(mirDef(mir, 0), mergedDtype);
+                    }
+                    break;
+
+                case OP_MOVE_WIDE:
+                case OP_MOVE_WIDE_FROM16:
+                case OP_MOVE_WIDE_16:
+                    srcDtype = pcgGetDtypeForSSANum(mirUse(mir, 0));
+                    dstDtype = pcgGetDtypeForSSANum(mirDef(mir, 0));
+                    src2Dtype = pcgGetDtypeForSSANum(mirUse(mir, 1));
+                    dst2Dtype = pcgGetDtypeForSSANum(mirDef(mir, 1));
+                    mergedDtype = pcgMergeDtypes(srcDtype, dstDtype);
+                    mergedDtype = pcgMergeDtypes(mergedDtype, src2Dtype);
+                    mergedDtype = pcgMergeDtypes(mergedDtype, dst2Dtype);
+                    if (mergedDtype != NOreg) {
+                        pcgSetDtypeForSSANum(mirUse(mir, 0), mergedDtype);
+                        pcgSetDtypeForSSANum(mirDef(mir, 0), mergedDtype);
+                        pcgSetDtypeForSSANum(mirUse(mir, 1), mergedDtype);
+                        pcgSetDtypeForSSANum(mirDef(mir, 1), mergedDtype);
+                    }
+                    break;
+
+                default:
+                    break;
+            }
+        }
+    }
+
+}
+
+static void subtractBVs(BitVector *r, BitVector *s1, BitVector *s2)
+{
+    if (r->storageSize != s1->storageSize ||
+        r->storageSize != s2->storageSize) {
+        printf("BV size error in subtractBVs\n");
+        exit(-1);
+    }
+
+    for (unsigned int i = 0; i < r->storageSize; i++) {
+        r->storage[i] = s1->storage[i] & ~(s2->storage[i]);
+    }
+}
+
+static void initGensAndKills(CompilationUnit *cUnit)
+{
+    GrowableList *blockList = &cUnit->blockList;
+    int bv_size = cUnit->numSSARegs;
+
+    for (unsigned int i = 0; i < blockList->numUsed; i++) {
+        BasicBlock *bb = (BasicBlock *)blockList->elemList[i];
+        BitVector *ins, *outs, *kills;
+
+        // Allocate and initialize the bit vectors
+        ins = dvmCompilerAllocBitVector(bv_size, false);
+        outs = dvmCompilerAllocBitVector(bv_size, false);
+        kills = dvmCompilerAllocBitVector(bv_size, false);
+        pcgModSSAIns[bb] = ins;
+        pcgModSSAOuts[bb] = outs;
+        pcgModSSAKills[bb] = kills;
+        dvmClearAllBits(ins);
+        dvmClearAllBits(outs);
+        dvmClearAllBits(kills);
+
+        for (MIR *mir = bb->firstMIRInsn; mir; mir = mir->next) {
+            for (int i = 0; i < mir->ssaRep->numDefs; i++) {
+                int ssaNum = mir->ssaRep->defs[i];
+                u2 vr_num = pcgGetVRFromSSANum(ssaNum);
+                BitVector *vr_defs_bv = pcgVRtoSSANumSet[vr_num];
+
+                // Add all defs of this VR to the kills set.
+                // Remove all defs of this VR from the gens set.
+                dvmUnifyBitVectors(kills, kills, vr_defs_bv);
+                subtractBVs(outs, outs, vr_defs_bv);
+
+                // Add this def to the gens set.
+                if (pcgSSANumInfo[ssaNum].registerize) {
+                    dvmSetBit(outs, ssaNum);
+                    dvmClearBit(kills, ssaNum);
+                }
+                if (pcgOpcodeIsInvoke(mir->dalvikInsn.opcode)) {
+                    dvmSetInitialBits(kills, bv_size);
+                    dvmClearAllBits(outs);
+                }
+            }
+        }
+    }
+}
+
+static void propagateOuts(CompilationUnit *cUnit)
+{
+    GrowableList *blockList = &cUnit->blockList;
+    bool changed = true;
+
+    // Allocate the temporary bit vectors that will be available for the
+    // duration of routine compilation.  tempBV is for small local uses.
+    // currModBV is used to track the current mod SSANum set during block
+    // translation.  (It is needed to compute the necessary writebacks for
+    // side exits.)
+    //
+    tempBV = dvmCompilerAllocBitVector(cUnit->numSSARegs, false);
+    currModBV = dvmCompilerAllocBitVector(cUnit->numSSARegs, false);
+
+    while (changed) {
+        changed = false;
+
+        for (unsigned int i = 0; i < blockList->numUsed; i++) {
+            BasicBlock *bb = (BasicBlock *)blockList->elemList[i];
+
+            BitVector *ins = pcgModSSAIns[bb];
+            BitVector *outs = pcgModSSAOuts[bb];
+            BitVector *kills = pcgModSSAKills[bb];
+            BitVectorIterator it;
+            int predId;
+            bool first = true;
+
+            dvmBitVectorIteratorInit(bb->predecessors, &it);
+            while ((predId = dvmBitVectorIteratorNext(&it)) != -1) {
+                BasicBlock *bb = (BasicBlock *)blockList->elemList[predId];
+                BitVector *pred_outs = pcgModSSAOuts[bb];
+
+                if (first) {
+                    dvmCopyBitVector(ins, pred_outs);
+                    first = false;
+                }
+                else {
+                    dvmIntersectBitVectors(ins, ins, pred_outs);
+                }
+            }
+
+            // outs = ins - kills + gens
+            dvmCopyBitVector(tempBV, ins);
+            subtractBVs(tempBV, tempBV, kills);
+            if (dvmCheckMergeBitVectors(outs, tempBV)) {
+                changed = true;
+            }
+
+#if 0
+            // Propagate Outs to Ins of the successors
+            if (bb->taken) {
+                BitVector *succ_ins = pcgModSSAIns[bb->taken];
+                dvmCopyBitVector(tempBV, succ_ins);
+                dvmIntersectBitVectors(succ_ins, succ_ins, outs);
+                if (dvmCompareBitVectors(tempBV, succ_ins)) {
+                    changed = true;
+                }
+            }
+
+            if (bb->fallThrough) {
+                BitVector *succ_ins = pcgModSSAIns[bb->fallThrough];
+                dvmCopyBitVector(tempBV, succ_ins);
+                dvmIntersectBitVectors(succ_ins, succ_ins, outs);
+                if (dvmCompareBitVectors(tempBV, succ_ins)) {
+                    changed = true;
+                }
+            }
+#endif
+        }
+    }
+}
+
+static void dumpBitVector(CompilationUnit *cUnit, BitVector *bv, int n)
+{
+    printf("{ ");
+    for (int i = 0; i < n; i ++) {
+        if (dvmIsBitSet(bv, i)) {
+            int dalvikReg = dvmConvertSSARegToDalvik(cUnit, i);
+            u2 vr_num = DECODE_REG(dalvikReg);
+            u2 vr_sub = DECODE_SUB(dalvikReg);
+            printf("%d_%d ", vr_num, vr_sub);
+        }
+    }
+    printf("}");
+}
+
+static void dumpModRegInfo(CompilationUnit *cUnit)
+{
+    printf("\nModified VR info for trace %d\n", pcgTraceCounter);
+    printf("===============================\n");
+    GrowableList *blockList = &cUnit->blockList;
+
+    for (unsigned int i = 0; i < blockList->numUsed; i++) {
+        BasicBlock *bb = (BasicBlock *)blockList->elemList[i];
+
+        printf("\nBlock %d ins:  ", i);
+        dumpBitVector (cUnit, pcgModSSAIns[bb], cUnit->numSSARegs);
+        printf("\n");
+        for (MIR *mir = bb->firstMIRInsn; mir; mir = mir->next) {
+            dumpMIR(cUnit, mir);
+        }
+        printf("Block %d outs: ", i);
+        dumpBitVector (cUnit, pcgModSSAOuts[bb], cUnit->numSSARegs);
+        printf("\n");
+
+        if (bb->taken || bb->fallThrough) {
+            printf("Succs:");
+            if (bb->taken) {
+                printf(" T%d%s", bb->taken->id, pcgBlockDumpString(bb->taken));
+            }
+            if (bb->fallThrough) {
+                printf(" F%d%s", bb->fallThrough->id,
+                       pcgBlockDumpString(bb->fallThrough));
+            }
+            printf("\n");
+        }
+    }
+}
+
+static void pcgAvoidDeferredWritebacks(CompilationUnit *cUnit)
+{
+    GrowableList *blockList = &cUnit->blockList;
+    BitVectorIterator it;
+    int ssaNum;
+    int always_defer_writebacks;
+
+    if (dvmExtractBackendOption("AlwaysDeferWB", &always_defer_writebacks) &&
+        always_defer_writebacks) {
+        return;
+    }
+
+    // Compute a union of all the writebacks that must occur at chaining cell
+    // trace exits.
+    //
+    dvmClearAllBits(tempBV);
+    for (unsigned int i = 0; i < blockList->numUsed; i++) {
+        BasicBlock *bb = (BasicBlock *)blockList->elemList[i];
+
+        if (bb->blockType < kChainingCellLast) {
+            dvmUnifyBitVectors(tempBV, tempBV, pcgModSSAIns[bb]);
+        }
+    }
+
+    dvmBitVectorIteratorInit(tempBV, &it);
+    while ((ssaNum = dvmBitVectorIteratorNext(&it)) != -1) {
+        pcgSSANumInfo[ssaNum].deferWriteback = false;
+    }
+}
+
+static void pcgCompilerModSSANum(CompilationUnit *cUnit)
+{
+    pcgModSSAIns.clear();
+    pcgModSSAOuts.clear();
+
+    initGensAndKills(cUnit);
+    propagateOuts(cUnit);
+
+    if (!cUnit->loopInformation) {
+        pcgAvoidDeferredWritebacks(cUnit);
+    }
+
+    if (DEBUG_REGISTERIZE_VRS()) {
+        dumpModRegInfo(cUnit);
+    }
+}
+
+static void disableRegisterizationForDef(SSANumInfoMap::iterator it)
+{
+    VRSet::iterator t;
+
+    it->second.registerize = false;
+    t = pcgReferencedVRs.find(it->first);
+    if (t != pcgReferencedVRs.end()) {
+        pcgReferencedVRs.erase(t);
+    }
+}
+
+static void applyRegisterizationHeuristics(SSANumInfoMap::iterator it)
+{
+    int ssaNum = it->first;
+    int zheur;
+    u2 vr_sub = 0;  // These initializations are unnecessary, but they avoid
+    u2 vr_num = 0;  // a compiler warning about "may be used uninitialized".
+
+    if (DEBUG_REGISTERIZE_VRS()) {
+        int dalvikReg = dvmConvertSSARegToDalvik(
+                                pcgCurrentCompilationUnit,
+                                ssaNum);
+        vr_num = DECODE_REG(dalvikReg);
+        vr_sub = DECODE_SUB(dalvikReg);
+    }
+
+    if (!dvmExtractBackendOption("zheur", &zheur)) {
+        zheur = 0;
+    }
+
+    if (zheur > 0) {
+        if (it->second.numUses <= zheur &&
+            it->second.parentSSANum == ssaNum &&
+            (it->second.mir == NULL ||
+             (ExtendedMIROpcode)(it->second.mir->dalvikInsn.opcode) !=
+             kMirOpPhi) &&
+            it->second.needsNullCheck == false) {
+            disableRegisterizationForDef(it);
+            if (DEBUG_REGISTERIZE_VRS()) {
+                printf("    Register v%d_%d [ssanum : %d]. NOT "
+                       "registerized globally. "
+                       "Z-heuristics(1).\n", vr_num, vr_sub, ssaNum);
+            }
+        }
+        else {
+            if (DEBUG_REGISTERIZE_VRS()) {
+                printf("    Register v%d_%d [ssanum : %d]. "
+                       "Registerized globally. "
+                       "Escaped Z-heuristics(1).\n", vr_num, vr_sub,
+                       ssaNum);
+            }
+        }
+    }
+
+    if (DEBUG_REGISTERIZE_VRS()) {
+        if (pcgSSANumInfo[ssaNum].parentSSANum == ssaNum) {
+            printf("v%d_%d type %s [ssanum : %d]\n", vr_num,
+                   vr_sub,
+                   dtypeName(it->second.dtype),
+                   ssaNum);
+        }
+    }
+}
+
+static void pcgNewRegisterizeVRAnalysisDoneWithTrace(CompilationUnit *cUnit)
+{
+    SSANumInfoMap::iterator it;
+
+    pcgVRtoSSANumSet.clear();
+
+    if (DEBUG_REGISTERIZE_VRS()) {
+        printf("\nSSANum type info for trace %d\n", pcgTraceCounter);
+        printf("==============================\n");
+    }
+
+    for (it = pcgSSANumInfo.begin(); it != pcgSSANumInfo.end(); ++it) {
+        // Only consider top level temps.
+        if (it->first != it->second.parentSSANum) {
+            continue;
+        }
+
+        // Resolve the type
+        if (it->second.dtype == Any) {
+            // We don't know the type or size, so just
+            // default to intreg. We only currently
+            // expect this for invoke arguments.
+            it->second.dtype = INTreg;
+        }
+
+        if (it->second.dtype == Any4) {
+            it->second.dtype = INTreg;
+        }
+        else if (it->second.dtype == Any8) {
+            it->second.dtype = DPVXreg64;
+        }
+
+        // Compute the VR number and add this SSA number to the list of
+        // SSA Numbers associated with the VR.
+        //
+        int ssaNum = it->first;
+        u2 vr_num = pcgGetVRFromSSANum(ssaNum);
+
+        if (pcgVRtoSSANumSet.find(vr_num) == pcgVRtoSSANumSet.end()) {
+            BitVector *bv =
+                dvmCompilerAllocBitVector(cUnit->numSSARegs, false); 
+            pcgVRtoSSANumSet[vr_num] = bv;
+            dvmClearAllBits(bv);
+        }
+        dvmSetBit(pcgVRtoSSANumSet[vr_num], ssaNum);
+
+        applyRegisterizationHeuristics(it);
+    }
+}
+
+static pcgDtype pcgMergeDtypes(pcgDtype dtype1, pcgDtype dtype2)
+{
+    if (dtype1 == dtype2) {
+        return dtype1;
+    }
+    if (dtype1 == NOreg) {
+        return dtype2;
+    }
+    if (dtype2 == NOreg) {
+        return dtype1;
+    }
+    if (dtype1 == Any) {
+        return dtype2;
+    }
+    if (dtype2 == Any) {
+        return dtype1;
+    }
+    if (dtype1 == Any4 && (dtype2 == VXreg32 || dtype2 == INTreg)) {
+        return dtype2;
+    }
+    if (dtype2 == Any4 && (dtype1 == VXreg32 || dtype1 == INTreg)) {
+        return dtype1;
+    }
+    if (dtype1 == Any8 && (dtype2 == DPVXreg64 || dtype2 == LLreg)) {
+        return dtype2;
+    }
+    if (dtype2 == Any8 && (dtype1 == DPVXreg64 || dtype1 == LLreg)) {
+        return dtype1;
+    }
+
+    return NOreg;
+}
+
+static const char* dtypeName(pcgDtype dtype)
+{
+    switch (dtype) {
+        case NOreg:     return "NOreg";
+        case INTreg:    return "INTreg";
+        case LLreg:     return "LLreg";
+        case VXreg32:   return "VXreg32";
+        case DPVXreg64: return "DPVXreg64";
+        case Any:       return "Any";
+        case Any4:      return "Any4";
+        case Any8:      return "Any8";
+        default:        break;
+    }
+    return "InvalidType";
+}
+
+void static pcgInitOptions(void)
+{
+    speculative_null_checks = true;
+    CG_bnl_expand_idivs = 0;
+}
+
+// Updated global state:
+//     gDvmJit.codeCacheByteUsed
+void pcgDvmCompilerMIR2LIR(CompilationUnit *cUnit, JitTranslationInfo* info)
+{
+    // printf("\n+++++++++++++ Using PCG. +++++++++++++++++++++\n");
+    // cUnit->baseAddr gives the address of the entry point for the compiled
+    // trace.  Note that this might not be the first available byte in the code
+    // cache, because we might need to add padding to align the start of the
+    // routine.  We set this to NULL here, because that is a signal to the
+    // caller that an error occured during compilation.  We will set it to a
+    // valid value after successfull compilation.
+    //
+    cUnit->baseAddr = NULL;
+
+    dvmExtractBackendOption("DebugLevel", (int*)&pcgDebugLevel);
+
+    // DLK - moderately useful debug dump:
+    //dvmCompilerDumpCompilationUnit(cUnit);
+
+    if (DUMP_TRACE()) {
+        CGSetTraceOutputFile(stdout);
+    }
+    pcgInitOptions();
+    CGCreateRoutine(cUnit);
+    pcgInitForTrace(cUnit);
+
+    pcgNewRegisterizeVRAnalysis(cUnit);
+    pcgNewRegisterizeVRAnalysisDoneWithTrace(cUnit);
+    pcgCompilerModSSANum(cUnit);
+
+    pcgConfigureTrace();
+    bool success = pcgGenIlForTrace(cUnit, info);
+
+    // Note that if !success, we leave cUnit->baseAddr as NULL.
+    if (success) {
+        CGCompileRoutine(cUnit);
+        pcgEmitCode(cUnit, info);
+    }
+
+    CGEndRoutine(0);
+}
+
+// Useful interface routine that allows us to selectively use PCG or the
+// existing dalvik JIT.
+//
+extern bool usePcgForTrace(CompilationUnit *cUnit)
+{
+    GrowableList *blockList = &cUnit->blockList;
+    bool trace_ok = true;
+    int use_pcg;
+    int bytecode_count = 0;
+
+    if (dvmExtractBackendOption("UsePcg", &use_pcg) && use_pcg == 0) {
+        return false;
+    }
+
+    for (unsigned int i = 0; i < blockList->numUsed; i++) {
+        BasicBlock *bb = (BasicBlock *)blockList->elemList[i];
+
+        for (MIR *mir = bb->firstMIRInsn; mir; mir = mir->next) {
+            Opcode dalvikOpCode = mir->dalvikInsn.opcode;
+
+            bytecode_count++;
+            switch (dalvikOpCode) {
+#if 0
+                case OP_REM_INT:
+                case OP_REM_INT_2ADDR:
+                    // Until we implement the divide specialization.
+                    trace_ok = false;
+                    break;
+#endif
+
+                case OP_EXECUTE_INLINE:
+                case OP_EXECUTE_INLINE_RANGE:
+                    switch (mir_vB(mir)) {
+                        case INLINE_STRING_EQUALS:
+                        case INLINE_STRING_COMPARETO:
+                        case INLINE_STRING_LENGTH:
+                        case INLINE_STRING_CHARAT:
+                        case INLINE_MATH_MAX_INT:
+                        case INLINE_MATH_MIN_INT:
+                        case INLINE_STRING_IS_EMPTY:
+                        case INLINE_DOUBLE_TO_RAW_LONG_BITS:
+                        case INLINE_FLOAT_TO_RAW_INT_BITS:
+                        case INLINE_MATH_SIN:
+                        case INLINE_MATH_COS:
+                            // These are supported.
+                            break;
+
+                        default:
+                            trace_ok = false;
+                            printf("\n:::::Not Using PCG for : \n");
+                            dumpMIR(cUnit, mir);
+                            break;
+                    }
+                    break;
+
+                case OP_FILLED_NEW_ARRAY:
+                case OP_FILLED_NEW_ARRAY_RANGE:
+                case OP_SPARSE_SWITCH:
+                case OP_INVOKE_VIRTUAL:
+                case OP_INVOKE_SUPER:
+                case OP_INVOKE_VIRTUAL_RANGE:
+                case OP_INVOKE_SUPER_RANGE:
+                case OP_INVOKE_INTERFACE_RANGE:
+                case OP_NEG_FLOAT:
+                case OP_FLOAT_TO_LONG:
+                case OP_DOUBLE_TO_LONG:
+                case OP_REM_FLOAT:
+                case OP_REM_DOUBLE:
+                case OP_REM_FLOAT_2ADDR:
+                case OP_REM_DOUBLE_2ADDR:
+                case OP_IPUT_WIDE_VOLATILE:
+                case OP_SGET_WIDE_VOLATILE:
+                case OP_SPUT_WIDE_VOLATILE:
+                case OP_BREAKPOINT:
+                case OP_THROW_VERIFICATION_ERROR:
+                case OP_INVOKE_OBJECT_INIT_RANGE:
+                    // Not yet implemented opcodes
+                    trace_ok = false;
+
+                    printf("\n:::::Not Using PCG for : \n");
+                    dumpMIR(cUnit, mir);
+                    break;
+
+                default:
+                    break;
+            }
+        }
+    }
+
+    int zexp_count = 0;
+    if (trace_ok && dvmExtractBackendOption("zexp_count", &zexp_count)) {
+        if (bytecode_count > zexp_count) {
+            return false;
+        }
+    }
+
+    static int counter = 0;
+    int max;
+    if (!dvmExtractBackendOption("Brutus", &max)) {
+        max = -1;
+    }
+    if (trace_ok && (max == -1 || counter < max)) {
+        counter++;
+        return true;
+    }
+
+    return false;
+}
+
+// CGGetRoutineNameFromClient requests that the client provide the code
+// generator with the name of the specified function.  The code generator
+// passes the same client_routine_handle that was passed to it via
+// CGCreateRoutine and CGCompileRoutine.
+//
+// dummy
+extern const char *CGGetRoutineNameFromClient(
+    const void *client_routine_handle
+)
+{
+    // HACK!  30 bytes should be enough.
+    const size_t buf_size = 30;
+    static char routine_name_buf[buf_size];
+    snprintf(routine_name_buf, buf_size, "dalvik_jit_trace_%d",
+             pcgTraceCounter);
+    return routine_name_buf;
+}
+
+// CGGetMemConstSymbolFromClient requests that the client allocate memory to
+// hold a constant value and then create a CGSymbol that the code generator can
+// use to reference that memory.  The memory must be at least "length" bytes
+// and have at least "align" alignment.  The client must copy the first
+// "length" bytes from "value" to the newly allocated memory.
+//
+// dummy
+extern CGSymbol CGGetMemConstSymbolFromClient(uint8_t *value, size_t length,
+                                              uint32_t align)
+{
+    // Not yet implemented.  Unrecoverable.
+    assert(0);
+    return CGSymbolInvalid;
+}
+
+// CGSymbolNeedsLargeModelFixup asks the client whether the specified symbol
+// might have an arbitrary 64-bit address.  If so, the client must return a
+// non-zero value.  If the symbol is known to reside in the lower 2GB of
+// the address space or if the symbol is known to be located within 2GB of
+// the generated code in PIC mode, then the client may return 0.
+//
+extern int CGSymbolNeedsLargeModelFixup(CGSymbol symbol)
+{
+    // We are generating x86 code, no
+    return 0;
+}
+
+// CGGetSymbolAddressFromClient requests that the client provide the absolute
+// address of the specified symbol.  PCG uses this information to process
+// relocations during calls to CGResolveSymbolReferences.  The return value
+// is defined as uint64_t to accommodate both 32-bit and 64-bit targets.
+//
+// dummy
+extern uint64_t CGGetSymbolAddressFromClient(CGSymbol symbol)
+{
+    // We do own symbol relocation, so we should never reach this point.
+    assert(0);
+    return 0;
+}
+
+// CGGetSymbolForNameFromClient requests that the client provide a CGSymbol
+// that PCG can use to reference an object level symbol of the specified name.
+// This callback function is typically used for library symbols resulting from
+// intrinsic function expansions.
+//
+extern CGSymbol CGGetSymbolForNameFromClient(const char *symbol_name)
+{
+    NameToSymbolMap::iterator it = pcgNameToSymbolMap.find(symbol_name);
+
+    if (it == pcgNameToSymbolMap.end()) {
+        printf("PCG Error:  Requested unsupported symbol %s.\n", symbol_name);
+        exit(-1);
+    }
+
+    return it->second;
+}
+
+// CGGetSymbolNameFromClient requests that the client provide the name of the
+// specified symbol.
+//
+// dummy implementation
+extern const char *CGGetSymbolNameFromClient(CGSymbol symbol)
+{
+    ClientSymbolInfo *client_symbol_info_p = pcgSymbolMap[symbol];
+    
+    return client_symbol_info_p->name;
+}
+
+// CGGetProbabilityOfOverlapFromClient requests that the client provide
+// disambiguation information about the memory references identified by
+// handle1 and handle2.  (handle1 and handle2 are the handles that were passed
+// to CGCreateNewInst for 'm' operands.)
+//
+// The client must return an integer in the range [0, 100].  A return value of
+// 0 is a guarantee from the client that the memory references do not overlap.
+// A return value of 100 is a guarantee from the client that the memory
+// references do overlap.  Any other value is the client's best guess for the
+// probability that the memory references overlap.
+//
+// dummy implementation
+extern uint32_t CGGetProbabilityOfOverlapFromClient(void *handle1,
+                                                    void *handle2)
+{
+    intptr_t h1 = (intptr_t)handle1;
+    intptr_t h2 = (intptr_t)handle2;
+    intptr_t h1_hi, h1_lo;
+    intptr_t h2_hi, h2_lo;
+    int old_dis;
+
+    if (dvmExtractBackendOption("OldDis", &old_dis) && old_dis != 0) {
+        return 50;
+    }
+
+    // Bit 0x1 indicates a non-VR load or store.  A non-VR memref cannot
+    // overlap a VR one.
+    //
+    if ((h1 & 0x1) != (h2 & 0x1)) {
+        return 0;
+    }
+
+    // Two non-VR memrefs ... just assume possible overlap.
+    if ((h1 & 0x1) != 0) {
+        return 50;
+    }
+
+    // Both memrefs are VR refs.  Check whether the same VR is referenced.
+    // In this case, we can always give an exact answer.
+    //
+    h1_lo = h1 >> 3;
+    h1_hi = h1_lo + (h1 & 0x4) ? 1 : 0;
+    h2_lo = h2 >> 3;
+    h2_hi = h2_lo + (h2 & 0x4) ? 1 : 0;
+
+    if (h1_lo > h2_hi || h1_hi < h2_lo) {
+        return 0;
+    }
+
+    return 100;
+}
+
+// CGAddRelocationToClient passes relocation information back to the client.
+// This routine is called as many times as necessary during the call to
+// CGCompileRoutine.  The client_routine_handle identifies the routine for the
+// client.  It is the same handle that was passed to PCG in the call to
+// CGCreateRoutine.  code_offset gives the location in the code at which to
+// apply the relocation action.  It is an offset from the start of the
+// function.  symbol gives the CGSymbol to which the relocation must be made.
+// relocation_type gives the type of relocation.  addend specifies a constant
+// addend used to compute the value to be stored in the relocatable field.
+//
+extern void CGAddRelocationToClient(void *client_routine_handle,
+                                    uint64_t code_offset,
+                                    CGSymbol symbol,
+                                    CGRelocationType relocation_type,
+                                    int64_t addend)
+{
+    Relocation relocation;
+
+    relocation.target_symbol = pcgSymbolMap[symbol];
+    relocation.addend = (int32_t)addend;
+    relocation.code_offset = (uint32_t)code_offset;
+    relocation.relocation_type = relocation_type;
+
+    pcgRelocationList.push_front(relocation);
+}
diff --git a/vm/compiler/codegen/x86/pcg/PcgInterface.h b/vm/compiler/codegen/x86/pcg/PcgInterface.h
new file mode 100644
index 0000000..0b8298d
--- /dev/null
+++ b/vm/compiler/codegen/x86/pcg/PcgInterface.h
@@ -0,0 +1,60 @@
+/*
+ * Copyright (C) 2010-2011 Intel Corporation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#ifndef _DALVIK_PCGINTERFACE
+#define _DALVIK_PCGINTERFACE
+
+#include "compiler/CompilerIR.h"
+#include "libpcg.h"
+#include "interp/InterpDefs.h"
+
+// PCG module level initialization and cleanup.
+extern void pcgModuleBegin(void);
+extern void pcgModuleEnd(void);
+
+extern CGSymbol pcgCreateSymbol(const char *name, void *address);
+
+/* PCG version of the function to lower middle-level IR to low-level IR */
+void pcgDvmCompilerMIR2LIR(CompilationUnit *cUnit, JitTranslationInfo* info);
+
+// Filter to allow us to selectively use PCG or the existing dalvik JIT.
+extern bool usePcgForTrace(CompilationUnit *cUnit);
+
+extern "C" void dvmJitToInterpNormal(int targetpc); //in %ebx
+extern "C" void dvmJitToInterpBackwardBranch(int targetpc);
+extern "C" void dvmJitToInterpTraceSelect(int targetpc); //in %ebx
+extern "C" void dvmJitToInterpTraceSelectNoChain(int targetpc); //in %ebx
+extern "C" void dvmJitToExceptionThrown(int targetpc); //in currentPc
+extern "C" void dvmJitToInterpPunt(int targetpc); //in currentPc
+extern "C" void dvmJitToInterpNoChain(int targetpc); //in %eax
+extern "C" void dvmJitToInterpNoChainNoProfile(int); //in currentPc
+extern const Method *dvmJitToPatchPredictedChain(const Method*, Thread*,
+						 PredictedChainingCell*,
+						 const ClassObject*);
+extern "C" const Method *dvmFindInterfaceMethodInCache(ClassObject*, u4,
+						       const Method*, DvmDex*);
+extern     int  common_errNullObject(void);
+
+// It seems like this function could be implemented in the JIT code itself.
+extern s4 dvmJitHandlePackedSwitch(const s4*, s4, u2, s4);
+
+// TODO (DLK): This declaration and use in PcgInterface.cpp is temporary.
+//             See the comment in PcgInterface.cpp for more details.
+//
+extern char* stream; //current stream pointer
+
+extern CGSymbol pcgClassResolveSymbol;
+
+#endif // _DALVIK_PCGINTERFACE
-- 
1.7.4.1

