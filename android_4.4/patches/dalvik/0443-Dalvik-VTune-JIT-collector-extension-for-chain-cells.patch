From 962bed1ee1782a9707c5a427fc4e5a870e8bcb47 Mon Sep 17 00:00:00 2001
From: Yevgeny Rouban <yevgeny.y.rouban@intel.com>
Date: Tue, 17 Dec 2013 14:17:11 +0700
Subject: Dalvik: VTune JIT collector extension for chain cells

BZ: 112422

Trace disassembly in VTune GUI looks obfuscated because processor instructions
interleaved with data. The data is disassembled as weird instructions, which
overlaps with subsequent instruction bytes.

One of the reason the data is generated is the design of chain cells.

This patch introduces and makes use of an extended VTune collector interface for
reporting chain cell formats and updates using 3 more fields of
the collector's Update event:
  - class_id - 2 lowest bits corresponds to code and format update flags
  - user_data - data format
  - user_data_size - size of the data format

If 1st bit of class_id is set then the Update event notifies the collector about
update of the content, which starts from method_load_address and of size method_size.

If 2nd bit of class_id is set then the Update event notifies the collector about
update of content's format string. The content address and size specified
with method_load_address and method_size fields respectively. The format string
and its length are set with user_data and user_data_size.

The new fields are set only if Dalvik is started with the following option:
  -Xjitvtuneversion:7777777

Without this option Dalvik works with the original VTune collector as before.
The version 7777777 will be changed when VTune will support the new fields.

Until then a new custom collector library called libittjsym.so should be used.
It writes fs2excel (jvmtisym) formatted files instead of *.jit files:
  /data/amplxe/results/<PID>.jsym

The new *.jsym files can be processed by the latest version of fs2excel.

For more details see the bugzilla.

In addition, this patch refactors VTune support sources:
- moves original VTune sources to vm/compiler/vtune directory
- updates the VTune sources
- extracts all specific code for VTune support to dedicated files
- removed content of outdated vm/compiler/codegen/x86/CodegenInterface.cpp as it is
  duplicated in the vm/compiler/codegen/x86/lightcg/CodegenInterface.cpp

Change-Id: Ia4ad480c91d3ed840dd9134b36a507402a74f048
Category: device enablement
Domain: AOSP.Dalvik-Compiler-CG
Origin: internal
Upstream-Candidate: no, need rework
Signed-off-by: Yevgeny Rouban <yevgeny.y.rouban@intel.com>
---
 vm/Dvm.mk                                          |    4 +-
 vm/Globals.h                                       |    3 +-
 vm/compiler/Frontend.cpp                           |  216 +--
 vm/compiler/JitProfiling.cpp                       |  628 -----
 vm/compiler/JitProfiling.h                         |  481 ----
 vm/compiler/VTuneSupport.cpp                       |  273 +++
 vm/compiler/VTuneSupport.h                         |   48 +
 vm/compiler/codegen/x86/CodegenInterface.cpp       | 2565 +-------------------
 vm/compiler/codegen/x86/VTuneSupportX86.cpp        |  342 +++
 vm/compiler/codegen/x86/VTuneSupportX86.h          |   38 +
 .../codegen/x86/lightcg/CodegenInterface.cpp       |   45 +-
 vm/compiler/codegen/x86/lightcg/Lower.cpp          |    4 +-
 vm/compiler/codegen/x86/lightcg/LowerInvoke.cpp    |    2 +-
 vm/compiler/codegen/x86/lightcg/LowerJump.cpp      |    2 +-
 .../codegen/x86/pcg/ChainingCellException.cpp      |   17 +-
 vm/compiler/ittnotify_config.h                     |  437 ----
 vm/compiler/ittnotify_types.h                      |   71 -
 vm/compiler/vtune/JitProfiling.cpp                 |  487 ++++
 vm/compiler/vtune/JitProfiling.h                   |  553 +++++
 vm/compiler/vtune/ittnotify_config.h               |  459 ++++
 vm/compiler/vtune/ittnotify_types.h                |   73 +
 21 files changed, 2324 insertions(+), 4424 deletions(-)
 delete mode 100644 vm/compiler/JitProfiling.cpp
 delete mode 100644 vm/compiler/JitProfiling.h
 create mode 100644 vm/compiler/VTuneSupport.cpp
 create mode 100644 vm/compiler/VTuneSupport.h
 create mode 100644 vm/compiler/codegen/x86/VTuneSupportX86.cpp
 create mode 100644 vm/compiler/codegen/x86/VTuneSupportX86.h
 delete mode 100644 vm/compiler/ittnotify_config.h
 delete mode 100644 vm/compiler/ittnotify_types.h
 create mode 100644 vm/compiler/vtune/JitProfiling.cpp
 create mode 100644 vm/compiler/vtune/JitProfiling.h
 create mode 100644 vm/compiler/vtune/ittnotify_config.h
 create mode 100644 vm/compiler/vtune/ittnotify_types.h

diff --git a/vm/Dvm.mk b/vm/Dvm.mk
index e88bb3e..f92773e 100644
--- a/vm/Dvm.mk
+++ b/vm/Dvm.mk
@@ -268,7 +268,8 @@ ifeq ($(WITH_JIT),true)
   LOCAL_CFLAGS += -DWITH_JIT
   LOCAL_SRC_FILES += \
 	compiler/Compiler.cpp \
-	compiler/JitProfiling.cpp \
+	compiler/vtune/JitProfiling.cpp \
+	compiler/VTuneSupport.cpp \
 	compiler/Frontend.cpp \
 	compiler/Utility.cpp \
 	compiler/InlineTransformation.cpp \
@@ -380,6 +381,7 @@ ifeq ($(dvm_arch),x86)
               compiler/codegen/$(dvm_arch_variant)/lightcg/Profile.cpp \
               compiler/codegen/$(dvm_arch_variant)/CompilationErrorX86.cpp \
               compiler/codegen/$(dvm_arch_variant)/X86Common.cpp \
+              compiler/codegen/$(dvm_arch_variant)/VTuneSupportX86.cpp \
               compiler/codegen/$(dvm_arch_variant)/BackEndEntry.cpp \
               compiler/codegen/$(dvm_arch_variant)/StackExtensionX86.cpp \
               compiler/PassDriver.cpp \
diff --git a/vm/Globals.h b/vm/Globals.h
index 8e02036..909d3aa 100644
--- a/vm/Globals.h
+++ b/vm/Globals.h
@@ -831,7 +831,8 @@ enum VTuneInfo {
 #define STR_VALUE(arg) _STR_VALUE(arg)
 
 // Update the default VTune build number to the latest public build
-#define VTUNE_VERSION_DEFAULT 279866
+#define VTUNE_VERSION_DEFAULT 313935
+#define VTUNE_VERSION_EXPERIMENTAL 7777777
 #endif
 
 struct ChainCellCounts;
diff --git a/vm/compiler/Frontend.cpp b/vm/compiler/Frontend.cpp
index dcdd44f..6809ecf 100644
--- a/vm/compiler/Frontend.cpp
+++ b/vm/compiler/Frontend.cpp
@@ -40,11 +40,7 @@ extern int opcodeJit[kNumPackedOpcodes];
 #endif
 
 #if defined(VTUNE_DALVIK)
-#include "JitProfiling.h"
-#include <vector>
-#include <algorithm>
-
-static void SendTraceInfoToVTune(CompilationUnit *cUnit, JitTraceDescription *desc);
+#include "VTuneSupport.h"
 #endif
 
 //Need it for UINT_MAX
@@ -2370,7 +2366,7 @@ static bool compileLoop(CompilationUnit *cUnit, unsigned int startOffset,
     /* Send the loop trace information to the VTune */
     if(gDvmJit.vtuneInfo != kVTuneInfoDisabled) {
         if(info->codeAddress) {
-            SendTraceInfoToVTune(cUnit, desc);
+            sendTraceInfoToVTune(cUnit, desc);
         } else {
             LOGD("Invalid trace\n");
         }
@@ -3075,7 +3071,7 @@ bool dvmCompileTrace(JitTraceDescription *desc, int numMaxInsts,
 #if defined(VTUNE_DALVIK)
     if(gDvmJit.vtuneInfo != kVTuneInfoDisabled) {
         if(info->codeAddress) {
-            SendTraceInfoToVTune(&cUnit, desc);
+            sendTraceInfoToVTune(&cUnit, desc);
         } else {
             LOGD("Invalid trace\n");
         }
@@ -3084,209 +3080,3 @@ bool dvmCompileTrace(JitTraceDescription *desc, int numMaxInsts,
 
     return info->codeAddress != NULL;
 }
-
-#if defined(VTUNE_DALVIK)
-extern int mapFromBCtoNCG[]; /* declaration from Lower.h file */
-
-typedef std::vector<LineNumberInfo> LineNumberInfoList;
-
-struct SortLineNumberInfoByOffset {
-    bool operator()(LineNumberInfo const& lhs, LineNumberInfo const& rhs) {
-        return lhs.Offset < rhs.Offset;
-    }
-};
-
-static char* makeDexDumpMethodName(const Method* method)
-{
-    char const* name = method->name;
-    u4 name_len = strlen(name);
-    char* signature = dexProtoCopyMethodDescriptor(&method->prototype);
-    u4 signature_len = strlen(signature);
-    char const* classD = method->clazz->descriptor;
-    u4 classD_len = strlen(classD);
-    u4 fullSignature_offset = 0;
-
-    /* make the same name as dexdump output for DEX code */
-    u4 fullSignature_len = classD_len - 1 /* L */ + name_len + 1 /* : */
-        + signature_len + 1 /* '\0' */;
-    char *fullSignature = (char *)dvmCompilerNew(fullSignature_len, false);
-
-    strcpy(fullSignature, classD + 1 /* delete 'L' */);
-    fullSignature_offset = classD_len - 1;
-    for (u4 i = 0; i < fullSignature_offset; ++i) {
-        if (fullSignature[i] == ';' || fullSignature[i] == '/') {
-            fullSignature[i] = '.';
-        }
-    }
-    strcpy(fullSignature + fullSignature_offset, name);
-    fullSignature_offset += name_len;
-    fullSignature[fullSignature_offset++] = ':';
-    strcpy(fullSignature + fullSignature_offset, signature);
-    fullSignature_offset += signature_len + 1 /* '\0' */;
-    assert(fullSignature_len == fullSignature_offset);
-    free(signature);
-
-    return fullSignature;
-}
-
-static void getLineInfoForByteCode(const Method* method,
-    LineNumberInfoList& lineInfoList)
-{
-    const DexCode* dexCode = dvmGetMethodCode(method);
-    LineNumberInfo lineInfo;
-
-    for (u4 offset = 0, i = 1; offset < dexCode->insnsSize; ++i) {
-        if (mapFromBCtoNCG[offset] != -1) {
-            lineInfo.Offset = mapFromBCtoNCG[offset];
-            lineInfo.LineNumber = i;
-            lineInfoList.push_back(lineInfo);
-        }
-        offset += dexGetWidthFromInstruction(dexCode->insns + offset);
-    }
-}
-
-static void getLineInfoForJavaCode(const Method* method,
-    LineNumberInfoList& lineInfoList)
-{
-    const DexCode* dexCode = dvmGetMethodCode(method);
-    LineNumberInfo lineInfo;
-
-    DexFile* pDexFile = method->clazz->pDvmDex->pDexFile;
-    const u1 *dbgstream = dexGetDebugInfoStream(pDexFile, dexCode);
-    if (method->clazz->sourceFile != NULL && dbgstream != NULL) {
-        /* mapping from JITed code to Java source code */
-        int adjopcode;
-        u4 line, parametersSize, address = 0;
-        line = readUnsignedLeb128(&dbgstream);
-        parametersSize = readUnsignedLeb128(&dbgstream);
-
-        while (parametersSize-- != 0) {
-            readUnsignedLeb128(&dbgstream);
-        }
-
-        bool isEndSequence = false;
-        while (!isEndSequence)  {
-            u1 opcode = *dbgstream++;
-            switch (opcode) {
-            case DBG_END_SEQUENCE:
-                isEndSequence = true;
-                break;
-
-            case DBG_ADVANCE_PC:
-                address += readUnsignedLeb128(&dbgstream);
-                break;
-
-            case DBG_ADVANCE_LINE:
-                line += readSignedLeb128(&dbgstream);
-                break;
-
-            case DBG_START_LOCAL:
-            case DBG_START_LOCAL_EXTENDED:
-                readUnsignedLeb128(&dbgstream);
-                readUnsignedLeb128(&dbgstream);
-                readUnsignedLeb128(&dbgstream);
-
-                if (opcode == DBG_START_LOCAL_EXTENDED) {
-                    readUnsignedLeb128(&dbgstream);
-                }
-                break;
-
-            case DBG_END_LOCAL:
-            case DBG_RESTART_LOCAL:
-                readUnsignedLeb128(&dbgstream);
-                break;
-
-            case DBG_SET_PROLOGUE_END:
-            case DBG_SET_EPILOGUE_BEGIN:
-            case DBG_SET_FILE:
-                break;
-
-            default:
-                adjopcode = opcode - DBG_FIRST_SPECIAL;
-                address += adjopcode / DBG_LINE_RANGE;
-                line += DBG_LINE_BASE + (adjopcode % DBG_LINE_RANGE);
-
-                if (mapFromBCtoNCG[address] != -1) {
-                    lineInfo.Offset = mapFromBCtoNCG[address];
-                    lineInfo.LineNumber = line;
-                    lineInfoList.push_back(lineInfo);
-                }
-                break;
-            }
-        }
-    }
-}
-
-/* Notify the trace formation and send the trace information to VTune
-*/
-static void SendTraceInfoToVTune(CompilationUnit *cUnit, JitTraceDescription *desc) {
-    if (gDvmJit.printMe == true) {
-        LOGD("JIT API: write a trace of '%s' method in jit file.", cUnit->method->name);
-    }
-
-    DexStringCache params_string;
-    dexStringCacheInit(&params_string);
-    const char* params = dexProtoGetParameterDescriptors(&desc->method->prototype, &params_string);
-    int len = strlen(desc->method->name) + 3;
-
-    // If params is not nil we should account it in the total length
-    if (params != 0) {
-        len += strlen(params);
-    }
-
-    char* name_with_params = (char*) dvmCompilerNew(len, true);
-    strcpy(name_with_params, desc->method->name);
-    strcat(name_with_params, "(");
-    if (params != 0) {
-        strcat(name_with_params, params);
-    }
-    strcat(name_with_params, ")");
-    dexStringCacheRelease(&params_string);
-
-    //Structure to load all the trace details to be sent later to VTune
-    iJIT_Method_Load jitMethod;
-    memset(&jitMethod, 0, sizeof(iJIT_Method_Load));
-    jitMethod.method_id = (int)(cUnit->method);
-    jitMethod.method_name = name_with_params;
-    jitMethod.class_file_name = (char*)(cUnit->method->clazz->descriptor);
-    jitMethod.method_load_address = cUnit->baseAddr;
-    jitMethod.method_size = *(u2 *)((char *)cUnit->baseAddr - 4);
-    jitMethod.source_file_name = (char*)(cUnit->method->clazz->sourceFile);
-
-    const Method* method = cUnit->method;
-    LineNumberInfoList lineInfoList;
-
-    if (gDvmJit.vtuneInfo == kVTuneInfoByteCode) {
-        jitMethod.source_file_name = makeDexDumpMethodName(method);
-        getLineInfoForByteCode(method, lineInfoList);
-    } else
-    if (gDvmJit.vtuneInfo == kVTuneInfoJavaCode) {
-        getLineInfoForJavaCode(method, lineInfoList);
-    }
-
-    if (!lineInfoList.empty()) {
-        std::sort(lineInfoList.begin(), lineInfoList.end(),
-            SortLineNumberInfoByOffset());
-
-        for (unsigned i = 0; i < lineInfoList.size() - 1; ++i) {
-            lineInfoList[i].Offset = lineInfoList[i + 1].Offset;
-        }
-        lineInfoList[lineInfoList.size() - 1].Offset = jitMethod.method_size;
-
-        jitMethod.line_number_size = lineInfoList.size();
-        jitMethod.line_number_table = &lineInfoList[0];
-    }
-
-    // Send the trace load event to the VTune analyzer
-    int res = iJIT_NotifyEvent(iJVM_EVENT_TYPE_METHOD_LOAD_FINISHED, (void*)&jitMethod);
-    if (gDvmJit.printMe == true) {
-        if (res != 0) {
-            LOGD("JIT API: a trace of '%s' method was written successfully: id=%u, address=%p, size=%d."
-                    , cUnit->method->name, jitMethod.method_id, jitMethod.method_load_address ,jitMethod.method_size);
-        } else {
-            LOGD("JIT API: failed to write a trace of '%s' method: id=%u, address=%p, size=%d."
-                    , cUnit->method->name, jitMethod.method_id, jitMethod.method_load_address ,jitMethod.method_size);
-        }
-    }
-}
-#endif
diff --git a/vm/compiler/JitProfiling.cpp b/vm/compiler/JitProfiling.cpp
deleted file mode 100644
index f23f878..0000000
--- a/vm/compiler/JitProfiling.cpp
+++ /dev/null
@@ -1,628 +0,0 @@
-/*
-* Copyright (C) 2010-2012 Intel Corporation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-*      http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
-
-#include "ittnotify_config.h"
-
-#if ITT_PLATFORM==ITT_PLATFORM_WIN
-#include <windows.h>
-#pragma optimize("", off)
-#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */
-#include <pthread.h>
-#include <dlfcn.h>
-#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */
-#include <malloc.h>
-#include <stdlib.h>
-
-#include "JitProfiling.h"
-#include <vector>
-#include <algorithm>
-
-static const char rcsid[] = "\n@(#) $Revision: 243957 $\n";
-
-#define DLL_ENVIRONMENT_VAR             "VS_PROFILER"
-
-#ifndef NEW_DLL_ENVIRONMENT_VAR
-#if ITT_ARCH==ITT_ARCH_IA32
-#define NEW_DLL_ENVIRONMENT_VAR            "INTEL_JIT_PROFILER32"
-#else
-#define NEW_DLL_ENVIRONMENT_VAR            "INTEL_JIT_PROFILER64"
-#endif
-#endif /* NEW_DLL_ENVIRONMENT_VAR */
-
-#if ITT_PLATFORM==ITT_PLATFORM_WIN
-#define DEFAULT_DLLNAME                 "JitPI.dll"
-HINSTANCE m_libHandle = NULL;
-#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */
-#define DEFAULT_DLLNAME                 "libJitPI.so"
-void* m_libHandle = NULL;
-#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */
-
-/* default location of JIT profiling agent on Android */
-#define ANDROID_JIT_AGENT_PATH  "/data/intel/libittnotify.so"
-
-/* the function pointers */
-typedef unsigned int(*TPInitialize)(void);
-static TPInitialize FUNC_Initialize=NULL;
-
-typedef unsigned int(*TPNotify)(unsigned int, void*);
-static TPNotify FUNC_NotifyEvent=NULL;
-
-static iJIT_IsProfilingActiveFlags executionMode = iJIT_NOTHING_RUNNING;
-
-/* end collector dll part. */
-
-/* loadiJIT_Funcs() : this function is called just in the beginning
- *  and is responsible to load the functions from BistroJavaCollector.dll
- * result:
- *  on success: the functions loads, iJIT_DLL_is_missing=0, return value = 1
- *  on failure: the functions are NULL, iJIT_DLL_is_missing=1, return value = 0
- */
-static int loadiJIT_Funcs(void);
-
-/* global representing whether the BistroJavaCollector can't be loaded */
-static int iJIT_DLL_is_missing = 0;
-
-/* Virtual stack - the struct is used as a virtual stack for each thread.
- * Every thread initializes with a stack of size INIT_TOP_STACK.
- * Every method entry decreases from the current stack point,
- * and when a thread stack reaches its top of stack (return from the global
- * function), the top of stack and the current stack increase. Notice that
- * when returning from a function the stack pointer is the address of
- * the function return.
- */
-#if ITT_PLATFORM==ITT_PLATFORM_WIN
-static DWORD threadLocalStorageHandle = 0;
-#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */
-static pthread_key_t threadLocalStorageHandle = (pthread_key_t)0;
-#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */
-
-#define INIT_TOP_Stack 10000
-
-typedef struct
-{
-    unsigned int TopStack;
-    unsigned int CurrentStack;
-} ThreadStack, *pThreadStack;
-
-/* end of virtual stack. */
-
-/*
- * This part is written for Dalvik in addition to the original code of VTune's jitprofiling.c.
- * TODO: It should be extracted to another source file to preserve JitProfiling.cpp
- * as close as possible to the original jitprofiling.c.
- *
- * MethodCode and MethodCodeMap are needed to get method_id by the address when
- * iJVM_EVENT_TYPE_METHOD_UPDATE events are fired as the chain cell patching
- * does not provide method_ids, which are needed by VTune.
- * MethodCodeMap is built with the data provided with the
- * iJVM_EVENT_TYPE_METHOD_LOAD_FINISHED.
- */
-struct MethodCode {
-  unsigned id;
-  const char *addr;
-  unsigned size;
-
-  /* Ordered by the start addresses*/
-  bool operator<(const MethodCode &cmp) const {
-      return addr < cmp.addr;
-  }
-
-  /* Exclusive end of the block */
-  const char* end() const {
-      return addr + size;
-  }
-
-  /* Checks if the block contains the specified address*/
-  bool contains(const char * addr) {
-      return this->addr <= addr && addr < end();
-  }
-};
-
-/* Maintains non-overlapped ordered set of code blocks */
-class MethodCodeMap {
-private:
-    typedef std::vector<MethodCode> Container;
-    typedef Container::iterator It;
-    Container table;
-
-public:
-    /* Adds a new code block with the specified method_id */
-    void setMethodIdForAddress(unsigned method_id, void * codeAddress, unsigned size) {
-        if (size == 0) {
-            return;
-        }
-
-        MethodCode methodCode = {method_id, (char*)codeAddress, size};
-        if (table.size() == 0 || table.back().end() <= codeAddress) {
-            // fast pass: the most frequent case expected.
-            table.push_back(methodCode);
-            return;
-        }
-        It it = std::upper_bound(table.begin(), table.end(), methodCode);
-        It newIt = table.insert(it, methodCode);
-
-        methodCode.addr += size-1;
-        It firstRightNonOverlapped = std::upper_bound(newIt+1, table.end(), methodCode);
-        It lastChangeIt = firstRightNonOverlapped-1;
-        if (newIt < lastChangeIt && lastChangeIt != table.end()) {
-            if (lastChangeIt->end() > newIt->end()) {
-                // fix overlapped successor
-                unsigned diff = newIt->end() - lastChangeIt->addr;
-                lastChangeIt->size -= diff;
-                // assert: lastChangeIt->size > 0
-                lastChangeIt->addr += diff;
-                --lastChangeIt;
-            }
-            // erase included
-            newIt = table.erase(newIt+1, lastChangeIt+1) - 1;
-        }
-
-        //fix overlapped predecessor
-        if (newIt != table.begin()) {
-            It prevIt = newIt - 1;
-            if (prevIt->end() > newIt->addr) {
-                unsigned newPrevSize = newIt->addr - prevIt->addr;
-                if (prevIt->end() > newIt->end()) {
-                    MethodCode rightPart = {prevIt->id, 
-                                            newIt->end(), 
-                                            static_cast<unsigned int> (prevIt->end() - newIt->end())};
-                    prevIt = table.insert(newIt+1, rightPart) - 2;
-                }
-                if (newPrevSize == 0) {
-                    table.erase(prevIt);
-                } else {
-                    prevIt->size = newPrevSize;
-                }
-            }
-        }
-    }
-
-    /* Returns a method_id for the specified address */
-    unsigned getMethodIdForAddress(void * codeAddress) {
-        MethodCode methodCode = {0,(char*)codeAddress,0};
-        It it = std::upper_bound(table.begin(), table.end(), methodCode);
-        if (it == table.begin()) {
-            return 0;
-        }
-        --it;
-        // assert: codeAddress >= it->addr;
-        return (codeAddress < it->end() ? it->id : 0);
-    }
-
-    /* Removes a method, which covers the specified address */
-    void unsetMethodIdForAddress(void * codeAddress) {
-        MethodCode methodCode = {0,(char*)codeAddress,0};
-        It it = std::upper_bound(table.begin(), table.end(), methodCode);
-        if (it == table.begin()) {
-            return;
-        }
-        it--;
-        if (it->addr <= codeAddress && codeAddress < it->end()) {
-            table.erase(it);
-        }
-    }
-};
-
-static MethodCodeMap methodCodeMap;
-
-/*
- * The function for reporting virtual-machine related events to VTune.
- * Note: when reporting iJVM_EVENT_TYPE_ENTER_NIDS, there is no need to fill
- * in the stack_id field in the iJIT_Method_NIDS structure, as VTune fills it.
- * The return value in iJVM_EVENT_TYPE_ENTER_NIDS &&
- * iJVM_EVENT_TYPE_LEAVE_NIDS events will be 0 in case of failure.
- * in iJVM_EVENT_TYPE_METHOD_LOAD_FINISHED event
- * it will be -1 if EventSpecificData == 0 otherwise it will be 0.
-*/
-
-ITT_EXTERN_C int JITAPI
-iJIT_NotifyEvent(iJIT_JVM_EVENT event_type, void *EventSpecificData)
-{
-    int ReturnValue = 0;
-
-    /*
-     * This section is for debugging outside of VTune.
-     * It creates the environment variables that indicates call graph mode.
-     * If running outside of VTune remove the remark.
-     *
-     *
-     * static int firstTime = 1;
-     * char DoCallGraph[12] = "DoCallGraph";
-     * if (firstTime)
-     * {
-     * firstTime = 0;
-     * SetEnvironmentVariable( "BISTRO_COLLECTORS_DO_CALLGRAPH", DoCallGraph);
-     * }
-     *
-     * end of section.
-    */
-
-    /* initialization part - the functions have not been loaded yet. This part
-     *        will load the functions, and check if we are in Call Graph mode.
-     *        (for special treatment).
-     */
-    if (!FUNC_NotifyEvent)
-    {
-        if (iJIT_DLL_is_missing)
-            return 0;
-
-        /* load the Function from the DLL */
-        if (!loadiJIT_Funcs())
-            return 0;
-
-        /* Call Graph initialization. */
-    }
-
-    /* If the event is method entry/exit, check that in the current mode
-     * VTune is allowed to receive it
-     */
-    if ((event_type == iJVM_EVENT_TYPE_ENTER_NIDS ||
-         event_type == iJVM_EVENT_TYPE_LEAVE_NIDS) &&
-        (executionMode != iJIT_CALLGRAPH_ON))
-    {
-        return 0;
-    }
-    /* This section is performed when method enter event occurs.
-     * It updates the virtual stack, or creates it if this is the first
-     * method entry in the thread. The stack pointer is decreased.
-     */
-    if (event_type == iJVM_EVENT_TYPE_ENTER_NIDS)
-    {
-#if ITT_PLATFORM==ITT_PLATFORM_WIN
-        pThreadStack threadStack =
-            (pThreadStack)TlsGetValue (threadLocalStorageHandle);
-#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */
-        pThreadStack threadStack =
-            (pThreadStack)pthread_getspecific(threadLocalStorageHandle);
-#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */
-
-        /* check for use of reserved method IDs */
-        if ( ((piJIT_Method_NIDS) EventSpecificData)->method_id <= 999 )
-            return 0;
-
-        if (!threadStack)
-        {
-            /* initialize the stack. */
-            threadStack = (pThreadStack) calloc (sizeof(ThreadStack), 1);
-            if (!threadStack)
-                return 0;
-            threadStack->TopStack = INIT_TOP_Stack;
-            threadStack->CurrentStack = INIT_TOP_Stack;
-#if ITT_PLATFORM==ITT_PLATFORM_WIN
-            TlsSetValue(threadLocalStorageHandle,(void*)threadStack);
-#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */
-            pthread_setspecific(threadLocalStorageHandle,(void*)threadStack);
-#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */
-        }
-
-        /* decrease the stack. */
-        ((piJIT_Method_NIDS) EventSpecificData)->stack_id =
-            (threadStack->CurrentStack)--;
-    }
-
-    /* This section is performed when method leave event occurs
-     * It updates the virtual stack.
-     *    Increases the stack pointer.
-     *    If the stack pointer reached the top (left the global function)
-     *        increase the pointer and the top pointer.
-     */
-    if (event_type == iJVM_EVENT_TYPE_LEAVE_NIDS)
-    {
-#if ITT_PLATFORM==ITT_PLATFORM_WIN
-        pThreadStack threadStack =
-           (pThreadStack)TlsGetValue (threadLocalStorageHandle);
-#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */
-        pThreadStack threadStack =
-            (pThreadStack)pthread_getspecific(threadLocalStorageHandle);
-#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */
-
-        /* check for use of reserved method IDs */
-        if ( ((piJIT_Method_NIDS) EventSpecificData)->method_id <= 999 )
-            return 0;
-
-        if (!threadStack)
-        {
-            /* Error: first report in this thread is method exit */
-            exit (1);
-        }
-
-        ((piJIT_Method_NIDS) EventSpecificData)->stack_id =
-            ++(threadStack->CurrentStack) + 1;
-
-        if (((piJIT_Method_NIDS) EventSpecificData)->stack_id
-               > threadStack->TopStack)
-            ((piJIT_Method_NIDS) EventSpecificData)->stack_id =
-                (unsigned int)-1;
-    }
-
-    if (event_type == iJVM_EVENT_TYPE_METHOD_LOAD_FINISHED)
-    {
-        /* check for use of reserved method IDs */
-        piJIT_Method_Load pMethodLoadArgs = ((piJIT_Method_Load) EventSpecificData);
-        if ( pMethodLoadArgs->method_id <= 999 )
-            return 0;
-
-        methodCodeMap.setMethodIdForAddress(pMethodLoadArgs->method_id, pMethodLoadArgs->method_load_address, pMethodLoadArgs->method_size);
-    }
-    if (event_type == iJVM_EVENT_TYPE_METHOD_UPDATE)
-    {
-        // resolve method_id by the given address
-        piJIT_Method_Load pMethodLoadArgs = ((piJIT_Method_Load) EventSpecificData);
-        unsigned method_id = methodCodeMap.getMethodIdForAddress(pMethodLoadArgs->method_load_address);
-
-        if (method_id <= 999) {
-            return 0;
-        }
-        pMethodLoadArgs->method_id = method_id;
-    }
-
-    // FUNC_NotifyEvent cannot be 0 but let's make static analyzer be happy
-    if (FUNC_NotifyEvent != 0)
-    {
-        ReturnValue = (int)FUNC_NotifyEvent(event_type, EventSpecificData);
-    }
-
-    return ReturnValue;
-}
-
-/* The new mode call back routine */
-ITT_EXTERN_C void JITAPI
-iJIT_RegisterCallbackEx(void *userdata, iJIT_ModeChangedEx
-                        NewModeCallBackFuncEx)
-{
-    /* is it already missing... or the load of functions from the DLL failed */
-    if (iJIT_DLL_is_missing || !loadiJIT_Funcs())
-    {
-        /* then do not bother with notifications */
-        NewModeCallBackFuncEx(userdata, iJIT_NO_NOTIFICATIONS);
-        /* Error: could not load JIT functions. */
-        return;
-    }
-    /* nothing to do with the callback */
-}
-
-/*
- * This function allows the user to query in which mode, if at all,
- *VTune is running
- */
-ITT_EXTERN_C iJIT_IsProfilingActiveFlags JITAPI iJIT_IsProfilingActive()
-{
-    if (!iJIT_DLL_is_missing)
-    {
-        loadiJIT_Funcs();
-    }
-
-    return executionMode;
-}
-
-/* this function loads the collector dll (BistroJavaCollector)
- * and the relevant functions.
- * on success: all functions load,     iJIT_DLL_is_missing = 0, return value = 1
- * on failure: all functions are NULL, iJIT_DLL_is_missing = 1, return value = 0
- */
-static int loadiJIT_Funcs()
-{
-    static int bDllWasLoaded = 0;
-#if ITT_PLATFORM==ITT_PLATFORM_WIN
-    DWORD dNameLength = 0;
-#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */
-
-    if(bDllWasLoaded)
-    {
-        /* dll was already loaded, no need to do it for the second time */
-        return 1;
-    }
-
-    /* Assumes that the DLL will not be found */
-    iJIT_DLL_is_missing = 1;
-    FUNC_NotifyEvent = NULL;
-
-    if (m_libHandle)
-    {
-#if ITT_PLATFORM==ITT_PLATFORM_WIN
-        FreeLibrary(m_libHandle);
-#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */
-        dlclose(m_libHandle);
-#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */
-        m_libHandle = NULL;
-    }
-
-    /* Try to get the dll name from the environment */
-#if ITT_PLATFORM==ITT_PLATFORM_WIN
-    dNameLength = GetEnvironmentVariableA(NEW_DLL_ENVIRONMENT_VAR, NULL, 0);
-    if (dNameLength)
-    {
-        DWORD envret = 0;
-        char *dllName = (char*)malloc(sizeof(char) * (dNameLength + 1));
-        envret = GetEnvironmentVariableA(NEW_DLL_ENVIRONMENT_VAR,
-                                         dllName, dNameLength);
-        if (envret)
-        {
-            /* Try to load the dll from the PATH... */
-            m_libHandle = LoadLibraryExA(dllName,
-                                         NULL, LOAD_WITH_ALTERED_SEARCH_PATH);
-        }
-        free(dllName);
-    } else {
-        /* Try to use old VS_PROFILER variable */
-        dNameLength = GetEnvironmentVariableA(DLL_ENVIRONMENT_VAR, NULL, 0);
-        if (dNameLength)
-        {
-            DWORD envret = 0;
-            char *dllName = (char*)malloc(sizeof(char) * (dNameLength + 1));
-            envret = GetEnvironmentVariableA(DLL_ENVIRONMENT_VAR,
-                                             dllName, dNameLength);
-            if (envret)
-            {
-                /* Try to load the dll from the PATH... */
-                m_libHandle = LoadLibraryA(dllName);
-            }
-            free(dllName);
-        }
-    }
-#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */
-    const char *dllName = getenv(NEW_DLL_ENVIRONMENT_VAR);
-    //If not defined
-    if (dllName == 0)
-    {
-        //Try another environment variable
-        dllName = getenv(DLL_ENVIRONMENT_VAR);
-    }
-#ifdef ANDROID
-    //If still not defined
-    if (dllName == 0)
-    {
-        //Define as the default android path
-        dllName = ANDROID_JIT_AGENT_PATH;
-    }
-#endif
-    //If defined
-    if (dllName != 0)
-    {
-        /* Try to load the dll from the PATH... */
-        m_libHandle = dlopen(dllName, RTLD_LAZY);
-    }
-#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */
-
-    if (!m_libHandle)
-    {
-#if ITT_PLATFORM==ITT_PLATFORM_WIN
-        m_libHandle = LoadLibraryA(DEFAULT_DLLNAME);
-#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */
-        m_libHandle = dlopen(DEFAULT_DLLNAME, RTLD_LAZY);
-#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */
-    }
-
-    /* if the dll wasn't loaded - exit. */
-    if (!m_libHandle)
-    {
-        iJIT_DLL_is_missing = 1; /* don't try to initialize
-                                  * JIT agent the second time
-                                  */
-        return 0;
-    }
-
-#if ITT_PLATFORM==ITT_PLATFORM_WIN
-    FUNC_NotifyEvent = (TPNotify)GetProcAddress(m_libHandle, "NotifyEvent");
-#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */
-    FUNC_NotifyEvent = (TPNotify)dlsym(m_libHandle, "NotifyEvent");
-#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */
-    if (!FUNC_NotifyEvent)
-    {
-        FUNC_Initialize = NULL;
-        return 0;
-    }
-
-#if ITT_PLATFORM==ITT_PLATFORM_WIN
-    FUNC_Initialize = (TPInitialize)GetProcAddress(m_libHandle, "Initialize");
-#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */
-    FUNC_Initialize = (TPInitialize)dlsym(m_libHandle, "Initialize");
-#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */
-    if (!FUNC_Initialize)
-    {
-        FUNC_NotifyEvent = NULL;
-        return 0;
-    }
-
-    executionMode = (iJIT_IsProfilingActiveFlags)FUNC_Initialize();
-
-    bDllWasLoaded = 1;
-    iJIT_DLL_is_missing = 0; /* DLL is ok. */
-
-    /*
-     * Call Graph mode: init the thread local storage
-     * (need to store the virtual stack there).
-     */
-    if ( executionMode == iJIT_CALLGRAPH_ON )
-    {
-        /* Allocate a thread local storage slot for the thread "stack" */
-        if (!threadLocalStorageHandle)
-#if ITT_PLATFORM==ITT_PLATFORM_WIN
-            threadLocalStorageHandle = TlsAlloc();
-#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */
-        pthread_key_create(&threadLocalStorageHandle, NULL);
-#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */
-    }
-
-    return 1;
-}
-
-/*
- * This function should be called by the user whenever a thread ends,
- * to free the thread "virtual stack" storage
- */
-ITT_EXTERN_C void JITAPI FinalizeThread()
-{
-    if (threadLocalStorageHandle)
-    {
-#if ITT_PLATFORM==ITT_PLATFORM_WIN
-        pThreadStack threadStack =
-            (pThreadStack)TlsGetValue (threadLocalStorageHandle);
-#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */
-        pThreadStack threadStack =
-            (pThreadStack)pthread_getspecific(threadLocalStorageHandle);
-#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */
-        if (threadStack)
-        {
-            free (threadStack);
-            threadStack = NULL;
-#if ITT_PLATFORM==ITT_PLATFORM_WIN
-            TlsSetValue (threadLocalStorageHandle, threadStack);
-#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */
-            pthread_setspecific(threadLocalStorageHandle, threadStack);
-#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */
-        }
-    }
-}
-
-/*
- * This function should be called by the user when the process ends,
- * to free the local storage index
-*/
-ITT_EXTERN_C void JITAPI FinalizeProcess()
-{
-    if (m_libHandle)
-    {
-#if ITT_PLATFORM==ITT_PLATFORM_WIN
-        FreeLibrary(m_libHandle);
-#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */
-        dlclose(m_libHandle);
-#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */
-        m_libHandle = NULL;
-    }
-
-    if (threadLocalStorageHandle)
-#if ITT_PLATFORM==ITT_PLATFORM_WIN
-        TlsFree (threadLocalStorageHandle);
-#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */
-    pthread_key_delete(threadLocalStorageHandle);
-#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */
-}
-
-/*
- * This function should be called by the user for any method once.
- * The function will return a unique method ID, the user should maintain
- * the ID for each method
- */
-ITT_EXTERN_C unsigned int JITAPI iJIT_GetNewMethodID()
-{
-    static unsigned int methodID = 0x100000;
-
-    if (methodID == 0)
-        return 0;  /* ERROR : this is not a valid value */
-
-    return methodID++;
-}
diff --git a/vm/compiler/JitProfiling.h b/vm/compiler/JitProfiling.h
deleted file mode 100644
index e3b056d..0000000
--- a/vm/compiler/JitProfiling.h
+++ /dev/null
@@ -1,481 +0,0 @@
-/*
-* Copyright (C) 2010-2012 Intel Corporation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-*      http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
-
-#ifndef __JITPROFILING_H__
-#define __JITPROFILING_H__
-
-/**
- * @brief JIT Profiling APIs
- *
- * The JIT Profiling API is used to report information about just-in-time
- * generated code that can be used by performance tools. The user inserts
- * calls in the code generator to report information before JIT-compiled
- * code goes to execution. This information is collected at runtime and used
- * by tools like Intel(R) VTune(TM) Amplifier to display performance metrics
- * associated with JIT-compiled code.
- *
- * These APIs can be used to\n
- * **Profile trace-based and method-based JIT-compiled
- * code**. Some examples of environments that you can profile with this APIs:
- * dynamic JIT compilation of JavaScript code traces, OpenCL JIT execution,
- * Java/.NET managed execution environments, and custom ISV JIT engines.
- *
- * @code
- * #include <jitprofiling.h>
- *
- * if (iJIT_IsProfilingActive != iJIT_SAMPLING_ON) {
- *     return;
- * }
- *
- * iJIT_Method_Load jmethod = {0};
- * jmethod.method_id = iJIT_GetNewMethodID();
- * jmethod.method_name = "method_name";
- * jmethod.class_file_name = "class_name";
- * jmethod.source_file_name = "source_file_name";
- * jmethod.method_load_address = code_addr;
- * jmethod.method_size = code_size;
- *
- * iJIT_NotifyEvent(iJVM_EVENT_TYPE_METHOD_LOAD_FINISHED, (void*)&jmethod);
- * iJIT_NotifyEvent(iJVM_EVENT_TYPE_SHUTDOWN, NULL);
- * @endcode
- *
- *  * Expected behaviour:
- *    * If supplied line number information contains multiple source lines for
- *      the same assembly instruction (code location), then VTune picks up
- *      the first line number.
- *
- * **Analyze split functions** (multiple joint or disjoint code regions
- * belonged to the same function) **including re-JIT**
- * with potential overlapping of code regions in time (this is common in
- * resource-limited environments).
- * @code
- * #include <jitprofiling.h>
- *
- * unsigned int method_id = iJIT_GetNewMethodID();
- *
- * iJIT_Method_Load a = {0};
- * a.method_id = method_id;
- * a.method_load_address = acode_addr;
- * a.method_size = acode_size;
- *
- * iJIT_Method_Load b = {0};
- * b.method_id = method_id;
- * b.method_load_address = baddr_second;
- * b.method_size = bsize_second;
- *
- * iJIT_NotifyEvent(iJVM_EVENT_TYPE_METHOD_LOAD_FINISHED, (void*)&a);
- * iJIT_NotifyEvent(iJVM_EVENT_TYPE_METHOD_LOAD_FINISHED, (void*)&b);
- * @endcode
- *
- *  * Expected behaviour:
- *      * If any iJVM_EVENT_TYPE_METHOD_LOAD_FINISHED event overwrites
- *        already reported method, then such method becomes invalid and its
- *        memory region is treated as unloaded.
- *      * All code regions reported with the same method are considered as
- *        belonging to the same method. Symbolic information (method name,
- *        source file name) will be taken from the first notification, all
- *        subsequent notifications with the same method ID will be processed
- *        only for line number table information. So VTune will map samples to
- *        source line using line number table from current notification while
- *        taking source file name from the very first one.\n
- *        Clarification of some cases:\n
- *          * If you register a second code region with a different source file
- *          name and the same method ID, then this information will be saved and
- *          will not be considered as extension of the first code region, but
- *          VTune will use source file of the first code region and map
- *          performance metrics incorrectly.
- *          * If you register a second code region with the same source file as
- *          for the first region and the same method ID, then source file will be
- *          discarded but, VTune maps metrics to source file correctly.
- *          * If you register a second code region with a null source file and
- *          the same method ID, then provided line number info will be associated
- *          with the source file of the first code region.
- *
- * **Explore inline functions** including multi-level hierarchy of
- * nested inlines to see how performance metrics are distributed through them.
- *
- * @code
- * #include <jitprofiling.h>
- *
- *  //                                    method_id   parent_id
- *  //   [-- c --]                          3000        2000
- *  //                  [---- d -----]      2001        1000
- *  //  [---- b ----]                       2000        1000
- *  // [------------ a ----------------]    1000         n/a
- *
- * iJIT_Method_Load a = {0};
- * a.method_id = 1000;
- *
- * iJIT_Method_Inline_Load b = {0};
- * b.method_id = 2000;
- * b.parent_method_id = 1000;
- *
- * iJIT_Method_Inline_Load c = {0};
- * c.method_id = 3000;
- * c.parent_method_id = 2000;
- *
- * iJIT_Method_Inline_Load d = {0};
- * d.method_id = 2001;
- * d.parent_method_id = 1000;
- *
- * iJIT_NotifyEvent(iJVM_EVENT_TYPE_METHOD_LOAD_FINISHED, (void*)&a);
- * iJIT_NotifyEvent(iJVM_EVENT_TYPE_METHOD_INLINE_LOAD_FINISHED, (void*)&b);
- * iJIT_NotifyEvent(iJVM_EVENT_TYPE_METHOD_INLINE_LOAD_FINISHED, (void*)&c);
- * iJIT_NotifyEvent(iJVM_EVENT_TYPE_METHOD_INLINE_LOAD_FINISHED, (void*)&d);
- * @endcode
- *
- *  * Requirements:
- *      * Each inline (iJIT_Method_Inline_Load) method should be associated
- *        with two method IDs: one for itself, one for its immediate parent.
- *      * Address regions of inline methods of the same parent method cannot
- *        overlap each other.
- *      * Execution of the parent method must not be started until it and all
- *        its inlines are reported.
- *  * Expected behaviour:
- *      * In case of nested inlines an order of
- *        iJVM_EVENT_TYPE_METHOD_INLINE_LOAD_FINISHED events is not important.
- *      * If any event overwrites either inline method or top parent method,
- *        then the parent including inlines becomes invalid and its memory
- *        region is treated as unloaded.
- *
- * **Life time of allocated data**\n
- * The client sends an event notification to the agent with event-specific
- * data, which is a structure. The pointers in the structure refers to memory
- * allocated by the client, which responsible for releasing it. The pointers are
- * used by the iJIT_NotifyEvent method to copy client's data in a trace file
- * and they are not used after the iJIT_NotifyEvent method returns.
- *
- */
-
-/**
- * @defgroup jitapi JIT Profiling
- * @ingroup internal
- * @{
- */
-
-/**
- * @enum iJIT_jvm_event
- * @brief Enumerator for the types of notifications
- */
-typedef enum iJIT_jvm_event
-{
-    iJVM_EVENT_TYPE_SHUTDOWN = 2,               /**< Send to shutdown the agent.
-                                                 * Use NULL for event data. */
-
-    iJVM_EVENT_TYPE_METHOD_LOAD_FINISHED = 13,  /**< Send when a dynamic code is
-                                                 * JIT compiled and loaded into
-                                                 * memory by the JIT engine but
-                                                 * before the code is executed.
-                                                 * Use iJIT_Method_Load as event
-                                                 * data. */
-/** @cond exclude_from_documentation */
-    iJVM_EVENT_TYPE_METHOD_UNLOAD_START,    /**< Send when a compiled dynamic
-                                             * code is being unloaded from memory.
-                                             * Use iJIT_Method_Load as event data.*/
-/** @endcond */
-
-    iJVM_EVENT_TYPE_METHOD_UPDATE,   /**< Send to provide a new content for
-                                      * an early reported dynamic code.
-                                      * The previous content will be invalidate
-                                      * starting from time of the notification.
-                                      * Use iJIT_Method_Load as event data but
-                                      * required fields are following:
-                                      * - method_id    identify the code to update.
-                                      * - method_load_address    specify start address
-                                      *                          within identified code range
-                                      *                          where update should be started.
-                                      * - method_size            specify length of updated code
-                                      *                          range. */
-
-    iJVM_EVENT_TYPE_METHOD_INLINE_LOAD_FINISHED, /**< Send when an inline dynamic
-                                                  * code is JIT compiled and loaded
-                                                  * into memory by the JIT engine
-                                                  * but before the parent code region
-                                                  * is started executing.
-                                                  * Use iJIT_Method_Load as event data.*/
-
-/** @cond exclude_from_documentation */
-    /* Legacy stuff. Do not use it. */
-    iJVM_EVENT_TYPE_ENTER_NIDS = 19,
-    iJVM_EVENT_TYPE_LEAVE_NIDS
-/** @endcond */
-
-} iJIT_JVM_EVENT;
-
-/** @cond exclude_from_documentation */
-/* Legacy stuff. Do not use it. */
-typedef enum _iJIT_ModeFlags
-{
-    iJIT_NO_NOTIFICATIONS          = 0x0000,
-    iJIT_BE_NOTIFY_ON_LOAD         = 0x0001,
-    iJIT_BE_NOTIFY_ON_UNLOAD       = 0x0002,
-    iJIT_BE_NOTIFY_ON_METHOD_ENTRY = 0x0004,
-    iJIT_BE_NOTIFY_ON_METHOD_EXIT  = 0x0008
-
-} iJIT_ModeFlags;
-/** @endcond */
-
-/**
- * @enum _iJIT_IsProfilingActiveFlags
- * @brief Enumerator for the agent's mode
- */
-typedef enum _iJIT_IsProfilingActiveFlags
-{
-    iJIT_NOTHING_RUNNING           = 0x0000,    /**< The agent is not running.
-                                                 * iJIT_NotifyEvent calls will
-                                                 * not be processed. */
-    iJIT_SAMPLING_ON               = 0x0001,    /**< The agent is running and
-                                                 * ready to process notifications. */
-
-/** @cond exclude_from_documentation */
-    /* Legacy. Call Graph is running */
-    iJIT_CALLGRAPH_ON              = 0x0002
-/** @endcond */
-
-} iJIT_IsProfilingActiveFlags;
-
-/** @cond exclude_from_documentation */
-/* Legacy stuff. Do not use it. */
-typedef enum _iJDEnvironmentType
-{
-    iJDE_JittingAPI = 2
-
-} iJDEnvironmentType;
-
-typedef struct _iJIT_Method_Id
-{
-    unsigned int method_id;
-
-} *piJIT_Method_Id, iJIT_Method_Id;
-
-typedef struct _iJIT_Method_NIDS
-{
-    unsigned int method_id;     /**< Unique method ID */
-    unsigned int stack_id;      /**< NOTE: no need to fill this field,
-                                 * it's filled by VTune */
-    char*  method_name;         /**< Method name (just the method, without the class) */
-
-} *piJIT_Method_NIDS, iJIT_Method_NIDS;
-/** @endcond */
-
-/**
- * @details Describes a single entry in the line number information of
- * a code region that gives information about how the reported code region
- * is mapped to source file.
- * Intel(R) VTune(TM) Amplifier uses line number information to attribute
- * the samples (virtual address) to a line number. \n
- * It is acceptable to report different code addresses for the same source line:
- * @code
- *   Offset LineNumber
- *      1       2
- *      12      4
- *      15      2
- *      18      1
- *      21      30
- *
- *  VTune(TM) Amplifier XE contsructs the following table using the client data
- *
- *   Code subrange  Line number
- *      0-1             2
- *      1-12            4
- *      12-15           2
- *      15-18           1
- *      18-21           30
- * @endcode
- */
-typedef struct _LineNumberInfo
-{
-    unsigned int Offset;     /**< Offset from the begining of the code region. */
-    unsigned int LineNumber; /**< Matching source line number offset (from beginning of source file). */
-
-} *pLineNumberInfo, LineNumberInfo;
-
-/**
- *  Description of JIT-compiled method.
- */
-typedef struct _iJIT_Method_Load
-{
-    unsigned int method_id; /**< Unique method ID.
-                             *  Method ID may not be smaller than 999.
-                             *  Either you use the API function
-                             *  iJIT_GetNewMethodID to get a valid and unique
-                             *  method ID, or you take care of ID uniqueness
-                             *  and correct range by yourself.\n
-                             *  You must use the same method ID for all code
-                             *  regions of the same method, otherwise different
-                             *  method IDs mean different methods. */
-
-    char* method_name; /** The name of the method. It can be optionally
-                        *  prefixed with its class name and appended with
-                        *  its complete signature. Can't be  NULL. */
-
-    void* method_load_address; /** The start virtual address of the method code
-                                *  region. If NULL that data provided with
-                                *  event are not accepted. */
-
-    unsigned int method_size; /** The code size of the method in memory.
-                               *  If 0, then data provided with the event are not
-                               *  accepted. */
-
-    unsigned int line_number_size; /** The number of entries in the line number
-                                    *  table.0 if none. */
-
-    pLineNumberInfo line_number_table; /** Pointer to the line numbers info
-                                        *  array. Can be NULL if
-                                        *  line_number_size is 0. See
-                                        *  LineNumberInfo Structure for a
-                                        *  description of a single entry in
-                                        *  the line number info array */
-
-    unsigned int class_id; /** This field is obsolete. */
-
-    char* class_file_name; /** Class name. Can be NULL.*/
-
-    char* source_file_name; /** Source file name. Can be NULL.*/
-
-    void* user_data; /** This field is obsolete. */
-
-    unsigned int user_data_size; /** This field is obsolete. */
-
-    iJDEnvironmentType  env; /** This field is obsolete. */
-
-} *piJIT_Method_Load, iJIT_Method_Load;
-
-/**
- * Description of inline JIT-compiled method.
- */
-typedef struct _iJIT_Method_Inline_Load
-{
-    unsigned int method_id; /**< Unique method ID.
-                             *  Method ID may not be smaller than 999.
-                             *  Either you use the API function
-                             *  iJIT_GetNewMethodID to get a valid and unique
-                             *  method ID, or you take care of ID uniqueness
-                             *  and correct range by yourself. */
-
-    unsigned int parent_method_id; /** Unique immediate parent's method ID.
-                                    *  Method ID may not be smaller than 999.
-                                    *  Either you use the API function
-                                    *  iJIT_GetNewMethodID to get a valid and unique
-                                    *  method ID, or you take care of ID uniqueness
-                                    *  and correct range by yourself. */
-
-    char* method_name; /** The name of the method. It can be optionally
-                        *  prefixed with its class name and appended with
-                        *  its complete signature. Can't be  NULL. */
-
-    void* method_load_address;  /** The virtual address on which the method
-                                  * is inlined. If NULL, then data provided with
-                                  * the event are not accepted. */
-
-    unsigned int method_size; /** The code size of the method in memory.
-                               *  If 0 that data provided with event are not
-                               *  accepted. */
-
-    unsigned int line_number_size; /** The number of entries in the line number
-                                    *  table. 0 if none. */
-
-    pLineNumberInfo line_number_table; /** Pointer to the line numbers info
-                                        *  array. Can be NULL if
-                                        *  line_number_size is 0. See
-                                        *  LineNumberInfo Structure for a
-                                        *  description of a single entry in
-                                        *  the line number info array */
-
-    char* class_file_name; /** Class name. Can be NULL.*/
-
-    char* source_file_name; /** Source file name. Can be NULL.*/
-
-} *piJIT_Method_Inline_Load, iJIT_Method_Inline_Load;
-
-/** @cond exclude_from_documentation */
-#ifdef __cplusplus
-extern "C" {
-#endif /* __cplusplus */
-
-#ifdef ARCH_IA32
-#ifndef CDECL
-#  if defined WIN32 || defined _WIN32
-#    define CDECL __cdecl
-#  else /* defined WIN32 || defined _WIN32 */
-#    if defined _M_X64 || defined _M_AMD64 || defined __x86_64__
-#      define CDECL /* not actual on x86_64 platform */
-#    else  /* _M_X64 || _M_AMD64 || __x86_64__ */
-#      define CDECL __attribute__ ((cdecl))
-#    endif /* _M_X64 || _M_AMD64 || __x86_64__ */
-#  endif /* defined WIN32 || defined _WIN32 */
-#endif /* CDECL */
-
-#define JITAPI CDECL
-#else
-#define JITAPI
-#endif
-/** @endcond */
-
-/**
- * @brief Generates a new unique method ID.
- *
- * You must use this API to obtain unique and valid method IDs for methods or
- * traces reported to the agent if you don't have you own mechanism to generate
- * unique method IDs.
- *
- * @return a new unique method ID. When out of unique method IDs, this API
- * returns 0, which is not an accepted value.
- */
-unsigned int JITAPI iJIT_GetNewMethodID(void);
-
-/**
- * @brief Returns the current mode of the agent.
- *
- * @return iJIT_SAMPLING_ON, indicating that agent is running, or
- * iJIT_NOTHING_RUNNING if no agent is running.
- */
-iJIT_IsProfilingActiveFlags JITAPI iJIT_IsProfilingActive(void);
-
-/**
- * @brief Reports infomation about JIT-compiled code to the agent.
- *
- * The reported information is used to attribute samples obtained from any
- * Intel(R) VTune(TM) Amplifier collector. This API needs to be called
- * after JIT compilation and before the first entry into the JIT compiled
- * code.
- *
- * @param[in] event_type - type of the data sent to the agent
- * @param[in] EventSpecificData - pointer to event-specific data
- *
- * @returns 1 on success, otherwise 0.
- */
-int JITAPI iJIT_NotifyEvent(iJIT_JVM_EVENT event_type, void *EventSpecificData);
-
-/** @cond exclude_from_documentation */
-/*
- * Do not use these legacy APIs, which are here for backward compatibility
- * with Intel(R) VTune(TM) Performance Analyzer.
- */
-typedef void (*iJIT_ModeChangedEx)(void *UserData, iJIT_ModeFlags Flags);
-void JITAPI iJIT_RegisterCallbackEx(void *userdata,
-                                    iJIT_ModeChangedEx NewModeCallBackFuncEx);
-void JITAPI FinalizeThread(void);
-void JITAPI FinalizeProcess(void);
-
-#ifdef __cplusplus
-}
-#endif /* __cplusplus */
-/** @endcond */
-
-/** @} jitapi group */
-
-#endif /* __JITPROFILING_H__ */
diff --git a/vm/compiler/VTuneSupport.cpp b/vm/compiler/VTuneSupport.cpp
new file mode 100644
index 0000000..7c2c46f
--- /dev/null
+++ b/vm/compiler/VTuneSupport.cpp
@@ -0,0 +1,273 @@
+/*
+* Copyright (C) 2010-2012 Intel Corporation
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+*      http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+#if defined(VTUNE_DALVIK)
+
+#include <vector>
+#include <algorithm>
+
+#include "Dalvik.h"
+#include "compiler/CompilerUtility.h"
+#include "CompilerIR.h"
+
+#include "VTuneSupport.h"
+#ifdef ARCH_IA32
+#include "codegen/x86/VTuneSupportX86.h"
+#endif
+
+/*
+ * This part is written for Dalvik in addition to the original code of VTune's jitprofiling.c.
+ *
+ * MethodCode and MethodCodeMap are needed to get method_id by the address when
+ * iJVM_EVENT_TYPE_METHOD_UPDATE events are fired as the chain cell patching
+ * does not provide method_ids, which are needed by VTune.
+ * MethodCodeMap is built with the data provided with the
+ * iJVM_EVENT_TYPE_METHOD_LOAD_FINISHED.
+ */
+
+/*
+ * @brief Method Code Map element denotes an address range with method's id.
+ */
+class MethodCode {
+    friend class MethodCodeMap;
+
+protected:
+    unsigned id; /**< @brief method id for VTune */
+    const char *addr; /**< @brief start address of the region */
+    unsigned size; /**< @brief size of the region */
+
+public:
+    /* @brief Constructor with all fields. */
+    MethodCode(unsigned id, const char * addr, unsigned size)
+    : id(id), addr(addr), size(size) {
+        ;
+    }
+
+    /* @brief Ordered by the start addresses. */
+    bool operator<(const MethodCode &cmp) const {
+        return addr < cmp.addr;
+    }
+
+    /* @brief Exclusive end of the block */
+    const char* end() const {
+        return addr + size;
+    }
+
+    /* @brief Checks if the block contains the specified address*/
+    bool contains(const char * addr) {
+        return this->addr <= addr && addr < end();
+    }
+};
+
+/* @brief Maintains a non-overlapped ordered set of code blocks with their method IDs
+ *
+ * Two main methods are implemented:
+ * - add a range with its associated method_id
+ * - find a range for a specified address inside it
+ */
+class MethodCodeMap {
+private:
+    std::vector<MethodCode> table; /**< @brief The ordered set of ranges */
+
+public:
+    /* @brief Adds a new code block with the specified method_id
+     * @param method_id method id for VTune
+     * @param codeAddress start address of the region
+     * @param size size of the region
+     */
+    void setMethodIdForAddress(unsigned method_id, void * codeAddress, unsigned size);
+
+    /* @brief Returns a method_id of the latest added range, which contains the
+     *        specified address.
+     * @param codeAddress address inside a range for which method_id is needed
+     */
+    unsigned getMethodIdForAddress(void * codeAddress);
+
+    /* @brief Removes a method, which covers the specified address
+     * @param codeAddress address inside a range for which method_id is needed
+     *
+     * This method is not used and added for completeness.
+     */
+    void unsetMethodIdForAddress(void * codeAddress);
+};
+
+void MethodCodeMap::setMethodIdForAddress(unsigned method_id, void * codeAddress, unsigned size) {
+    if (size == 0) {
+        return;
+    }
+
+    MethodCode methodCode(method_id, (char*)codeAddress, size);
+
+    // it is the most frequent case expected
+    // if no addresses were added greater than the new codeAddress:
+    // just put the new range to the end of the table
+    if (table.size() == 0 || table.back().end() <= codeAddress) {
+        table.push_back(methodCode);
+        return;
+    }
+
+    // find the proper place for the new range and insert
+    std::vector<MethodCode>::iterator it = std::upper_bound(table.begin(), table.end(), methodCode);
+    std::vector<MethodCode>::iterator newIt = table.insert(it, methodCode);
+
+    // we need to fix consistency after the new range inserted:
+    // all overlapped ranges should be:
+    // - removed (if lay within the new range)
+    // - split (if contain the new range)
+    // - adjust their start or end (if overlap the new range)
+
+    // fix overlapped successor if any
+    std::vector<MethodCode>::iterator firstRightNonOverlapped
+        = std::upper_bound(newIt+1, table.end(), MethodCode(0, methodCode.addr + size -1, 0));
+    std::vector<MethodCode>::iterator lastChangeIt = firstRightNonOverlapped-1;
+    if (newIt < lastChangeIt && lastChangeIt != table.end()) {
+        // fix the first if it overlapps
+        if (lastChangeIt->end() > newIt->end()) {
+            unsigned diff = newIt->end() - lastChangeIt->addr;
+            lastChangeIt->size -= diff;
+            // assert: lastChangeIt->size > 0
+            lastChangeIt->addr += diff;
+            --lastChangeIt;
+        }
+        // erase all the ranges included by the new one
+        newIt = table.erase(newIt+1, lastChangeIt+1) - 1;
+    }
+
+    //fix overlapped predecessor if any
+    // Note: cannot have more than one overlapping predecessor
+    // due to the consistency before the addition and
+    // we have just erased all the ranges, which were fully with the new range
+    if (newIt != table.begin()) {
+        std::vector<MethodCode>::iterator prevIt = newIt - 1;
+        if (prevIt->end() > newIt->addr) {
+            unsigned newPrevSize = newIt->addr - prevIt->addr;
+
+            if (prevIt->end() > newIt->end()) {
+                // split the range (into its left and right parts)
+                // as it contains the new range
+                MethodCode rightPart(prevIt->id, newIt->end(),
+                        static_cast<unsigned int> (prevIt->end() - newIt->end()));
+                prevIt = table.insert(newIt+1, rightPart) - 2;
+            }
+            if (newPrevSize == 0) {
+                table.erase(prevIt);
+            } else {
+                prevIt->size = newPrevSize;
+            }
+        }
+    }
+}
+
+unsigned MethodCodeMap::getMethodIdForAddress(void * codeAddress) {
+    MethodCode methodCode(0,(char*)codeAddress,0);
+    std::vector<MethodCode>::iterator it = std::upper_bound(table.begin(), table.end(), methodCode);
+    if (it == table.begin()) {
+        return 0;
+    }
+    --it;
+    // assert: codeAddress >= it->addr;
+    return (codeAddress < it->end() ? it->id : 0);
+}
+
+void MethodCodeMap::unsetMethodIdForAddress(void * codeAddress) {
+    MethodCode methodCode(0,(char*)codeAddress,0);
+    std::vector<MethodCode>::iterator it = std::upper_bound(table.begin(), table.end(), methodCode);
+    if (it == table.begin()) {
+        return;
+    }
+    --it;
+    if (it->addr <= codeAddress && codeAddress < it->end()) {
+        table.erase(it);
+    }
+}
+
+int notifyVTune(iJIT_JVM_EVENT event_type, void *eventSpecificData) {
+    static MethodCodeMap methodCodeMap;
+
+    if (event_type == iJVM_EVENT_TYPE_METHOD_LOAD_FINISHED) {
+        // remember the method range with the method_id
+        piJIT_Method_Load pMethodLoadArgs = ((piJIT_Method_Load) eventSpecificData);
+        if (pMethodLoadArgs->method_id != 0) {
+            methodCodeMap.setMethodIdForAddress(pMethodLoadArgs->method_id,
+                    pMethodLoadArgs->method_load_address, pMethodLoadArgs->method_size);
+        }
+    } else if (event_type == iJVM_EVENT_TYPE_METHOD_UPDATE) {
+        // resolve method_id by the given address
+        piJIT_Method_Load pMethodLoadArgs = ((piJIT_Method_Load) eventSpecificData);
+        unsigned method_id = methodCodeMap.getMethodIdForAddress(pMethodLoadArgs->method_load_address);
+        pMethodLoadArgs->method_id = method_id;
+    }
+
+    return iJIT_NotifyEvent(event_type, eventSpecificData);
+}
+
+void sendTraceInfoToVTune(CompilationUnit *cUnit, JitTraceDescription *desc) {
+    if (gDvmJit.printMe == true) {
+        LOGD("JIT API: write a trace of '%s' method in jit file.", cUnit->method->name);
+    }
+
+    DexStringCache params_string;
+    dexStringCacheInit(&params_string);
+    const char* params = dexProtoGetParameterDescriptors(&desc->method->prototype, &params_string);
+    int len = strlen(desc->method->name) + 3;
+
+    // If params is not nil we should account it in the total length
+    if (params != 0) {
+        len += strlen(params);
+    }
+
+    char* name_with_params = (char*) dvmCompilerNew(len, false);
+    strncpy(name_with_params, desc->method->name, len);
+    strncat(name_with_params, "(", len);
+    if (params != 0) {
+        strncat(name_with_params, params, len);
+    }
+    strncat(name_with_params, ")", len);
+    dexStringCacheRelease(&params_string);
+
+    // Structure to load all the trace details to be sent later to VTune
+    iJIT_Method_Load jitMethod;
+    memset(&jitMethod, 0, sizeof(iJIT_Method_Load));
+    jitMethod.method_id = (int)(cUnit->method);
+    jitMethod.method_name = name_with_params;
+    jitMethod.class_file_name = (char*)(cUnit->method->clazz->descriptor);
+    jitMethod.method_load_address = cUnit->baseAddr;
+    jitMethod.method_size = *(u2 *)((char *)cUnit->baseAddr - 4);
+    jitMethod.source_file_name = (char*)(cUnit->method->clazz->sourceFile);
+
+#ifdef ARCH_IA32
+    std::vector<LineNumberInfo> lineInfoList;
+    getLineInfo(cUnit, jitMethod, lineInfoList);
+#endif
+
+    // Send the trace load event to the VTune
+    int res = notifyVTune(iJVM_EVENT_TYPE_METHOD_LOAD_FINISHED, (void*)&jitMethod);
+    if (res != 0) {
+#ifdef ARCH_IA32
+        if (gDvmJit.vtuneVersion >= VTUNE_VERSION_EXPERIMENTAL) { // TODO: some future version
+            dvmCompilerReportChainCellDataToVTune(cUnit, jitMethod.method_id);
+        }
+#endif
+        if (gDvmJit.printMe == true) {
+            LOGD("JIT API: a trace of '%s' method was written successfully: id=%u, address=%p, size=%d."
+                    , cUnit->method->name, jitMethod.method_id, jitMethod.method_load_address ,jitMethod.method_size);
+        }
+    } else if (gDvmJit.printMe == true) {
+        LOGD("JIT API: failed to write a trace of '%s' method: id=%u, address=%p, size=%d."
+                , cUnit->method->name, jitMethod.method_id, jitMethod.method_load_address ,jitMethod.method_size);
+    }
+}
+
+#endif
diff --git a/vm/compiler/VTuneSupport.h b/vm/compiler/VTuneSupport.h
new file mode 100644
index 0000000..fa6b913
--- /dev/null
+++ b/vm/compiler/VTuneSupport.h
@@ -0,0 +1,48 @@
+/*
+ * Copyright (C) 2009 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef VTUNE_SUPPORT_H_
+#define VTUNE_SUPPORT_H_
+
+#include "vtune/JitProfiling.h"
+
+//Forward declarations
+struct CompilationUnit;
+struct JitTraceDescription;
+
+/*
+ * @brief Wrapper of VTune's iJIT_NotifyEvent needed for Update events
+ *        (event_type == iJVM_EVENT_TYPE_METHOD_UPDATE) to find
+ *        appropriate method_id set by a preceded Method Load event
+ *        (event_type == iJVM_EVENT_TYPE_METHOD_LOAD_FINISHED) by an address
+ *        inside the method range.
+ * @param event_type kind of event
+ * @param eventSpecificData data about the event
+ * @return see iJIT_NotifyEvent
+ *
+ * method_id is required by VTune iJIT_NotifyEvent/Update.
+ * The new upcoming VTune Update event is designed to not require the method_id.
+ * When the new Update will come, all the mapping can be removed.
+ */
+int notifyVTune(iJIT_JVM_EVENT event_type, void *eventSpecificData);
+
+/*
+ * @brief Prepare data about the compiled trace and send it to VTune.
+ * @param cUnit pointer to the CompilationUnit
+ * @param desc pointer to the JitTraceDescription
+ */
+void sendTraceInfoToVTune(CompilationUnit *cUnit, JitTraceDescription *desc);
+#endif
diff --git a/vm/compiler/codegen/x86/CodegenInterface.cpp b/vm/compiler/codegen/x86/CodegenInterface.cpp
index 36db7e6..51422eb 100644
--- a/vm/compiler/codegen/x86/CodegenInterface.cpp
+++ b/vm/compiler/codegen/x86/CodegenInterface.cpp
@@ -13,2568 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-#include <sys/mman.h>
-#include "CompilationUnit.h"
-#include "Dalvik.h"
-#include "libdex/DexOpcodes.h"
-#include "compiler/Compiler.h"
-#include "compiler/CompilerIR.h"
-#include "interp/Jit.h"
-#include "libdex/DexFile.h"
-#include "Lower.h"
-#include "NcgAot.h"
-#include "compiler/codegen/CompilerCodegen.h"
-#include "InstructionGeneration.h"
-#include "Singleton.h"
-#include "ExceptionHandling.h"
-#include "Scheduler.h"
-#include "CodegenErrors.h"
-#include "Profile.h"
 
-#ifdef HAVE_ANDROID_OS
-#include <cutils/properties.h>
-#endif
+// This is a placeholder for LCG and PCG common stuff from lightcg/CodegenInterface.cpp
+// TODO: move here all common code from lightcg/CodegenInterface.cpp
 
-#if !defined(VTUNE_DALVIK)
-/* Handy function for VTune updates of PredictedChainingCells */
-static void updateCodeCache(PredictedChainingCell& dst, const PredictedChainingCell& src)
-{
-    dst = src;
-}
-
-/* Handy function for VTune updates of ints */
-static void updateCodeCache(int &dst, int src)
-{
-    dst = src;
-}
-
-/* Send updated code cache content to VTune */
-static void SendUpdateToVTune(void * address, unsigned size, unsigned method_id = 0)
-{
-    (void) address; (void) size; (void) method_id;
-}
-
-#else
-
-#include "compiler/JitProfiling.h"
-
-/* Send updated code cache content to VTune */
-static void SendUpdateToVTune(void * address, unsigned size, unsigned method_id = 0)
-{
-    if (gDvmJit.vtuneInfo == kVTuneInfoDisabled || gDvmJit.vtuneVersion < 279867) {
-        return;
-    }
-
-    iJIT_Method_Load jitMethod;
-    memset (&jitMethod, 0, sizeof (jitMethod));
-
-    jitMethod.method_id = method_id;
-    jitMethod.method_load_address = address;
-    jitMethod.method_size = size;
-
-    // Send the trace update event to the VTune analyzer
-    int res = iJIT_NotifyEvent(iJVM_EVENT_TYPE_METHOD_UPDATE, (void*)&jitMethod);
-    if (gDvmJit.printMe == true) {
-        if (res != 0) {
-            if (jitMethod.method_id == 0) {
-                ALOGD("JIT API: a trace update with address=%p size=%u was not written.",
-                        jitMethod.method_load_address, jitMethod.method_size);
-            } else {
-                ALOGD("JIT API: a trace update with method_id=%u address=%p size=%u was written successfully.",
-                        jitMethod.method_id, jitMethod.method_load_address, jitMethod.method_size);
-            }
-        } else {
-            ALOGD("JIT API: failed to write a trace update with method_id=%u address=%p size=%u.",
-                    jitMethod.method_id, jitMethod.method_load_address, jitMethod.method_size);
-        }
-    }
-}
-
-/* Handy function for VTune updates of changed PredictedChainingCells */
-static void updateCodeCache(PredictedChainingCell& dst, const PredictedChainingCell& src)
-{
-    bool isDiff = dst.branch != src.branch || dst.branch2 != src.branch2;
-    dst = src;
-    if (isDiff == true) {
-        SendUpdateToVTune(&dst, sizeof(PredictedChainingCell));
-    }
-}
-
-/* Handy function for VTune updates of changed ints */
-static void updateCodeCache(int &dst, int src)
-{
-    bool isDiff = dst != src;
-    dst = src;
-    if (isDiff == true) {
-        SendUpdateToVTune(&dst, sizeof(int));
-    }
-}
-#endif // !defined(VTUNE_DALVIK)
-
-/* JIT opcode filtering */
-bool jitOpcodeTable[kNumPackedOpcodes];
-Opcode jitNotSupportedOpcode[] = {
-    OP_INVOKE_OBJECT_INIT_RANGE,
-#if defined (WITH_SELF_VERIFICATION)
-    OP_MONITOR_ENTER,
-    OP_MONITOR_EXIT,
-    OP_NEW_INSTANCE,
-    OP_NEW_ARRAY,
-    OP_CHECK_CAST,
-    OP_MOVE_EXCEPTION,
-    OP_FILL_ARRAY_DATA,
-    OP_EXECUTE_INLINE,
-    OP_EXECUTE_INLINE_RANGE,
-
-    //TODO: fix for the test case
-    /* const does not generate assembly instructions
-     * so a divergence will falsely occur when interp executes and sets
-     * the virtual registers (in memory ).
-     *
-     * const*
-     * return
-     *
-     * const*
-     * invoke_*
-     */
-    OP_CONST_4,
-    OP_CONST_16,
-    OP_CONST,
-    OP_CONST_HIGH16,
-    OP_CONST_WIDE_16,
-    OP_CONST_WIDE_32,
-    OP_CONST_WIDE,
-    OP_CONST_WIDE_HIGH16,
-    OP_CONST_STRING,
-    OP_CONST_STRING_JUMBO,
-
-    OP_RETURN,
-    OP_RETURN_VOID, //const and return
-    OP_RETURN_OBJECT,
-    OP_INVOKE_VIRTUAL_QUICK_RANGE,
-    OP_INVOKE_VIRTUAL_QUICK,
-    OP_INVOKE_INTERFACE,
-    OP_INVOKE_STATIC,
-
-    //occurs with threaded apps
-    OP_APUT_CHAR,
-    OP_APUT_BOOLEAN,
-    OP_APUT_BYTE,
-
-#endif
-};
-
-/* Init values when a predicted chain is initially assembled */
-/* E7FE is branch to self */
-#define PREDICTED_CHAIN_BX_PAIR_INIT     0xe7fe
-
-#if defined(WITH_JIT)
-/* Target-specific save/restore */
-extern "C" void dvmJitCalleeSave(double *saveArea);
-extern "C" void dvmJitCalleeRestore(double *saveArea);
-#endif
-
-/*
- * Determine the initial instruction set to be used for this trace.
- * Later components may decide to change this.
- */
-//JitInstructionSetType dvmCompilerInstructionSet(CompilationUnit *cUnit)
-JitInstructionSetType dvmCompilerInstructionSet(void)
-{
-    return DALVIK_JIT_IA32;
-}
-
-JitInstructionSetType dvmCompilerGetInterpretTemplateSet()
-{
-    return DALVIK_JIT_IA32;
-}
-
-/* we don't use template for IA32 */
-void *dvmCompilerGetInterpretTemplate()
-{
-      return NULL;//(void*) ((int)gDvmJit.codeCache);
-}
-
-/* Initialize the jitOpcodeTable which records what opcodes are supported
- *  by the JIT compiler.
- */
-void dvmInitJitOpcodeTable() {
-    unsigned int i;
-    memset(jitOpcodeTable, 1, sizeof(jitOpcodeTable));
-    for (i = 0; i < sizeof(jitNotSupportedOpcode)/sizeof(Opcode); i++) {
-        jitOpcodeTable[((unsigned int)jitNotSupportedOpcode[i])] = false;
-    }
-    for (i = 0; i < sizeof(jitOpcodeTable)/sizeof(bool); i++) {
-        if (jitOpcodeTable[i] == false)
-            ALOGV("opcode 0x%x not supported by JIT", i);
-    }
-}
-
-/* Return true if the opcode is supported by the JIT compiler. */
-bool dvmIsOpcodeSupportedByJit(const DecodedInstruction & insn)
-{
-     /* reject traces containing bytecodes requesting virtual registers exceeding allowed limit */
-     if ((insn.opcode == OP_INVOKE_VIRTUAL_RANGE) || (insn.opcode == OP_INVOKE_VIRTUAL_QUICK_RANGE) ||
-         (insn.opcode == OP_INVOKE_SUPER_RANGE) || (insn.opcode == OP_INVOKE_SUPER_QUICK_RANGE) ||
-         (insn.opcode == OP_INVOKE_DIRECT_RANGE) || (insn.opcode == OP_INVOKE_STATIC_RANGE) ||
-         (insn.opcode == OP_INVOKE_INTERFACE_RANGE)){
-        int opcodeArgs = (int) (insn.vA);
-        if (opcodeArgs > MAX_REG_PER_BYTECODE)
-           return false;
-     }
-    return jitOpcodeTable[((int) insn.opcode)];
-}
-
-/* Track the number of times that the code cache is patched */
-#if defined(WITH_JIT_TUNING)
-#define UPDATE_CODE_CACHE_PATCHES()    (gDvmJit.codeCachePatches++)
-#else
-#define UPDATE_CODE_CACHE_PATCHES()
-#endif
-
-//! default JIT table size used by x86 JIT
-#define DEFAULT_X86_ATOM_DALVIK_JIT_TABLE_SIZE 1<<12
-//! default JIT threshold used by x86 JIT
-#define DEFAULT_X86_ATOM_DALVIK_JIT_THRESHOLD 50
-//! default JIT code cache size used by x86 JIT
-#define DEFAULT_X86_ATOM_DALVIK_JIT_CODE_CACHE_SIZE 512*1024
-
-//! Initializes target-specific configuration
-
-//! Configures the jit table size, jit threshold, and jit code cache size
-//! Initializes status of all threads and the table of supported bytecodes
-//! @return true when initialization is successful (NOTE: current
-//! implementation always returns true)
-bool dvmCompilerArchInit() {
-#ifdef HAVE_ANDROID_OS
-    // Used to get global properties
-    char propertyBuffer[PROPERTY_VALUE_MAX];
-#endif
-    unsigned long propertyValue;
-
-    // Used to identify cpu
-    int familyAndModelInformation;
-    const int familyIdMask = 0xF00;
-    const int familyIdShift = 8;
-    const int modelMask = 0XF0;
-    const int modelShift = 4;
-    const int modelWidth = 4;
-    const int extendedModelIdMask = 0xF0000;
-    const int extendedModelShift = 16;
-
-    // Initialize JIT table size
-    if(gDvmJit.jitTableSize == 0 || (gDvmJit.jitTableSize & (gDvmJit.jitTableSize - 1))) {
-        // JIT table size has not been initialized yet or is not a power of two
-#ifdef HAVE_ANDROID_OS
-        memset(propertyBuffer, 0, PROPERTY_VALUE_MAX); // zero out buffer so we don't use junk
-        property_get("dalvik.jit.table_size", propertyBuffer, NULL);
-        propertyValue = strtoul(propertyBuffer, NULL, 10 /*base*/);
-#else
-        propertyValue = 0ul;
-#endif
-        if (errno == ERANGE || propertyValue == 0ul || (propertyValue & (propertyValue - 1ul)))
-            /* out of range, conversion failed, trying to use invalid value of 0, or using non-power of two */
-            gDvmJit.jitTableSize = DEFAULT_X86_ATOM_DALVIK_JIT_TABLE_SIZE;
-        else // property is valid, but we still need to cast from unsigned long to unsigned int
-            gDvmJit.jitTableSize = static_cast<unsigned int>(propertyValue);
-    }
-
-    // Initialize JIT table mask
-    gDvmJit.jitTableMask = gDvmJit.jitTableSize - 1;
-    gDvmJit.optLevel = kJitOptLevelO1;
-
-    // Initialize JIT threshold
-    if(gDvmJit.threshold == 0) { // JIT threshold has not been initialized yet
-#ifdef HAVE_ANDROID_OS
-        memset(propertyBuffer, 0, PROPERTY_VALUE_MAX); // zero out buffer so we don't use junk
-        property_get("dalvik.jit.threshold", propertyBuffer, NULL);
-        propertyValue = strtoul(propertyBuffer, NULL, 10 /*base*/);
-#else
-        propertyValue = 0ul;
-#endif
-        if (errno == ERANGE || propertyValue == 0ul)
-            /* out of range, conversion failed, or trying to use invalid value of 0 */
-            gDvmJit.threshold = DEFAULT_X86_ATOM_DALVIK_JIT_THRESHOLD;
-        else // property is valid, but we still need to cast from unsigned long to unsigned short
-            gDvmJit.threshold = static_cast<unsigned short>(propertyValue);
-    }
-
-    // Initialize JIT code cache size
-    if(gDvmJit.codeCacheSize == 0) { // JIT code cache size has not been initialized yet
-#ifdef HAVE_ANDROID_OS
-        memset(propertyBuffer, 0, PROPERTY_VALUE_MAX); // zero out buffer so we don't use junk
-        property_get("dalvik.jit.code_cache_size", propertyBuffer, NULL);
-        propertyValue = strtoul(propertyBuffer, NULL, 10 /*base*/);
-#else
-        propertyValue = 0ul;
-#endif
-        if (errno == ERANGE || propertyValue == 0ul)
-            /* out of range, conversion failed, or trying to use invalid value of 0 */
-            gDvmJit.codeCacheSize = DEFAULT_X86_ATOM_DALVIK_JIT_CODE_CACHE_SIZE;
-        else // property is valid, but we still need to cast from unsigned long to unsigned int
-            gDvmJit.codeCacheSize = static_cast<unsigned int>(propertyValue);
-    }
-
-    // Print out values used
-    ALOGV("JIT threshold set to %hu",gDvmJit.threshold);
-    ALOGV("JIT table size set to %u",gDvmJit.jitTableSize);
-    ALOGV("JIT code cache size set to %u",gDvmJit.codeCacheSize);
-
-    //Disable Method-JIT
-    gDvmJit.disableOpt |= (1 << kMethodJit);
-
-#ifdef HAVE_ANDROID_OS
-    // If JIT verbose has not been enabled, check the global property dalvik.jit.verbose
-    if (!gDvmJit.printMe) {
-        memset(propertyBuffer, 0, PROPERTY_VALUE_MAX); // zero out buffer so we don't use junk
-        property_get("dalvik.jit.verbose", propertyBuffer, NULL);
-        // Look for text ". We could enable finer control by checking application
-        // name, but the VM would need to know which application it is running
-        if (strncmp("true", propertyBuffer, PROPERTY_VALUE_MAX) == 0) {
-            gDvmJit.printMe = true;
-        }
-    }
-#endif
-
-    // Now determine machine model
-    asm volatile (
-            "movl $1, %%eax\n\t"
-            "pushl %%ebx\n\t"
-            "cpuid\n\t"
-            "popl %%ebx\n\t"
-            "movl %%eax, %0"
-            : "=r" (familyAndModelInformation)
-            :
-            : "eax", "ecx", "edx");
-    gDvmJit.cpuFamily = (familyAndModelInformation & familyIdMask) >> familyIdShift;
-    gDvmJit.cpuModel = (((familyAndModelInformation & extendedModelIdMask)
-            >> extendedModelShift) << modelWidth)
-            + ((familyAndModelInformation & modelMask) >> modelShift);
-
-#if defined(WITH_SELF_VERIFICATION)
-    /* Force into blocking mode */
-    gDvmJit.blockingMode = true;
-    gDvm.nativeDebuggerActive = true;
-#endif
-
-    // Make sure all threads have current values
-    dvmJitUpdateThreadStateAll();
-
-    /* Initialize jitOpcodeTable for JIT supported opcode */
-    dvmInitJitOpcodeTable();
-
-    return true;
-}
-
-void dvmCompilerPatchInlineCache(void)
-{
-    int i;
-    PredictedChainingCell *minAddr, *maxAddr;
-
-    /* Nothing to be done */
-    if (gDvmJit.compilerICPatchIndex == 0) return;
-
-    /*
-     * Since all threads are already stopped we don't really need to acquire
-     * the lock. But race condition can be easily introduced in the future w/o
-     * paying attention so we still acquire the lock here.
-     */
-    dvmLockMutex(&gDvmJit.compilerICPatchLock);
-
-    UNPROTECT_CODE_CACHE(gDvmJit.codeCache, gDvmJit.codeCacheByteUsed);
-
-    //ALOGD("Number of IC patch work orders: %d", gDvmJit.compilerICPatchIndex);
-
-    /* Initialize the min/max address range */
-    minAddr = (PredictedChainingCell *)
-        ((char *) gDvmJit.codeCache + gDvmJit.codeCacheSize);
-    maxAddr = (PredictedChainingCell *) gDvmJit.codeCache;
-
-    for (i = 0; i < gDvmJit.compilerICPatchIndex; i++) {
-        ICPatchWorkOrder *workOrder = &gDvmJit.compilerICPatchQueue[i];
-        PredictedChainingCell *cellAddr = workOrder->cellAddr;
-        PredictedChainingCell *cellContent = &workOrder->cellContent;
-        ClassObject *clazz = dvmFindClassNoInit(workOrder->classDescriptor,
-                                                workOrder->classLoader);
-
-        assert(clazz->serialNumber == workOrder->serialNumber);
-
-        /* Use the newly resolved clazz pointer */
-        cellContent->clazz = clazz;
-
-        if (cellAddr->clazz == NULL) {
-            COMPILER_TRACE_CHAINING(
-                ALOGI("Jit Runtime: predicted chain %p to %s (%s) initialized",
-                      cellAddr,
-                      cellContent->clazz->descriptor,
-                      cellContent->method->name));
-        } else {
-            COMPILER_TRACE_CHAINING(
-                ALOGI("Jit Runtime: predicted chain %p from %s to %s (%s) "
-                      "patched",
-                      cellAddr,
-                      cellAddr->clazz->descriptor,
-                      cellContent->clazz->descriptor,
-                      cellContent->method->name));
-        }
-
-        /* Patch the chaining cell */
-        updateCodeCache(*cellAddr, *cellContent);
-
-        minAddr = (cellAddr < minAddr) ? cellAddr : minAddr;
-        maxAddr = (cellAddr > maxAddr) ? cellAddr : maxAddr;
-    }
-
-    PROTECT_CODE_CACHE(gDvmJit.codeCache, gDvmJit.codeCacheByteUsed);
-
-    gDvmJit.compilerICPatchIndex = 0;
-    dvmUnlockMutex(&gDvmJit.compilerICPatchLock);
-}
-
-/* Target-specific cache clearing */
-void dvmCompilerCacheClear(char *start, size_t size)
-{
-    /* "0xFF 0xFF" is an invalid opcode for x86. */
-    memset(start, 0xFF, size);
-}
-
-/* for JIT debugging, to be implemented */
-void dvmJitCalleeSave(double *saveArea) {
-}
-
-void dvmJitCalleeRestore(double *saveArea) {
-}
-
-void dvmJitToInterpSingleStep() {
-}
-
-JitTraceDescription *dvmCopyTraceDescriptor(const u2 *pc,
-                                            const JitEntry *knownEntry) {
-    return NULL;
-}
-
-void dvmCompilerCodegenDump(CompilationUnit *cUnit) //in ArchUtility.c
-{
-}
-
-void dvmCompilerArchDump(void)
-{
-}
-
-void dvmCompilerAssembleLIR(CompilationUnit *cUnit, JitTranslationInfo* info)
-{
-}
-
-void dvmJitInstallClassObjectPointers(CompilationUnit *cUnit, char *codeAddress)
-{
-}
-
-void dvmCompilerMethodMIR2LIR(CompilationUnit *cUnit)
-{
-    // Method-based JIT not supported for x86.
-}
-
-void dvmJitScanAllClassPointers(void (*callback)(void *))
-{
-}
-
-/**
- * @brief Generates a jump with 32-bit relative immediate that jumps
- * to the target.
- * @details Updates the instruction stream with the jump.
- * @param target absolute address of target.
- */
-void unconditional_jump_rel32(void * target) {
-    // We will need to figure out the immediate to use for the relative
-    // jump, so we need to flush scheduler so that stream is updated.
-    // In most cases this won't affect the schedule since the jump would've
-    // ended the native BB anyway and would've been scheduled last.
-    if(gDvmJit.scheduling)
-        singletonPtr<Scheduler>()->signalEndOfNativeBasicBlock();
-
-    // Calculate the address offset between the destination of jump and the
-    // function we are jumping to.
-    int relOffset = reinterpret_cast<int>(target)
-            - reinterpret_cast<int>(stream);
-
-    // Since instruction pointer will already be updated when executing this,
-    // subtract size of jump instruction
-    relOffset -= getJmpCallInstSize(OpndSize_32, JmpCall_uncond);
-
-    // Generate the unconditional jump now
-    unconditional_jump_int(relOffset, OpndSize_32);
-}
-
-// works whether instructions for target basic block are generated or not
-LowOp* jumpToBasicBlock(char* instAddr, int targetId,
-        bool immediateNeedsAligned) {
-    stream = instAddr;
-    bool unknown;
-    OpndSize size;
-    if(gDvmJit.scheduling) {
-        // If target is chaining cell, we must align the immediate
-        unconditional_jump_block(targetId, immediateNeedsAligned);
-    } else {
-        if (immediateNeedsAligned == true) {
-            alignOffset(1);
-        }
-        int relativeNCG = getRelativeNCG(targetId, JmpCall_uncond, &unknown, &size);
-        unconditional_jump_int(relativeNCG, size);
-    }
-    return NULL;
-}
-
-LowOp* condJumpToBasicBlock(char* instAddr, ConditionCode cc, int targetId,
-        bool immediateNeedsAligned) {
-    stream = instAddr;
-    bool unknown;
-    OpndSize size;
-    if(gDvmJit.scheduling) {
-        // If target is chaining cell, we must align the immediate
-        conditional_jump_block(cc, targetId, immediateNeedsAligned);
-    } else {
-        int relativeNCG = getRelativeNCG(targetId, JmpCall_cond, &unknown, &size);
-        conditional_jump_int(cc, relativeNCG, size);
-    }
-    return NULL;
-}
-
-/*
- * Attempt to enqueue a work order to patch an inline cache for a predicted
- * chaining cell for virtual/interface calls.
- */
-static bool inlineCachePatchEnqueue(PredictedChainingCell *cellAddr,
-                                    PredictedChainingCell *newContent)
-{
-    bool result = true;
-
-    /*
-     * Make sure only one thread gets here since updating the cell (ie fast
-     * path and queueing the request (ie the queued path) have to be done
-     * in an atomic fashion.
-     */
-    dvmLockMutex(&gDvmJit.compilerICPatchLock);
-
-    /* Fast path for uninitialized chaining cell */
-    if (cellAddr->clazz == NULL &&
-        cellAddr->branch == PREDICTED_CHAIN_BX_PAIR_INIT) {
-        UNPROTECT_CODE_CACHE(cellAddr, sizeof(*cellAddr));
-
-        cellAddr->method = newContent->method;
-
-        /* remember if the branch address has changed, other fields do not matter.
-         * If changed then send new values to VTune a bit later */
-        bool isBranchUpdated = cellAddr->branch != newContent->branch || cellAddr->branch2 != newContent->branch2;
-
-        cellAddr->branch = newContent->branch;
-        cellAddr->branch2 = newContent->branch2;
-
-        /*
-         * The update order matters - make sure clazz is updated last since it
-         * will bring the uninitialized chaining cell to life.
-         */
-        android_atomic_release_store((int32_t)newContent->clazz,
-            (volatile int32_t *)(void*) &cellAddr->clazz);
-        //cacheflush((intptr_t) cellAddr, (intptr_t) (cellAddr+1), 0);
-        UPDATE_CODE_CACHE_PATCHES();
-        if (isBranchUpdated == true) {
-            SendUpdateToVTune(cellAddr, sizeof(*cellAddr));
-        }
-
-        PROTECT_CODE_CACHE(cellAddr, sizeof(*cellAddr));
-
-#if 0
-        MEM_BARRIER();
-        cellAddr->clazz = newContent->clazz;
-        //cacheflush((intptr_t) cellAddr, (intptr_t) (cellAddr+1), 0);
-#endif
-#if defined(WITH_JIT_TUNING)
-        gDvmJit.icPatchInit++;
-#endif
-        COMPILER_TRACE_CHAINING(
-            ALOGI("Jit Runtime: FAST predicted chain %p to method %s%s %p",
-                  cellAddr, newContent->clazz->descriptor, newContent->method->name, newContent->method));
-    /* Check if this is a frequently missed clazz */
-    } else if (cellAddr->stagedClazz != newContent->clazz) {
-        /* Not proven to be frequent yet - build up the filter cache */
-        UNPROTECT_CODE_CACHE(cellAddr, sizeof(*cellAddr));
-
-        cellAddr->stagedClazz = newContent->clazz;
-
-        UPDATE_CODE_CACHE_PATCHES();
-        PROTECT_CODE_CACHE(cellAddr, sizeof(*cellAddr));
-
-#if defined(WITH_JIT_TUNING)
-        gDvmJit.icPatchRejected++;
-#endif
-    /*
-     * Different classes but same method implementation - it is safe to just
-     * patch the class value without the need to stop the world.
-     */
-    } else if (cellAddr->method == newContent->method) {
-        UNPROTECT_CODE_CACHE(cellAddr, sizeof(*cellAddr));
-
-        cellAddr->clazz = newContent->clazz;
-        /* No need to flush the cache here since the branch is not patched */
-        UPDATE_CODE_CACHE_PATCHES();
-
-        PROTECT_CODE_CACHE(cellAddr, sizeof(*cellAddr));
-
-#if defined(WITH_JIT_TUNING)
-        gDvmJit.icPatchLockFree++;
-#endif
-    /*
-     * Cannot patch the chaining cell inline - queue it until the next safe
-     * point.
-     */
-    } else if (gDvmJit.compilerICPatchIndex < COMPILER_IC_PATCH_QUEUE_SIZE)  {
-        int index = gDvmJit.compilerICPatchIndex++;
-        const ClassObject *clazz = newContent->clazz;
-
-        gDvmJit.compilerICPatchQueue[index].cellAddr = cellAddr;
-        gDvmJit.compilerICPatchQueue[index].cellContent = *newContent;
-        gDvmJit.compilerICPatchQueue[index].classDescriptor = clazz->descriptor;
-        gDvmJit.compilerICPatchQueue[index].classLoader = clazz->classLoader;
-        /* For verification purpose only */
-        gDvmJit.compilerICPatchQueue[index].serialNumber = clazz->serialNumber;
-
-#if defined(WITH_JIT_TUNING)
-        gDvmJit.icPatchQueued++;
-#endif
-        COMPILER_TRACE_CHAINING(
-            ALOGI("Jit Runtime: QUEUE predicted chain %p to method %s%s",
-                  cellAddr, newContent->clazz->descriptor, newContent->method->name));
-    } else {
-    /* Queue is full - just drop this patch request */
-#if defined(WITH_JIT_TUNING)
-        gDvmJit.icPatchDropped++;
-#endif
-
-        COMPILER_TRACE_CHAINING(
-            ALOGI("Jit Runtime: DROP predicted chain %p to method %s%s",
-                  cellAddr, newContent->clazz->descriptor, newContent->method->name));
-    }
-
-    dvmUnlockMutex(&gDvmJit.compilerICPatchLock);
-    return result;
-}
-
-/*
- * This method is called from the invoke templates for virtual and interface
- * methods to speculatively setup a chain to the callee. The templates are
- * written in assembly and have setup method, cell, and clazz at r0, r2, and
- * r3 respectively, so there is a unused argument in the list. Upon return one
- * of the following three results may happen:
- *   1) Chain is not setup because the callee is native. Reset the rechain
- *      count to a big number so that it will take a long time before the next
- *      rechain attempt to happen.
- *   2) Chain is not setup because the callee has not been created yet. Reset
- *      the rechain count to a small number and retry in the near future.
- *   3) Ask all other threads to stop before patching this chaining cell.
- *      This is required because another thread may have passed the class check
- *      but hasn't reached the chaining cell yet to follow the chain. If we
- *      patch the content before halting the other thread, there could be a
- *      small window for race conditions to happen that it may follow the new
- *      but wrong chain to invoke a different method.
- */
-extern "C" const Method *dvmJitToPatchPredictedChain(const Method *method,
-                                          Thread *self,
-                                          PredictedChainingCell *cell,
-                                          const ClassObject *clazz)
-{
-    int newRechainCount = PREDICTED_CHAIN_COUNTER_RECHAIN;
-    /* Don't come back here for a long time if the method is native */
-    if (dvmIsNativeMethod(method)) {
-        UNPROTECT_CODE_CACHE(cell, sizeof(*cell));
-
-        /*
-         * Put a non-zero/bogus value in the clazz field so that it won't
-         * trigger immediate patching and will continue to fail to match with
-         * a real clazz pointer.
-         */
-        cell->clazz = (ClassObject *) PREDICTED_CHAIN_FAKE_CLAZZ;
-
-        UPDATE_CODE_CACHE_PATCHES();
-        PROTECT_CODE_CACHE(cell, sizeof(*cell));
-        COMPILER_TRACE_CHAINING(
-            ALOGI("Jit Runtime: predicted chain %p to native method %s ignored",
-                  cell, method->name));
-        goto done;
-    }
-    {
-    int tgtAddr = (int) dvmJitGetTraceAddr(method->insns);
-
-    /*
-     * Compilation not made yet for the callee. Reset the counter to a small
-     * value and come back to check soon.
-     */
-    if ((tgtAddr == 0) ||
-        ((void*)tgtAddr == dvmCompilerGetInterpretTemplate())) {
-        COMPILER_TRACE_CHAINING(
-            ALOGI("Jit Runtime: predicted chain %p to method %s%s delayed",
-                  cell, method->clazz->descriptor, method->name));
-        goto done;
-    }
-
-    PredictedChainingCell newCell;
-
-    if (cell->clazz == NULL) {
-        newRechainCount = self->icRechainCount;
-    }
-
-    int relOffset = (int) tgtAddr - (int)cell;
-    OpndSize immSize = estOpndSizeFromImm(relOffset);
-    int jumpSize = getJmpCallInstSize(immSize, JmpCall_uncond);
-    relOffset -= jumpSize;
-    COMPILER_TRACE_CHAINING(
-            ALOGI("inlineCachePatchEnqueue chain %p to method %s%s inst size %d",
-                  cell, method->clazz->descriptor, method->name, jumpSize));
-
-    // This does not need to go through lowering interface and can encode directly
-    // at address because it does not actually update code stream until safe point.
-    // Can't use stream here since it is used by the compilation thread.
-    encoder_imm(Mnemonic_JMP, immSize, relOffset, (char*) (&newCell)); //update newCell.branch
-
-    newCell.clazz = clazz;
-    newCell.method = method;
-
-    /*
-     * Enter the work order to the queue and the chaining cell will be patched
-     * the next time a safe point is entered.
-     *
-     * If the enqueuing fails reset the rechain count to a normal value so that
-     * it won't get indefinitely delayed.
-     */
-    inlineCachePatchEnqueue(cell, &newCell);
-    }
-done:
-    self->icRechainCount = newRechainCount;
-    return method;
-}
-
-/**
- * @class BackwardBranchChainingCellContents
- * @brief Defines the data structure of a Backward Branch Chaining Cell.
- */
-struct __attribute__ ((packed)) BackwardBranchChainingCellContents
-{
-    /**
-     * @brief Used to hold the "call rel32" to dvmJitToInterpBackwardBranch
-     */
-    char instructionHolder[5];
-
-    unsigned int nextPC;    //!< Next bytecode PC
-
-    /**
-     * @brief Holds address of operand of jump instruction that is to be patched.
-     * After chaining, the jump is  filled with relative offset to loop header.
-     * After unchaining it is filled with relative offset to the VR write-back.
-     */
-    char * codePtr;
-
-    char * loopHeaderAddr;    //!< Address of loop header block.
-    char * vrWriteBackAddr;   //!< Address of VR write-back block.
-    char * loopPreHeaderAddr; //!< Address of loop pre-header block.
-
-    /**
-     * Doxygen does not like documentation of functions here, so let's just document it but not expose it to doxygen
-     * brief Used for unchaining backward branch chaining cells.
-     * param location This is location where unchaining method can assume that a Backward Branch CC exists.
-     * return Returns size of unchained cell.
-     */
-    static size_t unchain (u1 * location)
-    {
-        //First we reinterpret the location to be a chaining cell
-        BackwardBranchChainingCellContents * contents =
-                reinterpret_cast<BackwardBranchChainingCellContents *> (location);
-
-        //We want to jump to the VR write back address and we know that the code
-        //pointer points to operand of jump. Thus we also subtract our assumed
-        //operand size of 32-bits.
-        int relativeOffset = (contents->vrWriteBackAddr - contents->codePtr)
-                - OpndSize_32;
-
-        //We want to patch with an int value so we reinterpret the address here
-        int * addressOfJumpOperand = reinterpret_cast<int *> (contents->codePtr);
-
-        //This does the actual patching with the offset we calculated
-        updateCodeCache(*addressOfJumpOperand, relativeOffset);
-
-        //We return size of our chaining cell
-        return sizeof(*contents);
-    }
-};
-
-#define BYTES_OF_NORMAL_CHAINING 13
-#define BYTES_OF_HOT_CHAINING 17
-#define BYTES_OF_SINGLETON_CHAINING 13
-#define BYTES_OF_PREDICTED_CHAINING 20
-#define OFFSET_OF_PATCHADDR 9 // offset in chaining cell to the field for the location to be patched
-#define OFFSET_OF_ISMOVEFLAG 13  // offset in hot chaining cell to the ismove_flag field
-#define BYTES_OF_32BITS 4
-/*
- * Unchain a trace given the starting address of the translation
- * in the code cache.  Refer to the diagram in dvmCompilerAssembleLIR.
- * For ARM, it returns the address following the last cell unchained.
- * For IA, it returns NULL since cacheflush is not required for IA.
- */
-u4* dvmJitUnchain(void* codeAddr)
-{
-    /* codeAddr is 4-byte aligned, so is chain cell count offset */
-    u2* pChainCellCountOffset = (u2*)((char*)codeAddr - 4);
-    u2 chainCellCountOffset = *pChainCellCountOffset;
-    /* chain cell counts information is 4-byte aligned */
-    ChainCellCounts *pChainCellCounts =
-          (ChainCellCounts*)((char*)codeAddr + chainCellCountOffset);
-    u2* pChainCellOffset = (u2*)((char*)codeAddr - 2);
-    u2 chainCellOffset = *pChainCellOffset;
-    u1* pChainCells;
-    int i,j;
-    PredictedChainingCell *predChainCell;
-    int padding;
-    u1* patchAddr;
-    int relativeNCG;
-    int ismove_flag = 0;
-
-    /* Locate the beginning of the chain cell region */
-    pChainCells = (u1 *)((char*)codeAddr + chainCellOffset);
-
-    /* The cells are sorted in order - walk through them and reset */
-    for (i = 0; i < kChainingCellGap; i++) {
-        /* for normal chaining:
-               call imm32
-               rPC
-               codePtr (offset address of jmp/jcc)
-           after chaining:
-               codePtr is filled with a relative offset to the target
-           after unchaining:
-              codePtr is filled with original relative offset to the chaining cell
-
-           for backward chaining:
-               call imm32
-               rPC
-               codePtr (offset address of jmp/jcc)
-               loop header address
-               vrStoreCodePtr (code address of deferred VR store)
-           after chaining:
-               codePtr is filled with a relative offset to the loop header
-           after unchaining:
-               if (vrStoreCodePtr)
-                   codePtr is filled with relative offset to the deferred vr store
-               else
-                   codePtr is filled with relative offset to the chaining cell
-
-          for singleton chaining:
-               call imm32
-               rPC
-               codePtr (offset address of movl)
-           after chaining:
-               codePtr is filled with absolute address to the target
-           after unchaining:
-               codePtr is filled with absolute adress of the chaining cell
-
-           for hot chaining:
-               call imm32
-               rPC
-               codePtr (offset address of jmp or movl)
-               ismove_flag
-           after chaining:
-               if (ismove_flag)
-                 codePtr is filled with a relative offset to the target
-               else
-                 codePtr is filled with absolute address to the target
-           after unchaining:
-               if (ismove_flag)
-                 codePtr is filled with original relative offset to the chaining cell
-               else
-                 codePtr is filled with absolute adress of the chaining cell
-
-           Space occupied by the chaining cell in bytes:
-                normal, singleton: 5+4+4
-                backward: 5+4+4+4+4
-                hot: 5+4+4+4
-                codePtr should be within 16B line.
-
-           Space for predicted chaining: 5 words = 20 bytes + padding to make it 4-byte aligned
-        */
-        int elemSize = 0;
-
-        COMPILER_TRACE_CHAINING(
-            ALOGI("Jit Runtime: unchaining type %d count %d", i, pChainCellCounts->u.count[i]));
-
-        for (j = 0; j < pChainCellCounts->u.count[i]; j++) {
-            switch(i) {
-                case kChainingCellNormal:
-                    COMPILER_TRACE_CHAINING(
-                        ALOGI("Jit Runtime: unchaining of normal"));
-                    elemSize = BYTES_OF_NORMAL_CHAINING;
-                    patchAddr = (u1 *)(*(int *)((char*)pChainCells + OFFSET_OF_PATCHADDR));
-                    relativeNCG = (pChainCells - patchAddr) - BYTES_OF_32BITS;
-                    if (patchAddr)
-                        updateCodeCache(*(int*)patchAddr, relativeNCG);
-                    break;
-                case kChainingCellHot:
-                    COMPILER_TRACE_CHAINING(
-                        ALOGI("Jit Runtime: unchaining of hot"));
-                    elemSize = BYTES_OF_HOT_CHAINING;
-                    patchAddr = (u1 *)(*(int *)((char*)pChainCells + OFFSET_OF_PATCHADDR));
-                    ismove_flag = *(int *)((char*)pChainCells + OFFSET_OF_ISMOVEFLAG);
-                    if (patchAddr) {
-                        if (ismove_flag) {
-                            relativeNCG = (pChainCells - patchAddr) - BYTES_OF_32BITS;
-                            updateCodeCache(*(int*)patchAddr, relativeNCG);
-                        } else
-                            updateCodeCache(*(int*)patchAddr, (int)pChainCells);
-                    }
-                    break;
-                case kChainingCellInvokeSingleton:
-                    COMPILER_TRACE_CHAINING(
-                        ALOGI("Jit Runtime: unchaining of singleton"));
-                    elemSize = BYTES_OF_SINGLETON_CHAINING;
-                    patchAddr = (u1 *)(*(int *)((char*)pChainCells + OFFSET_OF_PATCHADDR));
-                    if (patchAddr)
-                        updateCodeCache(*(int*)patchAddr, (int)pChainCells);
-                    break;
-                case kChainingCellBackwardBranch:
-                    COMPILER_TRACE_CHAINING(
-                        ALOGI("Jit Runtime: unchaining of backward"));
-                    elemSize = BackwardBranchChainingCellContents::unchain (pChainCells);
-                    break;
-                case kChainingCellInvokePredicted:
-                    COMPILER_TRACE_CHAINING(
-                        ALOGI("Jit Runtime: unchaining of predicted"));
-                    //The cell is always 4-byte aligned so we need to take that
-                    //into account first
-                    padding = (4 - ((u4) pChainCells & 3)) & 3;
-                    pChainCells += padding;
-
-                    predChainCell = reinterpret_cast<PredictedChainingCell *> (
-                            pChainCells);
-                    /*
-                     * There could be a race on another mutator thread to use
-                     * this particular predicted cell and the check has passed
-                     * the clazz comparison. So we cannot safely wipe the
-                     * method and branch but it is safe to clear the clazz,
-                     * which serves as the key.
-                     */
-                    predChainCell->clazz = PREDICTED_CHAIN_CLAZZ_INIT;
-
-                    elemSize = sizeof(*predChainCell);
-                    break;
-                default:
-                    ALOGI("JIT_INFO: Unexpected chaining type: %d", i);
-                    //Error is beyond the scope of the x86 JIT back-end
-                    ALOGE("\t FATAL ERROR. ABORTING!");
-                    dvmAbort();  // dvmAbort OK here - can't safely recover
-            }
-            COMPILER_TRACE_CHAINING(
-                ALOGI("Jit Runtime: unchaining 0x%x", (int)pChainCells));
-            pChainCells += elemSize;  /* Advance by a fixed number of bytes */
-        }
-    }
-    return NULL;
-}
-
-/* Unchain all translation in the cache. */
-void dvmJitUnchainAll()
-{
-    ALOGV("Jit Runtime: unchaining all");
-    if (gDvmJit.pJitEntryTable != NULL) {
-        COMPILER_TRACE_CHAINING(ALOGI("Jit Runtime: unchaining all"));
-        dvmLockMutex(&gDvmJit.tableLock);
-
-        UNPROTECT_CODE_CACHE(gDvmJit.codeCache, gDvmJit.codeCacheByteUsed);
-
-        for (size_t i = 0; i < gDvmJit.jitTableSize; i++) {
-            if (gDvmJit.pJitEntryTable[i].dPC &&
-                !gDvmJit.pJitEntryTable[i].u.info.isMethodEntry &&
-                gDvmJit.pJitEntryTable[i].codeAddress) {
-                      dvmJitUnchain(gDvmJit.pJitEntryTable[i].codeAddress);
-            }
-        }
-
-        PROTECT_CODE_CACHE(gDvmJit.codeCache, gDvmJit.codeCacheByteUsed);
-
-        dvmUnlockMutex(&gDvmJit.tableLock);
-        gDvmJit.translationChains = 0;
-    }
-    gDvmJit.hasNewChain = false;
-}
-
-/* Chaining cell for code that may need warmup. */
-/* ARM assembly: ldr r0, [r6, #76] (why a single instruction to access member of glue structure?)
-                 blx r0
-                 data 0xb23a //bytecode address: 0x5115b23a
-                 data 0x5115
-   IA32 assembly:
-                  call imm32 //relative offset to dvmJitToInterpNormal
-                  rPC
-                  codePtr
-*/
-static int handleNormalChainingCell(CompilationUnit *cUnit, unsigned int offset, int blockId)
-{
-    ALOGV("In handleNormalChainingCell for method %s block %d BC offset %x NCG offset %x",
-          cUnit->method->name, blockId, offset, stream - streamMethodStart);
-    if(dump_x86_inst)
-        ALOGI("LOWER NormalChainingCell at offsetPC %x offsetNCG %x @%p",
-              offset, stream - streamMethodStart, stream);
-#ifndef WITH_SELF_VERIFICATION
-    call_dvmJitToInterpNormal();
-#else
-    call_dvmJitToInterpBackwardBranch();
-#endif
-    unsigned int *ptr = (unsigned int*)stream;
-    *ptr++ = (unsigned int)(cUnit->method->insns + offset);
-    char* codePtr = searchNCGWorklist(blockId);
-    *ptr++ = (unsigned int)codePtr;
-    stream = (char*)ptr;
-    return 0;
-}
-
-/*
- * Chaining cell for instructions that immediately following already translated
- * code.
-   IA32 assembly:
-                  call imm32 // relative offset to dvmJitToInterpNormal or dvmJitToInterpTraceSelect
-                  rPC
-                  codePtr
-                  ismove_flag
- */
-static int handleHotChainingCell(CompilationUnit *cUnit, unsigned int offset, int blockId)
-{
-    ALOGV("In handleHotChainingCell for method %s block %d BC offset %x NCG offset %x",
-          cUnit->method->name, blockId, offset, stream - streamMethodStart);
-    if(dump_x86_inst)
-        ALOGI("LOWER HotChainingCell at offsetPC %x offsetNCG %x @%p",
-              offset, stream - streamMethodStart, stream);
-
-    int ismove_flag = 0;
-    char* codePtr = searchChainingWorklist(blockId);
-    if (codePtr == NULL) {
-        codePtr = searchNCGWorklist(blockId);
-        if (codePtr) {
-            call_dvmJitToInterpNormal();
-            ismove_flag = 1;
-        }
-        else call_dvmJitToInterpTraceSelect();
-    }
-    else
-        call_dvmJitToInterpTraceSelect();
-    unsigned int *ptr = (unsigned int*)stream;
-    *ptr++ = (unsigned int)(cUnit->method->insns + offset);
-    *ptr++ = (unsigned int)codePtr;
-    *ptr++ = (unsigned int)ismove_flag;
-    stream = (char*)ptr;
-    return 0;
-}
-
-/**
- * @brief Generates code for backward branch chaining cell.
- * @param cUnit the compilation unit
- * @param chainingCell the chaining cell we are generating code for
- * @return true if chaining cell was successfully generated
- */
-static bool handleBackwardBranchChainingCell (CompilationUnit *cUnit,
-        BasicBlock_O1 *chainingCell)
-{
-    assert(chainingCell != 0);
-    assert(chainingCell->blockType == kChainingCellBackwardBranch);
-
-    //Get the loop entry
-    BasicBlock *loopEntry = chainingCell->fallThrough;
-
-    //Paranoid
-    assert(cUnit->loopInformation != 0);
-
-    //We want the loop header and preloop header
-    char *loopHeaderAddr = 0;
-    char *preLoopHeaderAddr = 0;
-
-    BasicBlock_O1 *bbO1 = reinterpret_cast<BasicBlock_O1 *> (loopEntry);
-    assert(bbO1 != 0);
-
-    //Set the loop header address
-    loopHeaderAddr = bbO1->streamStart;
-
-    //Get the associated loop information
-    LoopInformation *info = cUnit->loopInformation;
-
-    //But if info is 0, we might not have that and should just use the fallThrough's information
-    //This can happen if the user has used the old loop system, and should only happen then
-    if (info == 0)
-    {
-        //Then request the interpreter jump back to where the loop is
-        preLoopHeaderAddr = loopHeaderAddr;
-    }
-    else
-    {
-        //Get the right loop
-        info = info->getLoopInformationByEntry (loopEntry);
-
-        //Paranoid
-        if (info != 0)
-        {
-            //We have a preLoop
-            BasicBlock *preLoop = info->getPreHeader ();
-
-            //Paranoid
-            if (preLoop != 0)
-            {
-                bbO1 = reinterpret_cast<BasicBlock_O1 *> (preLoop);
-
-                //Paranoid
-                if (bbO1 != 0)
-                {
-                    preLoopHeaderAddr = bbO1->streamStart;
-                }
-            }
-        }
-    }
-
-    //If we cannot find these, then we have a problem
-    if (loopHeaderAddr == 0 || preLoopHeaderAddr == 0)
-    {
-        return false;
-    }
-
-    //Every backward branch chaining cell must have a prebackward
-    //predecessor. So we look for it.
-    if (chainingCell->predecessors == 0)
-    {
-        return false;
-    }
-
-    //Initialize iterator
-    BitVectorIterator bvIterator;
-    dvmBitVectorIteratorInit (chainingCell->predecessors, &bvIterator);
-
-    //Get the block index of predecessor
-    int blockIdx = dvmBitVectorIteratorNext (&bvIterator);
-
-    //Return false if we did not find predecessor
-    if (blockIdx == -1)
-    {
-        return false;
-    }
-
-    //Get the predecessor block
-    BasicBlock_O1 *preBackward =
-            reinterpret_cast<BasicBlock_O1 *> (dvmGrowableListGetElement (
-                    &cUnit->blockList, blockIdx));
-
-    //If it is not the right type then we return false
-    if (preBackward == 0 || preBackward->blockType != kPreBackwardBlock)
-    {
-        return false;
-    }
-
-    char *vrStoreCodePtr = preBackward->streamStart;
-
-    //We should have already generated code for the prebackward block
-    if (vrStoreCodePtr == 0)
-    {
-        return false;
-    }
-
-    //If scheduling is enabled, lets assert that queue is empty. Otherwise,
-    //it is not safe to use the stream pointer.
-    if (gDvmJit.scheduling)
-    {
-        //Using stream pointer is not safe unless scheduler queue is empty.
-        //We should never get here with anything in queue.
-        if (singletonPtr<Scheduler>()->isQueueEmpty() == false)
-        {
-            return false;
-        }
-    }
-
-    //At this point we have tried gathering all information we could so we
-    //ready to generate the chaining cell
-    if (cUnit->printMe)
-    {
-        ALOGI("LOWER BackwardBranchChainingCell with offsetPC %x @%p",
-                chainingCell->startOffset, stream);
-    }
-
-    BackwardBranchChainingCellContents *backwardContents =
-            reinterpret_cast<BackwardBranchChainingCellContents *> (stream);
-
-    //Generate the call to interpreter
-    call_dvmJitToInterpBackwardBranch ();
-
-    //Paranoid, we want to make sure that chaining cell has enough room
-    //for the call instruction
-    assert((reinterpret_cast<int>(stream) - reinterpret_cast<int>(backwardContents))
-            == sizeof(backwardContents->instructionHolder));
-
-    //Find the jump that goes to the prebackward block
-    char *codePtr = searchNCGWorklist (preBackward->id);
-
-    //If we cannot find this jump, something went wrong
-    if (codePtr == 0)
-    {
-        return false;
-    }
-
-    //Now write the data into the chaining cell
-    backwardContents->nextPC =
-            reinterpret_cast<unsigned int> (cUnit->method->insns
-                    + chainingCell->startOffset);
-    backwardContents->codePtr = codePtr;
-    backwardContents->loopHeaderAddr = loopHeaderAddr;
-    backwardContents->vrWriteBackAddr = vrStoreCodePtr;
-    backwardContents->loopPreHeaderAddr = preLoopHeaderAddr;
-
-    //Update stream pointer
-    stream = reinterpret_cast<char *> (backwardContents)
-            + sizeof(*backwardContents);
-
-    //We have successfully generated the chaining cell
-    return true;
-}
-
-/* Chaining cell for monomorphic method invocations.
-   IA32 assembly:
-                  call imm32 // relative offset to dvmJitToInterpTraceSelect
-                  rPC
-                  codePtr
-*/
-static int handleInvokeSingletonChainingCell(CompilationUnit *cUnit,
-                                              const Method *callee, int blockId)
-{
-    ALOGV("In handleInvokeSingletonChainingCell for method %s block %d callee %s NCG offset %x",
-          cUnit->method->name, blockId, callee->name, stream - streamMethodStart);
-    if(dump_x86_inst)
-        ALOGI("LOWER InvokeSingletonChainingCell at block %d offsetNCG %x @%p",
-              blockId, stream - streamMethodStart, stream);
-
-    call_dvmJitToInterpTraceSelect();
-    unsigned int *ptr = (unsigned int*)stream;
-    *ptr++ = (unsigned int)(callee->insns);
-    char* codePtr = searchChainingWorklist(blockId);
-    *ptr++ = (unsigned int)codePtr;
-    stream = (char*)ptr;
-    return 0;
-}
-
-/**
- * @brief Generates code for predicted chaining cell.
- * @details This chaining cell is used for polymorphic invocations.
- * @param cUnit the compilation unit
- * @param chainingCell the chaining cell we are generating code for
- * @return true if chaining cell was successfully generated
- */
-static bool handleInvokePredictedChainingCell (CompilationUnit *cUnit,
-        BasicBlock_O1 *chainingCell)
-{
-    if(cUnit->printMe)
-    {
-        ALOGI("LOWER InvokePredictedChainingCell (block %d) @%p",
-                chainingCell->id, stream);
-    }
-
-#ifdef PREDICTED_CHAINING
-
-    //Because we will be patching this at runtime, we want to make sure that
-    //the chaining cell is 4 byte aligned. Since every field of the chaining
-    //cell is 4 byte wide, this will ensure atomic updates since the cell
-    //won't be split across cache line.
-    int padding = (4 - ((u4) stream & 3)) & 3;
-    stream += padding;
-
-    //Since we are aligning, we should also update the offset so anyone using
-    //it accesses the correct data.
-    chainingCell->label->lop.generic.offset += padding;
-
-    PredictedChainingCell *predictedContents =
-            reinterpret_cast<PredictedChainingCell *> (stream);
-
-    //Now initialize the data using the predefined macros for initialization
-    predictedContents->branch = PREDICTED_CHAIN_BX_PAIR_INIT;
-    predictedContents->branch2 = 0;
-    predictedContents->clazz = PREDICTED_CHAIN_CLAZZ_INIT;
-    predictedContents->method = PREDICTED_CHAIN_METHOD_INIT;
-    predictedContents->stagedClazz = PREDICTED_CHAIN_COUNTER_INIT;
-
-    //Update stream pointer
-    stream = reinterpret_cast<char *> (predictedContents)
-            + sizeof(*predictedContents);
-
-#else
-    //assume rPC for callee->insns in %ebx
-    scratchRegs[0] = PhysicalReg_EAX;
-#if defined(WITH_JIT_TUNING)
-    /* Predicted chaining is not enabled. Fall back to interpreter and
-     * indicate that predicted chaining was not done.
-     */
-    move_imm_to_reg(OpndSize_32, kInlineCacheMiss, PhysicalReg_EDX, true);
-#endif
-    call_dvmJitToInterpTraceSelectNoChain();
-#endif
-
-    //We have successfully generated the chaining cell
-    return true;
-}
-
-/**
- * @brief Used to handle semantics of extended MIRs, including possibly generating native code.
- * @param cUnit The compilation unit
- * @param bb The basic block containing the MIR
- * @param mir The extended instruction
- * @return Returns whether or not it successfully handled the extended MIR
- */
-bool handleExtendedMIR (CompilationUnit *cUnit, BasicBlock_O1 *bb, MIR *mir)
-{
-    if (cUnit->printMe == true)
-    {
-        char * decodedString = dvmCompilerGetDalvikDisassembly(&mir->dalvikInsn,
-                NULL);
-        ALOGI("LOWER %s @%p\n", decodedString, stream);
-    }
-
-    //Eagerly assume that we will be able to handle it
-    bool result = true;
-
-    ExecutionMode origMode = gDvm.executionMode;
-    gDvm.executionMode = kExecutionModeNcgO0;
-    switch ((ExtendedMIROpcode)mir->dalvikInsn.opcode) {
-        case kMirOpPhi: {
-            break;
-        }
-        case kMirOpNullCheck: {
-            genHoistedNullCheck (cUnit, mir);
-            break;
-        }
-        case kMirOpBoundCheck: {
-            genHoistedBoundCheck (cUnit, mir);
-            break;
-        }
-        case kMirOpNullNRangeUpCheck: {
-            genHoistedChecksForCountUpLoop(cUnit, mir);
-            break;
-        }
-        case kMirOpNullNRangeDownCheck: {
-            genHoistedChecksForCountDownLoop(cUnit, mir);
-            break;
-        }
-        case kMirOpLowerBound: {
-            genHoistedLowerBoundCheck(cUnit, mir);
-            break;
-        }
-        case kMirOpPunt: {
-            break;
-        }
-        case kMirOpRegisterize: {
-            gDvm.executionMode = origMode;
-            result = genRegisterize (cUnit, bb, mir);
-            break;
-        }
-#ifdef WITH_JIT_INLINING_PHASE2
-        case kMirOpCheckInlinePrediction: { //handled in ncg_o1_data.c
-            genValidationForPredictedInline(cUnit, mir);
-            break;
-        }
-#endif
-        default:
-        {
-            char * decodedString = dvmCompilerGetDalvikDisassembly(&mir->dalvikInsn, NULL);
-            ALOGD ("JIT_INFO: No logic to handle extended MIR %s", decodedString);
-            result = false;
-            break;
-        }
-    }
-    gDvm.executionMode = origMode;
-
-    return result;
-}
-
-#define PRINT_BUFFER_LEN 1024
-/* Print the code block in code cache in the range of [startAddr, endAddr)
- * in readable format.
- */
-void printEmittedCodeBlock(unsigned char *startAddr, unsigned char *endAddr)
-{
-    char strbuf[PRINT_BUFFER_LEN];
-    unsigned char *addr;
-    unsigned char *next_addr;
-    int n;
-
-    static const unsigned char nops[10][9] = {
-        { 0, },                                                     // 0, this line is dummy and not used in the loop below
-        { 0x90, },                                                  // 1-byte NOP
-        { 0x66, 0x90, },                                            // 2
-        { 0x0F, 0x1F, 0x00, },                                      // 3
-        { 0x0F, 0x1F, 0x40, 0x00, },                                // 4
-        { 0x0F, 0x1F, 0x44, 0x00, 0x00, },                          // 5
-        { 0x66, 0x0F, 0x1F, 0x44, 0x00, 0x00, },                    // 6
-        { 0x0F, 0x1F, 0x80, 0x00, 0x00, 0x00, 0x00, },              // 7
-        { 0x0F, 0x1F, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00, },        // 8
-        { 0x66, 0x0F, 0x1F, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00 },   // 9-byte NOP
-    };
-    int nopSize;
-    int pos;
-
-    if (gDvmJit.printBinary) {
-        // print binary in bytes
-        n = 0;
-        for (addr = startAddr; addr < endAddr; addr++) {
-            n += snprintf(&strbuf[n], PRINT_BUFFER_LEN-n, "0x%x, ", *addr);
-            if (n > PRINT_BUFFER_LEN - 10) {
-                ALOGD("## %s", strbuf);
-                n = 0;
-            }
-        }
-        if (n > 0)
-            ALOGD("## %s", strbuf);
-    }
-
-    // print disassembled instructions
-    addr = startAddr;
-    while (addr < endAddr) {
-        next_addr = reinterpret_cast<unsigned char*>
-            (decoder_disassemble_instr(reinterpret_cast<char*>(addr),
-                                       strbuf, PRINT_BUFFER_LEN));
-        if (addr != next_addr) {
-            ALOGD("**  %p: %s", addr, strbuf);
-        } else {
-            for (nopSize = 1; nopSize < 10; nopSize++) {
-                for (pos = 0; pos < nopSize; pos++) {
-                    if (addr[pos] != nops[nopSize][pos])
-                        break;
-                }
-                if (pos == nopSize) {
-                    ALOGD("**  %p: NOP (%d byte)", addr, nopSize);
-                    next_addr += nopSize;
-                    break;
-                }
-            }
-            if (nopSize == 10) {
-                ALOGD("** unable to decode binary at %p", addr);
-                break;
-            }
-        }
-        addr = next_addr;
-    }
-}
-
-/**
- * @brief Print the content of chaining cell block in code cache to LOG.
- * @param startAddr - starting address of the chaining cell block in code cache
- * @param blockType - chaining cell block type
- */
-static void printChainingCellBlocks(char *startAddr, BBType blockType)
-{
-    unsigned int *ui_ptr;
-
-    if (startAddr == 0 || blockType >= kChainingCellGap) {
-        return;
-    }
-
-    // Chaining cell block starts with a 5B "call rel32" at [startAddr, ui_ptr).
-    ui_ptr = (unsigned int *) ((unsigned char *)(startAddr+5));
-
-    switch (blockType) {
-        case kChainingCellNormal:
-            ALOGD("** // Normal Chaining Cell");
-            printEmittedCodeBlock((unsigned char *) startAddr, (unsigned char *) ui_ptr);
-            ALOGD("**  %p: %#x \t// next bytecode PC", (void*)ui_ptr, *ui_ptr);
-            ui_ptr++;
-            ALOGD("**  %p: %#x \t// code address to be patched", (void*)ui_ptr, *ui_ptr);
-            break;
-
-        case kChainingCellInvokeSingleton:
-            ALOGD("** // InvokeSingleton Chaining Cell");
-            printEmittedCodeBlock((unsigned char *) startAddr, (unsigned char *) ui_ptr);
-            ALOGD("**  %p: %#x \t// next bytecode PC", (void*)ui_ptr, *ui_ptr);
-            ui_ptr++;
-            ALOGD("**  %p: %#x \t// code address to be patched", (void*)ui_ptr, *ui_ptr);
-            break;
-
-        case kChainingCellHot:
-            ALOGD("** // Hot Chaining Cell");
-            printEmittedCodeBlock((unsigned char *) startAddr, (unsigned char *) ui_ptr);
-            ALOGD("**  %p: %#x \t// next bytecode PC", (void*)ui_ptr, *ui_ptr);
-            ui_ptr++;
-            ALOGD("**  %p: %#x \t// code address to be patched", (void*)ui_ptr, *ui_ptr);
-            ui_ptr++;
-            ALOGD("**  %p: %d   \t// above needs an IP-relative offset", (void*)ui_ptr, *ui_ptr);
-            break;
-
-        case kChainingCellBackwardBranch:
-            ALOGD("** // BackwardBranch Chaining Cell");
-            printEmittedCodeBlock((unsigned char *) startAddr, (unsigned char *) ui_ptr);
-            ALOGD("**  %p: %#x \t// next bytecode PC", (void*)ui_ptr, *ui_ptr);
-            ui_ptr++;
-            ALOGD("**  %p: %#x \t// code address to be patched", (void*)ui_ptr, *ui_ptr);
-            ui_ptr++;
-            ALOGD("**  %p: %#x \t// address of loop header block", (void*)ui_ptr, *ui_ptr);
-            ui_ptr++;
-            ALOGD("**  %p: %#x \t// address of VR write-back block", (void*)ui_ptr, *ui_ptr);
-            ui_ptr++;
-            ALOGD("**  %p: %#x \t// address of loop pre-header block", (void*)ui_ptr, *ui_ptr);
-            break;
-
-        case kChainingCellInvokePredicted:
-            ui_ptr = (unsigned int *) startAddr;
-            ALOGD("** // InvokePredicted Chaining Cell: %p",
-                  (void*) startAddr);
-            ALOGD("**  %p: %#x \t// to be patched", (void*)ui_ptr, *ui_ptr);
-            ui_ptr++;
-            ALOGD("**  %p: %#x \t// to be patched", (void*)ui_ptr, *ui_ptr);
-            ui_ptr++;
-            ALOGD("**  %p: %#x \t// class", (void*)ui_ptr, *ui_ptr);
-            ui_ptr++;
-            ALOGD("**  %p: %#x \t// method", (void*)ui_ptr, *ui_ptr);
-            ui_ptr++;
-            ALOGD("**  %p: %#x \t// rechain count", (void*)ui_ptr, *ui_ptr);
-            break;
-
-        default:
-            ALOGD("printChainingCellBlocks: Unknown chaining cell type %u!",
-                  blockType);
-            break;      // Not yet supported! Do nothing.
-    }
-}
-
-/**
- * @brief Print the content of the content of a trace to LOG.
- * @param cUnit - pointer to the CompilationUnit
- * @param code_block_table - reference to the code block table for code/data section addresses
- * @param chainCellCounts - reference to the ChainCellCounts table
- * @param wide_const_count - number of long/double constants in the constant section
- * @param pCCOffsetSection - pointer to the chaining cell offset header
- */
-typedef std::pair<BBType, char*> CodeBlockElem;
-static void printTrace(CompilationUnit *cUnit, std::vector<CodeBlockElem> &code_block_table,
-                       ChainCellCounts &chainCellCounts, int wide_const_count, u2* pCCOffsetSection)
-{
-    char *code_ptr, *next_code_ptr = 0;
-    BBType blk_type;
-    int k;
-
-    ALOGD("-------- Emit trace for [%s%s@%#x] binary code starts at %p (cache start %p)",
-          cUnit->method->clazz->descriptor, cUnit->method->name,
-          cUnit->traceDesc->trace[0].info.frag.startOffset,
-          cUnit->baseAddr, gDvmJit.codeCache);
-    ALOGD("** %s%s@%#x:", cUnit->method->clazz->descriptor,
-          cUnit->method->name, cUnit->traceDesc->trace[0].info.frag.startOffset);
-
-    code_ptr = NULL;
-    next_code_ptr = NULL;
-    for (k = 0; k < (code_block_table.size() - 1); k++) {
-        blk_type = code_block_table[k].first;
-        code_ptr = code_block_table[k].second;
-        next_code_ptr = code_block_table[k+1].second;
-
-        switch (blk_type) {
-        case kExceptionHandling:
-            if (code_ptr < next_code_ptr) {
-                ALOGD("** // exception handling VR restores");
-                // print like a normal code block
-                printEmittedCodeBlock((unsigned char *) code_ptr,
-                                      (unsigned char *) next_code_ptr);
-            }
-            break;
-
-        case kDalvikByteCode:
-            if (code_ptr < next_code_ptr) {
-                printEmittedCodeBlock((unsigned char *) code_ptr,
-                                      (unsigned char *) next_code_ptr);
-            }
-            break;
-
-        case kChainingCellNormal:
-        case kChainingCellHot:
-        case kChainingCellInvokeSingleton:
-        case kChainingCellInvokePredicted:
-        case kChainingCellBackwardBranch:
-            printChainingCellBlocks(code_ptr, blk_type);
-            break;
-
-        default:          // no print for other block types
-            break;
-        }
-    }
-
-    if (next_code_ptr == NULL) {
-        // simply return if there is no entry in code block
-        return;
-    }
-
-    // next_code_ptr should hold the pre-padded address of the chaining cell count section
-    // print the chaining cell count section
-    next_code_ptr = reinterpret_cast<char*>((reinterpret_cast<unsigned int>(next_code_ptr) + 3) & ~0x3);
-    ALOGD("** // chaining cell counts section (4B aligned)");
-    for (k=0; k< kChainingCellGap; k++) {
-        ALOGD("**  %p: %u", (void*) next_code_ptr, chainCellCounts.u.count[k]);
-        next_code_ptr += sizeof(chainCellCounts.u.count[k]);
-    }
-
-    // print the long/double constant section if any
-    if (wide_const_count > 0) {
-        long long *llptr;
-        double *dblptr;
-        ALOGD("** // long/double constant section (16B aligned)");
-        next_code_ptr = reinterpret_cast<char*>((reinterpret_cast<unsigned int>(next_code_ptr) + 0xF) & ~0xF);
-        llptr = (long long *) next_code_ptr;
-        for (k=0; k<wide_const_count; k++) {
-            dblptr = (double *) llptr;
-            ALOGD("**  %p: %lld (%g)", llptr, *llptr, *dblptr);
-            llptr++;        // increases pointer by 8B
-        }
-    }
-
-    // print the chaining cell offset header content
-    ALOGD("** // Patched (offset to chaining cell counts)@%p = %#x",
-          (void*)pCCOffsetSection, *pCCOffsetSection);
-    ALOGD("** // Patched (offset to chaining cell blocks)@%p = %#x",
-          (void*)&pCCOffsetSection[1], pCCOffsetSection[1]);
-}
-
-/**
- * @brief Handle fallthrough branch: determine whether we need one or not
- * @param cUnit the CompilationUnit
- * @param bb the BasicBlock
- * @param ptrNextFallThrough pointer to the nextFallThrough if requested (can be 0)
- */
-static void handleFallThroughBranch (CompilationUnit *cUnit, BasicBlock *bb, BasicBlock **ptrNextFallThrough)
-{
-    //Get next fall through
-    BasicBlock *nextFallThrough = *ptrNextFallThrough;
-
-    //Check if the jump needs alignment. If it needs alignment it means it will be patched at runtime
-    //and thus we cannot skip generating this jump
-    bool jumpNeedsAlignment = false;
-    if (nextFallThrough != 0)
-    {
-        jumpNeedsAlignment = doesJumpToBBNeedAlignment (nextFallThrough);
-    }
-
-    //We need a fallthrough branch if we had a next and it isn't the current BasicBlock or jump is needed
-    bool needFallThroughBranch = (nextFallThrough != 0 && (jumpNeedsAlignment == true || bb != nextFallThrough));
-
-    if (needFallThroughBranch == true)
-    {
-        //Generate the jump now
-        jumpToBasicBlock (stream, nextFallThrough->id, jumpNeedsAlignment);
-    }
-
-    //Clear it
-    *ptrNextFallThrough = 0;
-}
-
-/**
- * @brief Create a new record of 64bit constant in use
- * @details Allocates memory to store a 64bit constant and its details. All address fields
- *          are initialized to NULL.
- * @param listPtr address of the constList
- * @param constL the lower 32bits
- * @param constH the higher 32bits
- * @param reg Virtual Register number
- * @param align Align to 16 bytes
- */
-void addNewToConstList(struct ConstInfo** listPtr, int constL, int constH, int reg, bool align) {
-    struct ConstInfo* tmpPtr =static_cast<ConstInfo *>(dvmCompilerNew(sizeof(ConstInfo), false));
-    tmpPtr->valueL = constL;
-    tmpPtr->valueH = constH;
-    tmpPtr->regNum = reg;
-    tmpPtr->offsetAddr = 0;
-    tmpPtr->streamAddr = NULL;
-    tmpPtr->constAddr = NULL;
-    tmpPtr->constAlign = align;
-    tmpPtr->next = *listPtr;
-    *listPtr = tmpPtr;
-    assert(*listPtr != NULL);
-}
-
-/**
- * @brief Save address of memory access into constList
- * @details Populates stream information
- * @param listPtr address of the constList
- * @param constL the lower 32bits
- * @param constH the higher 32bits
- * @param reg Virtual Register number
- * @param patchAddr The address of memory location to be patched currently
- * @param offset the offset where to save the constant
- * @return true when it succeeds, false when it fails
- */
-bool saveAddrToConstList(struct ConstInfo** listPtr, int constL, int constH, int reg, char* patchAddr, int offset) {
-    struct ConstInfo* tmpPtr = *listPtr;
-    while (tmpPtr != NULL) {                // check all elements of the structure
-        if (tmpPtr->valueL == constL && tmpPtr->valueH == constH && tmpPtr->regNum == reg && tmpPtr->streamAddr==NULL) {
-            tmpPtr->streamAddr = patchAddr; // save address of instruction in jit stream
-            tmpPtr->offsetAddr = offset;    // save offset to memory location to patch for the instruction
-#ifdef DEBUG_CONST
-            ALOGD("**Save constants for VR# %d containing constant (%x):(%x) streamAddr is (%d)%x, offset %d",
-                             tmpPtr->regNum, tmpPtr->valueL, tmpPtr->valueH,
-                             tmpPtr->streamAddr, tmpPtr->streamAddr, tmpPtr->offsetAddr);
-#endif
-            return true;
-        }
-        tmpPtr = tmpPtr->next; // check next element
-    }
-    return false;
-}
-
-/**
- * @brief insert 64bit constants in a Constant Data Section at end of a trace
- * @details Populates stream information
- * @param constListTemp pointer to list of 64 bit constants
- * @param stream pointer to jit code
- * @return the updated value of stream
- */
-char* insertConstDataSection(struct ConstInfo *constListTemp,  char * stream) {
-    unsigned int *intaddr = reinterpret_cast<unsigned int *>(stream);
-    while(constListTemp != NULL){
-
-        /* Align trace to 16-bytes before Constant Data Section */
-        if (constListTemp->constAlign == true) {
-            stream = (char*)(((unsigned int)stream + 0xF) & ~0xF);
-        }
-        constListTemp->constAddr = stream;
-        intaddr = reinterpret_cast<unsigned int *>(stream);
-        *intaddr = constListTemp->valueL;    // store lower 32 bit of a constant
-#ifdef DEBUG_CONST
-        ALOGI("**Lower constants at  %p: %d(%x), VR# %d containing constant (%x):(%x) constAddr is %p",
-                             intaddr, *intaddr, *intaddr, constListTemp->regNum, constListTemp->valueL, constListTemp->valueH,
-                             *intaddr, constListTemp->constAddr);
-#endif
-        intaddr++;
-        *intaddr = constListTemp->valueH;    // store higher 32 bits of a constant
-        intaddr++;
-        stream = reinterpret_cast<char *>(intaddr);
-        constListTemp = constListTemp->next; // move to next constant in list
-    }
-    return stream;
-}
-
-/**
- * @brief patch stream with address of constants in Constant Data Section
- * @details lowers address of constant if placeholder data is found
- * @param constListTemp pointer to list of 64 bit constants
- * @param cUnit the compilation unit
- * @return returns -1 if error, else reports number of patches
- */
-int patchConstToStream(struct ConstInfo *constListTemp, CompilationUnit *cUnit) {
-    unsigned int *writeval;
-    char *iaddr;
-    int pResult = 0;
-
-    while (constListTemp != NULL){
-        /* iterate through the generated code to patch constants */
-        iaddr = static_cast<char*>(constListTemp->streamAddr+constListTemp->offsetAddr);
-
-        writeval = reinterpret_cast<unsigned int*>(iaddr);
-        unsigned int dispAddr =  getGlobalDataAddr("64bits");
-
-        if (*writeval == dispAddr){ /* verify that place holder data inserted is present */
-            *writeval = reinterpret_cast<unsigned int>(constListTemp->constAddr);
-#ifdef DEBUG_CONST
-            ALOGI("Patched location of VR# %d with constant (%x):(%x)",
-                            constListTemp->regNum, constListTemp->valueL, constListTemp->valueH);
-            ALOGI("Address is streamAddr %p,  offset %d with constAddr %p",
-                       constListTemp->streamAddr, constListTemp->offsetAddr, constListTemp->constAddr);
-#endif
-            pResult++;              /* keep count of successful patches in stream */
-        } else {
-            ALOGI("JIT_INFO: Error Wrong value found at streamAddr");
-#ifdef DEBUG_CONST
-            ALOGI("Tried patching VR# %d with constant (%x):(%x)",
-                            constListTemp->regNum, constListTemp->valueL, constListTemp->valueH);
-            ALOGI("Address is streamAddr %p, offset %d with constAddr %p",
-                    constListTemp->streamAddr, constListTemp->offsetAddr, constListTemp->constAddr);
-#endif
-            ALOGI("JIT_INFO: Constant init opt could not patch all required locations");
-            SET_JIT_ERROR(kJitErrorConstInitFail);
-            cUnit->constListHead = NULL;
-            return -1;              /* incorrect data found at patch location, reject trace */
-        }
-        constListTemp = constListTemp->next;
-    }
-    return pResult;
-}
-
-/**
- * @brief Generate the code for the BasicBlock
- * @param cUnit the CompilationUnit
- * @param bb the BasicBlock
- * @param nextFallThrough a pointer to the next fall through BasicBlock
- * @return whether the generation went well
- */
-static bool generateCode (CompilationUnit *cUnit, BasicBlock *bb, BasicBlock **nextFallThrough)
-{
-    ALOGV("Get ready to handle JIT bb %d type %d hidden %d @%p",
-            bb->id, bb->blockType, bb->hidden, stream);
-
-    /* We want to update the stream start to remember it for future backward chaining cells */
-    BasicBlock_O1 *bbO1 = reinterpret_cast<BasicBlock_O1 *> (bb);
-    assert (bbO1 != 0);
-    bbO1->streamStart = stream;
-
-#ifdef WITH_JIT_TPROFILE
-    //Generate the loop counter profile code for loop
-    genLoopCounterProfileCode(cUnit, bbO1);
-#endif
-    //Generate the code
-    startOfBasicBlock(bb);
-    int cg_ret = codeGenBasicBlockJit(cUnit->method, bb);
-    endOfBasicBlock(bb);
-
-    //Error handling, we return false
-    if(cg_ret < 0 || IS_ANY_JIT_ERROR_SET()) {
-        ALOGI("Could not compile trace for %s%s, offset %d",
-                cUnit->method->clazz->descriptor, cUnit->method->name,
-                cUnit->traceDesc->trace[0].info.frag.startOffset);
-        SET_JIT_ERROR(kJitErrorCodegen);
-        endOfTrace (cUnit);
-        PROTECT_CODE_CACHE(stream, unprotected_code_cache_bytes);
-        return false;
-    }
-
-    //Register next fall through
-    *nextFallThrough = bb->fallThrough;
-
-    //Everything went fine
-    return true;
-}
-
-//! \brief Lower middle-level IR ro low-level IR
-//!
-//! \details Entry function to invoke the backend of the JIT compiler
-//!
-//! \param cUnit: The current compilation unit
-//! \param info: JitTranslationInfo. Holds generated code address on success
-static void compilerMIR2LIRJit(CompilationUnit_O1 *cUnit, JitTranslationInfo *info)
-{
-    //Used to determine whether we need a fallthrough jump
-    BasicBlock *nextFallThrough = 0;
-    // Define the code_block_table for tracking various type of code blocks
-    //  for printing.
-    // CodeBlockElem has a block type and the starting address of the block.
-    std::vector<CodeBlockElem> code_block_table;
-    char *print_stream_ptr = 0; // current block stream pointer
-
-    dump_x86_inst = cUnit->printMe;
-
-    GrowableList chainingListByType[kChainingCellLast];
-
-    unsigned int i, padding;
-
-    traceMode = cUnit->jitMode;
-
-    //Initialize the base address to null
-    cUnit->baseAddr = NULL;
-
-    /*
-     * Initialize various types chaining lists.
-     */
-    for (i = 0; i < kChainingCellLast; i++) {
-        dvmInitGrowableList(&chainingListByType[i], 2);
-    }
-
-    GrowableListIterator iterator;
-
-    //BasicBlock **blockList = cUnit->blockList;
-    GrowableList *blockList = &cUnit->blockList;
-    BasicBlock *bb;
-
-    info->codeAddress = NULL;
-    stream = (char*)gDvmJit.codeCache + gDvmJit.codeCacheByteUsed;
-
-    // TODO: compile into a temporary buffer and then copy into the code cache.
-    // That would let us leave the code cache unprotected for a shorter time.
-    size_t unprotected_code_cache_bytes =
-            gDvmJit.codeCacheSize - gDvmJit.codeCacheByteUsed - CODE_CACHE_PADDING;
-    UNPROTECT_CODE_CACHE(stream, unprotected_code_cache_bytes);
-    //Use the variable otherwise compiler warns about it
-    (void) unprotected_code_cache_bytes;
-
-    streamStart = stream; /* trace start before alignment */
-
-#if defined(WITH_JIT_TPROFILE)
-    /* Align stream's address end with 0100, this is to make sure the code start address align to 16-bytes after add the extra bytes */
-    stream = ((u4)stream & 0x7) < 4 ? (char*)(((unsigned int)stream + 0x4) & ~0x3) : (char*)(((unsigned int)stream + 0x8) & ~0x3);
-    stream += EXTRA_BYTES_FOR_LOOP_COUNT_ADDR; /*This is for the loop count's addr*/
-    stream += EXTRA_BYTES_FOR_PROF_ADDR; /* This is for the execution count's addr */
-
-    //zero the loop count address, so we can check if the trace is a loop
-    memset(stream - EXTRA_BYTES_FOR_LOOP_COUNT_ADDR - EXTRA_BYTES_FOR_PROF_ADDR, 0, EXTRA_BYTES_FOR_LOOP_COUNT_ADDR + EXTRA_BYTES_FOR_PROF_ADDR);
-#endif
-
-    stream += EXTRA_BYTES_FOR_CHAINING; /* This is needed for chaining. */
-    stream = (char*)(((unsigned int)stream + 0xF) & ~0xF); /* Align trace to 16-bytes */
-    streamMethodStart = stream; /* code start */
-
-    cUnit->exceptionBlockId = -1;
-    for (i = 0; i < blockList->numUsed; i++) {
-        bb = (BasicBlock *) blockList->elemList[i];
-        if(bb->blockType == kExceptionHandling)
-            cUnit->exceptionBlockId = i;
-    }
-    startOfTrace(cUnit->method, cUnit->exceptionBlockId, cUnit);
-
-    /* Traces start with a profiling entry point.  Generate it here */
-    cUnit->profileCodeSize = genTraceProfileEntry(cUnit);
-
-    cUnit->constListHead = NULL; // Initialize constant list
-
-    if(gDvm.executionMode == kExecutionModeNcgO1) {
-
-        //Go over the basic blocks of the compilation unit
-        dvmGrowableListIteratorInit(&cUnit->blockList, &iterator);
-        for (bb = (BasicBlock *) (dvmGrowableListIteratorNext(&iterator));
-                bb != NULL;
-                bb = (BasicBlock *) (dvmGrowableListIteratorNext(&iterator))) {
-
-            int retCode = preprocessingBB (cUnit, bb);
-
-            if (retCode < 0) {
-                endOfTrace (cUnit);
-                SET_JIT_ERROR(kJitErrorCodegen);
-                return;
-            }
-        }
-    }
-
-    dvmGrowableListIteratorInit(&cUnit->blockList, &iterator);
-
-    /* Handle the content in each basic block */
-    for (bb = (BasicBlock *) (dvmGrowableListIteratorNext (&iterator)),
-         i = 0;
-         //We stop when bb is 0
-         bb != 0;
-         //Induction variables: bb goes to next iterator, i is incremented
-         bb = (BasicBlock *) (dvmGrowableListIteratorNext (&iterator)),
-         i++) {
-
-        //Get O1 version
-        BasicBlock_O1 *bbO1 = reinterpret_cast<BasicBlock_O1 *> (bb);
-
-        //Paranoid
-        if (bbO1 == 0) {
-            continue;
-        }
-
-        //Switch depending on the BasicBlock type
-        switch (bbO1->blockType)
-        {
-            case kEntryBlock:
-                //The entry block should always be processed first because it is entry to trace
-                assert (i == 0);
-
-                //Intentional fallthrough because we handle it same way as an exit block
-            case kExitBlock:
-                //Only handle the fallthrough if there is an instruction
-                if (bbO1->firstMIRInsn != 0)
-                {
-                    //First handle fallthrough branch
-                    handleFallThroughBranch (cUnit, bbO1, &nextFallThrough);
-                }
-
-                //Set label offset
-                bbO1->label->lop.generic.offset = (stream - streamMethodStart);
-
-                if (generateCode (cUnit, bbO1, &nextFallThrough) == false)
-                {
-                    //Generate code set an error for the jit, we can just return
-                    return;
-                }
-                break;
-            case kDalvikByteCode:
-            case kPreBackwardBlock:
-                //If hidden, we don't generate code
-                if (bbO1->hidden == false)
-                {
-                    //First handle fallthrough branch
-                    handleFallThroughBranch (cUnit, bbO1, &nextFallThrough);
-
-                    //Set label offset
-                    bbO1->label->lop.generic.offset = (stream - streamMethodStart);
-
-                    if (generateCode (cUnit, bbO1, &nextFallThrough) == false)
-                    {
-                        //Generate code set an error for the jit, we can just return
-                        return;
-                    }
-                }
-                break;
-            case kChainingCellNormal:
-                /* Handle the codegen later */
-                dvmInsertGrowableList(&chainingListByType[kChainingCellNormal], i);
-                break;
-            case kChainingCellInvokeSingleton:
-                /* Handle the codegen later */
-                dvmInsertGrowableList (&chainingListByType[kChainingCellInvokeSingleton], i);
-                break;
-            case kChainingCellInvokePredicted:
-                /* Handle the codegen later */
-                dvmInsertGrowableList(&chainingListByType[kChainingCellInvokePredicted], i);
-                break;
-            case kChainingCellHot:
-                /* Handle the codegen later */
-                dvmInsertGrowableList(&chainingListByType[kChainingCellHot], i);
-                break;
-            case kExceptionHandling:
-                //First handle fallthrough branch
-                handleFallThroughBranch (cUnit, bbO1, &nextFallThrough);
-                bbO1->label->lop.generic.offset = (stream - streamMethodStart);
-                scratchRegs[0] = PhysicalReg_EAX;
-                jumpToInterpPunt();
-                break;
-            case kChainingCellBackwardBranch:
-                /* Handle the codegen later */
-                dvmInsertGrowableList(&chainingListByType[kChainingCellBackwardBranch], i);
-                break;
-            default:
-                break;
-            }
-        }
-
-    if (cUnit->printMe) {
-        // record all assmebly code before chaining cells as a block
-        CodeBlockElem code_blk_elem(kDalvikByteCode, streamMethodStart);
-        code_block_table.push_back(code_blk_elem);
-        print_stream_ptr = stream;
-    }
-
-    char* streamChainingStart = 0;
-    /* Handle the chaining cells in predefined order */
-
-    for (i = 0; i < kChainingCellGap; i++) {
-        size_t j;
-        cUnit->numChainingCells[i] = chainingListByType[i].numUsed;
-
-        /* No chaining cells of this type */
-        if (cUnit->numChainingCells[i] == 0)
-            continue;
-
-        //First handle fallthrough branch
-        handleFallThroughBranch (cUnit, 0, &nextFallThrough);
-
-        //If we haven't initialized the start of the chaining cells we do it now
-        if (streamChainingStart == 0)
-        {
-            //Stream has been updated because handleFallThroughBranch always generates jumps which
-            //forces scheduler to update the stream pointer. Thus we can use it here.
-            assert (singletonPtr<Scheduler>()->isQueueEmpty() == true);
-
-            //Initialize the beginning of the chaining cells
-            streamChainingStart = stream;
-        }
-
-        if (cUnit->printMe && print_stream_ptr < stream) {
-            // If there is any code before the chaining cell block and the
-            // last recorded block, make it a separate code block.
-            CodeBlockElem code_blk_elem(kDalvikByteCode, print_stream_ptr);
-            code_block_table.push_back(code_blk_elem);
-            print_stream_ptr = stream;
-        }
-
-        /* Record the first LIR for a new type of chaining cell */
-        for (j = 0; j < chainingListByType[i].numUsed; j++) {
-            int blockId = (int) dvmGrowableListGetElement (& (chainingListByType[i]), j);
-
-            BasicBlock *chainingBlock =
-                (BasicBlock *) dvmGrowableListGetElement(&cUnit->blockList,
-                                                         blockId);
-
-            //Get O1 version
-            BasicBlock_O1 *bbO1 = reinterpret_cast<BasicBlock_O1 *> (chainingBlock);
-
-            //Paranoid
-            if (bbO1 == 0) {
-                continue;
-            }
-
-            //Set offset
-            bbO1->label->lop.generic.offset = (stream - streamMethodStart);
-
-            //Eagerly assume we successfully generated chaining cell
-            bool success = true;
-
-            int nop_size;
-            switch (chainingBlock->blockType) {
-                case kChainingCellNormal:
-                    nop_size = handleNormalChainingCell(cUnit,
-                     chainingBlock->startOffset, blockId);
-                    bbO1->label->lop.generic.offset += nop_size; //skip over nop
-                    break;
-                case kChainingCellInvokeSingleton:
-                    nop_size = handleInvokeSingletonChainingCell(cUnit,
-                        chainingBlock->containingMethod, blockId);
-                    bbO1->label->lop.generic.offset += nop_size; //skip over nop
-                    break;
-                case kChainingCellInvokePredicted:
-                    success = handleInvokePredictedChainingCell (cUnit, bbO1);
-                    break;
-                case kChainingCellHot:
-                    nop_size = handleHotChainingCell(cUnit,
-                        chainingBlock->startOffset, blockId);
-                    bbO1->label->lop.generic.offset += nop_size; //skip over nop
-                    break;
-                case kChainingCellBackwardBranch:
-                    success = handleBackwardBranchChainingCell (cUnit, bbO1);
-                    break;
-                default:
-                    ALOGI("JIT_INFO: Bad blocktype %d", chainingBlock->blockType);
-                    SET_JIT_ERROR(kJitErrorTraceFormation);
-                    endOfTrace (cUnit);
-                    code_block_table.clear();
-                    return;
-            }
-
-            if (success == false)
-            {
-                SET_JIT_ERROR(kJitErrorChainingCell);
-                endOfTrace (cUnit);
-                return;
-            }
-
-            if (cUnit->printMe) {
-                // record the chaining cell block
-                CodeBlockElem code_blk_elem(chainingBlock->blockType, print_stream_ptr);
-                code_block_table.push_back(code_blk_elem);
-                print_stream_ptr = stream;
-            }
-
-            if (gDvmJit.codeCacheByteUsed + (stream - streamStart) + CODE_CACHE_PADDING > gDvmJit.codeCacheSize) {
-                ALOGI("JIT_INFO: Code cache full after ChainingCell (trace uses %uB)", (stream - streamStart));
-                SET_JIT_ERROR(kJitErrorCodeCacheFull);
-                gDvmJit.codeCacheFull = true;
-                endOfTrace (cUnit);
-                PROTECT_CODE_CACHE(stream, unprotected_code_cache_bytes);
-                code_block_table.clear();
-                return;
-            }
-        }
-    }
-
-    // Now that we finished handling all of the MIR BBs, we can dump all exception handling
-    // restore state to the code stream
-    singletonPtr<ExceptionHandlingRestoreState>()->dumpAllExceptionHandlingRestoreState();
-
-    //In case, handle fallthrough branch
-    handleFallThroughBranch (cUnit, 0, &nextFallThrough);
-
-    //Since we are at end of trace, we need to finish all work in the worklists
-    performWorklistWork ();
-
-    //We finished generating code for trace so we can signal end of trace now
-    endOfTrace (cUnit);
-
-    if (cUnit->printMe) {
-        // record exception VR restores as block type kExceptionHandling
-        CodeBlockElem code_blk_elem(kExceptionHandling, print_stream_ptr);
-        code_block_table.push_back(code_blk_elem);
-        print_stream_ptr = stream;
-    }
-
-    if (gDvmJit.codeCacheFull) {
-        // We hit code cache size limit either after dumping exception handling
-        // state or after calling endOfTrace. Bail out for this trace!
-        ALOGI("JIT_INFO: Code cache full after endOfTrace (trace uses %uB)", (stream - streamStart));
-        SET_JIT_ERROR(kJitErrorCodeCacheFull);
-        PROTECT_CODE_CACHE(stream, unprotected_code_cache_bytes);
-        code_block_table.clear();
-        return;
-    }
-
-    /* dump section for chaining cell counts, make sure it is 4-byte aligned */
-    padding = (4 - ((u4)stream & 3)) & 3;
-    stream += padding;
-    ChainCellCounts chainCellCounts;
-    /* Install the chaining cell counts */
-    for (i=0; i< kChainingCellGap; i++) {
-        chainCellCounts.u.count[i] = cUnit->numChainingCells[i];
-    }
-    char* streamCountStart = (char*)stream;
-    memcpy((char*)stream, &chainCellCounts, sizeof(chainCellCounts));
-    stream += sizeof(chainCellCounts);
-
-    cUnit->totalSize = (stream - streamStart);
-    if(gDvmJit.codeCacheByteUsed + cUnit->totalSize + CODE_CACHE_PADDING > gDvmJit.codeCacheSize) {
-        ALOGI("JIT_INFO: Code cache full after ChainingCellCounts (trace uses %uB)", (stream - streamStart));
-        SET_JIT_ERROR(kJitErrorCodeCacheFull);
-        gDvmJit.codeCacheFull = true;
-        PROTECT_CODE_CACHE(stream, unprotected_code_cache_bytes);
-        code_block_table.clear();
-        return;
-    }
-
-    /* write chaining cell count offset & chaining cell offset */
-    u2* pOffset = (u2*)(streamMethodStart - EXTRA_BYTES_FOR_CHAINING); /* space was already allocated for this purpose */
-    *pOffset = streamCountStart - streamMethodStart; /* from codeAddr */
-    pOffset[1] = streamChainingStart - streamMethodStart;
-
-#if defined(WITH_JIT_TPROFILE)
-    /* Install the trace description, so that we can retrieve the trace info from trace code addr later */
-    int descSize = (cUnit->jitMode == kJitMethod) ?
-        0 : getTraceDescriptionSize(cUnit->traceDesc);
-    memcpy((char*) stream, cUnit->traceDesc, descSize);
-    stream += descSize;
-    cUnit->totalSize = (stream - streamStart);
-
-    /* Check if the trace installation will cause the code cache full */
-    if(gDvmJit.codeCacheByteUsed + cUnit->totalSize + CODE_CACHE_PADDING > gDvmJit.codeCacheSize) {
-        ALOGI("JIT_INFO: Code cache full after Trace Description (trace uses %uB)", (stream - streamStart));
-        SET_JIT_ERROR(kJitErrorCodeCacheFull);
-        gDvmJit.codeCacheFull = true;
-        cUnit->baseAddr = NULL;
-        PROTECT_CODE_CACHE(stream, unprotected_code_cache_bytes);
-        return;
-    }
-#endif
-
-    PROTECT_CODE_CACHE(stream, unprotected_code_cache_bytes);
-
-    /* Align trace to 16-bytes before Constant Data Section */
-    stream = reinterpret_cast<char*>((reinterpret_cast<unsigned int>(stream) + 0xF) & ~0xF);
-    char * streamEnd = stream; // To store end of stream including constant data section
-
-    int patchCount = 0;       // Store number of constants initialized in a trace
-    ConstInfo *constListTemp; // Temp ptr for constant initialization
-
-    if(((gDvmJit.disableOpt & (1 << kElimConstInitOpt)) == false) && cUnit->constListHead != NULL ) {
-
-        constListTemp = cUnit->constListHead;
-        while(constListTemp != NULL){ // Find projected end of trace
-            streamEnd = (char*)(((unsigned int)streamEnd + 0xF));
-            constListTemp = constListTemp->next;
-        }
-
-        //  Sum of bytes used in code cache, constant data section should be lower than code cache size
-        if((gDvmJit.codeCacheByteUsed + (streamEnd - streamStart)) > gDvmJit.codeCacheSize) {
-            ALOGI("JIT_INFO: Code cache full after ChainingCellCounts and constant data section");
-            SET_JIT_ERROR(kJitErrorCodeCacheFull);
-            gDvmJit.codeCacheFull = true;
-            cUnit->baseAddr = NULL;
-            PROTECT_CODE_CACHE(stream, unprotected_code_cache_bytes);
-            return;
-        }
-
-        /* Insert constant data section at the end of a trace */
-        streamEnd = insertConstDataSection(cUnit->constListHead, stream);
-
-        /* Patch address of constants into stream */
-        constListTemp = cUnit->constListHead;
-        patchCount = patchConstToStream(constListTemp, cUnit);
-
-        if (patchCount < 0) {// if patchCount is less than 0, trigger error recovery
-            ALOGI("JIT_INFO: Constant init opt could not patch all required locations");
-            SET_JIT_ERROR(kJitErrorConstInitFail);
-            cUnit->baseAddr = NULL;
-            cUnit->constListHead = NULL;
-            return;
-        }
-    }
-
-    cUnit->constListHead = NULL;
-    cUnit->totalSize = (streamEnd - streamStart);  // store size of trace in cUnit->totalSize
-    gDvmJit.codeCacheByteUsed += cUnit->totalSize; // store code cache byte used to include the current trace
-
-    // Now print out the trace in code cache based on code_block_table
-    if (cUnit->printMe) {
-        // Push an kExitBlock block as an end marker of the trace.
-        // The chaining cell count and the long/double constants are
-        //  emit after the end marker.
-        CodeBlockElem code_blk_elem(kExitBlock, print_stream_ptr);
-        code_block_table.push_back(code_blk_elem);
-        printTrace(cUnit, code_block_table, chainCellCounts, patchCount, pOffset);
-    }
-    code_block_table.clear();
-    ALOGV("JIT CODE after trace %p to %p size %x START %p", streamMethodStart,
-          (char *) gDvmJit.codeCache + gDvmJit.codeCacheByteUsed,
-          cUnit->totalSize, gDvmJit.codeCache);
-
-    gDvmJit.numCompilations++;
-
-    //Update the base addr
-    cUnit->baseAddr = streamMethodStart;
-
-    info->codeAddress = (char*)cUnit->baseAddr;// + cUnit->headerSize;
-#if defined(WITH_JIT_TPROFILE)
-    info->profileCodeSize = cUnit->profileCodeSize;
-#endif
-}
-
-//! \brief Helper function to call compilerMIR2LIRJit
-//!
-//! \details Calls dvmCompilerMIR2LIRJit, checks for errors
-//! and retries if possible.
-//!
-//! \param cUnit: The current compilation unit
-//! \param info: JitTranslationInfo.
-void dvmCompilerMIR2LIR(CompilationUnit *cUnit, JitTranslationInfo *info) {
-
-    //Make a x86 version of our CompilationUnit
-    CompilationUnit_O1 &x86CUnit = *static_cast<CompilationUnit_O1*>(cUnit);
-
-   //Save the optimization state to restore it at the end of this compilation
-   SErrorCompilationState compilationState;
-   dvmSaveOptimizationState (compilationState);
-
-   //Start the counter
-   int numTries = 0;
-   bool isLastAttempt = false;
-
-   //Try to lower MIR
-   do {
-        //See if we have been here too many times:
-        if (numTries > MAX_RETRIES) {
-
-            //Abort if the flag is set.
-            if (gDvmJit.abortOnCompilerError == true) {
-                ALOGE("Too many retries for trace  %s%s, offset %d", cUnit->method->clazz->descriptor,
-                        cUnit->method->name, cUnit->traceDesc->trace[0].info.frag.startOffset);
-
-                //This will cause a full abort due to the flag
-                dvmCompilerAbort(cUnit);
-            }
-
-            ALOGD("Too many retries while compiling trace  %s%s, offset %d", cUnit->method->clazz->descriptor,
-                    cUnit->method->name, cUnit->traceDesc->trace[0].info.frag.startOffset);
-            ALOGD("Rejecting Trace");
-
-            //Restore the compilation state
-            dvmRestoreCompilationState (compilationState);
-            //Make sure 'NULL' will be returned as compilation result
-            cUnit->baseAddr = NULL;
-            info->codeAddress = NULL;
-            return;
-        }
-
-        //Ignore errors in previous compilations
-        CLEAR_ALL_JIT_ERRORS();
-
-        //Do the trace compilation
-        numTries++;
-        compilerMIR2LIRJit(&x86CUnit, info);
-
-        //Once done, see if errors happened, and if so
-        //see if we can retry and come back
-        isLastAttempt = numTries == MAX_RETRIES;
-    } while (IS_ANY_JIT_ERROR_SET() && dvmCanFixErrorsAndRetry(&x86CUnit, isLastAttempt));
-
-   //Restore the compilation state
-   dvmRestoreCompilationState (compilationState);
-}
-
-
-/*
- * Perform translation chain operation.
- */
-void* dvmJitChain(void* tgtAddr, u4* branchAddr)
-{
-#ifdef JIT_CHAIN
-    int relOffset;
-
-    if ((gDvmJit.pProfTable != NULL) && (gDvm.sumThreadSuspendCount == 0) &&
-        (gDvmJit.codeCacheFull == false)) {
-
-        UNPROTECT_CODE_CACHE(branchAddr, sizeof(int));
-        gDvmJit.translationChains++;
-        UPDATE_CODE_CACHE_PATCHES();
-
-        relOffset = (int) tgtAddr - (int)branchAddr - 4; // 32bit offset
-
-        updateCodeCache(*(int*)branchAddr, relOffset);
-
-        gDvmJit.hasNewChain = true;
-
-        PROTECT_CODE_CACHE(branchAddr, sizeof(int));
-        COMPILER_TRACE_CHAINING(
-            ALOGI("Jit Runtime: chaining 0x%x to %p with relOffset %x",
-                  (int) branchAddr, tgtAddr, relOffset));
-    }
-#endif
-    return tgtAddr;
-}
-
-/*
- * Perform chaining operation. Patched branchAddr using static address tgtAddr
- */
-void* dvmJitChain_staticAddr(void* tgtAddr, u4* branchAddr)
-{
-#ifdef JIT_CHAIN
-    if ((gDvmJit.pProfTable != NULL) && (gDvm.sumThreadSuspendCount == 0) &&
-        (gDvmJit.codeCacheFull == false)) {
-
-        UNPROTECT_CODE_CACHE(branchAddr, sizeof(int));
-        gDvmJit.translationChains++;
-        UPDATE_CODE_CACHE_PATCHES();
-
-        updateCodeCache(*(int*)branchAddr, (int)tgtAddr);
-
-        gDvmJit.hasNewChain = true;
-
-        PROTECT_CODE_CACHE(branchAddr, sizeof(int));
-        COMPILER_TRACE_CHAINING(
-            ALOGI("Jit Runtime: chaining 0x%x to %p\n",
-                 (int) branchAddr, tgtAddr));
-    }
-#endif
-    return tgtAddr;
-}
-
-/**
- * @brief Send off the work
- * @param work the CompilerWorkOrder
- * @return if the compilation succeeded
- */
-static bool sendOffWork (CompilerWorkOrder *work)
-{
-    //Get trace description
-    JitTraceDescription *desc = static_cast<JitTraceDescription *> (work->info);
-    bool success = true;
-
-    //Will we compile it?
-    bool (*middleEndGate) (JitTraceDescription *, int, JitTranslationInfo *, jmp_buf *, int ) = gDvmJit.jitFramework.middleEndGate;
-
-    //Compilation function
-    bool (*middleEndFunction) (JitTraceDescription *, int, JitTranslationInfo *, jmp_buf *, int ) = gDvmJit.jitFramework.middleEndFunction;
-
-    //If we have a middle-end function, we have work
-    if (middleEndFunction != 0)
-    {
-        //Suppose we will compile it
-        bool willCompile = true;
-
-        //If we have a gate
-        if (middleEndGate != 0)
-        {
-            willCompile = middleEndGate (desc, JIT_MAX_TRACE_LEN, &work->result, work->bailPtr, 0);
-        }
-
-        if (willCompile == true)
-        {
-            //Get middle end function
-
-            success = middleEndFunction (desc, JIT_MAX_TRACE_LEN, &work->result, work->bailPtr, 0 /* no hints */);
-        }
-    }
-
-    return success;
-}
-
-/*
- * Accept the work and start compiling.  Returns true if compilation
- * is attempted.
- */
-bool dvmCompilerDoWork(CompilerWorkOrder *work)
-{
-    bool isCompile = true;
-    bool success = true;
-
-    if (gDvmJit.codeCacheFull == true) {
-        return false;
-    }
-
-    switch (work->kind) {
-        case kWorkOrderTrace:
-            sendOffWork (work);
-            break;
-        case kWorkOrderTraceDebug:
-            {
-                bool oldPrintMe = gDvmJit.printMe;
-                gDvmJit.printMe = true;
-                sendOffWork (work);
-                gDvmJit.printMe = oldPrintMe;
-                break;
-            }
-        case kWorkOrderProfileMode:
-            dvmJitChangeProfileMode ( (TraceProfilingModes) (int) work->info);
-            isCompile = false;
-            break;
-        default:
-            isCompile = false;
-            ALOGI ("JIT_INFO: Unknown work order type");
-            assert (0);  // Bail if debug build, discard otherwise
-            ALOGI ("\tError ignored");
-            break;
-    }
-
-    if (success == false) {
-        work->result.codeAddress = NULL;
-    }
-
-    return isCompile;
-}
-
-void dvmCompilerCacheFlush(long start, long end, long flags) {
-  /* cacheflush is needed for ARM, but not for IA32 (coherent icache) */
-}
-
-bool dvmCompilerFindRegClass (MIR *mir, int vR, RegisterClass &regClass)
-{
-    //Get information about the VRs in current bytecode
-    VirtualRegInfo infoByteCode[MAX_REG_PER_BYTECODE];
-    int numVRs = getVirtualRegInfo (infoByteCode, mir);
-
-    //If we get a negative return value, there was an error.
-    if (numVRs < 0)
-    {
-        return false;
-    }
-
-    int entry;
-    for (entry = 0; entry < numVRs; entry++) {
-        if (infoByteCode[entry].regNum == vR) {
-            break;
-        }
-    }
-
-    // If we cannot find this VR, we failed
-    if (entry == numVRs)
-    {
-        return false;
-    }
-
-    switch (infoByteCode[entry].physicalType)
-    {
-        case LowOpndRegType_gp:
-            regClass = kCoreReg;
-            break;
-        case LowOpndRegType_fs_s:
-        case LowOpndRegType_fs:
-            regClass = kX87Reg;
-            break;
-        case LowOpndRegType_ss:
-            regClass = kSFPReg;
-            break;
-        case LowOpndRegType_xmm:
-            regClass = kDFPReg;
-            break;
-        default:
-            ALOGD ("JIT_INFO: dvmCompilerFindClass: Type not found %d\n",
-                    infoByteCode[entry].physicalType);
-            return false;
-    }
-
-    //Success, signal it
-    return true;
-}
-
-BasicBlock *x86StandAloneArchSpecificNewBB (void)
-{
-    // Make space on arena for this BB
-    void * space = dvmCompilerNew(sizeof(BasicBlock_O1), true);
-
-    // Ensure that constructor is called
-    BasicBlock_O1 * newBB = new (space) BasicBlock_O1;
-
-    // Paranoid because dvmCompilerNew should never return NULL
-    assert(newBB != 0);
-
-    return newBB;
-}
-
-void x86StandAloneArchSpecificDumpBB (CompilationUnit *cUnit, BasicBlock *bb, FILE *file, bool beforeMIRs)
-{
-    // We have already created the x86 specific BB so cast is okay
-    BasicBlock_O1 * curBB = reinterpret_cast<BasicBlock_O1 *>(bb);
-
-    if (beforeMIRs == true)
-    {
-        curBB->associationTable.printToDot(file);
-    }
-}
diff --git a/vm/compiler/codegen/x86/VTuneSupportX86.cpp b/vm/compiler/codegen/x86/VTuneSupportX86.cpp
new file mode 100644
index 0000000..c22cbda
--- /dev/null
+++ b/vm/compiler/codegen/x86/VTuneSupportX86.cpp
@@ -0,0 +1,342 @@
+/*
+ * Copyright (C) 2013 Intel Corporation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#if defined(VTUNE_DALVIK)
+
+#include <algorithm>
+
+#include "libdex/Leb128.h"
+#include "Lower.h"
+#include "VTuneSupportX86.h"
+
+/* @brief Get line info from mapFromBCtoNCG.
+ * @param method pointer to a Method
+ * @param lineInfoList result vector
+ */
+static void getLineInfoForByteCode(const Method* method, std::vector<LineNumberInfo>& lineInfoList) {
+    const DexCode* dexCode = dvmGetMethodCode(method);
+
+    for (u4 offset = 0, i = 1; offset < dexCode->insnsSize; ++i) {
+        if (mapFromBCtoNCG[offset] != -1) {
+            LineNumberInfo lineInfo;
+            lineInfo.Offset = mapFromBCtoNCG[offset];
+            lineInfo.LineNumber = i;
+            lineInfoList.push_back(lineInfo);
+        }
+        offset += dexGetWidthFromInstruction(dexCode->insns + offset);
+    }
+}
+
+/* @brief Get line info from dex debug info and mapFromBCtoNCG.
+ * @param method pointer to a Method
+ * @param lineInfoList result vector
+ */
+static void getLineInfoForJavaCode(const Method* method, std::vector<LineNumberInfo>& lineInfoList) {
+    const DexCode* dexCode = dvmGetMethodCode(method);
+    LineNumberInfo lineInfo;
+
+    DexFile* pDexFile = method->clazz->pDvmDex->pDexFile;
+    const u1 *dbgstream = dexGetDebugInfoStream(pDexFile, dexCode);
+    if (method->clazz->sourceFile == NULL || dbgstream == NULL) {
+        return;
+    }
+
+    // Reads debug information from dex file to get BC to Java line mapping.
+    int adjopcode;
+    u4 address = 0;
+    u4 line = readUnsignedLeb128(&dbgstream);
+
+    // skip parameters
+    for(u4 paramCount = readUnsignedLeb128(&dbgstream); paramCount != 0; --paramCount) {
+        readUnsignedLeb128(&dbgstream);
+    }
+
+    for(bool isEndSequence = false; isEndSequence == false; ) {
+        u1 opcode = *dbgstream++;
+        switch (opcode) {
+        case DBG_END_SEQUENCE:
+            isEndSequence = true;
+            break;
+
+        case DBG_ADVANCE_PC:
+            address += readUnsignedLeb128(&dbgstream);
+            break;
+
+        case DBG_ADVANCE_LINE:
+            line += readSignedLeb128(&dbgstream);
+            break;
+
+        case DBG_START_LOCAL:
+        case DBG_START_LOCAL_EXTENDED:
+            readUnsignedLeb128(&dbgstream);
+            readUnsignedLeb128(&dbgstream);
+            readUnsignedLeb128(&dbgstream);
+
+            if (opcode == DBG_START_LOCAL_EXTENDED) {
+                readUnsignedLeb128(&dbgstream);
+            }
+            break;
+
+        case DBG_END_LOCAL:
+        case DBG_RESTART_LOCAL:
+            readUnsignedLeb128(&dbgstream);
+            break;
+
+        case DBG_SET_PROLOGUE_END:
+        case DBG_SET_EPILOGUE_BEGIN:
+        case DBG_SET_FILE:
+            break;
+
+        default:
+            adjopcode = opcode - DBG_FIRST_SPECIAL;
+            address += adjopcode / DBG_LINE_RANGE;
+            line += DBG_LINE_BASE + (adjopcode % DBG_LINE_RANGE);
+
+            if (mapFromBCtoNCG[address] != -1) {
+                lineInfo.Offset = mapFromBCtoNCG[address];
+                lineInfo.LineNumber = line;
+                lineInfoList.push_back(lineInfo);
+            }
+            break;
+        }
+    }
+}
+
+/* @brief Order line numbers by their offset. Used by std::sort. */
+struct SortLineNumberInfoByOffset {
+    bool operator()(LineNumberInfo const& lhs, LineNumberInfo const& rhs) {
+        return lhs.Offset < rhs.Offset;
+    }
+};
+
+/* @brief Calculates method full name as dexdump does.
+ * @param method pointer to a Method
+ * @return null-terminated string with method's full name
+ */
+static char* makeDexDumpMethodName(const Method* method) {
+    char const* name = method->name;
+    u4 name_len = strlen(name);
+    char* signature = dexProtoCopyMethodDescriptor(&method->prototype);
+    u4 signature_len = strlen(signature);
+    char const* classD = method->clazz->descriptor;
+    u4 classD_len = strlen(classD);
+    u4 fullSignature_offset = 0;
+
+    // clculate result len =
+    // classname without leading 'L'
+    // + method name + ':'
+    // + signature +'\0'
+    u4 fullSignature_len = classD_len - 1 + name_len + 1 + signature_len + 1;
+    char *fullSignature = static_cast<char*>(dvmCompilerNew(fullSignature_len, false));
+
+    // copy classD without leading 'L'
+    strncpy(fullSignature, classD + 1, fullSignature_len);
+    fullSignature_offset = classD_len - 1;
+
+    // change '/' and ';' to '.'
+    for (u4 i = 0; i < fullSignature_offset; ++i) {
+        if (fullSignature[i] == ';' || fullSignature[i] == '/') {
+            fullSignature[i] = '.';
+        }
+    }
+
+    // copy method name
+    strncpy(fullSignature + fullSignature_offset, name, fullSignature_len - fullSignature_offset);
+    fullSignature_offset += name_len;
+    fullSignature[fullSignature_offset] = ':';
+    ++fullSignature_offset;
+
+    // copy signature
+    strncpy(fullSignature + fullSignature_offset, signature, fullSignature_len - fullSignature_offset);
+    fullSignature_offset += signature_len + 1; // '\0'
+
+    assert(fullSignature_len == fullSignature_offset);
+    free(signature), signature = 0;
+
+    return fullSignature;
+}
+
+void getLineInfo(CompilationUnit *cUnit, iJIT_Method_Load &jitMethod, std::vector<LineNumberInfo> &lineInfoList) {
+    const Method* method = cUnit->method;
+
+    // get the line table
+    if (gDvmJit.vtuneInfo == kVTuneInfoByteCode) {
+        jitMethod.source_file_name = makeDexDumpMethodName(method);
+        getLineInfoForByteCode(method, lineInfoList);
+    } else if (gDvmJit.vtuneInfo == kVTuneInfoJavaCode) {
+        getLineInfoForJavaCode(method, lineInfoList);
+    }
+
+    // sort the table if not empty
+    if (lineInfoList.empty() == false) {
+        std::sort(lineInfoList.begin(), lineInfoList.end(), SortLineNumberInfoByOffset());
+
+        // shift offsets
+        for (unsigned i = 0; i < lineInfoList.size() - 1; ++i) {
+            lineInfoList[i].Offset = lineInfoList[i + 1].Offset;
+        }
+        lineInfoList[lineInfoList.size() - 1].Offset = jitMethod.method_size;
+
+        jitMethod.line_number_size = lineInfoList.size();
+        jitMethod.line_number_table = &lineInfoList[0];
+    }
+}
+
+static const char * FORMAT_CODE = NULL;
+
+/* @brief Dump the format of the region of the trace to the VTune ittnotify
+ * @param cUnit pointer to the CompilationUnit
+ * @param jitMethod iJIT_Method_Load to send to VTune
+ * @param addr start address of the region
+ * @param size size of the region
+ * @param format printf format of the region if it is a data region,
+ *               otherwise (i.e. region contains code) NULL
+ */
+static void dvmCompilerReportBlockToVtune(CompilationUnit *cUnit, iJIT_Method_Load &jitMethod, void *addr, unsigned int size, const char *format = FORMAT_CODE) {
+    jitMethod.method_load_address = addr;
+    jitMethod.method_size = size;
+    jitMethod.class_id = 2; // update format, leave bytes as is
+    jitMethod.user_data = const_cast<char*>(format);
+    jitMethod.user_data_size = format == NULL ? 0 : strlen(format);
+
+    int res = notifyVTune(iJVM_EVENT_TYPE_METHOD_UPDATE, (void*)&jitMethod);
+    if (gDvmJit.printMe == true) {
+        LOGD("JIT API: %s %s block of '%s' method: id=%u, address=%p, size=%d."
+                , res == 0 ? "failed to report" : "reported"
+                , format == NULL ? "code" : "data"
+                , cUnit->method->name, jitMethod.method_id
+                , jitMethod.method_load_address ,jitMethod.method_size);
+    }
+}
+
+/* @brief Pair of size and printf format used to describe formatting of a region. */
+struct Block {
+    int size;
+    const char *format;
+};
+
+/*
+ * Chain cell disassembly dsecriptions as an array of list of fields' sizes and formats.
+ * Every list ends with Block{size=0, format=0} and describes one type of chain cells.
+ */
+
+/* @brief Sizes and formats of Normal Chaining Cell fields. */
+static Block CC_FORMAT_NORMAL[] = { // size = 17
+        {0, "Normal Chaining Cell"}
+        , {5, FORMAT_CODE}
+        , {4, "rPC: %#x"}
+        , {4, "codePtr: %#x"}
+        , {4, "isSwitch: %d"}
+        , {0, NULL}};
+
+/* @brief Sizes and formats of Hot Chaining Cell fields. */
+static Block CC_FORMAT_HOT[] = { // size = 17
+        {0, "Hot Chaining Cell"}
+        , {5, FORMAT_CODE}
+        , {4, "rPC: %#x"}
+        , {4, "codePtr: %#x"}
+        , {4, "isMove: %d"}
+        , {0, NULL}};
+
+/* @brief Sizes and formats of Singleton Chaining Cell fields. */
+static Block CC_FORMAT_SINGLETON[] = { // size = 17
+        {0, "Singleton Chaining Cell"}
+        , {5, FORMAT_CODE}
+        , {4, "rPC: %#x"}
+        , {4, "codePtr: %#x"}
+        , {4, "unused"}
+        , {0, NULL}};
+
+/* @brief Sizes and formats of Predicted Chaining Cell fields. */
+static Block CC_FORMAT_PREDICTED[] = { // size = 20
+        {0, "Predicted Chaining Cell"}
+        , {5, FORMAT_CODE}
+        , {3, "padding"}
+        , {4, "class: %#x"}
+        , {4, "method: %#x"}
+        , {4, "rechainCount: %#x"}
+        , {0, NULL}};
+
+/* @brief Sizes and formats of Backward Branch Chaining Cell fields. */
+static Block CC_FORMAT_BACKWARD_BRANCH[] = { // size = 25
+        {0, "Backward Branch Chaining Cell"}
+        , {5, FORMAT_CODE}
+        , {4, "rPC: %#x"}
+        , {4, "codePtr: %#x"}
+        , {4, "loop header: %#x"}
+        , {4, "VR write-back: %#x"}
+        , {4, "loop pre-header: %#x"}
+        , {0, NULL}};
+
+/* @brief Array of sizes and formats of all kinds of Chaining Cells.
+ *
+ * The order corresponds to the BBType enumeration.
+ */
+static Block *chainCellDescriptions[] = {
+        CC_FORMAT_NORMAL, CC_FORMAT_HOT,
+        CC_FORMAT_SINGLETON, CC_FORMAT_PREDICTED,
+        CC_FORMAT_BACKWARD_BRANCH
+};
+
+void dvmCompilerReportChainCellDataToVTune(CompilationUnit *cUnit, unsigned int method_id) {
+    // right before the trace start 4 bytes contain:
+    // 2 bytes of chain cell ChainCellCounts' offset followed by
+    // 2 bytes of the first chain cell's offset
+    char * startAddress = (char*) cUnit->baseAddr;
+    u2 countOffset = ((u2*)(startAddress - 4))[0];
+    u2 chainCellsOffset = ((u2*)(startAddress - 4))[1];
+    ChainCellCounts *chainCellCounts = ((ChainCellCounts*)(startAddress + countOffset));
+    char *pChainCell = startAddress + chainCellsOffset;
+
+    iJIT_Method_Load jitMethod;
+    memset(&jitMethod, 0, sizeof(jitMethod));
+    jitMethod.method_id = method_id;
+
+    assert(kChainingCellGap == sizeof(chainCellDescriptions)/sizeof(chainCellDescriptions[0]));
+
+    // iterate over all chain cells of the trace
+    // for each kind of chain cell
+    for(int cellKind = 0; cellKind < kChainingCellGap; ++cellKind) {
+        Block *ccDescr = chainCellDescriptions[cellKind];
+
+        // for each chain cell of this kind according to the
+        int cellSize = 0;
+        for(int cellIdx = 0
+                ; cellIdx < chainCellCounts->u.count[cellKind]
+                ; ++cellIdx, pChainCell += cellSize) {
+
+            // each Predicted Chain Cell is alligned to 4-byte boundary
+            if (cellKind == kChainingCellInvokePredicted) {
+                int padding = (4 - ((u4) pChainCell & 3)) & 3;
+                if (padding != 0) {
+                    dvmCompilerReportBlockToVtune(cUnit, jitMethod, pChainCell, padding, "padding");
+                }
+                pChainCell += padding;
+            }
+
+            // report every field of the chain cell
+            int offset = 0;
+            for(Block *block = ccDescr;
+                block->size != 0 || block->format != 0;
+                offset += block->size, ++block) {
+                dvmCompilerReportBlockToVtune(cUnit, jitMethod, pChainCell + offset, block->size, block->format);
+            }
+            assert(cellSize == 0 || cellSize == offset);
+            cellSize = offset;
+        }
+    }
+}
+
+#endif
diff --git a/vm/compiler/codegen/x86/VTuneSupportX86.h b/vm/compiler/codegen/x86/VTuneSupportX86.h
new file mode 100644
index 0000000..42e91c1
--- /dev/null
+++ b/vm/compiler/codegen/x86/VTuneSupportX86.h
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2009 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef VTUNE_SUPPORT_X86_H_
+#define VTUNE_SUPPORT_X86_H_
+
+#include "VTuneSupport.h"
+
+/*
+ * @brief Report all chain cells formats of the trace to VTune.
+ * @param cUnit pointer to CompilationUnit
+ * @param method_id VTune's method id got from previous call
+ *                  notifyVTune(iJVM_EVENT_TYPE_METHOD_LOAD_FINISHED, ...)
+ */
+void dvmCompilerReportChainCellDataToVTune(CompilationUnit *cUnit, unsigned int method_id);
+
+/* @brief Calculates line number information and fills jitMethod.
+ * @param cUnit pointer to CompilationUnit
+ * @param jitMethod iJIT_Method_Load to get the line info
+ * @param lineInfoList storage of the line info, which must persist before return
+ *                     from VTune Method Load event
+ */
+void getLineInfo(CompilationUnit *cUnit, iJIT_Method_Load &jitMethod, std::vector<LineNumberInfo> &lineInfoList);
+
+#endif
diff --git a/vm/compiler/codegen/x86/lightcg/CodegenInterface.cpp b/vm/compiler/codegen/x86/lightcg/CodegenInterface.cpp
index d9e7a2f..5e5e826 100644
--- a/vm/compiler/codegen/x86/lightcg/CodegenInterface.cpp
+++ b/vm/compiler/codegen/x86/lightcg/CodegenInterface.cpp
@@ -58,7 +58,7 @@ static void SendUpdateToVTune(void * address, unsigned size, unsigned method_id
 
 #else
 
-#include "compiler/JitProfiling.h"
+#include "compiler/codegen/x86/VTuneSupportX86.h"
 
 /* Send updated code cache content to VTune */
 static void SendUpdateToVTune(void * address, unsigned size, unsigned method_id = 0)
@@ -73,22 +73,18 @@ static void SendUpdateToVTune(void * address, unsigned size, unsigned method_id
     jitMethod.method_id = method_id;
     jitMethod.method_load_address = address;
     jitMethod.method_size = size;
+    if (gDvmJit.vtuneVersion >= VTUNE_VERSION_EXPERIMENTAL) {
+        jitMethod.class_id = 1; // update bytes, do not change format
+    }
 
     // Send the trace update event to the VTune analyzer
-    int res = iJIT_NotifyEvent(iJVM_EVENT_TYPE_METHOD_UPDATE, (void*)&jitMethod);
+    int res = notifyVTune(iJVM_EVENT_TYPE_METHOD_UPDATE, (void*)&jitMethod);
     if (gDvmJit.printMe == true) {
-        if (res != 0) {
-            if (jitMethod.method_id == 0) {
-                ALOGD("JIT API: a trace update with address=%p size=%u was not written.",
-                        jitMethod.method_load_address, jitMethod.method_size);
-            } else {
-                ALOGD("JIT API: a trace update with method_id=%u address=%p size=%u was written successfully.",
-                        jitMethod.method_id, jitMethod.method_load_address, jitMethod.method_size);
-            }
-        } else {
-            ALOGD("JIT API: failed to write a trace update with method_id=%u address=%p size=%u.",
-                    jitMethod.method_id, jitMethod.method_load_address, jitMethod.method_size);
-        }
+        ALOGD("JIT API: code update with method_id=%u address=%p size=%u %s",
+                jitMethod.method_id, jitMethod.method_load_address, jitMethod.method_size,
+                (res == 0 ?                    "failed to write"
+                 : (jitMethod.method_id == 0 ? "failed to resolve"
+                 :                             "written")));
     }
 }
 
@@ -165,9 +161,16 @@ Opcode jitNotSupportedOpcode[] = {
 #endif
 };
 
-/* Init values when a predicted chain is initially assembled */
-/* E7FE is branch to self */
-#define PREDICTED_CHAIN_BX_PAIR_INIT     0xe7fe
+/*
+ * Initial value of predicted chain cell
+ * EB FE   : jmp -2 // self
+ * 0F 1F 00: nop3
+ * 0F 1F 00: nop3
+ *
+ * When patched with 5-byte call/jmp rel32 instruction it will be correct.
+ */
+#define PREDICTED_CHAIN_BX_PAIR_INIT1     0x1f0ffeeb
+#define PREDICTED_CHAIN_BX_PAIR_INIT2     0x001f0f00
 
 #if defined(WITH_JIT)
 /* Target-specific save/restore */
@@ -573,7 +576,7 @@ static bool inlineCachePatchEnqueue(PredictedChainingCell *cellAddr,
 
     /* Fast path for uninitialized chaining cell */
     if (cellAddr->clazz == NULL &&
-        cellAddr->branch == PREDICTED_CHAIN_BX_PAIR_INIT) {
+        cellAddr->branch == PREDICTED_CHAIN_BX_PAIR_INIT1) {
         UNPROTECT_CODE_CACHE(cellAddr, sizeof(*cellAddr));
 
         cellAddr->method = newContent->method;
@@ -749,6 +752,8 @@ extern "C" const Method *dvmJitToPatchPredictedChain(const Method *method,
     // This does not need to go through lowering interface and can encode directly
     // at address because it does not actually update code stream until safe point.
     // Can't use stream here since it is used by the compilation thread.
+    newCell.branch = PREDICTED_CHAIN_BX_PAIR_INIT1;
+    newCell.branch2 = PREDICTED_CHAIN_BX_PAIR_INIT2;
     encoder_imm(Mnemonic_JMP, immSize, relOffset, (char*) (&newCell)); //update newCell.branch
 
     newCell.clazz = clazz;
@@ -1394,8 +1399,8 @@ static bool handleInvokePredictedChainingCell (CompilationUnit *cUnit,
             reinterpret_cast<PredictedChainingCell *> (stream);
 
     //Now initialize the data using the predefined macros for initialization
-    predictedContents->branch = PREDICTED_CHAIN_BX_PAIR_INIT;
-    predictedContents->branch2 = 0;
+    predictedContents->branch = PREDICTED_CHAIN_BX_PAIR_INIT1;
+    predictedContents->branch2 = PREDICTED_CHAIN_BX_PAIR_INIT2;
     predictedContents->clazz = PREDICTED_CHAIN_CLAZZ_INIT;
     predictedContents->method = PREDICTED_CHAIN_METHOD_INIT;
     predictedContents->stagedClazz = PREDICTED_CHAIN_COUNTER_INIT;
diff --git a/vm/compiler/codegen/x86/lightcg/Lower.cpp b/vm/compiler/codegen/x86/lightcg/Lower.cpp
index 5cf2b23..72ecb6b 100644
--- a/vm/compiler/codegen/x86/lightcg/Lower.cpp
+++ b/vm/compiler/codegen/x86/lightcg/Lower.cpp
@@ -34,7 +34,7 @@
 #include "libdex/DexCatch.h"
 #include "compiler/CompilerIR.h"
 #if defined VTUNE_DALVIK
-#include "compiler/JitProfiling.h"
+#include "compiler/codegen/x86/VTuneSupportX86.h"
 #endif
 #include "Singleton.h"
 #include "ExceptionHandling.h"
@@ -1146,7 +1146,7 @@ void sendLabelInfoToVTune(int startStreamPtr, int endStreamPtr, const char* labe
     jitMethod.method_name = const_cast<char *>(labelName);
     jitMethod.method_load_address = (void *)startStreamPtr;
     jitMethod.method_size = endStreamPtr-startStreamPtr;
-    int res = iJIT_NotifyEvent(iJVM_EVENT_TYPE_METHOD_LOAD_FINISHED, (void*)&jitMethod);
+    int res = notifyVTune(iJVM_EVENT_TYPE_METHOD_LOAD_FINISHED, (void*)&jitMethod);
     if (gDvmJit.printMe == true) {
         if (res != 0) {
             ALOGD("JIT API: a trace of %s method was written successfully address: id=%u, address=%p, size=%d."
diff --git a/vm/compiler/codegen/x86/lightcg/LowerInvoke.cpp b/vm/compiler/codegen/x86/lightcg/LowerInvoke.cpp
index b8b9892..ae2a131 100644
--- a/vm/compiler/codegen/x86/lightcg/LowerInvoke.cpp
+++ b/vm/compiler/codegen/x86/lightcg/LowerInvoke.cpp
@@ -28,7 +28,7 @@
 #include "enc_wrapper.h"
 
 #if defined VTUNE_DALVIK
-#include "compiler/JitProfiling.h"
+#include "compiler/codegen/x86/VTuneSupportX86.h"
 #endif
 
 char* streamMisPred = NULL;
diff --git a/vm/compiler/codegen/x86/lightcg/LowerJump.cpp b/vm/compiler/codegen/x86/lightcg/LowerJump.cpp
index 027acde..13ccf39 100644
--- a/vm/compiler/codegen/x86/lightcg/LowerJump.cpp
+++ b/vm/compiler/codegen/x86/lightcg/LowerJump.cpp
@@ -35,7 +35,7 @@
 #include "Singleton.h"
 
 #if defined VTUNE_DALVIK
-#include "compiler/JitProfiling.h"
+#include "compiler/codegen/x86/VTuneSupportX86.h"
 #endif
 
 LabelMap* globalMap;
diff --git a/vm/compiler/codegen/x86/pcg/ChainingCellException.cpp b/vm/compiler/codegen/x86/pcg/ChainingCellException.cpp
index 815a47d..6ff40b4 100644
--- a/vm/compiler/codegen/x86/pcg/ChainingCellException.cpp
+++ b/vm/compiler/codegen/x86/pcg/ChainingCellException.cpp
@@ -145,9 +145,16 @@ static uint8_t* dvmCompilerPcgEmitSingletonChainingCell (CompilationUnitPCG *cUn
     return currCachePtr;
 }
 
-// Init values when a predicted chain is initially assembled.
-// E7FE is branch to self.
-#define PREDICTED_CHAIN_BX_PAIR_INIT     0xe7fe
+/*
+ * Initial value of predicted chain cell
+ * EB FE   : jmp -2 // self
+ * 0F 1F 00: nop3
+ * 0F 1F 00: nop3
+ *
+ * When patched with 5-byte call/jmp rel32 instruction it will be correct.
+ */
+#define PREDICTED_CHAIN_BX_PAIR_INIT1     0x1f0ffeeb
+#define PREDICTED_CHAIN_BX_PAIR_INIT2     0x001f0f00
 
 /**
  * @brief Emit a predicted chaining cell
@@ -198,8 +205,8 @@ static uint8_t* dvmCompilerPcgEmitPredictedChainingCell (CompilationUnitPCG *cUn
     dvmCompilerPcgBindSymbolAddress (cUnit, blockSymbol, currCachePtr);
     int *intStream = (int *)currCachePtr;
 
-    intStream[0] = PREDICTED_CHAIN_BX_PAIR_INIT;
-    intStream[1] = 0;
+    intStream[0] = PREDICTED_CHAIN_BX_PAIR_INIT1;
+    intStream[1] = PREDICTED_CHAIN_BX_PAIR_INIT2;
     // To be filled: class
     intStream[2] = PREDICTED_CHAIN_CLAZZ_INIT;
     // To be filled: method
diff --git a/vm/compiler/ittnotify_config.h b/vm/compiler/ittnotify_config.h
deleted file mode 100644
index 7c7675d..0000000
--- a/vm/compiler/ittnotify_config.h
+++ /dev/null
@@ -1,437 +0,0 @@
-/*
-* Copyright (C) 2010-2012 Intel Corporation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-*      http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
-
-#ifndef _ITTNOTIFY_CONFIG_H_
-#define _ITTNOTIFY_CONFIG_H_
-
-/** @cond exclude_from_documentation */
-#ifndef ITT_OS_WIN
-#  define ITT_OS_WIN   1
-#endif /* ITT_OS_WIN */
-
-#ifndef ITT_OS_LINUX
-#  define ITT_OS_LINUX 2
-#endif /* ITT_OS_LINUX */
-
-#ifndef ITT_OS_MAC
-#  define ITT_OS_MAC   3
-#endif /* ITT_OS_MAC */
-
-#ifndef ITT_OS
-#  if defined WIN32 || defined _WIN32
-#    define ITT_OS ITT_OS_WIN
-#  elif defined( __APPLE__ ) && defined( __MACH__ )
-#    define ITT_OS ITT_OS_MAC
-#  else
-#    define ITT_OS ITT_OS_LINUX
-#  endif
-#endif /* ITT_OS */
-
-#ifndef ITT_PLATFORM_WIN
-#  define ITT_PLATFORM_WIN 1
-#endif /* ITT_PLATFORM_WIN */
-
-#ifndef ITT_PLATFORM_POSIX
-#  define ITT_PLATFORM_POSIX 2
-#endif /* ITT_PLATFORM_POSIX */
-
-#ifndef ITT_PLATFORM
-#  if ITT_OS==ITT_OS_WIN
-#    define ITT_PLATFORM ITT_PLATFORM_WIN
-#  else
-#    define ITT_PLATFORM ITT_PLATFORM_POSIX
-#  endif /* _WIN32 */
-#endif /* ITT_PLATFORM */
-
-#if defined(_UNICODE) && !defined(UNICODE)
-#define UNICODE
-#endif
-
-#include <stddef.h>
-#if ITT_PLATFORM==ITT_PLATFORM_WIN
-#include <tchar.h>
-#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */
-#include <stdint.h>
-#if defined(UNICODE) || defined(_UNICODE)
-#include <wchar.h>
-#endif /* UNICODE || _UNICODE */
-#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */
-
-#ifndef CDECL
-#  if ITT_PLATFORM==ITT_PLATFORM_WIN
-#    define CDECL __cdecl
-#  else /* ITT_PLATFORM==ITT_PLATFORM_WIN */
-#    if defined _M_X64 || defined _M_AMD64 || defined __x86_64__
-#      define CDECL /* not actual on x86_64 platform */
-#    else  /* _M_X64 || _M_AMD64 || __x86_64__ */
-#      define CDECL __attribute__ ((cdecl))
-#    endif /* _M_X64 || _M_AMD64 || __x86_64__ */
-#  endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */
-#endif /* CDECL */
-
-#ifndef STDCALL
-#  if ITT_PLATFORM==ITT_PLATFORM_WIN
-#    define STDCALL __stdcall
-#  else /* ITT_PLATFORM==ITT_PLATFORM_WIN */
-#    if defined _M_X64 || defined _M_AMD64 || defined __x86_64__
-#      define STDCALL /* not supported on x86_64 platform */
-#    else  /* _M_X64 || _M_AMD64 || __x86_64__ */
-#      define STDCALL __attribute__ ((stdcall))
-#    endif /* _M_X64 || _M_AMD64 || __x86_64__ */
-#  endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */
-#endif /* STDCALL */
-
-#define ITTAPI    CDECL
-#define LIBITTAPI CDECL
-
-/* TODO: Temporary for compatibility! */
-#define ITTAPI_CALL    CDECL
-#define LIBITTAPI_CALL CDECL
-
-#if ITT_PLATFORM==ITT_PLATFORM_WIN
-/* use __forceinline (VC++ specific) */
-#define INLINE           __forceinline
-#define INLINE_ATTRIBUTE /* nothing */
-#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */
-/*
- * Generally, functions are not inlined unless optimization is specified.
- * For functions declared inline, this attribute inlines the function even
- * if no optimization level was specified.
- */
-#ifdef __STRICT_ANSI__
-#define INLINE           static
-#else  /* __STRICT_ANSI__ */
-#define INLINE           static inline
-#endif /* __STRICT_ANSI__ */
-#define INLINE_ATTRIBUTE __attribute__ ((always_inline))
-#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */
-/** @endcond */
-
-#ifndef ITT_ARCH_IA32
-#  define ITT_ARCH_IA32  1
-#endif /* ITT_ARCH_IA32 */
-
-#ifndef ITT_ARCH_IA32E
-#  define ITT_ARCH_IA32E 2
-#endif /* ITT_ARCH_IA32E */
-
-#ifndef ITT_ARCH_IA64
-#  define ITT_ARCH_IA64  3
-#endif /* ITT_ARCH_IA64 */
-
-#ifndef ITT_ARCH
-#  if defined _M_X64 || defined _M_AMD64 || defined __x86_64__
-#    define ITT_ARCH ITT_ARCH_IA32E
-#  elif defined _M_IA64 || defined __ia64
-#    define ITT_ARCH ITT_ARCH_IA64
-#  else
-#    define ITT_ARCH ITT_ARCH_IA32
-#  endif
-#endif
-
-//#ifdef __cplusplus
-#  define ITT_EXTERN_C extern "C"
-//#else
-//#  define ITT_EXTERN_C /* nothing */
-//#endif /* __cplusplus */
-
-#define ITT_TO_STR_AUX(x) #x
-#define ITT_TO_STR(x)     ITT_TO_STR_AUX(x)
-
-#define __ITT_BUILD_ASSERT(expr, suffix) do { static char __itt_build_check_##suffix[(expr) ? 1 : -1]; __itt_build_check_##suffix[0] = 0; } while(0)
-#define _ITT_BUILD_ASSERT(expr, suffix)  __ITT_BUILD_ASSERT((expr), suffix)
-#define ITT_BUILD_ASSERT(expr)           _ITT_BUILD_ASSERT((expr), __LINE__)
-
-#define ITT_MAGIC { 0xED, 0xAB, 0xAB, 0xEC, 0x0D, 0xEE, 0xDA, 0x30 }
-
-/* Replace with snapshot date YYYYMMDD for promotion build. */
-#define API_VERSION_BUILD    20111111
-
-#ifndef API_VERSION_NUM
-#define API_VERSION_NUM 0.0.0
-#endif /* API_VERSION_NUM */
-
-#define API_VERSION "ITT-API-Version " ITT_TO_STR(API_VERSION_NUM) " (" ITT_TO_STR(API_VERSION_BUILD) ")"
-
-/* OS communication functions */
-#if ITT_PLATFORM==ITT_PLATFORM_WIN
-#include <windows.h>
-typedef HMODULE           lib_t;
-typedef DWORD             TIDT;
-typedef CRITICAL_SECTION  mutex_t;
-#define MUTEX_INITIALIZER { 0 }
-#define strong_alias(name, aliasname) /* empty for Windows */
-#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */
-#include <dlfcn.h>
-#if defined(UNICODE) || defined(_UNICODE)
-#include <wchar.h>
-#endif /* UNICODE */
-#ifndef _GNU_SOURCE
-#define _GNU_SOURCE 1 /* need for PTHREAD_MUTEX_RECURSIVE */
-#endif /* _GNU_SOURCE */
-#include <pthread.h>
-typedef void*             lib_t;
-typedef pthread_t         TIDT;
-typedef pthread_mutex_t   mutex_t;
-#define MUTEX_INITIALIZER PTHREAD_MUTEX_INITIALIZER
-#define _strong_alias(name, aliasname) extern __typeof (name) aliasname __attribute__ ((alias (#name)));
-#define strong_alias(name, aliasname) _strong_alias(name, aliasname)
-#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */
-
-#if ITT_PLATFORM==ITT_PLATFORM_WIN
-#define __itt_get_proc(lib, name) GetProcAddress(lib, name)
-#define __itt_mutex_init(mutex)   InitializeCriticalSection(mutex)
-#define __itt_mutex_lock(mutex)   EnterCriticalSection(mutex)
-#define __itt_mutex_unlock(mutex) LeaveCriticalSection(mutex)
-#define __itt_load_lib(name)      LoadLibraryA(name)
-#define __itt_unload_lib(handle)  FreeLibrary(handle)
-#define __itt_system_error()      (int)GetLastError()
-#define __itt_fstrcmp(s1, s2)     lstrcmpA(s1, s2)
-#define __itt_fstrlen(s)          lstrlenA(s)
-#define __itt_fstrcpyn(s1, s2, l) lstrcpynA(s1, s2, l)
-#define __itt_fstrdup(s)          _strdup(s)
-#define __itt_thread_id()         GetCurrentThreadId()
-#define __itt_thread_yield()      SwitchToThread()
-#ifndef ITT_SIMPLE_INIT
-INLINE int __itt_interlocked_increment(volatile long* ptr)
-{
-    return InterlockedIncrement(ptr);
-}
-#endif /* ITT_SIMPLE_INIT */
-#else /* ITT_PLATFORM!=ITT_PLATFORM_WIN */
-#define __itt_get_proc(lib, name) dlsym(lib, name)
-#define __itt_mutex_init(mutex)   \
-    {                                                                                        \
-        pthread_mutexattr_t mutex_attr;                                                      \
-        int error_code = pthread_mutexattr_init(&mutex_attr);                                \
-        if (error_code)                                                                      \
-            __itt_report_error(__itt_error_system, "pthread_mutexattr_init", error_code);    \
-        error_code = pthread_mutexattr_settype(&mutex_attr, PTHREAD_MUTEX_RECURSIVE);        \
-        if (error_code)                                                                      \
-            __itt_report_error(__itt_error_system, "pthread_mutexattr_settype", error_code); \
-        error_code = pthread_mutex_init(mutex, &mutex_attr);                                 \
-        if (error_code)                                                                      \
-            __itt_report_error(__itt_error_system, "pthread_mutex_init", error_code);        \
-        error_code = pthread_mutexattr_destroy(&mutex_attr);                                 \
-        if (error_code)                                                                      \
-            __itt_report_error(__itt_error_system, "pthread_mutexattr_destroy", error_code); \
-    }
-#define __itt_mutex_lock(mutex)   pthread_mutex_lock(mutex)
-#define __itt_mutex_unlock(mutex) pthread_mutex_unlock(mutex)
-#define __itt_load_lib(name)      dlopen(name, RTLD_LAZY)
-#define __itt_unload_lib(handle)  dlclose(handle)
-#define __itt_system_error()      errno
-#define __itt_fstrcmp(s1, s2)     strcmp(s1, s2)
-#define __itt_fstrlen(s)          strlen(s)
-#define __itt_fstrcpyn(s1, s2, l) strncpy(s1, s2, l)
-#define __itt_fstrdup(s)          strdup(s)
-#define __itt_thread_id()         pthread_self()
-#define __itt_thread_yield()      sched_yield()
-#if ITT_ARCH==ITT_ARCH_IA64
-#ifdef __INTEL_COMPILER
-#define __TBB_machine_fetchadd4(addr, val) __fetchadd4_acq((void *)addr, val)
-#else  /* __INTEL_COMPILER */
-/* TODO: Add Support for not Intel compilers for IA64 */
-#endif /* __INTEL_COMPILER */
-#else /* ITT_ARCH!=ITT_ARCH_IA64 */
-INLINE int __TBB_machine_fetchadd4(volatile void* ptr, long addend)
-{
-    int result;
-    __asm__ __volatile__("lock\nxaddl %0,%1"
-                          : "=r"(result),"=m"(*(long*)ptr)
-                          : "0"(addend), "m"(*(long*)ptr)
-                          : "memory");
-    return result;
-}
-#endif /* ITT_ARCH==ITT_ARCH_IA64 */
-#ifndef ITT_SIMPLE_INIT
-INLINE int __itt_interlocked_increment(volatile long* ptr)
-{
-    return __TBB_machine_fetchadd4(ptr, 1) + 1;
-}
-#endif /* ITT_SIMPLE_INIT */
-#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */
-
-typedef enum {
-    __itt_collection_normal = 0,
-    __itt_collection_paused = 1
-} __itt_collection_state;
-
-typedef enum {
-    __itt_thread_normal  = 0,
-    __itt_thread_ignored = 1
-} __itt_thread_state;
-
-#pragma pack(push, 8)
-
-typedef struct ___itt_thread_info
-{
-    const char* nameA; /*!< Copy of original name in ASCII. */
-#if defined(UNICODE) || defined(_UNICODE)
-    const wchar_t* nameW; /*!< Copy of original name in UNICODE. */
-#else  /* UNICODE || _UNICODE */
-    void* nameW;
-#endif /* UNICODE || _UNICODE */
-    TIDT               tid;
-    __itt_thread_state state;   /*!< Thread state (paused or normal) */
-    int                extra1;  /*!< Reserved to the runtime */
-    void*              extra2;  /*!< Reserved to the runtime */
-    struct ___itt_thread_info* next;
-} __itt_thread_info;
-
-#include "ittnotify_types.h" /* For __itt_group_id definition */
-
-typedef struct ___itt_api_info_20101001
-{
-    const char*    name;
-    void**         func_ptr;
-    void*          init_func;
-    __itt_group_id group;
-}  __itt_api_info_20101001;
-
-typedef struct ___itt_api_info
-{
-    const char*    name;
-    void**         func_ptr;
-    void*          init_func;
-    void*          null_func;
-    __itt_group_id group;
-}  __itt_api_info;
-
-struct ___itt_domain;
-struct ___itt_string_handle;
-
-typedef struct ___itt_global
-{
-    unsigned char          magic[8];
-    unsigned long          version_major;
-    unsigned long          version_minor;
-    unsigned long          version_build;
-    volatile long          api_initialized;
-    volatile long          mutex_initialized;
-    volatile long          atomic_counter;
-    mutex_t                mutex;
-    lib_t                  lib;
-    void*                  error_handler;
-    const char**           dll_path_ptr;
-    __itt_api_info*        api_list_ptr;
-    struct ___itt_global*  next;
-    /* Joinable structures below */
-    __itt_thread_info*     thread_list;
-    struct ___itt_domain*  domain_list;
-    struct ___itt_string_handle* string_list;
-    __itt_collection_state state;
-} __itt_global;
-
-#pragma pack(pop)
-
-#define NEW_THREAD_INFO_W(gptr,h,h_tail,t,s,n) { \
-    h = (__itt_thread_info*)malloc(sizeof(__itt_thread_info)); \
-    if (h != NULL) { \
-        h->tid    = t; \
-        h->nameA  = NULL; \
-        h->nameW  = n ? _wcsdup(n) : NULL; \
-        h->state  = s; \
-        h->extra1 = 0;    /* reserved */ \
-        h->extra2 = NULL; /* reserved */ \
-        h->next   = NULL; \
-        if (h_tail == NULL) \
-            (gptr)->thread_list = h; \
-        else \
-            h_tail->next = h; \
-    } \
-}
-
-#define NEW_THREAD_INFO_A(gptr,h,h_tail,t,s,n) { \
-    h = (__itt_thread_info*)malloc(sizeof(__itt_thread_info)); \
-    if (h != NULL) { \
-        h->tid    = t; \
-        h->nameA  = n ? __itt_fstrdup(n) : NULL; \
-        h->nameW  = NULL; \
-        h->state  = s; \
-        h->extra1 = 0;    /* reserved */ \
-        h->extra2 = NULL; /* reserved */ \
-        h->next   = NULL; \
-        if (h_tail == NULL) \
-            (gptr)->thread_list = h; \
-        else \
-            h_tail->next = h; \
-    } \
-}
-
-#define NEW_DOMAIN_W(gptr,h,h_tail,name) { \
-    h = (__itt_domain*)malloc(sizeof(__itt_domain)); \
-    if (h != NULL) { \
-        h->flags  = 0;    /* domain is disabled by default */ \
-        h->nameA  = NULL; \
-        h->nameW  = name ? _wcsdup(name) : NULL; \
-        h->extra1 = 0;    /* reserved */ \
-        h->extra2 = NULL; /* reserved */ \
-        h->next   = NULL; \
-        if (h_tail == NULL) \
-            (gptr)->domain_list = h; \
-        else \
-            h_tail->next = h; \
-    } \
-}
-
-#define NEW_DOMAIN_A(gptr,h,h_tail,name) { \
-    h = (__itt_domain*)malloc(sizeof(__itt_domain)); \
-    if (h != NULL) { \
-        h->flags  = 0;    /* domain is disabled by default */ \
-        h->nameA  = name ? __itt_fstrdup(name) : NULL; \
-        h->nameW  = NULL; \
-        h->extra1 = 0;    /* reserved */ \
-        h->extra2 = NULL; /* reserved */ \
-        h->next   = NULL; \
-        if (h_tail == NULL) \
-            (gptr)->domain_list = h; \
-        else \
-            h_tail->next = h; \
-    } \
-}
-
-#define NEW_STRING_HANDLE_W(gptr,h,h_tail,name) { \
-    h = (__itt_string_handle*)malloc(sizeof(__itt_string_handle)); \
-    if (h != NULL) { \
-        h->strA   = NULL; \
-        h->strW   = name ? _wcsdup(name) : NULL; \
-        h->extra1 = 0;    /* reserved */ \
-        h->extra2 = NULL; /* reserved */ \
-        h->next   = NULL; \
-        if (h_tail == NULL) \
-            (gptr)->string_list = h; \
-        else \
-            h_tail->next = h; \
-    } \
-}
-
-#define NEW_STRING_HANDLE_A(gptr,h,h_tail,name) { \
-    h = (__itt_string_handle*)malloc(sizeof(__itt_string_handle)); \
-    if (h != NULL) { \
-        h->strA   = name ? __itt_fstrdup(name) : NULL; \
-        h->strW   = NULL; \
-        h->extra1 = 0;    /* reserved */ \
-        h->extra2 = NULL; /* reserved */ \
-        h->next   = NULL; \
-        if (h_tail == NULL) \
-            (gptr)->string_list = h; \
-        else \
-            h_tail->next = h; \
-    } \
-}
-
-#endif /* _ITTNOTIFY_CONFIG_H_ */
diff --git a/vm/compiler/ittnotify_types.h b/vm/compiler/ittnotify_types.h
deleted file mode 100644
index ef631f7..0000000
--- a/vm/compiler/ittnotify_types.h
+++ /dev/null
@@ -1,71 +0,0 @@
-/*
-* Copyright (C) 2010-2012 Intel Corporation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-*      http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
-
-#ifndef _ITTNOTIFY_TYPES_H_
-#define _ITTNOTIFY_TYPES_H_
-
-typedef enum ___itt_group_id
-{
-    __itt_group_none      = 0,
-    __itt_group_legacy    = 1<<0,
-    __itt_group_control   = 1<<1,
-    __itt_group_thread    = 1<<2,
-    __itt_group_mark      = 1<<3,
-    __itt_group_sync      = 1<<4,
-    __itt_group_fsync     = 1<<5,
-    __itt_group_jit       = 1<<6,
-    __itt_group_model     = 1<<7,
-    __itt_group_splitter_min = 1<<7,
-    __itt_group_counter   = 1<<8,
-    __itt_group_frame     = 1<<9,
-    __itt_group_stitch    = 1<<10,
-    __itt_group_heap      = 1<<11,
-    __itt_group_splitter_max = 1<<12,
-    __itt_group_structure = 1<<12,
-    __itt_group_suppress = 1<<13,
-    __itt_group_all       = -1
-} __itt_group_id;
-
-#pragma pack(push, 8)
-
-typedef struct ___itt_group_list
-{
-    __itt_group_id id;
-    const char*    name;
-} __itt_group_list;
-
-#pragma pack(pop)
-
-#define ITT_GROUP_LIST(varname) \
-    static __itt_group_list varname[] = {       \
-        { __itt_group_all,       "all"       }, \
-        { __itt_group_control,   "control"   }, \
-        { __itt_group_thread,    "thread"    }, \
-        { __itt_group_mark,      "mark"      }, \
-        { __itt_group_sync,      "sync"      }, \
-        { __itt_group_fsync,     "fsync"     }, \
-        { __itt_group_jit,       "jit"       }, \
-        { __itt_group_model,     "model"     }, \
-        { __itt_group_counter,   "counter"   }, \
-        { __itt_group_frame,     "frame"     }, \
-        { __itt_group_stitch,    "stitch"    }, \
-        { __itt_group_heap,      "heap"      }, \
-        { __itt_group_structure, "structure" }, \
-        { __itt_group_suppress,  "suppress"  }, \
-        { __itt_group_none,      NULL        }  \
-    }
-
-#endif /* _ITTNOTIFY_TYPES_H_ */
diff --git a/vm/compiler/vtune/JitProfiling.cpp b/vm/compiler/vtune/JitProfiling.cpp
new file mode 100644
index 0000000..1a12055
--- /dev/null
+++ b/vm/compiler/vtune/JitProfiling.cpp
@@ -0,0 +1,487 @@
+/*
+* Copyright (C) 2010-2012 Intel Corporation
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+*      http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+#include "ittnotify_config.h"
+
+#if ITT_PLATFORM==ITT_PLATFORM_WIN
+#include <windows.h>
+#pragma optimize("", off)
+#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */
+#include <pthread.h>
+#include <dlfcn.h>
+#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */
+#include <malloc.h>
+#include <stdlib.h>
+
+#include "JitProfiling.h"
+
+static const char rcsid[] = "\n@(#) $Revision: 304601 $\n";
+
+#define DLL_ENVIRONMENT_VAR             "VS_PROFILER"
+
+#ifndef NEW_DLL_ENVIRONMENT_VAR
+#if ITT_ARCH==ITT_ARCH_IA32
+#define NEW_DLL_ENVIRONMENT_VAR "INTEL_JIT_PROFILER32"
+#else
+#define NEW_DLL_ENVIRONMENT_VAR "INTEL_JIT_PROFILER64"
+#endif
+#endif /* NEW_DLL_ENVIRONMENT_VAR */
+
+#if ITT_PLATFORM==ITT_PLATFORM_WIN
+#define DEFAULT_DLLNAME                 "JitPI.dll"
+HINSTANCE m_libHandle = NULL;
+#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */
+#define DEFAULT_DLLNAME                 "libJitPI.so"
+void* m_libHandle = NULL;
+#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */
+
+/* default location of JIT profiling agent on Android */
+#define ANDROID_JIT_AGENT_PATH  "/data/intel/libittnotify.so"
+
+/* the function pointers */
+typedef unsigned int(*TPInitialize)(void);
+static TPInitialize FUNC_Initialize=NULL;
+
+typedef unsigned int(*TPNotify)(unsigned int, void*);
+static TPNotify FUNC_NotifyEvent=NULL;
+
+static iJIT_IsProfilingActiveFlags executionMode = iJIT_NOTHING_RUNNING;
+
+/* end collector dll part. */
+
+/* loadiJIT_Funcs() : this function is called just in the beginning
+ *  and is responsible to load the functions from BistroJavaCollector.dll
+ * result:
+ *  on success: the functions loads, iJIT_DLL_is_missing=0, return value = 1
+ *  on failure: the functions are NULL, iJIT_DLL_is_missing=1, return value = 0
+ */
+static int loadiJIT_Funcs(void);
+
+/* global representing whether the BistroJavaCollector can't be loaded */
+static int iJIT_DLL_is_missing = 0;
+
+/* Virtual stack - the struct is used as a virtual stack for each thread.
+ * Every thread initializes with a stack of size INIT_TOP_STACK.
+ * Every method entry decreases from the current stack point,
+ * and when a thread stack reaches its top of stack (return from the global
+ * function), the top of stack and the current stack increase. Notice that
+ * when returning from a function the stack pointer is the address of
+ * the function return.
+ */
+#if ITT_PLATFORM==ITT_PLATFORM_WIN
+static DWORD threadLocalStorageHandle = 0;
+#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */
+static pthread_key_t threadLocalStorageHandle = (pthread_key_t)0;
+#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */
+
+#define INIT_TOP_Stack 10000
+
+typedef struct
+{
+    unsigned int TopStack;
+    unsigned int CurrentStack;
+} ThreadStack, *pThreadStack;
+
+/* end of virtual stack. */
+
+/*
+ * The function for reporting virtual-machine related events to VTune.
+ * Note: when reporting iJVM_EVENT_TYPE_ENTER_NIDS, there is no need to fill
+ * in the stack_id field in the iJIT_Method_NIDS structure, as VTune fills it.
+ * The return value in iJVM_EVENT_TYPE_ENTER_NIDS &&
+ * iJVM_EVENT_TYPE_LEAVE_NIDS events will be 0 in case of failure.
+ * in iJVM_EVENT_TYPE_METHOD_LOAD_FINISHED event
+ * it will be -1 if EventSpecificData == 0 otherwise it will be 0.
+*/
+
+ITT_EXTERN_C int JITAPI
+iJIT_NotifyEvent(iJIT_JVM_EVENT event_type, void *EventSpecificData)
+{
+    int ReturnValue = 0;
+
+    /*
+     * This section is for debugging outside of VTune.
+     * It creates the environment variables that indicates call graph mode.
+     * If running outside of VTune remove the remark.
+     *
+     *
+     * static int firstTime = 1;
+     * char DoCallGraph[12] = "DoCallGraph";
+     * if (firstTime)
+     * {
+     * firstTime = 0;
+     * SetEnvironmentVariable( "BISTRO_COLLECTORS_DO_CALLGRAPH", DoCallGraph);
+     * }
+     *
+     * end of section.
+    */
+
+    /* initialization part - the functions have not been loaded yet. This part
+     *        will load the functions, and check if we are in Call Graph mode.
+     *        (for special treatment).
+     */
+    if (!FUNC_NotifyEvent)
+    {
+        if (iJIT_DLL_is_missing)
+            return 0;
+
+        /* load the Function from the DLL */
+        if (!loadiJIT_Funcs())
+            return 0;
+
+        /* Call Graph initialization. */
+    }
+
+    /* If the event is method entry/exit, check that in the current mode
+     * VTune is allowed to receive it
+     */
+    if ((event_type == iJVM_EVENT_TYPE_ENTER_NIDS ||
+         event_type == iJVM_EVENT_TYPE_LEAVE_NIDS) &&
+        (executionMode != iJIT_CALLGRAPH_ON))
+    {
+        return 0;
+    }
+    /* This section is performed when method enter event occurs.
+     * It updates the virtual stack, or creates it if this is the first
+     * method entry in the thread. The stack pointer is decreased.
+     */
+    if (event_type == iJVM_EVENT_TYPE_ENTER_NIDS)
+    {
+#if ITT_PLATFORM==ITT_PLATFORM_WIN
+        pThreadStack threadStack =
+            (pThreadStack)TlsGetValue (threadLocalStorageHandle);
+#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */
+        pThreadStack threadStack =
+            (pThreadStack)pthread_getspecific(threadLocalStorageHandle);
+#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */
+
+        /* check for use of reserved method IDs */
+        if ( ((piJIT_Method_NIDS) EventSpecificData)->method_id <= 999 )
+            return 0;
+
+        if (!threadStack)
+        {
+            /* initialize the stack. */
+            threadStack = (pThreadStack) calloc (sizeof(ThreadStack), 1);
+            if (!threadStack)
+                return 0;
+            threadStack->TopStack = INIT_TOP_Stack;
+            threadStack->CurrentStack = INIT_TOP_Stack;
+#if ITT_PLATFORM==ITT_PLATFORM_WIN
+            TlsSetValue(threadLocalStorageHandle,(void*)threadStack);
+#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */
+            pthread_setspecific(threadLocalStorageHandle,(void*)threadStack);
+#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */
+        }
+
+        /* decrease the stack. */
+        ((piJIT_Method_NIDS) EventSpecificData)->stack_id =
+            (threadStack->CurrentStack)--;
+    }
+
+    /* This section is performed when method leave event occurs
+     * It updates the virtual stack.
+     *    Increases the stack pointer.
+     *    If the stack pointer reached the top (left the global function)
+     *        increase the pointer and the top pointer.
+     */
+    if (event_type == iJVM_EVENT_TYPE_LEAVE_NIDS)
+    {
+#if ITT_PLATFORM==ITT_PLATFORM_WIN
+        pThreadStack threadStack =
+           (pThreadStack)TlsGetValue (threadLocalStorageHandle);
+#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */
+        pThreadStack threadStack =
+            (pThreadStack)pthread_getspecific(threadLocalStorageHandle);
+#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */
+
+        /* check for use of reserved method IDs */
+        if ( ((piJIT_Method_NIDS) EventSpecificData)->method_id <= 999 )
+            return 0;
+
+        if (!threadStack)
+        {
+            /* Error: first report in this thread is method exit */
+            exit (1);
+        }
+
+        ((piJIT_Method_NIDS) EventSpecificData)->stack_id =
+            ++(threadStack->CurrentStack) + 1;
+
+        if (((piJIT_Method_NIDS) EventSpecificData)->stack_id
+               > threadStack->TopStack)
+            ((piJIT_Method_NIDS) EventSpecificData)->stack_id =
+                (unsigned int)-1;
+    }
+
+    if (event_type == iJVM_EVENT_TYPE_METHOD_LOAD_FINISHED)
+    {
+        /* check for use of reserved method IDs */
+        if ( ((piJIT_Method_Load) EventSpecificData)->method_id <= 999 )
+            return 0;
+    }
+    else if (event_type == iJVM_EVENT_TYPE_METHOD_LOAD_FINISHED_V2)
+    {
+        /* check for use of reserved method IDs */
+        if ( ((piJIT_Method_Load_V2) EventSpecificData)->method_id <= 999 )
+            return 0;
+    }
+
+    ReturnValue = (int)FUNC_NotifyEvent(event_type, EventSpecificData);
+
+    return ReturnValue;
+}
+
+/* The new mode call back routine */
+ITT_EXTERN_C void JITAPI
+iJIT_RegisterCallbackEx(void *userdata, iJIT_ModeChangedEx
+                        NewModeCallBackFuncEx)
+{
+    /* is it already missing... or the load of functions from the DLL failed */
+    if (iJIT_DLL_is_missing || !loadiJIT_Funcs())
+    {
+        /* then do not bother with notifications */
+        NewModeCallBackFuncEx(userdata, iJIT_NO_NOTIFICATIONS);
+        /* Error: could not load JIT functions. */
+        return;
+    }
+    /* nothing to do with the callback */
+}
+
+/*
+ * This function allows the user to query in which mode, if at all,
+ *VTune is running
+ */
+ITT_EXTERN_C iJIT_IsProfilingActiveFlags JITAPI iJIT_IsProfilingActive()
+{
+    if (!iJIT_DLL_is_missing)
+    {
+        loadiJIT_Funcs();
+    }
+
+    return executionMode;
+}
+
+/* this function loads the collector dll (BistroJavaCollector)
+ * and the relevant functions.
+ * on success: all functions load,     iJIT_DLL_is_missing = 0, return value = 1
+ * on failure: all functions are NULL, iJIT_DLL_is_missing = 1, return value = 0
+ */
+static int loadiJIT_Funcs()
+{
+    static int bDllWasLoaded = 0;
+    char *dllName = (char*)rcsid; /* !! Just to avoid unused code elimination */
+#if ITT_PLATFORM==ITT_PLATFORM_WIN
+    DWORD dNameLength = 0;
+#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */
+
+    if(bDllWasLoaded)
+    {
+        /* dll was already loaded, no need to do it for the second time */
+        return 1;
+    }
+
+    /* Assumes that the DLL will not be found */
+    iJIT_DLL_is_missing = 1;
+    FUNC_NotifyEvent = NULL;
+
+    if (m_libHandle)
+    {
+#if ITT_PLATFORM==ITT_PLATFORM_WIN
+        FreeLibrary(m_libHandle);
+#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */
+        dlclose(m_libHandle);
+#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */
+        m_libHandle = NULL;
+    }
+
+    /* Try to get the dll name from the environment */
+#if ITT_PLATFORM==ITT_PLATFORM_WIN
+    dNameLength = GetEnvironmentVariableA(NEW_DLL_ENVIRONMENT_VAR, NULL, 0);
+    if (dNameLength)
+    {
+        DWORD envret = 0;
+        dllName = (char*)malloc(sizeof(char) * (dNameLength + 1));
+        envret = GetEnvironmentVariableA(NEW_DLL_ENVIRONMENT_VAR,
+                                         dllName, dNameLength);
+        if (envret)
+        {
+            /* Try to load the dll from the PATH... */
+            m_libHandle = LoadLibraryExA(dllName,
+                                         NULL, LOAD_WITH_ALTERED_SEARCH_PATH);
+        }
+        free(dllName);
+    } else {
+        /* Try to use old VS_PROFILER variable */
+        dNameLength = GetEnvironmentVariableA(DLL_ENVIRONMENT_VAR, NULL, 0);
+        if (dNameLength)
+        {
+            DWORD envret = 0;
+            dllName = (char*)malloc(sizeof(char) * (dNameLength + 1));
+            envret = GetEnvironmentVariableA(DLL_ENVIRONMENT_VAR,
+                                             dllName, dNameLength);
+            if (envret)
+            {
+                /* Try to load the dll from the PATH... */
+                m_libHandle = LoadLibraryA(dllName);
+            }
+            free(dllName);
+        }
+    }
+#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */
+    dllName = getenv(NEW_DLL_ENVIRONMENT_VAR);
+    if (!dllName)
+        dllName = getenv(DLL_ENVIRONMENT_VAR);
+#if defined(__ANDROID__) || defined(ANDROID)
+    if (!dllName)
+        dllName = ANDROID_JIT_AGENT_PATH;
+#endif
+    if (dllName)
+    {
+        /* Try to load the dll from the PATH... */
+        m_libHandle = dlopen(dllName, RTLD_LAZY);
+    }
+#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */
+
+    if (!m_libHandle)
+    {
+#if ITT_PLATFORM==ITT_PLATFORM_WIN
+        m_libHandle = LoadLibraryA(DEFAULT_DLLNAME);
+#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */
+        m_libHandle = dlopen(DEFAULT_DLLNAME, RTLD_LAZY);
+#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */
+    }
+
+    /* if the dll wasn't loaded - exit. */
+    if (!m_libHandle)
+    {
+        iJIT_DLL_is_missing = 1; /* don't try to initialize
+                                  * JIT agent the second time
+                                  */
+        return 0;
+    }
+
+#if ITT_PLATFORM==ITT_PLATFORM_WIN
+    FUNC_NotifyEvent = (TPNotify)GetProcAddress(m_libHandle, "NotifyEvent");
+#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */
+    FUNC_NotifyEvent = (TPNotify)dlsym(m_libHandle, "NotifyEvent");
+#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */
+    if (!FUNC_NotifyEvent)
+    {
+        FUNC_Initialize = NULL;
+        return 0;
+    }
+
+#if ITT_PLATFORM==ITT_PLATFORM_WIN
+    FUNC_Initialize = (TPInitialize)GetProcAddress(m_libHandle, "Initialize");
+#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */
+    FUNC_Initialize = (TPInitialize)dlsym(m_libHandle, "Initialize");
+#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */
+    if (!FUNC_Initialize)
+    {
+        FUNC_NotifyEvent = NULL;
+        return 0;
+    }
+
+    executionMode = (iJIT_IsProfilingActiveFlags)FUNC_Initialize();
+
+    bDllWasLoaded = 1;
+    iJIT_DLL_is_missing = 0; /* DLL is ok. */
+
+    /*
+     * Call Graph mode: init the thread local storage
+     * (need to store the virtual stack there).
+     */
+    if ( executionMode == iJIT_CALLGRAPH_ON )
+    {
+        /* Allocate a thread local storage slot for the thread "stack" */
+        if (!threadLocalStorageHandle)
+#if ITT_PLATFORM==ITT_PLATFORM_WIN
+            threadLocalStorageHandle = TlsAlloc();
+#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */
+        pthread_key_create(&threadLocalStorageHandle, NULL);
+#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */
+    }
+
+    return 1;
+}
+
+/*
+ * This function should be called by the user whenever a thread ends,
+ * to free the thread "virtual stack" storage
+ */
+ITT_EXTERN_C void JITAPI FinalizeThread()
+{
+    if (threadLocalStorageHandle)
+    {
+#if ITT_PLATFORM==ITT_PLATFORM_WIN
+        pThreadStack threadStack =
+            (pThreadStack)TlsGetValue (threadLocalStorageHandle);
+#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */
+        pThreadStack threadStack =
+            (pThreadStack)pthread_getspecific(threadLocalStorageHandle);
+#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */
+        if (threadStack)
+        {
+            free (threadStack);
+            threadStack = NULL;
+#if ITT_PLATFORM==ITT_PLATFORM_WIN
+            TlsSetValue (threadLocalStorageHandle, threadStack);
+#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */
+            pthread_setspecific(threadLocalStorageHandle, threadStack);
+#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */
+        }
+    }
+}
+
+/*
+ * This function should be called by the user when the process ends,
+ * to free the local storage index
+*/
+ITT_EXTERN_C void JITAPI FinalizeProcess()
+{
+    if (m_libHandle)
+    {
+#if ITT_PLATFORM==ITT_PLATFORM_WIN
+        FreeLibrary(m_libHandle);
+#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */
+        dlclose(m_libHandle);
+#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */
+        m_libHandle = NULL;
+    }
+
+    if (threadLocalStorageHandle)
+#if ITT_PLATFORM==ITT_PLATFORM_WIN
+        TlsFree (threadLocalStorageHandle);
+#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */
+    pthread_key_delete(threadLocalStorageHandle);
+#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */
+}
+
+/*
+ * This function should be called by the user for any method once.
+ * The function will return a unique method ID, the user should maintain
+ * the ID for each method
+ */
+ITT_EXTERN_C unsigned int JITAPI iJIT_GetNewMethodID()
+{
+    static unsigned int methodID = 0x100000;
+
+    if (methodID == 0)
+        return 0;  /* ERROR : this is not a valid value */
+
+    return methodID++;
+}
diff --git a/vm/compiler/vtune/JitProfiling.h b/vm/compiler/vtune/JitProfiling.h
new file mode 100644
index 0000000..0c4ed55
--- /dev/null
+++ b/vm/compiler/vtune/JitProfiling.h
@@ -0,0 +1,553 @@
+/*
+* Copyright (C) 2010-2012 Intel Corporation
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+*      http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+#ifndef __JITPROFILING_H__
+#define __JITPROFILING_H__
+
+/**
+ * @brief JIT Profiling APIs
+ *
+ * The JIT Profiling API is used to report information about just-in-time
+ * generated code that can be used by performance tools. The user inserts
+ * calls in the code generator to report information before JIT-compiled
+ * code goes to execution. This information is collected at runtime and used
+ * by tools like Intel(R) VTune(TM) Amplifier to display performance metrics
+ * associated with JIT-compiled code.
+ *
+ * These APIs can be used to\n
+ * - **Profile trace-based and method-based JIT-compiled
+ * code**. Some examples of environments that you can profile with these APIs:
+ * dynamic JIT compilation of JavaScript code traces, JIT execution in OpenCL(TM)
+ * software technology, Java/.NET managed execution environments, and custom
+ * ISV JIT engines.
+ * @code
+ * #include <jitprofiling.h>
+ *
+ * if (iJIT_IsProfilingActive != iJIT_SAMPLING_ON) {
+ *     return;
+ * }
+ *
+ * iJIT_Method_Load jmethod = {0};
+ * jmethod.method_id = iJIT_GetNewMethodID();
+ * jmethod.method_name = "method_name";
+ * jmethod.class_file_name = "class_name";
+ * jmethod.source_file_name = "source_file_name";
+ * jmethod.method_load_address = code_addr;
+ * jmethod.method_size = code_size;
+ *
+ * iJIT_NotifyEvent(iJVM_EVENT_TYPE_METHOD_LOAD_FINISHED, (void*)&jmethod);
+ * iJIT_NotifyEvent(iJVM_EVENT_TYPE_SHUTDOWN, NULL);
+ * @endcode
+ *
+ *  * Expected behavior:
+ *    * If any iJVM_EVENT_TYPE_METHOD_LOAD_FINISHED event overwrites an
+ *      already reported method, then such a method becomes invalid and its
+ *      memory region is treated as unloaded. VTune Amplifier displays the metrics
+ *      collected by the method until it is overwritten.
+ *    * If supplied line number information contains multiple source lines for
+ *      the same assembly instruction (code location), then VTune Amplifier picks up
+ *      the first line number.
+ *    * Dynamically generated code can be associated with a module name.
+ *      Use the iJIT_Method_Load_V2 structure.\n
+ *      Clarification of some cases:
+ *        * If you register a function with the same method ID multiple times,
+ *          specifying different module names, then the VTune Amplifier picks up
+ *          the module name registered first. If you want to distinguish the same
+ *          function between different JIT engines, supply different method IDs for
+ *          each function. Other symbolic information (for example, source file)
+ *          can be identical.
+ *
+ * - **Analyze split functions** (multiple joint or disjoint code regions
+ * belonging to the same function) **including re-JIT**
+ * with potential overlapping of code regions in time, which is common in
+ * resource-limited environments.
+ * @code
+ * #include <jitprofiling.h>
+ *
+ * unsigned int method_id = iJIT_GetNewMethodID();
+ *
+ * iJIT_Method_Load a = {0};
+ * a.method_id = method_id;
+ * a.method_load_address = 0x100;
+ * a.method_size = 0x20;
+ *
+ * iJIT_Method_Load b = {0};
+ * b.method_id = method_id;
+ * b.method_load_address = 0x200;
+ * b.method_size = 0x30;
+ *
+ * iJIT_NotifyEvent(iJVM_EVENT_TYPE_METHOD_LOAD_FINISHED, (void*)&a);
+ * iJIT_NotifyEvent(iJVM_EVENT_TYPE_METHOD_LOAD_FINISHED, (void*)&b);
+ * @endcode
+ *
+ *  * Expected behaviour:
+ *      * If a iJVM_EVENT_TYPE_METHOD_LOAD_FINISHED event overwrites an
+ *        already reported method, then such a method becomes invalid and
+ *        its memory region is treated as unloaded.
+ *      * All code regions reported with the same method ID are considered as
+ *        belonging to the same method. Symbolic information (method name,
+ *        source file name) will be taken from the first notification, and all
+ *        subsequent notifications with the same method ID will be processed
+ *        only for line number table information. So, the VTune Amplifier will map
+ *        samples to a source line using the line number table from the current
+ *        notification while taking the source file name from the very first one.\n
+ *        Clarification of some cases:\n
+ *          * If you register a second code region with a different source file
+ *          name and the same method ID, then this information will be saved and
+ *          will not be considered as an extension of the first code region, but
+ *          VTune Amplifier will use the source file of the first code region and map
+ *          performance metrics incorrectly.
+ *          * If you register a second code region with the same source file as
+ *          for the first region and the same method ID, then the source file will be
+ *          discarded but VTune Amplifier will map metrics to the source file correctly.
+ *          * If you register a second code region with a null source file and
+ *          the same method ID, then provided line number info will be associated
+ *          with the source file of the first code region.
+ *
+ * - **Explore inline functions** including multi-level hierarchy of
+ * nested inline methods which shows how performance metrics are distributed through them.
+ * @code
+ * #include <jitprofiling.h>
+ *
+ *  //                                    method_id   parent_id
+ *  //   [-- c --]                          3000        2000
+ *  //                  [---- d -----]      2001        1000
+ *  //  [---- b ----]                       2000        1000
+ *  // [------------ a ----------------]    1000         n/a
+ *
+ * iJIT_Method_Load a = {0};
+ * a.method_id = 1000;
+ *
+ * iJIT_Method_Inline_Load b = {0};
+ * b.method_id = 2000;
+ * b.parent_method_id = 1000;
+ *
+ * iJIT_Method_Inline_Load c = {0};
+ * c.method_id = 3000;
+ * c.parent_method_id = 2000;
+ *
+ * iJIT_Method_Inline_Load d = {0};
+ * d.method_id = 2001;
+ * d.parent_method_id = 1000;
+ *
+ * iJIT_NotifyEvent(iJVM_EVENT_TYPE_METHOD_LOAD_FINISHED, (void*)&a);
+ * iJIT_NotifyEvent(iJVM_EVENT_TYPE_METHOD_INLINE_LOAD_FINISHED, (void*)&b);
+ * iJIT_NotifyEvent(iJVM_EVENT_TYPE_METHOD_INLINE_LOAD_FINISHED, (void*)&c);
+ * iJIT_NotifyEvent(iJVM_EVENT_TYPE_METHOD_INLINE_LOAD_FINISHED, (void*)&d);
+ * @endcode
+ *
+ *  * Requirements:
+ *      * Each inline (iJIT_Method_Inline_Load) method should be associated
+ *        with two method IDs: one for itself; one for its immediate parent.
+ *      * Address regions of inline methods of the same parent method cannot
+ *        overlap each other.
+ *      * Execution of the parent method must not be started until it and all
+ *        its inline methods are reported.
+ *  * Expected behaviour:
+ *      * In case of nested inline methods an order of
+ *        iJVM_EVENT_TYPE_METHOD_INLINE_LOAD_FINISHED events is not important.
+ *      * If any event overwrites either inline method or top parent method,
+ *        then the parent, including inline methods, becomes invalid and its memory
+ *        region is treated as unloaded.
+ *
+ * **Life time of allocated data**\n
+ * The client sends an event notification to the agent with event-specific
+ * data, which is a structure. The pointers in the structure refer to memory
+ * allocated by the client, which responsible for releasing it. The pointers are
+ * used by the iJIT_NotifyEvent method to copy client's data in a trace file,
+ * and they are not used after the iJIT_NotifyEvent method returns.
+ *
+ */
+
+/**
+ * @defgroup jitapi JIT Profiling
+ * @ingroup internal
+ * @{
+ */
+
+/**
+ * @brief Enumerator for the types of notifications
+ */
+typedef enum iJIT_jvm_event
+{
+    iJVM_EVENT_TYPE_SHUTDOWN = 2,               /**<\brief Send this to shutdown the agent.
+                                                 * Use NULL for event data. */
+
+    iJVM_EVENT_TYPE_METHOD_LOAD_FINISHED = 13,  /**<\brief Send when dynamic code is
+                                                 * JIT compiled and loaded into
+                                                 * memory by the JIT engine, but
+                                                 * before the code is executed.
+                                                 * Use iJIT_Method_Load as event
+                                                 * data. */
+/** @cond exclude_from_documentation */
+    iJVM_EVENT_TYPE_METHOD_UNLOAD_START,    /**<\brief Send when compiled dynamic
+                                             * code is being unloaded from memory.
+                                             * Use iJIT_Method_Load as event data.*/
+/** @endcond */
+
+    iJVM_EVENT_TYPE_METHOD_UPDATE,   /**<\brief Send to provide new content for
+                                      * a previously reported dynamic code.
+                                      * The previous content will be invalidated
+                                      * starting from the time of the notification.
+                                      * Use iJIT_Method_Load as event data but
+                                      * required fields are following:
+                                      * - method_id    identify the code to update.
+                                      * - method_load_address    specify start address
+                                      *                          within identified code range
+                                      *                          where update should be started.
+                                      * - method_size            specify length of updated code
+                                      *                          range. */
+
+
+    iJVM_EVENT_TYPE_METHOD_INLINE_LOAD_FINISHED, /**<\brief Send when an inline dynamic
+                                                  * code is JIT compiled and loaded
+                                                  * into memory by the JIT engine,
+                                                  * but before the parent code region
+                                                  * starts executing.
+                                                  * Use iJIT_Method_Inline_Load as event data.*/
+
+/** @cond exclude_from_documentation */
+    /* Legacy stuff. Do not use it. */
+    iJVM_EVENT_TYPE_ENTER_NIDS = 19,
+    iJVM_EVENT_TYPE_LEAVE_NIDS,
+/** @endcond */
+
+    iJVM_EVENT_TYPE_METHOD_LOAD_FINISHED_V2  /**<\brief Send when a dynamic code is
+                                              * JIT compiled and loaded into
+                                              * memory by the JIT engine, but
+                                              * before the code is executed.
+                                              * Use iJIT_Method_Load_V2 as event
+                                              * data. */
+} iJIT_JVM_EVENT;
+
+/** @cond exclude_from_documentation */
+/* Legacy stuff. Do not use it. */
+typedef enum _iJIT_ModeFlags
+{
+    iJIT_NO_NOTIFICATIONS          = 0x0000,
+    iJIT_BE_NOTIFY_ON_LOAD         = 0x0001,
+    iJIT_BE_NOTIFY_ON_UNLOAD       = 0x0002,
+    iJIT_BE_NOTIFY_ON_METHOD_ENTRY = 0x0004,
+    iJIT_BE_NOTIFY_ON_METHOD_EXIT  = 0x0008
+
+} iJIT_ModeFlags;
+/** @endcond */
+
+/**
+ * @brief Enumerator for the agent's mode
+ */
+typedef enum _iJIT_IsProfilingActiveFlags
+{
+    iJIT_NOTHING_RUNNING           = 0x0000,    /**<\brief The agent is not running;
+                                                 * iJIT_NotifyEvent calls will
+                                                 * not be processed. */
+    iJIT_SAMPLING_ON               = 0x0001,    /**<\brief The agent is running and
+                                                 * ready to process notifications. */
+
+/** @cond exclude_from_documentation */
+    /* Legacy. Call Graph is running */
+    iJIT_CALLGRAPH_ON              = 0x0002
+/** @endcond */
+
+} iJIT_IsProfilingActiveFlags;
+
+/** @cond exclude_from_documentation */
+/* Legacy stuff. Do not use it. */
+typedef enum _iJDEnvironmentType
+{
+    iJDE_JittingAPI = 2
+
+} iJDEnvironmentType;
+
+typedef struct _iJIT_Method_Id
+{
+    unsigned int method_id;
+
+} *piJIT_Method_Id, iJIT_Method_Id;
+
+typedef struct _iJIT_Method_NIDS
+{
+    unsigned int method_id;     /**<\brief Unique method ID */
+    unsigned int stack_id;      /**<\brief NOTE: no need to fill this field,
+                                 * it's filled by VTune Amplifier */
+    char*  method_name;         /**<\brief Method name (just the method, without the class) */
+
+} *piJIT_Method_NIDS, iJIT_Method_NIDS;
+/** @endcond */
+
+/**
+ * @brief Description of a single entry in the line number information of a code region.
+ * @details A table of line number entries gives information about how the reported code region
+ * is mapped to source file.
+ * Intel(R) VTune(TM) Amplifier uses line number information to attribute
+ * the samples (virtual address) to a line number. \n
+ * It is acceptable to report different code addresses for the same source line:
+ * @code
+ *   Offset LineNumber
+ *      1       2
+ *      12      4
+ *      15      2
+ *      18      1
+ *      21      30
+ *
+ *  VTune Amplifier constructs the following table using the client data
+ *
+ *   Code subrange  Line number
+ *      0-1             2
+ *      1-12            4
+ *      12-15           2
+ *      15-18           1
+ *      18-21           30
+ * @endcode
+ */
+typedef struct _LineNumberInfo
+{
+    unsigned int Offset;     /**<\brief Offset from the begining of the code region. */
+    unsigned int LineNumber; /**<\brief Matching source line number offset (from beginning of source file). */
+
+} *pLineNumberInfo, LineNumberInfo;
+
+/**
+ * @brief Description of a JIT-compiled method
+ * @details When you use the iJIT_Method_Load structure to describe
+ *  the JIT compiled method, use iJVM_EVENT_TYPE_METHOD_LOAD_FINISHED
+ *  as an event type to report it.
+ */
+typedef struct _iJIT_Method_Load
+{
+    unsigned int method_id; /**<\brief Unique method ID.
+                             *  Method ID cannot be smaller than 999.
+                             *  You must either use the API function
+                             *  iJIT_GetNewMethodID to get a valid and unique
+                             *  method ID, or else manage ID uniqueness
+                             *  and correct range by yourself.\n
+                             *  You must use the same method ID for all code
+                             *  regions of the same method, otherwise different
+                             *  method IDs specify different methods. */
+
+    char* method_name; /**<\brief The name of the method. It can be optionally
+                        *  prefixed with its class name and appended with
+                        *  its complete signature. Can't be NULL. */
+
+    void* method_load_address; /**<\brief The start virtual address of the method code
+                                *  region. If NULL, data provided with
+                                *  event are not accepted. */
+
+    unsigned int method_size; /**<\brief The code size of the method in memory.
+                               *  If 0, then data provided with the event are not
+                               *  accepted. */
+
+    unsigned int line_number_size; /**<\brief The number of entries in the line number
+                                    *  table.0 if none. */
+
+    pLineNumberInfo line_number_table; /**<\brief Pointer to the line numbers info
+                                        *  array. Can be NULL if
+                                        *  line_number_size is 0. See
+                                        *  LineNumberInfo Structure for a
+                                        *  description of a single entry in
+                                        *  the line number info array */
+
+    unsigned int class_id; /**<\brief This field is obsolete. */
+
+    char* class_file_name; /**<\brief Class name. Can be NULL.*/
+
+    char* source_file_name; /**<\brief Source file name. Can be NULL.*/
+
+    void* user_data; /**<\brief This field is obsolete. */
+
+    unsigned int user_data_size; /**<\brief This field is obsolete. */
+
+    iJDEnvironmentType  env; /**<\brief This field is obsolete. */
+
+} *piJIT_Method_Load, iJIT_Method_Load;
+
+#pragma pack(push, 8)
+/**
+ * @brief Description of a JIT-compiled method
+ * @details When you use the iJIT_Method_Load_V2 structure to describe
+ *  the JIT compiled method, use iJVM_EVENT_TYPE_METHOD_LOAD_FINISHED_V2
+ *  as an event type to report it.
+ */
+typedef struct _iJIT_Method_Load_V2
+{
+    unsigned int method_id; /**<\brief Unique method ID.
+                             *  Method ID cannot be smaller than 999.
+                             *  You must either use the API function
+                             *  iJIT_GetNewMethodID to get a valid and unique
+                             *  method ID, or else manage ID uniqueness
+                             *  and correct range by yourself.\n
+                             *  You must use the same method ID for all code
+                             *  regions of the same method, otherwise different
+                             *  method IDs specify different methods. */
+
+    char* method_name; /**<\brief The name of the method. It can be optionally
+                        *  prefixed with its class name and appended with
+                        *  its complete signature. Can't be  NULL. */
+
+    void* method_load_address; /**<\brief The start virtual address of the method code
+                                *  region. If NULL, then data provided with the
+                                *  event are not accepted. */
+
+    unsigned int method_size; /**<\brief The code size of the method in memory.
+                               *  If 0, then data provided with the event are not
+                               *  accepted. */
+
+    unsigned int line_number_size; /**<\brief The number of entries in the line number
+                                    *  table. 0 if none. */
+
+    pLineNumberInfo line_number_table; /**<\brief Pointer to the line numbers info
+                                        *  array. Can be NULL if
+                                        *  line_number_size is 0. See
+                                        *  LineNumberInfo Structure for a
+                                        *  description of a single entry in
+                                        *  the line number info array. */
+
+    char* class_file_name; /**<\brief Class name. Can be NULL. */
+
+    char* source_file_name; /**<\brief Source file name. Can be NULL. */
+
+    char* module_name; /**<\brief Module name. Can be NULL.
+                           The module name can be useful for distinguishing among
+                           different JIT engines. VTune Amplifier will display
+                           reported methods grouped by specific module. */
+
+} *piJIT_Method_Load_V2, iJIT_Method_Load_V2;
+#pragma pack(pop)
+
+/**
+ * @brief Description of an inline JIT-compiled method
+ * @details When you use the_iJIT_Method_Inline_Load structure to describe
+ *  the JIT compiled method, use iJVM_EVENT_TYPE_METHOD_INLINE_LOAD_FINISHED
+ *  as an event type to report it.
+ */
+typedef struct _iJIT_Method_Inline_Load
+{
+    unsigned int method_id; /**<\brief Unique method ID.
+                             *  Method ID cannot be smaller than 999.
+                             *  You must either use the API function
+                             *  iJIT_GetNewMethodID to get a valid and unique
+                             *  method ID, or else manage ID uniqueness
+                             *  and correct range by yourself. */
+
+    unsigned int parent_method_id; /**<\brief Unique immediate parent's method ID.
+                                    *  Method ID may not be smaller than 999.
+                                    *  You must either use the API function
+                                    *  iJIT_GetNewMethodID to get a valid and unique
+                                    *  method ID, or else manage ID uniqueness
+                                    *  and correct range by yourself. */
+
+    char* method_name; /**<\brief The name of the method. It can be optionally
+                        *  prefixed with its class name and appended with
+                        *  its complete signature. Can't be NULL. */
+
+    void* method_load_address;  /** <\brief The virtual address on which the method
+                                 *  is inlined. If NULL, then data provided with
+                                 *  the event are not accepted. */
+
+    unsigned int method_size; /**<\brief The code size of the method in memory.
+                               *  If 0, then data provided with the event are not
+                               *  accepted. */
+
+    unsigned int line_number_size; /**<\brief The number of entries in the line number
+                                    *  table. 0 if none. */
+
+    pLineNumberInfo line_number_table; /**<\brief Pointer to the line numbers info
+                                        *  array. Can be NULL if
+                                        *  line_number_size is 0. See
+                                        *  LineNumberInfo Structure for a
+                                        *  description of a single entry in
+                                        *  the line number info array */
+
+    char* class_file_name; /**<\brief Class name. Can be NULL.*/
+
+    char* source_file_name; /**<\brief Source file name. Can be NULL.*/
+
+} *piJIT_Method_Inline_Load, iJIT_Method_Inline_Load;
+
+/** @cond exclude_from_documentation */
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+#ifndef CDECL
+#  if defined WIN32 || defined _WIN32
+#    define CDECL __cdecl
+#  else /* defined WIN32 || defined _WIN32 */
+#    if defined _M_IX86 || defined __i386__
+#      define CDECL __attribute__ ((cdecl))
+#    else  /* _M_IX86 || __i386__ */
+#      define CDECL /* actual only on x86_64 platform */
+#    endif /* _M_IX86 || __i386__ */
+#  endif /* defined WIN32 || defined _WIN32 */
+#endif /* CDECL */
+
+#define JITAPI CDECL
+/** @endcond */
+
+/**
+ * @brief Generates a new unique method ID.
+ *
+ * You must use this API to obtain unique and valid method IDs for methods or
+ * traces reported to the agent if you don't have your own mechanism to generate
+ * unique method IDs.
+ *
+ * @return a new unique method ID. When out of unique method IDs, this API
+ * returns 0, which is not an accepted value.
+ */
+unsigned int JITAPI iJIT_GetNewMethodID(void);
+
+/**
+ * @brief Returns the current mode of the agent.
+ *
+ * @return iJIT_SAMPLING_ON, indicating that agent is running, or
+ * iJIT_NOTHING_RUNNING if no agent is running.
+ */
+iJIT_IsProfilingActiveFlags JITAPI iJIT_IsProfilingActive(void);
+
+/**
+ * @brief Reports infomation about JIT-compiled code to the agent.
+ *
+ * The reported information is used to attribute samples obtained from any
+ * Intel(R) VTune(TM) Amplifier collector. This API needs to be called
+ * after JIT compilation and before the first entry into the JIT-compiled
+ * code.
+ *
+ * @param[in] event_type - type of the data sent to the agent
+ * @param[in] EventSpecificData - pointer to event-specific data
+ *
+ * @returns 1 on success, otherwise 0.
+ */
+int JITAPI iJIT_NotifyEvent(iJIT_JVM_EVENT event_type, void *EventSpecificData);
+
+/** @cond exclude_from_documentation */
+/*
+ * Do not use these legacy APIs, which are here for backward compatibility
+ * with Intel(R) VTune(TM) Performance Analyzer.
+ */
+typedef void (*iJIT_ModeChangedEx)(void *UserData, iJIT_ModeFlags Flags);
+void JITAPI iJIT_RegisterCallbackEx(void *userdata,
+                                    iJIT_ModeChangedEx NewModeCallBackFuncEx);
+void JITAPI FinalizeThread(void);
+void JITAPI FinalizeProcess(void);
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+/** @endcond */
+
+/** @} jitapi group */
+
+#endif /* __JITPROFILING_H__ */
diff --git a/vm/compiler/vtune/ittnotify_config.h b/vm/compiler/vtune/ittnotify_config.h
new file mode 100644
index 0000000..69384de
--- /dev/null
+++ b/vm/compiler/vtune/ittnotify_config.h
@@ -0,0 +1,459 @@
+/*
+* Copyright (C) 2010-2012 Intel Corporation
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+*      http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+#ifndef _ITTNOTIFY_CONFIG_H_
+#define _ITTNOTIFY_CONFIG_H_
+
+/** @cond exclude_from_documentation */
+#ifndef ITT_OS_WIN
+#  define ITT_OS_WIN   1
+#endif /* ITT_OS_WIN */
+
+#ifndef ITT_OS_LINUX
+#  define ITT_OS_LINUX 2
+#endif /* ITT_OS_LINUX */
+
+#ifndef ITT_OS_MAC
+#  define ITT_OS_MAC   3
+#endif /* ITT_OS_MAC */
+
+#ifndef ITT_OS
+#  if defined WIN32 || defined _WIN32
+#    define ITT_OS ITT_OS_WIN
+#  elif defined( __APPLE__ ) && defined( __MACH__ )
+#    define ITT_OS ITT_OS_MAC
+#  else
+#    define ITT_OS ITT_OS_LINUX
+#  endif
+#endif /* ITT_OS */
+
+#ifndef ITT_PLATFORM_WIN
+#  define ITT_PLATFORM_WIN 1
+#endif /* ITT_PLATFORM_WIN */
+
+#ifndef ITT_PLATFORM_POSIX
+#  define ITT_PLATFORM_POSIX 2
+#endif /* ITT_PLATFORM_POSIX */
+
+#ifndef ITT_PLATFORM
+#  if ITT_OS==ITT_OS_WIN
+#    define ITT_PLATFORM ITT_PLATFORM_WIN
+#  else
+#    define ITT_PLATFORM ITT_PLATFORM_POSIX
+#  endif /* _WIN32 */
+#endif /* ITT_PLATFORM */
+
+#if defined(_UNICODE) && !defined(UNICODE)
+#define UNICODE
+#endif
+
+#include <stddef.h>
+#if ITT_PLATFORM==ITT_PLATFORM_WIN
+#include <tchar.h>
+#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */
+#include <stdint.h>
+#if defined(UNICODE) || defined(_UNICODE)
+#include <wchar.h>
+#endif /* UNICODE || _UNICODE */
+#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */
+
+#ifndef CDECL
+#  if ITT_PLATFORM==ITT_PLATFORM_WIN
+#    define CDECL __cdecl
+#  else /* ITT_PLATFORM==ITT_PLATFORM_WIN */
+#    if defined _M_IX86 || defined __i386__
+#      define CDECL __attribute__ ((cdecl))
+#    else  /* _M_IX86 || __i386__ */
+#      define CDECL /* actual only on x86 platform */
+#    endif /* _M_IX86 || __i386__ */
+#  endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */
+#endif /* CDECL */
+
+#ifndef STDCALL
+#  if ITT_PLATFORM==ITT_PLATFORM_WIN
+#    define STDCALL __stdcall
+#  else /* ITT_PLATFORM==ITT_PLATFORM_WIN */
+#    if defined _M_IX86 || defined __i386__
+#      define STDCALL __attribute__ ((stdcall)) 
+#    else  /* _M_IX86 || __i386__ */
+#      define STDCALL /* supported only on x86 platform */
+#    endif /* _M_IX86 || __i386__ */
+#  endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */
+#endif /* STDCALL */
+
+#define ITTAPI    CDECL
+#define LIBITTAPI CDECL
+
+/* TODO: Temporary for compatibility! */
+#define ITTAPI_CALL    CDECL
+#define LIBITTAPI_CALL CDECL
+
+#if ITT_PLATFORM==ITT_PLATFORM_WIN
+/* use __forceinline (VC++ specific) */
+#define ITT_INLINE           __forceinline
+#define ITT_INLINE_ATTRIBUTE /* nothing */
+#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */
+/*
+ * Generally, functions are not inlined unless optimization is specified.
+ * For functions declared inline, this attribute inlines the function even
+ * if no optimization level was specified.
+ */
+#ifdef __STRICT_ANSI__
+#define ITT_INLINE           static
+#else  /* __STRICT_ANSI__ */
+#define ITT_INLINE           static inline
+#endif /* __STRICT_ANSI__ */
+#define ITT_INLINE_ATTRIBUTE __attribute__ ((always_inline, unused))
+#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */
+/** @endcond */
+
+#ifndef ITT_ARCH_IA32
+#  define ITT_ARCH_IA32  1
+#endif /* ITT_ARCH_IA32 */
+
+#ifndef ITT_ARCH_IA32E
+#  define ITT_ARCH_IA32E 2
+#endif /* ITT_ARCH_IA32E */
+
+#ifndef ITT_ARCH_ARM
+#  define ITT_ARCH_ARM  4
+#endif /* ITT_ARCH_ARM */
+
+#ifndef ITT_ARCH
+#  if defined _M_IX86 || defined __i386__
+#    define ITT_ARCH ITT_ARCH_IA32
+#  elif defined _M_X64 || defined _M_AMD64 || defined __x86_64__
+#    define ITT_ARCH ITT_ARCH_IA32E
+#  elif defined _M_IA64 || defined __ia64__
+#    define ITT_ARCH ITT_ARCH_IA64
+#  elif defined _M_ARM || __arm__
+#    define ITT_ARCH ITT_ARCH_ARM
+#  endif
+#endif
+
+#ifdef __cplusplus
+#  define ITT_EXTERN_C extern "C"
+#else
+#  define ITT_EXTERN_C /* nothing */
+#endif /* __cplusplus */
+
+#define ITT_TO_STR_AUX(x) #x
+#define ITT_TO_STR(x)     ITT_TO_STR_AUX(x)
+
+#define __ITT_BUILD_ASSERT(expr, suffix) do { \
+    static char __itt_build_check_##suffix[(expr) ? 1 : -1]; \
+    __itt_build_check_##suffix[0] = 0; \
+} while(0)
+#define _ITT_BUILD_ASSERT(expr, suffix)  __ITT_BUILD_ASSERT((expr), suffix)
+#define ITT_BUILD_ASSERT(expr)           _ITT_BUILD_ASSERT((expr), __LINE__)
+
+#define ITT_MAGIC { 0xED, 0xAB, 0xAB, 0xEC, 0x0D, 0xEE, 0xDA, 0x30 }
+
+/* Replace with snapshot date YYYYMMDD for promotion build. */
+#define API_VERSION_BUILD    20111111
+
+#ifndef API_VERSION_NUM
+#define API_VERSION_NUM 0.0.0
+#endif /* API_VERSION_NUM */
+
+#define API_VERSION "ITT-API-Version " ITT_TO_STR(API_VERSION_NUM) \
+                                " (" ITT_TO_STR(API_VERSION_BUILD) ")"
+
+/* OS communication functions */
+#if ITT_PLATFORM==ITT_PLATFORM_WIN
+#include <windows.h>
+typedef HMODULE           lib_t;
+typedef DWORD             TIDT;
+typedef CRITICAL_SECTION  mutex_t;
+#define MUTEX_INITIALIZER { 0 }
+#define strong_alias(name, aliasname) /* empty for Windows */
+#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */
+#include <dlfcn.h>
+#if defined(UNICODE) || defined(_UNICODE)
+#include <wchar.h>
+#endif /* UNICODE */
+#ifndef _GNU_SOURCE
+#define _GNU_SOURCE 1 /* need for PTHREAD_MUTEX_RECURSIVE */
+#endif /* _GNU_SOURCE */
+#ifndef __USE_UNIX98
+#define __USE_UNIX98 1 /* need for PTHREAD_MUTEX_RECURSIVE, on SLES11.1 with gcc 4.3.4 wherein pthread.h missing dependency on __USE_XOPEN2K8 */
+#endif /*__USE_UNIX98*/
+#include <pthread.h>
+typedef void*             lib_t;
+typedef pthread_t         TIDT;
+typedef pthread_mutex_t   mutex_t;
+#define MUTEX_INITIALIZER PTHREAD_MUTEX_INITIALIZER
+#define _strong_alias(name, aliasname) \
+            extern __typeof (name) aliasname __attribute__ ((alias (#name)));
+#define strong_alias(name, aliasname) _strong_alias(name, aliasname)
+#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */
+
+#if ITT_PLATFORM==ITT_PLATFORM_WIN
+#define __itt_get_proc(lib, name) GetProcAddress(lib, name)
+#define __itt_mutex_init(mutex)   InitializeCriticalSection(mutex)
+#define __itt_mutex_lock(mutex)   EnterCriticalSection(mutex)
+#define __itt_mutex_unlock(mutex) LeaveCriticalSection(mutex)
+#define __itt_load_lib(name)      LoadLibraryA(name)
+#define __itt_unload_lib(handle)  FreeLibrary(handle)
+#define __itt_system_error()      (int)GetLastError()
+#define __itt_fstrcmp(s1, s2)     lstrcmpA(s1, s2)
+#define __itt_fstrlen(s)          lstrlenA(s)
+#define __itt_fstrcpyn(s1, s2, l) lstrcpynA(s1, s2, l)
+#define __itt_fstrdup(s)          _strdup(s)
+#define __itt_thread_id()         GetCurrentThreadId()
+#define __itt_thread_yield()      SwitchToThread()
+#ifndef ITT_SIMPLE_INIT
+ITT_INLINE long
+__itt_interlocked_increment(volatile long* ptr) ITT_INLINE_ATTRIBUTE;
+ITT_INLINE long __itt_interlocked_increment(volatile long* ptr)
+{
+    return InterlockedIncrement(ptr);
+}
+#endif /* ITT_SIMPLE_INIT */
+#else /* ITT_PLATFORM!=ITT_PLATFORM_WIN */
+#define __itt_get_proc(lib, name) dlsym(lib, name)
+#define __itt_mutex_init(mutex)   {\
+    pthread_mutexattr_t mutex_attr;                                         \
+    int error_code = pthread_mutexattr_init(&mutex_attr);                   \
+    if (error_code)                                                         \
+        __itt_report_error(__itt_error_system, "pthread_mutexattr_init",    \
+                           error_code);                                     \
+    error_code = pthread_mutexattr_settype(&mutex_attr,                     \
+                                           PTHREAD_MUTEX_RECURSIVE);        \
+    if (error_code)                                                         \
+        __itt_report_error(__itt_error_system, "pthread_mutexattr_settype", \
+                           error_code);                                     \
+    error_code = pthread_mutex_init(mutex, &mutex_attr);                    \
+    if (error_code)                                                         \
+        __itt_report_error(__itt_error_system, "pthread_mutex_init",        \
+                           error_code);                                     \
+    error_code = pthread_mutexattr_destroy(&mutex_attr);                    \
+    if (error_code)                                                         \
+        __itt_report_error(__itt_error_system, "pthread_mutexattr_destroy", \
+                           error_code);                                     \
+}
+#define __itt_mutex_lock(mutex)   pthread_mutex_lock(mutex)
+#define __itt_mutex_unlock(mutex) pthread_mutex_unlock(mutex)
+#define __itt_load_lib(name)      dlopen(name, RTLD_LAZY)
+#define __itt_unload_lib(handle)  dlclose(handle)
+#define __itt_system_error()      errno
+#define __itt_fstrcmp(s1, s2)     strcmp(s1, s2)
+#define __itt_fstrlen(s)          strlen(s)
+#define __itt_fstrcpyn(s1, s2, l) strncpy(s1, s2, l)
+#define __itt_fstrdup(s)          strdup(s)
+#define __itt_thread_id()         pthread_self()
+#define __itt_thread_yield()      sched_yield()
+#if ITT_ARCH==ITT_ARCH_IA64
+#ifdef __INTEL_COMPILER
+#define __TBB_machine_fetchadd4(addr, val) __fetchadd4_acq((void *)addr, val)
+#else  /* __INTEL_COMPILER */
+/* TODO: Add Support for not Intel compilers for IA64 */
+#endif /* __INTEL_COMPILER */
+#elif ITT_ARCH==ITT_ARCH_IA32 || ITT_ARCH==ITT_ARCH_IA32E /* ITT_ARCH!=ITT_ARCH_IA64 */
+ITT_INLINE long
+__TBB_machine_fetchadd4(volatile void* ptr, long addend) ITT_INLINE_ATTRIBUTE;
+ITT_INLINE long __TBB_machine_fetchadd4(volatile void* ptr, long addend)
+{
+    long result;
+    __asm__ __volatile__("lock\nxadd %0,%1"
+                          : "=r"(result),"=m"(*(long*)ptr)
+                          : "0"(addend), "m"(*(long*)ptr)
+                          : "memory");
+    return result;
+}
+#elif ITT_ARCH==ITT_ARCH_ARM
+#define __TBB_machine_fetchadd4(addr, val) __sync_fetch_and_add(addr, val)
+#endif /* ITT_ARCH==ITT_ARCH_IA64 */
+#ifndef ITT_SIMPLE_INIT
+ITT_INLINE long
+__itt_interlocked_increment(volatile long* ptr) ITT_INLINE_ATTRIBUTE;
+ITT_INLINE long __itt_interlocked_increment(volatile long* ptr)
+{
+    return __TBB_machine_fetchadd4(ptr, 1) + 1L;
+}
+#endif /* ITT_SIMPLE_INIT */
+#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */
+
+typedef enum {
+    __itt_collection_normal = 0,
+    __itt_collection_paused = 1
+} __itt_collection_state;
+
+typedef enum {
+    __itt_thread_normal  = 0,
+    __itt_thread_ignored = 1
+} __itt_thread_state;
+
+#pragma pack(push, 8)
+
+typedef struct ___itt_thread_info
+{
+    const char* nameA; /*!< Copy of original name in ASCII. */
+#if defined(UNICODE) || defined(_UNICODE)
+    const wchar_t* nameW; /*!< Copy of original name in UNICODE. */
+#else  /* UNICODE || _UNICODE */
+    void* nameW;
+#endif /* UNICODE || _UNICODE */
+    TIDT               tid;
+    __itt_thread_state state;   /*!< Thread state (paused or normal) */
+    int                extra1;  /*!< Reserved to the runtime */
+    void*              extra2;  /*!< Reserved to the runtime */
+    struct ___itt_thread_info* next;
+} __itt_thread_info;
+
+#include "ittnotify_types.h" /* For __itt_group_id definition */
+
+typedef struct ___itt_api_info_20101001
+{
+    const char*    name;
+    void**         func_ptr;
+    void*          init_func;
+    __itt_group_id group;
+}  __itt_api_info_20101001;
+
+typedef struct ___itt_api_info
+{
+    const char*    name;
+    void**         func_ptr;
+    void*          init_func;
+    void*          null_func;
+    __itt_group_id group;
+}  __itt_api_info;
+
+struct ___itt_domain;
+struct ___itt_string_handle;
+
+typedef struct ___itt_global
+{
+    unsigned char          magic[8];
+    unsigned long          version_major;
+    unsigned long          version_minor;
+    unsigned long          version_build;
+    volatile long          api_initialized;
+    volatile long          mutex_initialized;
+    volatile long          atomic_counter;
+    mutex_t                mutex;
+    lib_t                  lib;
+    void*                  error_handler;
+    const char**           dll_path_ptr;
+    __itt_api_info*        api_list_ptr;
+    struct ___itt_global*  next;
+    /* Joinable structures below */
+    __itt_thread_info*     thread_list;
+    struct ___itt_domain*  domain_list;
+    struct ___itt_string_handle* string_list;
+    __itt_collection_state state;
+} __itt_global;
+
+#pragma pack(pop)
+
+#define NEW_THREAD_INFO_W(gptr,h,h_tail,t,s,n) { \
+    h = (__itt_thread_info*)malloc(sizeof(__itt_thread_info)); \
+    if (h != NULL) { \
+        h->tid    = t; \
+        h->nameA  = NULL; \
+        h->nameW  = n ? _wcsdup(n) : NULL; \
+        h->state  = s; \
+        h->extra1 = 0;    /* reserved */ \
+        h->extra2 = NULL; /* reserved */ \
+        h->next   = NULL; \
+        if (h_tail == NULL) \
+            (gptr)->thread_list = h; \
+        else \
+            h_tail->next = h; \
+    } \
+}
+
+#define NEW_THREAD_INFO_A(gptr,h,h_tail,t,s,n) { \
+    h = (__itt_thread_info*)malloc(sizeof(__itt_thread_info)); \
+    if (h != NULL) { \
+        h->tid    = t; \
+        h->nameA  = n ? __itt_fstrdup(n) : NULL; \
+        h->nameW  = NULL; \
+        h->state  = s; \
+        h->extra1 = 0;    /* reserved */ \
+        h->extra2 = NULL; /* reserved */ \
+        h->next   = NULL; \
+        if (h_tail == NULL) \
+            (gptr)->thread_list = h; \
+        else \
+            h_tail->next = h; \
+    } \
+}
+
+#define NEW_DOMAIN_W(gptr,h,h_tail,name) { \
+    h = (__itt_domain*)malloc(sizeof(__itt_domain)); \
+    if (h != NULL) { \
+        h->flags  = 0;    /* domain is disabled by default */ \
+        h->nameA  = NULL; \
+        h->nameW  = name ? _wcsdup(name) : NULL; \
+        h->extra1 = 0;    /* reserved */ \
+        h->extra2 = NULL; /* reserved */ \
+        h->next   = NULL; \
+        if (h_tail == NULL) \
+            (gptr)->domain_list = h; \
+        else \
+            h_tail->next = h; \
+    } \
+}
+
+#define NEW_DOMAIN_A(gptr,h,h_tail,name) { \
+    h = (__itt_domain*)malloc(sizeof(__itt_domain)); \
+    if (h != NULL) { \
+        h->flags  = 0;    /* domain is disabled by default */ \
+        h->nameA  = name ? __itt_fstrdup(name) : NULL; \
+        h->nameW  = NULL; \
+        h->extra1 = 0;    /* reserved */ \
+        h->extra2 = NULL; /* reserved */ \
+        h->next   = NULL; \
+        if (h_tail == NULL) \
+            (gptr)->domain_list = h; \
+        else \
+            h_tail->next = h; \
+    } \
+}
+
+#define NEW_STRING_HANDLE_W(gptr,h,h_tail,name) { \
+    h = (__itt_string_handle*)malloc(sizeof(__itt_string_handle)); \
+    if (h != NULL) { \
+        h->strA   = NULL; \
+        h->strW   = name ? _wcsdup(name) : NULL; \
+        h->extra1 = 0;    /* reserved */ \
+        h->extra2 = NULL; /* reserved */ \
+        h->next   = NULL; \
+        if (h_tail == NULL) \
+            (gptr)->string_list = h; \
+        else \
+            h_tail->next = h; \
+    } \
+}
+
+#define NEW_STRING_HANDLE_A(gptr,h,h_tail,name) { \
+    h = (__itt_string_handle*)malloc(sizeof(__itt_string_handle)); \
+    if (h != NULL) { \
+        h->strA   = name ? __itt_fstrdup(name) : NULL; \
+        h->strW   = NULL; \
+        h->extra1 = 0;    /* reserved */ \
+        h->extra2 = NULL; /* reserved */ \
+        h->next   = NULL; \
+        if (h_tail == NULL) \
+            (gptr)->string_list = h; \
+        else \
+            h_tail->next = h; \
+    } \
+}
+
+#endif /* _ITTNOTIFY_CONFIG_H_ */
diff --git a/vm/compiler/vtune/ittnotify_types.h b/vm/compiler/vtune/ittnotify_types.h
new file mode 100644
index 0000000..b5550b1
--- /dev/null
+++ b/vm/compiler/vtune/ittnotify_types.h
@@ -0,0 +1,73 @@
+/*
+* Copyright (C) 2010-2012 Intel Corporation
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+*      http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+#ifndef _ITTNOTIFY_TYPES_H_
+#define _ITTNOTIFY_TYPES_H_
+
+typedef enum ___itt_group_id
+{
+    __itt_group_none      = 0,
+    __itt_group_legacy    = 1<<0,
+    __itt_group_control   = 1<<1,
+    __itt_group_thread    = 1<<2,
+    __itt_group_mark      = 1<<3,
+    __itt_group_sync      = 1<<4,
+    __itt_group_fsync     = 1<<5,
+    __itt_group_jit       = 1<<6,
+    __itt_group_model     = 1<<7,
+    __itt_group_splitter_min = 1<<7,
+    __itt_group_counter   = 1<<8,
+    __itt_group_frame     = 1<<9,
+    __itt_group_stitch    = 1<<10,
+    __itt_group_heap      = 1<<11,
+    __itt_group_splitter_max = 1<<12,
+    __itt_group_structure = 1<<12,
+    __itt_group_suppress = 1<<13,
+    __itt_group_arrays    = 1<<14,
+    __itt_group_all       = -1
+} __itt_group_id;
+
+#pragma pack(push, 8)
+
+typedef struct ___itt_group_list
+{
+    __itt_group_id id;
+    const char*    name;
+} __itt_group_list;
+
+#pragma pack(pop)
+
+#define ITT_GROUP_LIST(varname) \
+    static __itt_group_list varname[] = {       \
+        { __itt_group_all,       "all"       }, \
+        { __itt_group_control,   "control"   }, \
+        { __itt_group_thread,    "thread"    }, \
+        { __itt_group_mark,      "mark"      }, \
+        { __itt_group_sync,      "sync"      }, \
+        { __itt_group_fsync,     "fsync"     }, \
+        { __itt_group_jit,       "jit"       }, \
+        { __itt_group_model,     "model"     }, \
+        { __itt_group_counter,   "counter"   }, \
+        { __itt_group_frame,     "frame"     }, \
+        { __itt_group_stitch,    "stitch"    }, \
+        { __itt_group_heap,      "heap"      }, \
+        { __itt_group_structure, "structure" }, \
+        { __itt_group_suppress,  "suppress"  }, \
+        { __itt_group_arrays,    "arrays"    }, \
+        { __itt_group_none,      NULL        }  \
+    }
+
+#endif /* _ITTNOTIFY_TYPES_H_ */
-- 
1.7.4.1

