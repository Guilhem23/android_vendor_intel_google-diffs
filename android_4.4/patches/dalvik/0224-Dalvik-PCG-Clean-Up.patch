From 560f48898668f69386e37768b676ba583f4d56fb Mon Sep 17 00:00:00 2001
From: Jean Christophe Beyler <jean.christophe.beyler@intel.com>
Date: Fri, 14 Jun 2013 16:44:44 -0700
Subject: Dalvik: PCG Clean-Up

BZ: 116713

Cleaning up the PCG backend.

Category: device-enablement
Domain: AOSP-Dalvik-Compiler-CG
Origin: internal
Upstream-Candidate: no, needs rework

Change-Id: Ib5773aa61adbcf3fd5ed89afa579911982012c26
Orig-MCG-Change-Id: I757b51f98c3257aa095abcc507047b6744b8410d
Signed-off-by: Jean Christophe Beyler <jean.christophe.beyler@intel.com>
Signed-off-by: Qiming Shi <qiming.shi@intel.com>
Signed-off-by: Serguei Katkov <serguei.i.katkov@intel.com>
---
 vm/compiler/codegen/x86/pcg/Analysis.cpp           |   47 +++--
 vm/compiler/codegen/x86/pcg/Analysis.h             |    3 +-
 vm/compiler/codegen/x86/pcg/Android.mk             |    4 +-
 .../codegen/x86/pcg/ChainingCellException.cpp      |   39 +---
 .../codegen/x86/pcg/ChainingCellException.h        |   14 -
 vm/compiler/codegen/x86/pcg/CodeGeneration.cpp     |  256 +++++++------------
 vm/compiler/codegen/x86/pcg/CompilationUnitPCG.cpp |   11 +-
 vm/compiler/codegen/x86/pcg/CompilationUnitPCG.h   |   13 +-
 vm/compiler/codegen/x86/pcg/Labels.cpp             |   12 +-
 vm/compiler/codegen/x86/pcg/Labels.h               |   15 +-
 vm/compiler/codegen/x86/pcg/LowerALU.cpp           |   45 +----
 vm/compiler/codegen/x86/pcg/LowerALU.h             |   33 +--
 vm/compiler/codegen/x86/pcg/LowerCall.cpp          |  140 ++---------
 vm/compiler/codegen/x86/pcg/LowerCall.h            |   21 +--
 vm/compiler/codegen/x86/pcg/LowerJump.cpp          |   21 ++-
 vm/compiler/codegen/x86/pcg/LowerJump.h            |    9 +-
 vm/compiler/codegen/x86/pcg/LowerMemory.h          |    5 +-
 vm/compiler/codegen/x86/pcg/LowerOther.cpp         |    8 +-
 vm/compiler/codegen/x86/pcg/PcgInterface.cpp       |   53 ++--
 vm/compiler/codegen/x86/pcg/Utility.cpp            |  155 +++++++++++--
 vm/compiler/codegen/x86/pcg/Utility.h              |    9 +
 vm/compiler/codegen/x86/pcg/libpcg.h               |    2 +-
 22 files changed, 412 insertions(+), 503 deletions(-)

diff --git a/vm/compiler/codegen/x86/pcg/Analysis.cpp b/vm/compiler/codegen/x86/pcg/Analysis.cpp
index 3ed6620..8f723ff 100644
--- a/vm/compiler/codegen/x86/pcg/Analysis.cpp
+++ b/vm/compiler/codegen/x86/pcg/Analysis.cpp
@@ -159,8 +159,9 @@ static void pcgMergeSSANums (CompilationUnitPCG *cUnit, int childNum, int parent
  * @brief Analyze the execute inline opcode
  * @param cUnit the CompilationUnitPCG
  * @param mir the MIR instruction
+ * @return whether we succeeded or not
  */
-static void pcgAnalyzeExecuteInline (CompilationUnitPCG *cUnit, MIR *mir)
+static bool pcgAnalyzeExecuteInline (CompilationUnitPCG *cUnit, MIR *mir)
 {
     //vB holds the index for intrinsic
     NativeInlineOps op = (NativeInlineOps) (mir->dalvikInsn.vB);
@@ -217,9 +218,10 @@ static void pcgAnalyzeExecuteInline (CompilationUnitPCG *cUnit, MIR *mir)
         default:
             //TODO: use the error framework
             ALOGI ("+++ PCG Error +++ Unsupported execute inline routine\n");
-            exit (-1);
-            break;
+            return false;
     }
+
+    return true;
 }
 
 /**
@@ -422,15 +424,19 @@ static void pcgAvoidDeferredWritebacks (CompilationUnitPCG *cUnit)
         }
     }
 
-    //TODO clean the loop to not have an affection in it
     dvmBitVectorIteratorInit (tempBV, &it);
-    while ( (ssaNum = dvmBitVectorIteratorNext (&it)) != -1)
+    ssaNum = dvmBitVectorIteratorNext (&it);
+
+    while (ssaNum != -1)
     {
         //Get information
         SSANumInfo &info = cUnit->getSSANumInformation (ssaNum);
 
         //Update deferment
         info.deferWriteback = false;
+
+        //Get next number
+        ssaNum = dvmBitVectorIteratorNext (&it);
     }
 
     cUnit->freeTemporaryBitVector (tempBV);
@@ -442,17 +448,15 @@ void dvmCompilerPcgApplyRegisterizationHeuristics (CompilationUnitPCG *cUnit, in
     u2 vrSub = 0;  // These initializations are unnecessary, but they avoid
     u2 vrNum = 0;  // a compiler warning about "may be used uninitialized".
 
-    if (cUnit->checkOptimizationMask (OptimizationMaskRegisterizeVRs) == true)
+    if (cUnit->checkDebugMask (DebugMaskRegisterizeVRs) == true)
     {
-        //TODO handle these dynamic_casts better
-        int dalvikReg = dvmConvertSSARegToDalvik (
-                dynamic_cast<CompilationUnit *> (cUnit),
-                ssaNum);
+        CompilationUnit *simpleCUnit = dynamic_cast<CompilationUnit *> (cUnit);
+        int dalvikReg = dvmConvertSSARegToDalvik (simpleCUnit, ssaNum);
         vrNum = DECODE_REG (dalvikReg);
         vrSub = DECODE_SUB (dalvikReg);
     }
 
-    if (!dvmExtractBackendOption ("zheur", &zheur))
+    if (dvmExtractBackendOption ("zheur", &zheur) == false)
     {
         zheur = 0;
     }
@@ -464,7 +468,7 @@ void dvmCompilerPcgApplyRegisterizationHeuristics (CompilationUnitPCG *cUnit, in
                 info.needsNullCheck == false)
         {
             cUnit->disableRegisterizationForDef (ssaNum);
-            if (cUnit->checkOptimizationMask (OptimizationMaskRegisterizeVRs) == true)
+            if (cUnit->checkDebugMask (DebugMaskRegisterizeVRs) == true)
 
             {
                 ALOGI ("    Register v%d_%d [ssanum : %d]. NOT registerized globally. Z-heuristics (1).\n", vrNum, vrSub, ssaNum);
@@ -472,7 +476,7 @@ void dvmCompilerPcgApplyRegisterizationHeuristics (CompilationUnitPCG *cUnit, in
         }
         else
         {
-            if (cUnit->checkOptimizationMask (OptimizationMaskRegisterizeVRs) == true)
+            if (cUnit->checkDebugMask (DebugMaskRegisterizeVRs) == true)
 
             {
                 ALOGI ("    Register v%d_%d [ssanum : %d]. Registerized globally. Escaped Z-heuristics (1).\n", vrNum, vrSub, ssaNum);
@@ -480,7 +484,7 @@ void dvmCompilerPcgApplyRegisterizationHeuristics (CompilationUnitPCG *cUnit, in
         }
     }
 
-    if (cUnit->checkOptimizationMask (OptimizationMaskRegisterizeVRs) == true)
+    if (cUnit->checkDebugMask (DebugMaskRegisterizeVRs) == true)
     {
         //Get information
         SSANumInfo &info = cUnit->getSSANumInformation (ssaNum);
@@ -492,7 +496,7 @@ void dvmCompilerPcgApplyRegisterizationHeuristics (CompilationUnitPCG *cUnit, in
     }
 }
 
-void dvmCompilerPcgNewRegisterizeVRAnalysis (CompilationUnitPCG *cUnit)
+bool dvmCompilerPcgNewRegisterizeVRAnalysis (CompilationUnitPCG *cUnit)
 {
     GrowableList *blockList = &cUnit->blockList;
 
@@ -1085,7 +1089,11 @@ void dvmCompilerPcgNewRegisterizeVRAnalysis (CompilationUnitPCG *cUnit)
 
                 case OP_EXECUTE_INLINE:
                 case OP_EXECUTE_INLINE_RANGE:
-                    pcgAnalyzeExecuteInline (cUnit, mir);
+                    //If it fails, we fail
+                    if (pcgAnalyzeExecuteInline (cUnit, mir) == false)
+                    {
+                        return false;
+                    }
                     break;
 
                 case OP_INVOKE_DIRECT:
@@ -1135,7 +1143,7 @@ void dvmCompilerPcgNewRegisterizeVRAnalysis (CompilationUnitPCG *cUnit)
                     ALOGI ("%s\n", mybuf);
 
                     //TODO: use the error framework
-                    exit (-1);
+                    return false;
             }
 
             // Any uses of "version 0" of a virtual register indicates a value
@@ -1230,6 +1238,9 @@ void dvmCompilerPcgNewRegisterizeVRAnalysis (CompilationUnitPCG *cUnit)
             }
         }
     }
+
+    //Return success
+    return true;
 }
 
 void dvmCompilerPcgModSSANum (CompilationUnitPCG *cUnit)
@@ -1242,7 +1253,7 @@ void dvmCompilerPcgModSSANum (CompilationUnitPCG *cUnit)
         pcgAvoidDeferredWritebacks (cUnit);
     }
 
-    if (cUnit->checkOptimizationMask (OptimizationMaskRegisterizeVRs) == true)
+    if (cUnit->checkDebugMask (DebugMaskRegisterizeVRs) == true)
     {
         dvmCompilerPcgDumpModRegInfo (cUnit);
     }
diff --git a/vm/compiler/codegen/x86/pcg/Analysis.h b/vm/compiler/codegen/x86/pcg/Analysis.h
index d868dbd..6f892a0 100644
--- a/vm/compiler/codegen/x86/pcg/Analysis.h
+++ b/vm/compiler/codegen/x86/pcg/Analysis.h
@@ -25,8 +25,9 @@ struct SSANumInfo;
 /**
  * @brief Analyze the CompilationUnit for registerization
  * @param cUnit the CompilationUnitPCG
+ * @return whether the analysis succeeded or not
  */
-void dvmCompilerPcgNewRegisterizeVRAnalysis (CompilationUnitPCG *cUnit);
+bool dvmCompilerPcgNewRegisterizeVRAnalysis (CompilationUnitPCG *cUnit);
 
 /**
  * @brief Handle the SSA live-ins and live-outs
diff --git a/vm/compiler/codegen/x86/pcg/Android.mk b/vm/compiler/codegen/x86/pcg/Android.mk
index c8c0ceb..2605c99 100644
--- a/vm/compiler/codegen/x86/pcg/Android.mk
+++ b/vm/compiler/codegen/x86/pcg/Android.mk
@@ -41,7 +41,7 @@ LOCAL_MODULE := libpcgdvmjit
 LOCAL_CFLAGS += $(target_smp_flag)
 LOCAL_CFLAGS += -DARCH_IA32 -DWITH_JIT -DWITH_HOUDINI -DWITH_REGION_GC -DVTUNE_DALVIK -DEXTRA_SCRATCH_VR -DMTERP_STUB -DMTERP_NO_UNALIGN_64 -Wall -Wextra -O3
 LOCAL_ALLOW_UNDEFINED_SYMBOLS := true
-TARGET_LIBGCC = $(shell $(TARGET_CC) -print-libgcc-file-name)
+TARGET_LIBGCC = $(shell $(TARGET_CC) -m32 -print-libgcc-file-name)
 LOCAL_LDFLAGS += -Wl,--whole-archive $(TARGET_LIBGCC) -Wl,--no-whole-archive
 LOCAL_STATIC_LIBRARIES += libpcg libirc libsvml libgnustl_static
 LOCAL_SRC_FILES := Analysis.cpp \
@@ -100,7 +100,7 @@ ifeq ($(WITH_HOST_DALVIK),true)
     LOCAL_CFLAGS += $(host_smp_flag)
     LOCAL_CFLAGS += -DARCH_IA32 -DWITH_JIT -DWITH_HOUDINI -DWITH_REGION_GC -DVTUNE_DALVIK -DEXTRA_SCRATCH_VR -DMTERP_STUB -DMTERP_NO_UNALIGN_64
     LOCAL_ALLOW_UNDEFINED_SYMBOLS := true
-    TARGET_LIBGCC = $(shell $(TARGET_CC) -print-libgcc-file-name)
+    TARGET_LIBGCC = $(shell $(TARGET_CC) -m32 -print-libgcc-file-name)
     LOCAL_STATIC_LIBRARIES += libpcg_host libirc libsvml
     LOCAL_SRC_FILES := Analysis.cpp \
         Client.cpp \
diff --git a/vm/compiler/codegen/x86/pcg/ChainingCellException.cpp b/vm/compiler/codegen/x86/pcg/ChainingCellException.cpp
index a419d24..dbf85d0 100644
--- a/vm/compiler/codegen/x86/pcg/ChainingCellException.cpp
+++ b/vm/compiler/codegen/x86/pcg/ChainingCellException.cpp
@@ -433,7 +433,7 @@ static uint8_t* dvmCompilerPcgEmitBackwardBranchChainingCell (CompilationUnitPCG
     *currCachePtr++ = 0xe8;
 
     //Get symbol to the dvmJitToInterpNormal callback
-    CGSymbol callback = singletonPtr<PersistentInfo> ()->getCallBack ("dvmJitToInterBackwardBranch");
+    CGSymbol callback = singletonPtr<PersistentInfo> ()->getCallBack ("dvmJitToInterpBackwardBranch");
     void * callbackAddress = dvmCompilerPcgGetSymbolAddress (callback);
 
     * ( (int32_t*)currCachePtr) = (int32_t)callbackAddress -
@@ -789,7 +789,7 @@ void dvmCompilerPcgGenerateNullCheck (CompilationUnitPCG *cUnit, CGInst base, MI
     //First check if the ME said to ignore it
     if ((mir->OptimizationFlags & MIR_IGNORE_NULL_CHECK) != 0)
     {
-        if (cUnit->checkOptimizationMask (OptimizationMaskRegisterizeVRs) == true)
+        if (cUnit->checkDebugMask (DebugMaskRegisterizeVRs) == true)
         {
             ALOGI ("    avoiding null check..\n");
         }
@@ -803,8 +803,7 @@ void dvmCompilerPcgGenerateNullCheck (CompilationUnitPCG *cUnit, CGInst base, MI
 
         if (info.checkedForNull == true)
         {
-            //TODO: change above and below messages
-            if (cUnit->checkOptimizationMask (OptimizationMaskRegisterizeVRs) == true)
+            if (cUnit->checkDebugMask (DebugMaskRegisterizeVRs) == true)
             {
                 ALOGI ("    avoiding null check..\n");
             }
@@ -856,36 +855,6 @@ static void dvmCompilerPcgGenerateSpeculativeNullCheck (CompilationUnitPCG *cUni
     CGBindLabel (nullCheckPassedLabel);
 }
 
-void dvmCompilerPcgGenerateMoveException (CompilationUnitPCG *cUnit, MIR *mir)
-{
-    CGInst self = dvmCompilerPcgGetSelfPointer (cUnit);
-    CGInst exception = dvmCompilerPcgCreateSimpleLoad (self, OFFSETOF_MEMBER (Thread,exception));
-    dvmCompilerPcgCreateSimpleStore (self, OFFSETOF_MEMBER (Thread,exception), CGCreateNewInst ("mov", "i", 0));
-
-    //Get SSARepresentation
-    SSARepresentation *ssaRep = mir->ssaRep;
-
-    dvmCompilerPcgSetVirtualReg (cUnit, ssaRep->defs[0], "mov", 4, exception);
-}
-
-void dvmCompilerPcgGenerateThrow (CompilationUnitPCG *cUnit, MIR *mir)
-{
-    // For now, just punt to interpreter
-    CGInst parmEdi = dvmCompilerPcgGenerateVMPtrMov (cUnit);
-    CGInst parmEbp = dvmCompilerPcgGenerateFramePtrMov (cUnit);
-    CGInst parms[3] = {parmEdi, parmEbp, CGInstInvalid};
-
-    //Get symbol to the dvmJitToInterpPunt callback
-    CGSymbol callback = singletonPtr<PersistentInfo> ()->getCallBack ("dvmJitToInterpPunt");
-
-    //Paranoid
-    assert (callback != 0);
-
-    dvmCompilerPcgCreateJsr (callback, parms);
-
-   (void) mir;
-}
-
 void dvmCompilerPcgGenerateRangeCheck (CompilationUnitPCG *cUnit, CGInst base, CGInst index, MIR *mir)
 {
     if ( (mir->OptimizationFlags & MIR_IGNORE_RANGE_CHECK))
@@ -924,7 +893,7 @@ void dvmCompilerPcgGenerateSpeculativeNullChecks (CompilationUnitPCG *cUnit)
 
         if ( (info.needsNullCheck == true) && (info.checkedForNull == false))
         {
-            if (cUnit->checkOptimizationMask (OptimizationMaskRegisterizeVRs) == true)
+            if (cUnit->checkDebugMask (DebugMaskSpeculative) == true)
             {
                 ALOGI ("\n--------- generating speculative null check for SSA:%d.\n", temp);
             }
diff --git a/vm/compiler/codegen/x86/pcg/ChainingCellException.h b/vm/compiler/codegen/x86/pcg/ChainingCellException.h
index efe244d..a7147be 100644
--- a/vm/compiler/codegen/x86/pcg/ChainingCellException.h
+++ b/vm/compiler/codegen/x86/pcg/ChainingCellException.h
@@ -47,13 +47,6 @@ void dvmCompilerPcgGenerateRaiseException (CompilationUnitPCG *cUnit);
 void dvmCompilerPcgGenerateNullCheck (CompilationUnitPCG *cUnit, CGInst base, MIR *mir, int ssaNum = -1);
 
 /**
- * @brief Handle a throw instruction
- * @param cUnit the CompilationUnitPCG
- * @param mir the MIR instruction
- */
-void dvmCompilerPcgGenerateThrow (CompilationUnitPCG *cUnit, MIR *mir);
-
-/**
  * @brief Generate a JSR to the dvmJitToExceptionThrown function
  * @param cUnit the CompilationUnitPCG
  */
@@ -110,11 +103,4 @@ void dvmCompilerPcgGeneratePredictedChain (CompilationUnitPCG *cUnit, BasicBlock
  * @param cUnit the CompilationUnitPCG
  */
 void dvmCompilerPcgGenerateSpeculativeNullChecks (CompilationUnitPCG *cUnit);
-
-/**
- * @brief Generate a move exception instruction
- * @param cUnit the CompilationUnitPCG
- * @param mir the MIR instruction
- */
-void dvmCompilerPcgGenerateMoveException(CompilationUnitPCG *cUnit, MIR *mir);
 #endif
diff --git a/vm/compiler/codegen/x86/pcg/CodeGeneration.cpp b/vm/compiler/codegen/x86/pcg/CodeGeneration.cpp
index b082e31..fbd94bb 100644
--- a/vm/compiler/codegen/x86/pcg/CodeGeneration.cpp
+++ b/vm/compiler/codegen/x86/pcg/CodeGeneration.cpp
@@ -39,10 +39,9 @@
 /**
  * @brief Translate an MIR instruction
  * @param cUnit the CompilationUnit
- * @param bb the BasicBlock
  * @param mir the MIR instruction
  */
-static bool dvmCompilerPcgTranslateInsn (CompilationUnitPCG *cUnit, BasicBlockPCG *bb, MIR *mir)
+static bool dvmCompilerPcgTranslateInsn (CompilationUnitPCG *cUnit, MIR *mir)
 {
     bool success = true;
     Opcode dalvikOpCode = mir->dalvikInsn.opcode;
@@ -98,16 +97,15 @@ static bool dvmCompilerPcgTranslateInsn (CompilationUnitPCG *cUnit, BasicBlockPC
             // exactly the same way as OP_MOVE_WIDE, but this matches the
             // existing Dalvik implementation.
             // TODO - Check on this.  It might be a bug.
-            //
             dvmCompilerPcgTranslateMoveWide (cUnit, mir);
             break;
 
         case OP_MOVE_EXCEPTION:
-            dvmCompilerPcgGenerateMoveException (cUnit, mir);
+            dvmCompilerPcgGenerateRaiseException (cUnit);
             break;
 
         case OP_THROW:
-            dvmCompilerPcgGenerateThrow (cUnit, mir);
+            dvmCompilerPcgGenerateRaiseException (cUnit);
             break;
 
         case OP_CONST:
@@ -152,197 +150,159 @@ static bool dvmCompilerPcgTranslateInsn (CompilationUnitPCG *cUnit, BasicBlockPC
             break;
 
         case OP_IF_EQ:
-            dvmCompilerPcgTranslateIf (cUnit, bb, mir, "eq");
+            dvmCompilerPcgTranslateIf (cUnit, mir, "eq");
             break;
 
         case OP_IF_NE:
-            dvmCompilerPcgTranslateIf (cUnit, bb, mir, "ne");
+            dvmCompilerPcgTranslateIf (cUnit, mir, "ne");
             break;
 
         case OP_IF_LT:
-            dvmCompilerPcgTranslateIf (cUnit, bb, mir, "slt");
+            dvmCompilerPcgTranslateIf (cUnit, mir, "slt");
             break;
 
         case OP_IF_GE:
-            dvmCompilerPcgTranslateIf (cUnit, bb, mir, "sge");
+            dvmCompilerPcgTranslateIf (cUnit, mir, "sge");
             break;
 
         case OP_IF_GT:
-            dvmCompilerPcgTranslateIf (cUnit, bb, mir, "sgt");
+            dvmCompilerPcgTranslateIf (cUnit, mir, "sgt");
             break;
 
         case OP_IF_LE:
-            dvmCompilerPcgTranslateIf (cUnit, bb, mir, "sle");
+            dvmCompilerPcgTranslateIf (cUnit, mir, "sle");
             break;
 
         case OP_IF_GEZ:
-            dvmCompilerPcgTranslateIfZero (cUnit, bb, mir, "sge");
+            dvmCompilerPcgTranslateIfZero (cUnit, mir, "sge");
             break;
 
         case OP_IF_NEZ:
-            dvmCompilerPcgTranslateIfZero (cUnit, bb, mir, "ne");
+            dvmCompilerPcgTranslateIfZero (cUnit, mir, "ne");
             break;
 
         case OP_IF_EQZ:
-            dvmCompilerPcgTranslateIfZero (cUnit, bb, mir, "eq");
+            dvmCompilerPcgTranslateIfZero (cUnit, mir, "eq");
             break;
 
         case OP_IF_LTZ:
-            dvmCompilerPcgTranslateIfZero (cUnit, bb, mir, "slt");
+            dvmCompilerPcgTranslateIfZero (cUnit, mir, "slt");
             break;
 
         case OP_IF_GTZ:
-            dvmCompilerPcgTranslateIfZero (cUnit, bb, mir, "sgt");
+            dvmCompilerPcgTranslateIfZero (cUnit, mir, "sgt");
             break;
 
         case OP_IF_LEZ:
-            dvmCompilerPcgTranslateIfZero (cUnit, bb, mir, "sle");
+            dvmCompilerPcgTranslateIfZero (cUnit, mir, "sle");
             break;
 
         case OP_GOTO:
         case OP_GOTO_16:
         case OP_GOTO_32:
-            dvmCompilerPcgTranslateGoto (bb);
-            break;
+            {
+                BasicBlockPCG *bb = static_cast<BasicBlockPCG *> (mir->bb);
+
+                //Paranoid
+                assert (bb != 0);
+
+                dvmCompilerPcgTranslateGoto (bb);
+                break;
+            }
 
         case OP_NEG_INT:
-            dvmCompilerPcgTranslateIntOp (cUnit, mir,"neg");
+            dvmCompilerPcgTranslateIntOp (cUnit, mir, "neg");
             break;
 
         case OP_NOT_INT:
-            dvmCompilerPcgTranslateIntOp (cUnit, mir,"not");
+            dvmCompilerPcgTranslateIntOp (cUnit, mir, "not");
             break;
 
         case OP_SUB_INT:
-            dvmCompilerPcgTranslateIntOpOp (cUnit, mir,"sub");
+        case OP_SUB_INT_2ADDR:
+            dvmCompilerPcgTranslateIntOpOp (cUnit, mir, "sub");
             break;
 
         case OP_RSUB_INT:
+        case OP_RSUB_INT_LIT8:
             dvmCompilerPcgTranslateRsub (cUnit, mir);
             break;
 
-        case OP_SUB_INT_2ADDR:
-            dvmCompilerPcgTranslateIntOpOp (cUnit, mir,"sub");
-            break;
-
         case OP_ADD_INT:
-            dvmCompilerPcgTranslateIntOpOp (cUnit, mir,"add");
+        case OP_ADD_INT_2ADDR:
+            dvmCompilerPcgTranslateIntOpOp (cUnit, mir, "add");
             break;
 
         case OP_OR_INT:
-            dvmCompilerPcgTranslateIntOpOp (cUnit, mir,"or");
+        case OP_OR_INT_2ADDR:
+            dvmCompilerPcgTranslateIntOpOp (cUnit, mir, "or");
             break;
 
         case OP_AND_INT:
-            dvmCompilerPcgTranslateIntOpOp (cUnit, mir,"and");
-            break;
-
-        case OP_XOR_INT:
-            dvmCompilerPcgTranslateIntOpOp (cUnit, mir,"xor");
-            break;
-
-        case OP_SHL_INT:
-            dvmCompilerPcgTranslateIntOpOp (cUnit, mir,"shl");
-            break;
-
-        case OP_SHR_INT:
-            dvmCompilerPcgTranslateIntOpOp (cUnit, mir,"sar");
-            break;
-
-        case OP_USHR_INT:
-            dvmCompilerPcgTranslateIntOpOp (cUnit, mir,"shr");
-            break;
-
-        case OP_ADD_INT_2ADDR:
-            dvmCompilerPcgTranslateIntOpOp (cUnit, mir,"add");
-            break;
-
         case OP_AND_INT_2ADDR:
-            dvmCompilerPcgTranslateIntOpOp (cUnit, mir,"and");
+            dvmCompilerPcgTranslateIntOpOp (cUnit, mir, "and");
             break;
 
+        case OP_XOR_INT:
         case OP_XOR_INT_2ADDR:
-            dvmCompilerPcgTranslateIntOpOp (cUnit, mir,"xor");
-            break;
-
-        case OP_OR_INT_2ADDR:
-            dvmCompilerPcgTranslateIntOpOp (cUnit, mir,"or");
-            break;
-
-        case OP_MUL_INT_2ADDR:
-            dvmCompilerPcgTranslateIntOpOp (cUnit, mir,"imul");
+            dvmCompilerPcgTranslateIntOpOp (cUnit, mir, "xor");
             break;
 
+        case OP_SHL_INT:
         case OP_SHL_INT_2ADDR:
-            dvmCompilerPcgTranslateIntOpOp (cUnit, mir,"shl");
+            dvmCompilerPcgTranslateIntOpOp (cUnit, mir, "shl");
             break;
 
+        case OP_SHR_INT:
         case OP_SHR_INT_2ADDR:
-            dvmCompilerPcgTranslateIntOpOp (cUnit, mir,"sar");
+            dvmCompilerPcgTranslateIntOpOp (cUnit, mir, "sar");
             break;
 
+        case OP_USHR_INT:
         case OP_USHR_INT_2ADDR:
-            dvmCompilerPcgTranslateIntOpOp (cUnit, mir,"shr");
+            dvmCompilerPcgTranslateIntOpOp (cUnit, mir, "shr");
             break;
 
         case OP_ADD_INT_LIT8:
-            dvmCompilerPcgTranslateIntOpLit (cUnit, mir,"add");
-            break;
-
-        case OP_RSUB_INT_LIT8:
-            dvmCompilerPcgTranslateRsub (cUnit, mir);
+        case OP_ADD_INT_LIT16:
+            dvmCompilerPcgTranslateIntOpLit (cUnit, mir, "add");
             break;
 
+        case OP_OR_INT_LIT16:
         case OP_OR_INT_LIT8:
-            dvmCompilerPcgTranslateIntOpLit (cUnit, mir,"or");
+            dvmCompilerPcgTranslateIntOpLit (cUnit, mir, "or");
             break;
 
         case OP_XOR_INT_LIT8:
+        case OP_XOR_INT_LIT16:
             dvmCompilerPcgTranslateIntOpLit (cUnit, mir, "xor");
             break;
 
+        case OP_AND_INT_LIT16:
         case OP_AND_INT_LIT8:
             dvmCompilerPcgTranslateIntOpLit (cUnit, mir, "and");
             break;
 
         case OP_SHL_INT_LIT8:
-            dvmCompilerPcgTranslateIntOpLit (cUnit, mir,"shl");
+            dvmCompilerPcgTranslateIntOpLit (cUnit, mir, "shl");
             break;
 
         case OP_SHR_INT_LIT8:
-            dvmCompilerPcgTranslateIntOpLit (cUnit, mir,"sar");
+            dvmCompilerPcgTranslateIntOpLit (cUnit, mir, "sar");
             break;
 
         case OP_USHR_INT_LIT8:
-            dvmCompilerPcgTranslateIntOpLit (cUnit, mir,"shr");
-            break;
-
-        case OP_ADD_INT_LIT16:
-            dvmCompilerPcgTranslateIntOpLit (cUnit, mir,"add");
-            break;
-
-        case OP_OR_INT_LIT16:
-            dvmCompilerPcgTranslateIntOpLit (cUnit, mir,"or");
-            break;
-
-        case OP_AND_INT_LIT16:
-            dvmCompilerPcgTranslateIntOpLit (cUnit, mir,"and");
-            break;
-
-        case OP_XOR_INT_LIT16:
-            dvmCompilerPcgTranslateIntOpLit (cUnit, mir,"xor");
+            dvmCompilerPcgTranslateIntOpLit (cUnit, mir, "shr");
             break;
 
         case OP_MUL_INT:
-            dvmCompilerPcgTranslateIntOpOp (cUnit, mir,"imul");
+        case OP_MUL_INT_2ADDR:
+            dvmCompilerPcgTranslateIntOpOp (cUnit, mir, "imul");
             break;
 
         case OP_MUL_INT_LIT8:
-            dvmCompilerPcgTranslateIntOpLit (cUnit, mir,"imul");
-            break;
-
         case OP_MUL_INT_LIT16:
-            dvmCompilerPcgTranslateIntOpLit (cUnit, mir,"imul");
+            dvmCompilerPcgTranslateIntOpLit (cUnit, mir, "imul");
             break;
 
         case OP_INT_TO_LONG:
@@ -369,43 +329,34 @@ static bool dvmCompilerPcgTranslateInsn (CompilationUnitPCG *cUnit, BasicBlockPC
             dvmCompilerPcgTranslateCmpLong (cUnit, mir);
             break;
 
-        case OP_ADD_LONG_2ADDR:
-            dvmCompilerPcgTranslate2addrLLreg (cUnit, mir, "ladd");
-            break;
-
-        case OP_SUB_LONG_2ADDR:
-            dvmCompilerPcgTranslate2addrLLreg (cUnit, mir, "lsub");
-            break;
-
-        case OP_MUL_LONG_2ADDR:
-            dvmCompilerPcgTranslate2addrLLreg (cUnit, mir, "limul");
-            break;
-
         case OP_MUL_LONG:
-            dvmCompilerPcgTranslate3addrLLreg (cUnit, mir, "limul");
+        case OP_MUL_LONG_2ADDR:
+            dvmCompilerPcgTranslateLLreg (cUnit, mir, "limul");
             break;
 
         case OP_ADD_LONG:
-            dvmCompilerPcgTranslate3addrLLreg (cUnit, mir, "ladd");
+        case OP_ADD_LONG_2ADDR:
+            dvmCompilerPcgTranslateLLreg (cUnit, mir, "ladd");
             break;
 
         case OP_SUB_LONG:
-            dvmCompilerPcgTranslate3addrLLreg (cUnit, mir, "lsub");
+        case OP_SUB_LONG_2ADDR:
+            dvmCompilerPcgTranslateLLreg (cUnit, mir, "lsub");
             break;
 
         case OP_AND_LONG:
         case OP_AND_LONG_2ADDR:
-            dvmCompilerPcgTranslate3addrLLreg (cUnit, mir, "land");
+            dvmCompilerPcgTranslateLLreg (cUnit, mir, "land");
             break;
 
         case OP_OR_LONG:
         case OP_OR_LONG_2ADDR:
-            dvmCompilerPcgTranslate3addrLLreg (cUnit, mir, "lor");
+            dvmCompilerPcgTranslateLLreg (cUnit, mir, "lor");
             break;
 
         case OP_XOR_LONG:
         case OP_XOR_LONG_2ADDR:
-            dvmCompilerPcgTranslate3addrLLreg (cUnit, mir, "lxor");
+            dvmCompilerPcgTranslateLLreg (cUnit, mir, "lxor");
             break;
 
         case OP_NEG_LONG:
@@ -447,76 +398,58 @@ static bool dvmCompilerPcgTranslateInsn (CompilationUnitPCG *cUnit, BasicBlockPC
 
         case OP_DIV_INT_LIT8:
         case OP_REM_INT_LIT8:
-            dvmCompilerPcgTranslateDivRemIntLit (cUnit, mir);
-            break;
-
         case OP_DIV_INT_LIT16:
         case OP_REM_INT_LIT16:
             dvmCompilerPcgTranslateDivRemIntLit (cUnit, mir);
             break;
 
         case OP_ADD_FLOAT_2ADDR:
-            dvmCompilerPcgTranslate2addrFloat (cUnit, mir, "addss1");
+            dvmCompilerPcgTranslateFloat (cUnit, mir, "addss1");
             break;
 
         case OP_SUB_FLOAT_2ADDR:
-            dvmCompilerPcgTranslate2addrFloat (cUnit, mir, "subss1");
+            dvmCompilerPcgTranslateFloat (cUnit, mir, "subss1");
             break;
 
         case OP_MUL_FLOAT_2ADDR:
-            dvmCompilerPcgTranslate2addrFloat (cUnit, mir, "mulss1");
-            break;
-
-        case OP_DIV_FLOAT_2ADDR:
-            dvmCompilerPcgTranslate2addrFloat (cUnit, mir, "divss1");
+            dvmCompilerPcgTranslateFloat (cUnit, mir, "mulss1");
             break;
 
         case OP_ADD_FLOAT:
-            dvmCompilerPcgTranslate3addrFloat (cUnit, mir, "addss1");
+            dvmCompilerPcgTranslateFloat (cUnit, mir, "addss1");
             break;
 
         case OP_SUB_FLOAT:
-            dvmCompilerPcgTranslate3addrFloat (cUnit, mir, "subss1");
+            dvmCompilerPcgTranslateFloat (cUnit, mir, "subss1");
             break;
 
         case OP_MUL_FLOAT:
-            dvmCompilerPcgTranslate3addrFloat (cUnit, mir, "mulss1");
+            dvmCompilerPcgTranslateFloat (cUnit, mir, "mulss1");
             break;
 
         case OP_DIV_FLOAT:
-            dvmCompilerPcgTranslate3addrFloat (cUnit, mir, "divss1");
-            break;
-
-        case OP_ADD_DOUBLE_2ADDR:
-            dvmCompilerPcgTranslate2addrDouble (cUnit, mir, "addsd1");
-            break;
-
-        case OP_SUB_DOUBLE_2ADDR:
-            dvmCompilerPcgTranslate2addrDouble (cUnit, mir, "subsd1");
-            break;
-
-        case OP_MUL_DOUBLE_2ADDR:
-            dvmCompilerPcgTranslate2addrDouble (cUnit, mir, "mulsd1");
-            break;
-
-        case OP_DIV_DOUBLE_2ADDR:
-            dvmCompilerPcgTranslate2addrDouble (cUnit, mir, "divsd1");
+        case OP_DIV_FLOAT_2ADDR:
+            dvmCompilerPcgTranslateFloat (cUnit, mir, "divss1");
             break;
 
         case OP_ADD_DOUBLE:
-            dvmCompilerPcgTranslate3addrDouble (cUnit, mir, "addsd1");
+        case OP_ADD_DOUBLE_2ADDR:
+            dvmCompilerPcgTranslateDouble (cUnit, mir, "addsd1");
             break;
 
         case OP_SUB_DOUBLE:
-            dvmCompilerPcgTranslate3addrDouble (cUnit, mir, "subsd1");
+        case OP_SUB_DOUBLE_2ADDR:
+            dvmCompilerPcgTranslateDouble (cUnit, mir, "subsd1");
             break;
 
         case OP_MUL_DOUBLE:
-            dvmCompilerPcgTranslate3addrDouble (cUnit, mir, "mulsd1");
+        case OP_MUL_DOUBLE_2ADDR:
+            dvmCompilerPcgTranslateDouble (cUnit, mir, "mulsd1");
             break;
 
         case OP_DIV_DOUBLE:
-            dvmCompilerPcgTranslate3addrDouble (cUnit, mir, "divsd1");
+        case OP_DIV_DOUBLE_2ADDR:
+            dvmCompilerPcgTranslateDouble (cUnit, mir, "divsd1");
             break;
 
         case OP_INT_TO_DOUBLE:
@@ -560,19 +493,19 @@ static bool dvmCompilerPcgTranslateInsn (CompilationUnitPCG *cUnit, BasicBlockPC
             break;
 
         case OP_CMPG_FLOAT:
-            dvmCompilerPcgTranslateIfFp (cUnit, bb, mir, 4, 1);
+            dvmCompilerPcgTranslateIfFp (cUnit, mir, 4, 1);
             break;
 
         case OP_CMPL_FLOAT:
-            dvmCompilerPcgTranslateIfFp (cUnit, bb, mir, 4, -1);
+            dvmCompilerPcgTranslateIfFp (cUnit, mir, 4, -1);
             break;
 
         case OP_CMPG_DOUBLE:
-            dvmCompilerPcgTranslateIfFp (cUnit, bb, mir, 8, 1);
+            dvmCompilerPcgTranslateIfFp (cUnit, mir, 8, 1);
             break;
 
         case OP_CMPL_DOUBLE:
-            dvmCompilerPcgTranslateIfFp (cUnit, bb, mir, 8, -1);
+            dvmCompilerPcgTranslateIfFp (cUnit, mir, 8, -1);
             break;
 
         case OP_IGET_WIDE_QUICK:
@@ -751,24 +684,24 @@ static bool dvmCompilerPcgTranslateInsn (CompilationUnitPCG *cUnit, BasicBlockPC
 
         case OP_INVOKE_VIRTUAL_QUICK:
         case OP_INVOKE_VIRTUAL_QUICK_RANGE:
-            dvmCompilerPcgTranslateInvokeVirtualQuick (cUnit, bb, mir);
+            dvmCompilerPcgTranslateInvokeVirtualQuick (cUnit, mir);
             break;
 
         case OP_INVOKE_STATIC:
         case OP_INVOKE_STATIC_RANGE:
         case OP_INVOKE_SUPER_QUICK:
         case OP_INVOKE_SUPER_QUICK_RANGE:
-            dvmCompilerPcgTranslateInvokeStaticSuperQuick (cUnit, bb, mir);
+            dvmCompilerPcgTranslateInvokeStaticSuperQuick (cUnit, mir);
             break;
 
         case OP_INVOKE_INTERFACE:
         case OP_INVOKE_INTERFACE_RANGE:
-            dvmCompilerPcgTranslateInvokeInterface (cUnit, bb, mir);
+            dvmCompilerPcgTranslateInvokeInterface (cUnit, mir);
             break;
 
         case OP_INVOKE_DIRECT:
         case OP_INVOKE_DIRECT_RANGE:
-            dvmCompilerPcgTranslateInvokeDirect (cUnit, bb, mir);
+            dvmCompilerPcgTranslateInvokeDirect (cUnit, mir);
             break;
 
         case OP_MOVE_RESULT:
@@ -934,7 +867,8 @@ static bool dvmCompilerPcgTranslateBB (CompilationUnitPCG *cUnit, BasicBlockPCG
         CGSymbol cgSymbol;
         std::string blockName;
         dvmCompilerPcgGetBlockName (bb, blockName);
-        cgSymbol = dvmCompilerPcgCreateSymbol (blockName, 0);
+        //We want the block to have an aligned symbol information, to get all jumps towards it aligned
+        cgSymbol = dvmCompilerPcgCreateSymbol (blockName, 0, true);
         cUnit->addLabelSymbolPair(cgLabel, cgSymbol);
 
         // Now find the backward branch chaining cell block and store the
@@ -984,7 +918,7 @@ static bool dvmCompilerPcgTranslateBB (CompilationUnitPCG *cUnit, BasicBlockPCG
 
     for (mir = bb->firstMIRInsn; mir; mir = mir->next)
     {
-        if (dvmCompilerPcgTranslateInsn (cUnit, bb, mir) == false)
+        if (dvmCompilerPcgTranslateInsn (cUnit, mir) == false)
         {
             return false;
         }
@@ -1093,7 +1027,8 @@ static bool dvmCompilerPcgTranslateCUnit (CompilationUnitPCG *cUnit, JitTranslat
         {
             std::string blockName;
             dvmCompilerPcgGetBlockName (bb, blockName);
-            bb->chainingCellSymbol = dvmCompilerPcgCreateSymbol (blockName, 0);
+            //We want the block to have an aligned symbol information, to get all jumps towards it aligned
+            bb->chainingCellSymbol = dvmCompilerPcgCreateSymbol (blockName, 0, true);
         }
 
         // Attempt to merge all the exception handling blocks
@@ -1201,11 +1136,8 @@ static bool dvmCompilerPcgTranslateCUnit (CompilationUnitPCG *cUnit, JitTranslat
                 CGInst parmEbp = dvmCompilerPcgGenerateFramePtrMov (cUnit);
                 CGInst parms[3] = {parmEdi, parmEbp, CGInstInvalid};
 
-                CGInst spadd = CGCreateNewInst ("spaddi", "ri",
-                        CGGetStackPointerDef (), 0);
-                CGSetRreg (spadd, "esp");
-                CGSymbol chainingCellSym = bb->chainingCellSymbol;
-                CGCreateNewInst ("jsr", "nl", chainingCellSym, parms);
+                //Create the JSR
+                dvmCompilerPcgCreateJsr (bb->chainingCellSymbol, parms);
             }
         }
     }
diff --git a/vm/compiler/codegen/x86/pcg/CompilationUnitPCG.cpp b/vm/compiler/codegen/x86/pcg/CompilationUnitPCG.cpp
index abcc8db..4ce2b01 100644
--- a/vm/compiler/codegen/x86/pcg/CompilationUnitPCG.cpp
+++ b/vm/compiler/codegen/x86/pcg/CompilationUnitPCG.cpp
@@ -21,8 +21,13 @@
 
 uint32_t CompilationUnitPCG::traceID = 0;
 
-CompilationUnitPCG::CompilationUnitPCG (void)
+CompilationUnitPCG::CompilationUnitPCG (CompilationUnit *cUnit)
 {
+    CompilationUnit *cUnitLimited = this;
+
+    //Copy the ME's CUnit in
+    *cUnitLimited = *cUnit;
+
     //Augment trace counter
     traceID++;
 
@@ -61,7 +66,7 @@ CompilationUnitPCG::CompilationUnitPCG (void)
     // This needs to be initialized to some value larger than the highest
     // SSA number, because we use the SSA number as the
     // temp number when we registerize VRs.
-    setCurrentTemporaryVR (1000000);
+    setCurrentTemporaryVR (numSSARegs + 1);
     vmPtrReg = getCurrentTemporaryVR (true);
 
     //Create the frame pointer register
@@ -132,7 +137,7 @@ void CompilationUnitPCG::registerizeAnalysisDone (void)
 {
     std::map<int, SSANumInfo>::iterator it;
 
-    if (checkOptimizationMask (OptimizationMaskRegisterizeVRs) == true)
+    if (checkDebugMask (DebugMaskRegisterizeVRs) == true)
     {
         ALOGI ("\nSSANum type info for trace %d\n", traceID);
         ALOGI ("==============================\n");
diff --git a/vm/compiler/codegen/x86/pcg/CompilationUnitPCG.h b/vm/compiler/codegen/x86/pcg/CompilationUnitPCG.h
index ea123cd..d13f7c1 100644
--- a/vm/compiler/codegen/x86/pcg/CompilationUnitPCG.h
+++ b/vm/compiler/codegen/x86/pcg/CompilationUnitPCG.h
@@ -37,6 +37,8 @@ enum DebugFlags
     DebugFlagsTrace,            /**< @brief Do we want to dump the trace */
     DebugFlagsBytecode,         /**< @brief Do we want to dump the bytecode */
     DebugFlagsDisasm,           /**< @brief Do we want to dump the generate assembly in memory */
+    DebugFlagsRegisterizeVRs,   /**< @brief Do we want to dump about registerization? */
+    DebugFlagsSpeculative       /**< @brief Do we want to dump about speculative? */
 };
 
 /**
@@ -49,6 +51,8 @@ enum DebugMasks
     DebugMaskTrace = (1 << DebugFlagsTrace),        /**< @brief Do we want to dump the trace */
     DebugMaskBytecode = (1 << DebugFlagsBytecode),  /**< @brief Do we want to dump the bytecode */
     DebugMaskDisasm = (1 << DebugFlagsDisasm),      /**< @brief Do we want to dump the generated assembly in memory */
+    DebugMaskRegisterizeVRs = (1 << DebugFlagsRegisterizeVRs),  /**< @brief Do we want to dump about registerization? */
+    DebugMaskSpeculative = (1 << DebugFlagsSpeculative)         /**< @brief Do we want to dump about speculative checks? */
 };
 
 /**
@@ -57,7 +61,6 @@ enum DebugMasks
 enum OptimizationFlags
 {
     OptimizationFlagsSpeculativeNullChecks, /**< @brief Do we want speculative null checks? */
-    OptimizationFlagsRegisterizeVRs         /**< @brief Do we want to registerize? */
 };
 
 /**
@@ -66,7 +69,6 @@ enum OptimizationFlags
 enum OptimizationMasks
 {
     OptimizationMaskSpeculativeNullChecks = (1 << OptimizationFlagsSpeculativeNullChecks),  /**< @brief Do we want speculative null checks? */
-    OptimizationMaskRegisterizeVRs = (1 << OptimizationFlagsRegisterizeVRs)                 /**< @brief Do we want to registerize? */
 };
 
 /**
@@ -140,8 +142,11 @@ class CompilationUnitPCG: public CompilationUnit
         static uint32_t traceID;
 
     public:
-        /** @brief Constructor */
-        CompilationUnitPCG (void);
+        /**
+         * @brief Constructor
+         * @param cUnit the CompilationUnit
+         */
+        CompilationUnitPCG (CompilationUnit *cUnit);
 
         /**
          * @brief Check the debug flag for a certain property
diff --git a/vm/compiler/codegen/x86/pcg/Labels.cpp b/vm/compiler/codegen/x86/pcg/Labels.cpp
index 97b2807..4587e50 100644
--- a/vm/compiler/codegen/x86/pcg/Labels.cpp
+++ b/vm/compiler/codegen/x86/pcg/Labels.cpp
@@ -77,9 +77,17 @@ void dvmCompilerPcgResolveSymbolReferences (const CompilationUnitPCG *cUnit, uin
  * @details createSymbol creates a new CGSymbol with the specified name and address.
  *  The symbol is created and returned, and a SClientSymbolInfo structure is created and inserted into the pcgSymbolMap.
  */
-CGSymbol dvmCompilerPcgCreateSymbol (const std::string &name, void *address)
+CGSymbol dvmCompilerPcgCreateSymbol (const std::string &name, void *address, bool aligned)
 {
-    CGSymbol cgSymbol = CGCreateSymbol ("p");
+    const char *str = "";
+
+    //If we need the symbol aligned, add it to the str variable
+    if (aligned == true)
+    {
+        str = "p";
+    }
+
+    CGSymbol cgSymbol = CGCreateSymbol (str);
 
     //Create the symbol information
     SClientSymbolInfo clientSymbol;
diff --git a/vm/compiler/codegen/x86/pcg/Labels.h b/vm/compiler/codegen/x86/pcg/Labels.h
index eb516d9..a7530ae 100644
--- a/vm/compiler/codegen/x86/pcg/Labels.h
+++ b/vm/compiler/codegen/x86/pcg/Labels.h
@@ -1,7 +1,7 @@
 /*
- * Copyright (C) 2013 Intel Corporation
+ * Copyright  (C) 2013 Intel Corporation
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
+ * Licensed under the Apache License, Version 2.0  (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
@@ -29,35 +29,36 @@ class CompilationUnitPCG;
  * @brief Create a symbol
  * @param name the name of the symbol
  * @param address the address of the symbol
+ * @param aligned do we want the label aligned? (default: false)
  * @return CGSymbol the Code Generation Symbol obtained
  */
-CGSymbol dvmCompilerPcgCreateSymbol(const std::string &name, void *address);
+CGSymbol dvmCompilerPcgCreateSymbol (const std::string &name, void *address, bool aligned = false);
 
 /**
  * @brief Get the address of a symbol
  * @param cgSymbol the CGSymbol
  * @return the address of a given symbol
  */
-void* dvmCompilerPcgGetSymbolAddress(CGSymbol cgSymbol);
+void* dvmCompilerPcgGetSymbolAddress (CGSymbol cgSymbol);
 
 /**
  * @brief Bind the address of a symbol
  * @param cgSymbol the CGSymbol
  * @param address the address of a given symbol
  */
-void dvmCompilerPcgBindSymbolAddress(CGSymbol cgSymbol, void *address);
+void dvmCompilerPcgBindSymbolAddress (CGSymbol cgSymbol, void *address);
 
 /**
  * @brief Bind a BasicBlock
  * @param bb the BasicBlockPCG
  */
-void dvmCompilerPcgBindBlockLabel(BasicBlockPCG *bb);
+void dvmCompilerPcgBindBlockLabel (BasicBlockPCG *bb);
 
 /**
  * @brief Resolve the relocations
  * @param cUnit the CompilationUnitPCG
  * @param code_ptr the code section for the trace generation
  */
-void dvmCompilerPcgResolveSymbolReferences(const CompilationUnitPCG* cUnit, uint8_t *code_ptr);
+void dvmCompilerPcgResolveSymbolReferences (const CompilationUnitPCG* cUnit, uint8_t *code_ptr);
 
 #endif
diff --git a/vm/compiler/codegen/x86/pcg/LowerALU.cpp b/vm/compiler/codegen/x86/pcg/LowerALU.cpp
index 44478f3..a1e7126 100644
--- a/vm/compiler/codegen/x86/pcg/LowerALU.cpp
+++ b/vm/compiler/codegen/x86/pcg/LowerALU.cpp
@@ -205,7 +205,7 @@ void dvmCompilerPcgTranslateConstString (CompilationUnitPCG *cUnit, MIR *mir)
     dvmCompilerPcgSetVirtualReg (cUnit, ssaRep->defs[0], "mov", 4, strInst);
 }
 
-void dvmCompilerPcgTranslate2addrLLreg (CompilationUnitPCG *cUnit, MIR *mir, const char *opcode)
+void dvmCompilerPcgTranslateLLreg (CompilationUnitPCG *cUnit, MIR *mir, const char *opcode)
 {
     //Get the SSARepresentation
     SSARepresentation *ssaRep = mir->ssaRep;
@@ -218,19 +218,6 @@ void dvmCompilerPcgTranslate2addrLLreg (CompilationUnitPCG *cUnit, MIR *mir, con
     dvmCompilerPcgSetVirtualReg (cUnit, ssaRep->defs[0], "lmov", 8, op);
 }
 
-void dvmCompilerPcgTranslate3addrLLreg (CompilationUnitPCG *cUnit, MIR *mir, const char *opcode)
-{
-    //Get the SSARepresentation
-    SSARepresentation *ssaRep = mir->ssaRep;
-
-    assert (ssaRep != 0);
-
-    CGInst B = dvmCompilerPcgGetVirtualReg (cUnit, ssaRep->uses[0], "lmov", 8);
-    CGInst C = dvmCompilerPcgGetVirtualReg (cUnit, ssaRep->uses[2], "lmov", 8);
-    CGInst op = CGCreateNewInst (opcode, "rr", B, C);
-    dvmCompilerPcgSetVirtualReg (cUnit, ssaRep->defs[0], "lmov", 8, op);
-}
-
 void dvmCompilerPcgTranslateLLregOp (CompilationUnitPCG *cUnit, const char *opcode, int ssaA, int ssaB)
 {
     CGInst B = dvmCompilerPcgGetVirtualReg (cUnit, ssaB, "lmov", 8);
@@ -252,7 +239,7 @@ void dvmCompilerPcgTranslateLLregShift (CompilationUnitPCG *cUnit, MIR *mir, con
     dvmCompilerPcgSetVirtualReg (cUnit, ssaRep->defs[0], "lmov", 8, op);
 }
 
-void dvmCompilerPcgTranslate2addrFloat (CompilationUnitPCG *cUnit, MIR *mir, const char *opcode)
+void dvmCompilerPcgTranslateFloat (CompilationUnitPCG *cUnit, MIR *mir, const char *opcode)
 {
     //Get the SSARepresentation
     SSARepresentation *ssaRep = mir->ssaRep;
@@ -265,20 +252,7 @@ void dvmCompilerPcgTranslate2addrFloat (CompilationUnitPCG *cUnit, MIR *mir, con
     dvmCompilerPcgSetVirtualReg (cUnit, ssaRep->defs[0], "movss1", 4, op);
 }
 
-void dvmCompilerPcgTranslate3addrFloat (CompilationUnitPCG *cUnit, MIR *mir, const char *opcode)
-{
-    //Get the SSARepresentation
-    SSARepresentation *ssaRep = mir->ssaRep;
-
-    assert (ssaRep != 0);
-
-    CGInst B = dvmCompilerPcgGetVirtualReg (cUnit, ssaRep->uses[0], "movss1", 4);
-    CGInst C = dvmCompilerPcgGetVirtualReg (cUnit, ssaRep->uses[1], "movss1", 4);
-    CGInst op = CGCreateNewInst (opcode, "rr", B, C);
-    dvmCompilerPcgSetVirtualReg (cUnit, ssaRep->defs[0], "movss1", 4, op);
-}
-
-void dvmCompilerPcgTranslate2addrDouble (CompilationUnitPCG *cUnit, MIR *mir, const char *opcode)
+void dvmCompilerPcgTranslateDouble (CompilationUnitPCG *cUnit, MIR *mir, const char *opcode)
 {
     //Get the SSARepresentation
     SSARepresentation *ssaRep = mir->ssaRep;
@@ -291,19 +265,6 @@ void dvmCompilerPcgTranslate2addrDouble (CompilationUnitPCG *cUnit, MIR *mir, co
     dvmCompilerPcgSetVirtualReg (cUnit, ssaRep->defs[0], "movsd1", 8, op);
 }
 
-void dvmCompilerPcgTranslate3addrDouble (CompilationUnitPCG *cUnit, MIR *mir, const char *opcode)
-{
-    //Get the SSARepresentation
-    SSARepresentation *ssaRep = mir->ssaRep;
-
-    assert (ssaRep != 0);
-
-    CGInst B = dvmCompilerPcgGetVirtualReg (cUnit, ssaRep->uses[0], "movsd1", 8);
-    CGInst C = dvmCompilerPcgGetVirtualReg (cUnit, ssaRep->uses[2], "movsd1", 8);
-    CGInst op = CGCreateNewInst (opcode, "rr", B, C);
-    dvmCompilerPcgSetVirtualReg (cUnit, ssaRep->defs[0], "movsd1", 8, op);
-}
-
 void dvmCompilerPcgTranslateIntToFP (CompilationUnitPCG *cUnit, MIR *mir, int32_t size)
 {
     //Get the SSARepresentation
diff --git a/vm/compiler/codegen/x86/pcg/LowerALU.h b/vm/compiler/codegen/x86/pcg/LowerALU.h
index 102fd25..9303a91 100644
--- a/vm/compiler/codegen/x86/pcg/LowerALU.h
+++ b/vm/compiler/codegen/x86/pcg/LowerALU.h
@@ -72,18 +72,11 @@ void dvmCompilerPcgTranslateConstHigh16 (CompilationUnitPCG *cUnit, MIR *mir);
 void dvmCompilerPcgTranslateConstWide (CompilationUnitPCG *cUnit, MIR *mir, u8 val);
 
 /**
- * @brief Translate a 2addr LL reg instruction
+ * @brief Translate a 2addr or 3addr LL reg instruction
  * @param cUnit the CompilationUnitPCG
  * @param mir the MIR instruction
  */
-void dvmCompilerPcgTranslate2addrLLreg (CompilationUnitPCG *cUnit, MIR *mir, const char *dvmCompilerPcgTranslateOpcode);
-
-/**
- * @brief Translate a 3addr LL reg instruction
- * @param cUnit the CompilationUnitPCG
- * @param mir the MIR instruction
- */
-void dvmCompilerPcgTranslate3addrLLreg (CompilationUnitPCG *cUnit, MIR *mir, const char *dvmCompilerPcgTranslateOpcode);
+void dvmCompilerPcgTranslateLLreg (CompilationUnitPCG *cUnit, MIR *mir, const char *dvmCompilerPcgTranslateOpcode);
 
 /**
  * @brief Translate a LLreg operation
@@ -100,32 +93,18 @@ void dvmCompilerPcgTranslateLLregOp (CompilationUnitPCG *cUnit, const char *dvmC
 void dvmCompilerPcgTranslateLLregShift (CompilationUnitPCG *cUnit, MIR *mir, const char *dvmCompilerPcgTranslateOpcode);
 
 /**
- * @brief Translate a 2addr float
- * @param cUnit the CompilationUnitPCG
- * @param mir the MIR instruction
- */
-void dvmCompilerPcgTranslate2addrFloat (CompilationUnitPCG *cUnit, MIR *mir, const char *dvmCompilerPcgTranslateOpcode);
-
-/**
- * @brief Translate a 3addr float
- * @param cUnit the CompilationUnitPCG
- * @param mir the MIR instruction
- */
-void dvmCompilerPcgTranslate3addrFloat (CompilationUnitPCG *cUnit, MIR *mir, const char *dvmCompilerPcgTranslateOpcode);
-
-/**
- * @brief Translate a 2addr double
+ * @brief Translate a 2addr or 3addr float
  * @param cUnit the CompilationUnitPCG
  * @param mir the MIR instruction
  */
-void dvmCompilerPcgTranslate2addrDouble (CompilationUnitPCG *cUnit, MIR *mir, const char *dvmCompilerPcgTranslateOpcode);
+void dvmCompilerPcgTranslateFloat (CompilationUnitPCG *cUnit, MIR *mir, const char *dvmCompilerPcgTranslateOpcode);
 
 /**
- * @brief Translate a 3addr double
+ * @brief Translate a 2addr or 3addr double
  * @param cUnit the CompilationUnitPCG
  * @param mir the MIR instruction
  */
-void dvmCompilerPcgTranslate3addrDouble (CompilationUnitPCG *cUnit, MIR *mir, const char *dvmCompilerPcgTranslateOpcode);
+void dvmCompilerPcgTranslateDouble (CompilationUnitPCG *cUnit, MIR *mir, const char *dvmCompilerPcgTranslateOpcode);
 
 /**
  * @brief Translate an integer to a floating point
diff --git a/vm/compiler/codegen/x86/pcg/LowerCall.cpp b/vm/compiler/codegen/x86/pcg/LowerCall.cpp
index b938497..b175ad8 100644
--- a/vm/compiler/codegen/x86/pcg/LowerCall.cpp
+++ b/vm/compiler/codegen/x86/pcg/LowerCall.cpp
@@ -27,38 +27,6 @@
 #include "Singleton.h"
 #include "Utility.h"
 
-/**
- * @brief Get a call and register from a type
- * @param dtype the pcgDtype
- * @param rregPtr the register to use
- * @return the call opcode
- */
-static const char* dvmCompilerPcgGetCallOpcodeAndRreg (pcgDtype dtype, const char **rregPtr)
-{
-    switch (dtype)
-    {
-        case INTreg:
-            *rregPtr = "eax";
-            return "icall";
-
-        case LLreg:
-            *rregPtr = "eax";
-            return "lcall";
-
-        case NOreg:
-            *rregPtr = "";
-            return "call";
-
-        default:
-            break;
-    }
-
-    // We can add support for FP results, but they aren't currently needed, so just give an error here.
-    //TODO remove this exit -1
-    ALOGI ("PCG Error: Unsupported call dtype");
-    exit (-1);
-}
-
 CGSymbol dvmCompilerPcgGetInvokeTarget (CompilationUnitPCG *cUnit, const BasicBlockPCG *bb, bool *needsCfgArc)
 {
     CGSymbol sym;
@@ -115,87 +83,13 @@ static void dvmCompilerPcgAddPostInvokeEntryCode (CompilationUnitPCG *cUnit)
     cUnit->setFramePtr (pcgFramePtr);
 }
 
-/**
- * @details  Create a call to a routine that uses the standard X86 calling convention,
- * i.e. arguments on the stack. The number of arguments is specified by
- * nArgs, and the actual arguments are specified in a variable argument list.
- * Each argument is specified by two arguments: pcgDtype, CGInst.
- * The result data type is given by resultDtype, which can be NOreg. All
- * result types are supported.
- *
- * This routine currently assumes that EDI and EBP are needed by the callee.
- * That may not be necessary.
- */
-CGInst dvmCompilerPcgGenerateX86Call (CompilationUnitPCG *cUnit, const char *targetName, pcgDtype resultDtype, int nArgs, ...)
+void dvmCompilerPcgTranslateInvokeVirtualQuick (CompilationUnitPCG *cUnit, MIR *mir)
 {
-    CGSymbol target = singletonPtr<PersistentInfo> ()->getCallBack (targetName);
-    const char *rreg;
-    const char *callOpc = dvmCompilerPcgGetCallOpcodeAndRreg (resultDtype, &rreg);
-    const char *copyOpc;
-    int32_t stackSize, offset, i;
-    va_list args;
-    CGInst spIl;
-    CGInst parms[3];
-
-    // Compute the required stack size to hold outgoing arguments.
-    stackSize = 0;
-    va_start (args, nArgs);
-    for (i = 0; i < nArgs; i++)
-    {
-        pcgDtype argDtype = (pcgDtype) va_arg (args, int);
-
-        // Advance past the actual argument.  It isn't needed here.
-        va_arg (args, CGInst);
-
-        stackSize += dvmCompilerPcgGetOpcodeAndSizeForDtype (argDtype, &copyOpc);
-    }
-    va_end (args);
-
-    //We must align the stack
-    int32_t remainder = stackSize % 16;
-
-    if (remainder != 0)
-    {
-        stackSize += (16 - remainder);
-    }
+    BasicBlockPCG *bb = static_cast<BasicBlockPCG *> (mir->bb);
 
-    spIl = CGCreateNewInst ("sub", "ri", CGGetStackPointerDef (), stackSize);
-    CGSetRreg (spIl, "esp");
-
-    // Store the outgoing arguments to the stack.
-    offset = 0;
-    va_start (args, nArgs);
-    for (i = 0; i < nArgs; i++)
-    {
-        pcgDtype argDtype = (pcgDtype)va_arg (args, int);
-        CGInst arg = va_arg (args, CGInst);
-
-        int32_t argSize = dvmCompilerPcgGetOpcodeAndSizeForDtype (argDtype, &copyOpc);
-        dvmCompilerPcgCreateTypedStore (spIl, CGInstInvalid, 0, CGSymbolInvalid, offset,
-                argDtype, arg);
-        offset += argSize;
-    }
-    va_end (args);
-
-    parms[0] = dvmCompilerPcgGenerateVMPtrMov (cUnit);
-    parms[1] = dvmCompilerPcgGenerateFramePtrMov (cUnit);
-    parms[2] = CGInstInvalid;
-    CGInst theCall = CGCreateNewInst (callOpc, "nl", target, parms);
-    CGSetRreg (theCall, rreg);
-    spIl = CGCreateNewInst ("add", "ri", CGGetStackPointerDef (), stackSize);
-    CGSetRreg (spIl, "esp");
-
-    if (resultDtype != NOreg)
-    {
-        dvmCompilerPcgGetOpcodeAndSizeForDtype (resultDtype, &copyOpc);
-        theCall = CGCreateNewInst (copyOpc, "r", theCall);
-    }
-
-    return theCall;
-}
+    //Paranoid
+    assert (bb != 0);
 
-void dvmCompilerPcgTranslateInvokeVirtualQuick (CompilationUnitPCG *cUnit, BasicBlockPCG *bb, MIR *mir)
-{
     if (mir->OptimizationFlags & MIR_INLINED)
     {
         return;
@@ -250,8 +144,13 @@ ArgsDoneType dvmCompilerPcgTranslateConvertCalleeToType (const Method* calleeMet
     return ArgsDone_Normal;
 }
 
-void dvmCompilerPcgTranslateInvokeStaticSuperQuick (CompilationUnitPCG *cUnit, BasicBlockPCG *bb, MIR *mir)
+void dvmCompilerPcgTranslateInvokeStaticSuperQuick (CompilationUnitPCG *cUnit, MIR *mir)
 {
+    BasicBlockPCG *bb = static_cast<BasicBlockPCG *> (mir->bb);
+
+    //Paranoid
+    assert (bb != 0);
+
     Opcode dalvikOpCode = mir->dalvikInsn.opcode;
     const Method *calleeMethod;
 
@@ -291,8 +190,13 @@ void dvmCompilerPcgTranslateInvokeStaticSuperQuick (CompilationUnitPCG *cUnit, B
     dvmCompilerPcgCommonInvokeMethodJmp (cUnit, bb, methodType, methodIl);
 }
 
-void dvmCompilerPcgTranslateInvokeInterface (CompilationUnitPCG *cUnit, BasicBlockPCG *bb, MIR *mir)
+void dvmCompilerPcgTranslateInvokeInterface (CompilationUnitPCG *cUnit, MIR *mir)
 {
+    BasicBlockPCG *bb = static_cast<BasicBlockPCG *> (mir->bb);
+
+    //Paranoid
+    assert (bb != 0);
+
     //Get the SSARepresentation
     SSARepresentation *ssaRep = mir->ssaRep;
 
@@ -312,8 +216,13 @@ void dvmCompilerPcgTranslateInvokeInterface (CompilationUnitPCG *cUnit, BasicBlo
     dvmCompilerPcgGeneratePredictedChain (cUnit, bb, tmp, -1, true, C, mir);
 }
 
-void dvmCompilerPcgTranslateInvokeDirect (CompilationUnitPCG *cUnit, BasicBlockPCG *bb, MIR *mir)
+void dvmCompilerPcgTranslateInvokeDirect (CompilationUnitPCG *cUnit, MIR *mir)
 {
+    BasicBlockPCG *bb = static_cast<BasicBlockPCG *> (mir->bb);
+
+    //Paranoid
+    assert (bb != 0);
+
     //Get the SSARepresentation
     SSARepresentation *ssaRep = mir->ssaRep;
 
@@ -344,6 +253,11 @@ void dvmCompilerPcgTranslateInvokeDirect (CompilationUnitPCG *cUnit, BasicBlockP
 
 void dvmCompilerPcgTranslateReturn (CompilationUnitPCG *cUnit, MIR *mir, bool isVoid)
 {
+    BasicBlockPCG *bb = static_cast<BasicBlockPCG *> (mir->bb);
+
+    //Paranoid
+    assert (bb != 0);
+
     CGInst selfIl = dvmCompilerPcgGetSelfPointer (cUnit);
 
     if (isVoid == false)
diff --git a/vm/compiler/codegen/x86/pcg/LowerCall.h b/vm/compiler/codegen/x86/pcg/LowerCall.h
index 42d822e..b9d55a1 100644
--- a/vm/compiler/codegen/x86/pcg/LowerCall.h
+++ b/vm/compiler/codegen/x86/pcg/LowerCall.h
@@ -26,21 +26,11 @@ class CompilationUnitPCG;
 struct MIR;
 
 /**
- * @brief Generate X86 call
- * @param cUnit the CompilationUnitPCG
- * @param targetName the target name
- * @param resultDtype the result type
- * @param nArgs the number of arguments
- */
-CGInst dvmCompilerPcgGenerateX86Call (CompilationUnitPCG *cUnit, const char *targetName, pcgDtype resultDtype, int nArgs, ...);
-
-/**
  * @brief Translate the invoke virtual quick opcode
  * @param cUnit the CompilationUnit
- * @param bb the BasicBlock
  * @param mir the MIR instruction
  */
-void dvmCompilerPcgTranslateInvokeVirtualQuick (CompilationUnitPCG *cUnit, BasicBlockPCG *bb, MIR *mir);
+void dvmCompilerPcgTranslateInvokeVirtualQuick (CompilationUnitPCG *cUnit, MIR *mir);
 
 /**
  * @brief Convert callee to a type
@@ -52,26 +42,23 @@ ArgsDoneType dvmCompilerPcgTranslateConvertCalleeToType (const Method* calleeMet
 /**
  * @brief Translate the new invoke super quick bytecode
  * @param cUnit the CompilationUnit
- * @param bb the BasicBlockPCG
  * @param mir the MIR instruction
  */
-void dvmCompilerPcgTranslateInvokeStaticSuperQuick (CompilationUnitPCG *cUnit, BasicBlockPCG *bb, MIR *mir);
+void dvmCompilerPcgTranslateInvokeStaticSuperQuick (CompilationUnitPCG *cUnit, MIR *mir);
 
 /**
  * @brief Translate the invoke virtual interface
  * @param cUnit the CompilationUnit
- * @param bb the BasicBlockPCG
  * @param mir the MIR instruction
  */
-void dvmCompilerPcgTranslateInvokeInterface (CompilationUnitPCG *cUnit, BasicBlockPCG *bb, MIR *mir);
+void dvmCompilerPcgTranslateInvokeInterface (CompilationUnitPCG *cUnit, MIR *mir);
 
 /**
  * @brief Translate the new invoke direct bytecode
  * @param cUnit the CompilationUnit
- * @param bb the BasicBlockPCG
  * @param mir the MIR instruction
  */
-void dvmCompilerPcgTranslateInvokeDirect (CompilationUnitPCG *cUnit, BasicBlockPCG *bb, MIR *mir);
+void dvmCompilerPcgTranslateInvokeDirect (CompilationUnitPCG *cUnit, MIR *mir);
 
 /**
  * @brief Translate the return bytecode
diff --git a/vm/compiler/codegen/x86/pcg/LowerJump.cpp b/vm/compiler/codegen/x86/pcg/LowerJump.cpp
index a2c9940..44ef274 100644
--- a/vm/compiler/codegen/x86/pcg/LowerJump.cpp
+++ b/vm/compiler/codegen/x86/pcg/LowerJump.cpp
@@ -90,8 +90,13 @@ void dvmCompilerPcgTranslateConditionalJump (BasicBlockPCG *bb, CGInst a, const
     CGCreateNewInst ("cjcc", "rcrbp", a, cond, b, targetLabel, branchProb);
 }
 
-void dvmCompilerPcgTranslateIf (CompilationUnitPCG *cUnit, BasicBlockPCG *bb, MIR *mir, const char *cond)
+void dvmCompilerPcgTranslateIf (CompilationUnitPCG *cUnit, MIR *mir, const char *cond)
 {
+    BasicBlockPCG *bb = static_cast<BasicBlockPCG *> (mir->bb);
+
+    //Paranoid
+    assert (bb != 0);
+
     //Get the SSARepresentation
     SSARepresentation *ssaRep = mir->ssaRep;
 
@@ -102,8 +107,13 @@ void dvmCompilerPcgTranslateIf (CompilationUnitPCG *cUnit, BasicBlockPCG *bb, MI
     dvmCompilerPcgTranslateConditionalJump (bb, A, cond, B);
 }
 
-void dvmCompilerPcgTranslateIfZero (CompilationUnitPCG *cUnit, BasicBlockPCG *bb, MIR *mir, const char *cond)
+void dvmCompilerPcgTranslateIfZero (CompilationUnitPCG *cUnit, MIR *mir, const char *cond)
 {
+    BasicBlockPCG *bb = static_cast<BasicBlockPCG *> (mir->bb);
+
+    //Paranoid
+    assert (bb != 0);
+
     //Get the SSARepresentation
     SSARepresentation *ssaRep = mir->ssaRep;
 
@@ -121,11 +131,16 @@ void dvmCompilerPcgTranslateIfZero (CompilationUnitPCG *cUnit, BasicBlockPCG *bb
     dvmCompilerPcgTranslateConditionalJump (bb, A, cond, zero);
 }
 
-void dvmCompilerPcgTranslateIfFp (CompilationUnitPCG *cUnit, BasicBlockPCG *bb, MIR *mir, uint32_t opSize, int nanVal)
+void dvmCompilerPcgTranslateIfFp (CompilationUnitPCG *cUnit, MIR *mir, uint32_t opSize, int nanVal)
 {
     const char *opcode;
     const char *cond1, *cond2;
 
+    BasicBlockPCG *bb = static_cast<BasicBlockPCG *> (mir->bb);
+
+    //Paranoid
+    assert (bb != 0);
+
     if (opSize == 4)
     {
         opcode = "movss1";
diff --git a/vm/compiler/codegen/x86/pcg/LowerJump.h b/vm/compiler/codegen/x86/pcg/LowerJump.h
index 703d55e..fa78daa 100644
--- a/vm/compiler/codegen/x86/pcg/LowerJump.h
+++ b/vm/compiler/codegen/x86/pcg/LowerJump.h
@@ -50,30 +50,27 @@ void dvmCompilerPcgTranslateConditionalJump (BasicBlockPCG *bb, CGInst a, const
 /**
  * @brief Translate if
  * @param cUnit the CompilationUnitPCG
- * @param bb the BasicBlockPCG
  * @param mir the MIR instruction
  * @param cond the condition
  */
-void dvmCompilerPcgTranslateIf (CompilationUnitPCG *cUnit, BasicBlockPCG *bb, MIR *mir, const char *cond);
+void dvmCompilerPcgTranslateIf (CompilationUnitPCG *cUnit, MIR *mir, const char *cond);
 
 /**
  * @brief Translate a if-zero instruction
  * @param cUnit the CompilationUnitPCG
- * @param bb the BasicBlockPCG
  * @param mir the MIR instruction
  * @param cond the condition
  */
-void dvmCompilerPcgTranslateIfZero (CompilationUnitPCG *cUnit, BasicBlockPCG *bb, MIR *mir, const char *cond);
+void dvmCompilerPcgTranslateIfZero (CompilationUnitPCG *cUnit, MIR *mir, const char *cond);
 
 /**
  * @brief Translate a if-floating instruction
  * @param cUnit the CompilationUnitPCG
- * @param bb the BasicBlockPCG
  * @param mir the MIR instruction
  * @param opSize the size of the operation
  * @param naVal the nan value
  */
-void dvmCompilerPcgTranslateIfFp (CompilationUnitPCG *cUnit, BasicBlockPCG *bb, MIR *mir, uint32_t opSize, int nanVal);
+void dvmCompilerPcgTranslateIfFp (CompilationUnitPCG *cUnit, MIR *mir, uint32_t opSize, int nanVal);
 
 /**
  * @brief Translate a goto instruction
diff --git a/vm/compiler/codegen/x86/pcg/LowerMemory.h b/vm/compiler/codegen/x86/pcg/LowerMemory.h
index ba5a033..863add1 100644
--- a/vm/compiler/codegen/x86/pcg/LowerMemory.h
+++ b/vm/compiler/codegen/x86/pcg/LowerMemory.h
@@ -41,6 +41,7 @@ CGInst dvmCompilerPcgGetSelfPointer (const CompilationUnitPCG *cUnit);
 
 /**
  * @brief Create a simple load
+ * @details this relates to 32-bit loads that just use a base register to specify the address
  * @param base the base register
  * @param offset the offset
  * @return the load
@@ -48,7 +49,8 @@ CGInst dvmCompilerPcgGetSelfPointer (const CompilationUnitPCG *cUnit);
 CGInst dvmCompilerPcgCreateSimpleLoad (CGInst base, int32_t offset);
 
 /**
- * @brief Create a simple load
+ * @brief Create a simple store
+ * @details this relates to 32-bit stores that just use a base register to specify the address
  * @param base the base register
  * @param offset the offset
  * @param r what we want to store
@@ -73,6 +75,7 @@ void dvmCompilerPcgStoreVirtualReg (CompilationUnitPCG *cUnit, int ssaNum, int s
 
 /**
  * @brief Create a store
+ * @brief this relates to 32-bit stores
  * @param base the base register
  * @param scale the scale
  * @param offset the offset
diff --git a/vm/compiler/codegen/x86/pcg/LowerOther.cpp b/vm/compiler/codegen/x86/pcg/LowerOther.cpp
index c332293..09f05d1 100644
--- a/vm/compiler/codegen/x86/pcg/LowerOther.cpp
+++ b/vm/compiler/codegen/x86/pcg/LowerOther.cpp
@@ -389,7 +389,7 @@ void dvmCompilerPcgAddVRInterfaceCode (CompilationUnitPCG *cUnit)
     const char *pcgOpcode;
     int32_t size;
 
-    if (cUnit->checkOptimizationMask (OptimizationMaskRegisterizeVRs) == true)
+    if (cUnit->checkDebugMask (DebugMaskRegisterizeVRs) == true)
     {
         ALOGI ("    BEGIN Generating Entry Loads.\n    =============================\n");
     }
@@ -414,7 +414,7 @@ void dvmCompilerPcgAddVRInterfaceCode (CompilationUnitPCG *cUnit)
         if (info.checkedForNull == true)
         {
             // speculative null check has already loaded this ssa
-            if (cUnit->checkOptimizationMask (OptimizationMaskRegisterizeVRs) == true)
+            if (cUnit->checkDebugMask (DebugMaskRegisterizeVRs) == true)
             {
                 ALOGI ("    Not generating entry load for v%d_%d."
                         " Already null checked.\n",
@@ -424,7 +424,7 @@ void dvmCompilerPcgAddVRInterfaceCode (CompilationUnitPCG *cUnit)
             continue;
         }
 
-        if (cUnit->checkOptimizationMask (OptimizationMaskRegisterizeVRs) == true)
+        if (cUnit->checkDebugMask (DebugMaskRegisterizeVRs) == true)
         {
             ALOGI ("    Generating entry load for v%d_%d.\n", virtualReg,
                     DECODE_SUB (dvmConvertSSARegToDalvik (cUnit, ssaNum)));
@@ -439,7 +439,7 @@ void dvmCompilerPcgAddVRInterfaceCode (CompilationUnitPCG *cUnit)
         CGAddTempDef (info.parentSSANum, load);
     }
 
-    if (cUnit->checkOptimizationMask (OptimizationMaskRegisterizeVRs) == true)
+    if (cUnit->checkDebugMask (DebugMaskRegisterizeVRs) == true)
     {
         ALOGI ("    END Generating Entry Loads.\n"
                 "    ===========================\n");
diff --git a/vm/compiler/codegen/x86/pcg/PcgInterface.cpp b/vm/compiler/codegen/x86/pcg/PcgInterface.cpp
index ba60d48..4379b83 100644
--- a/vm/compiler/codegen/x86/pcg/PcgInterface.cpp
+++ b/vm/compiler/codegen/x86/pcg/PcgInterface.cpp
@@ -64,11 +64,7 @@ static void pcgConfigureTrace (CompilationUnitPCG *cUnit)
  */
 void pcgDvmCompilerMIR2LIR (CompilationUnit *cUnitME, JitTranslationInfo* info)
 {
-    CompilationUnitPCG cUnit;
-    CompilationUnit &cUnitLimited = cUnit;
-
-    //Copy the ME's CUnit in
-    cUnitLimited = *cUnitME;
+    CompilationUnitPCG cUnit (cUnitME);
 
     // cUnit->baseAddr gives the address of the entry point for the compiled
     // trace.  Note that this might not be the first available byte in the code
@@ -90,26 +86,29 @@ void pcgDvmCompilerMIR2LIR (CompilationUnit *cUnitME, JitTranslationInfo* info)
 
     CGCreateRoutine (&cUnit);
 
+    //If analysis succeeds continue
+    if (dvmCompilerPcgNewRegisterizeVRAnalysis (&cUnit) == true)
+    {
+        cUnit.registerizeAnalysisDone ();
+        dvmCompilerPcgModSSANum (&cUnit);
 
-    dvmCompilerPcgNewRegisterizeVRAnalysis (&cUnit);
-    cUnit.registerizeAnalysisDone ();
-    dvmCompilerPcgModSSANum (&cUnit);
-
-    pcgConfigureTrace (&cUnit);
+        pcgConfigureTrace (&cUnit);
 
-    bool success = dvmCompilerPcgGenerateIlForTrace (&cUnit, info);
+        bool success = dvmCompilerPcgGenerateIlForTrace (&cUnit, info);
 
-    // Note that if !success, we leave cUnit->baseAddr as 0.
-    if (success == true)
-    {
-        CGCompileRoutine (&cUnit);
-        dvmCompilerPcgEmitCode (&cUnit, info);
+        // Note that if !success, we leave cUnit->baseAddr as 0.
+        if (success == true)
+        {
+            CGCompileRoutine (&cUnit);
+            dvmCompilerPcgEmitCode (&cUnit, info);
+        }
     }
 
     CGEndRoutine (0);
 
     //Copy back
-    *cUnitME = cUnitLimited;
+    CompilationUnit *cUnitLimited = &cUnit;
+    *cUnitME = *cUnitLimited;
 }
 
 /**
@@ -122,6 +121,10 @@ static void dvmCompilerPcgCreateCallBack (const char * name, void *addr)
     singletonPtr<PersistentInfo> ()->setCallBack (name, dvmCompilerPcgCreateSymbol (name, addr));
 }
 
+
+//External definition for the module initialization
+extern "C" int64_t __muldi3(int64_t, int64_t);
+
 /**
  * @brief PCG module level initialization
  */
@@ -129,6 +132,9 @@ void pcgModuleBegin (void)
 {
     CGCreateModule (0);
 
+    //Add muldi3
+    dvmCompilerPcgCreateCallBack("__muldi3", (void *) __muldi3);
+
 #ifdef DEBUG_HOOK
     void *hookPtr = dvmCompilerPcgCreateHookFunction ();
     dvmCompilerPcgCreateCallBack ("debugHook",  hookPtr);
@@ -156,15 +162,6 @@ static BasicBlock *pcgBBAllocator (void)
 /**
  * @brief Initialization of the plugin for the PCG back-end
  */
-
-extern "C" int64_t __muldi3(int64_t, int64_t);
-
-void pullinginlibgccsymbols() {
-    // This is required to pull in the __muldi3 symbol
-    int64_t a = 0;
-    a = __muldi3(a, a);
-}
-
 extern "C" void setupPcgJit (void) {
     //Now set the default function pointers
     SJitFramework &jitFramework = gDvmJit.jitFramework;
@@ -178,6 +175,9 @@ extern "C" void setupPcgJit (void) {
     jitFramework.backEndInvokeArgsDone = dvmCompilerPcgHandleInvokeArgsHeader;
 }
 
+/**
+ * @brief Plugin initialization
+ */
 extern "C" void dalvikPluginInit (void) {
     ALOGI ("\n+++++++++++++ Using PCG. +++++++++++++++++++++\n");
 
@@ -189,4 +189,5 @@ extern "C" void dalvikPluginInit (void) {
     dvmCompilerRemovePass("Invariant_Removal");
     dvmCompilerRemovePass("Iget_Iput_Removal");
     dvmCompilerRemovePass("Accumulation_Sinking");
+    dvmCompilerRemovePass("DDDO_Optimization");
 }
diff --git a/vm/compiler/codegen/x86/pcg/Utility.cpp b/vm/compiler/codegen/x86/pcg/Utility.cpp
index 110f2e1..56e3f19 100644
--- a/vm/compiler/codegen/x86/pcg/Utility.cpp
+++ b/vm/compiler/codegen/x86/pcg/Utility.cpp
@@ -20,8 +20,43 @@
 #include "Dataflow.h"
 #include "Labels.h"
 #include "LowerMemory.h"
+#include "LowerOther.h"
+#include "PersistentInfo.h"
+#include "Singleton.h"
 #include "Utility.h"
 
+/**
+ * @brief Get a call and register from a type
+ * @param dtype the pcgDtype
+ * @param rregPtr the register to use
+ * @return the call opcode
+ */
+static const char *getCallOpcodeAndRreg (pcgDtype dtype, const char **rregPtr)
+{
+    switch (dtype)
+    {
+        case INTreg:
+            *rregPtr = "eax";
+            return "icall";
+
+        case LLreg:
+            *rregPtr = "eax";
+            return "lcall";
+
+        case NOreg:
+            *rregPtr = "";
+            return "call";
+
+        default:
+            break;
+    }
+
+    // We can add support for FP results, but they aren't currently needed, so just give an error here.
+    //TODO remove this exit -1
+    ALOGI ("PCG Error: Unsupported call dtype");
+    exit (-1);
+}
+
 int32_t dvmCompilerPcgGetOpcodeAndSizeForDtype (pcgDtype dtype, const char **opcPtr)
 {
     int32_t size;
@@ -88,36 +123,36 @@ void dvmCompilerPcgSetDtypeForSSANum (CompilationUnitPCG *cUnit, int ssaNum, pcg
 {
     //TODO: Same issue as above, before we had a find and no check for end, so this is diff
     //See if we care
-    SSANumInfo &info = cUnit->getSSANumInformation (ssaNum);
+    SSANumInfo *info = & (cUnit->getSSANumInformation (ssaNum));
 
     //Get parent SSA
-    int parentSSANum = info.parentSSANum;
+    int parentSSANum = info->parentSSANum;
 
     //See if we have a parent
     if (ssaNum != parentSSANum)
     {
         //Get its information
-        info = cUnit->getSSANumInformation (parentSSANum);
+        info = & (cUnit->getSSANumInformation (parentSSANum));
     }
 
     //TODO: ask why we don't set the ssaNum, only its parent in certain cases
-    info.dtype = dtype;
+    info->dtype = dtype;
 }
 
 CGInst dvmCompilerPcgGetVirtualReg (CompilationUnitPCG *cUnit, int ssaNum, const char *pcgOpcode, uint32_t loadSize)
 {
     //Get parent ssaNum
-    SSANumInfo &info = cUnit->getSSANumInformation (ssaNum);
-    ssaNum = info.parentSSANum;
+    SSANumInfo *info = & (cUnit->getSSANumInformation (ssaNum));
+    ssaNum = info->parentSSANum;
 
     //TODO handle dynamic_cast better
     int dalvikReg = dvmConvertSSARegToDalvik (dynamic_cast<CompilationUnit *> (cUnit), ssaNum);
 
-    if (info.registerize == true)
+    if (info->registerize == true)
     {
         //Get its parent SSA information
-        info = cUnit->getSSANumInformation (ssaNum);
-        return CGGetTempUseInst (info.parentSSANum);
+        info = & (cUnit->getSSANumInformation (ssaNum));
+        return CGGetTempUseInst (info->parentSSANum);
     }
 
     u2 virtualReg = DECODE_REG (dalvikReg);
@@ -133,10 +168,10 @@ void dvmCompilerPcgSetVirtualReg (CompilationUnitPCG *cUnit, int ssaNum, const c
                              uint32_t storeSize, CGInst storeVal)
 {
     //Get parent ssaNum
-    SSANumInfo &info = cUnit->getSSANumInformation (ssaNum);
-    ssaNum = info.parentSSANum;
+    SSANumInfo *info = & (cUnit->getSSANumInformation (ssaNum));
+    ssaNum = info->parentSSANum;
 
-    if (info.registerize == true)
+    if (info->registerize == true)
     {
         pcgDtype regDtype = dvmCompilerPcgGetDtypeForSSANum (cUnit, ssaNum);
         dvmCompilerPcgGetOpcodeAndSizeForDtype (regDtype, &pcgOpcode);
@@ -276,18 +311,29 @@ void dvmCompilerPcgGetBlockName (BasicBlockPCG *bb, std::string &label)
  */
 static void dumpBitVector (CompilationUnit *cUnit, BitVector *bv, int n)
 {
-    ALOGI ("{ ");
+    char buffer[512];
+    std::string s = "{ ";
     for (int i = 0; i < n; i ++)
     {
         if (dvmIsBitSet (bv, i) == true)
         {
             int dalvikReg = dvmConvertSSARegToDalvik (cUnit, i);
+
+            //Decode the SSA register
             u2 vrNum = DECODE_REG (dalvikReg);
             u2 vrSub = DECODE_SUB (dalvikReg);
-            ALOGI ("%d_%d ", vrNum, vrSub);
+
+            //Get the numbers in a char*
+            snprintf (buffer, sizeof (buffer), "%d_%d ", vrNum, vrSub);
+
+            //Append it
+            s += buffer;
         }
     }
-    ALOGI ("}");
+
+    s += "}";
+
+    ALOGI ("%s", s.c_str ());
 }
 
 void dvmCompilerPcgDumpModRegInfo (CompilationUnitPCG *cUnit)
@@ -513,3 +559,82 @@ CGInst dvmCompilerPcgGetResClasses (CGInst selfPtr)
     return ret;
 }
 
+/**
+ * @details  Create a call to a routine that uses the standard X86 calling convention,
+ * i.e. arguments on the stack. The number of arguments is specified by
+ * nArgs, and the actual arguments are specified in a variable argument list.
+ * Each argument is specified by two arguments: pcgDtype, CGInst.
+ * The result data type is given by resultDtype, which can be NOreg. All
+ * result types are supported.
+ *
+ * This routine currently assumes that EDI and EBP are needed by the callee.
+ * That may not be necessary.
+ */
+CGInst dvmCompilerPcgGenerateX86Call (CompilationUnitPCG *cUnit, const char *targetName, pcgDtype resultDtype, int nArgs, ...)
+{
+    CGSymbol target = singletonPtr<PersistentInfo> ()->getCallBack (targetName);
+    const char *rreg;
+    const char *callOpc = getCallOpcodeAndRreg (resultDtype, &rreg);
+    const char *copyOpc;
+    int32_t stackSize, offset, i;
+    va_list args;
+    CGInst spIl;
+    CGInst parms[3];
+
+    // Compute the required stack size to hold outgoing arguments.
+    stackSize = 0;
+    va_start (args, nArgs);
+    for (i = 0; i < nArgs; i++)
+    {
+        pcgDtype argDtype = (pcgDtype) va_arg (args, int);
+
+        // Advance past the actual argument.  It isn't needed here.
+        va_arg (args, CGInst);
+
+        stackSize += dvmCompilerPcgGetOpcodeAndSizeForDtype (argDtype, &copyOpc);
+    }
+    va_end (args);
+
+    //We must align the stack
+    int32_t remainder = stackSize % 16;
+
+    if (remainder != 0)
+    {
+        stackSize += (16 - remainder);
+    }
+
+    spIl = CGCreateNewInst ("sub", "ri", CGGetStackPointerDef (), stackSize);
+    CGSetRreg (spIl, "esp");
+
+    // Store the outgoing arguments to the stack.
+    offset = 0;
+    va_start (args, nArgs);
+    for (i = 0; i < nArgs; i++)
+    {
+        pcgDtype argDtype = (pcgDtype)va_arg (args, int);
+        CGInst arg = va_arg (args, CGInst);
+
+        int32_t argSize = dvmCompilerPcgGetOpcodeAndSizeForDtype (argDtype, &copyOpc);
+        dvmCompilerPcgCreateTypedStore (spIl, CGInstInvalid, 0, CGSymbolInvalid, offset,
+                argDtype, arg);
+        offset += argSize;
+    }
+    va_end (args);
+
+    parms[0] = dvmCompilerPcgGenerateVMPtrMov (cUnit);
+    parms[1] = dvmCompilerPcgGenerateFramePtrMov (cUnit);
+    parms[2] = CGInstInvalid;
+    CGInst theCall = CGCreateNewInst (callOpc, "nl", target, parms);
+    CGSetRreg (theCall, rreg);
+    spIl = CGCreateNewInst ("add", "ri", CGGetStackPointerDef (), stackSize);
+    CGSetRreg (spIl, "esp");
+
+    if (resultDtype != NOreg)
+    {
+        dvmCompilerPcgGetOpcodeAndSizeForDtype (resultDtype, &copyOpc);
+        theCall = CGCreateNewInst (copyOpc, "r", theCall);
+    }
+
+    return theCall;
+}
+
diff --git a/vm/compiler/codegen/x86/pcg/Utility.h b/vm/compiler/codegen/x86/pcg/Utility.h
index 11717a9..cd49e2d 100644
--- a/vm/compiler/codegen/x86/pcg/Utility.h
+++ b/vm/compiler/codegen/x86/pcg/Utility.h
@@ -129,4 +129,13 @@ bool dvmCompilerPcgBlockEndsInInvoke (BasicBlockPCG *bb);
  * @parm selfPtr the self pointer
  */
 CGInst dvmCompilerPcgGetResClasses (CGInst selfPtr);
+
+/**
+ * @brief Generate X86 call
+ * @param cUnit the CompilationUnitPCG
+ * @param targetName the target name
+ * @param resultDtype the result type
+ * @param nArgs the number of arguments
+ */
+CGInst dvmCompilerPcgGenerateX86Call (CompilationUnitPCG *cUnit, const char *targetName, pcgDtype resultDtype, int nArgs, ...);
 #endif
diff --git a/vm/compiler/codegen/x86/pcg/libpcg.h b/vm/compiler/codegen/x86/pcg/libpcg.h
index c11c351..e6e71f8 100644
--- a/vm/compiler/codegen/x86/pcg/libpcg.h
+++ b/vm/compiler/codegen/x86/pcg/libpcg.h
@@ -672,7 +672,7 @@ extern void CGSetTraceOutputFile(FILE *trace_file);
 //     coming into all routines, and we try to maintain 16B alignment going
 //     out from all calls.
 //     This is mode "2", and how GCC and ICC operate, by default.
-//     Note that, for Windows, the default is "0".  
+//     Note that, for Windows, the default is "0".
 //
 //     This interface is used to change the default behavior.
 //     "0" is used to completely remove all alignment, and only align the stack
-- 
1.7.4.1

