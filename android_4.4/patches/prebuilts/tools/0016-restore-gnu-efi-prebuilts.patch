From d7afdf68265936b0a91b24868d6acfd9ebc1772c Mon Sep 17 00:00:00 2001
From: Andrew Boie <andrew.p.boie@intel.com>
Date: Wed, 6 Nov 2013 10:51:22 -0800
Subject: restore gnu-efi prebuilts

Change-Id: I50d52818c04ce508b5208c32b091e0f1ef17a1ba
Signed-off-by: Andrew Boie <andrew.p.boie@intel.com>
---
 linux-x86/gnu-efi/include/efi/efi.h                |   50 +
 linux-x86/gnu-efi/include/efi/efi_nii.h            |   74 +
 linux-x86/gnu-efi/include/efi/efi_pxe.h            | 1743 ++++++++++++++++++++
 linux-x86/gnu-efi/include/efi/efiapi.h             | 1003 +++++++++++
 linux-x86/gnu-efi/include/efi/eficon.h             |  302 ++++
 linux-x86/gnu-efi/include/efi/efidebug.h           |  110 ++
 linux-x86/gnu-efi/include/efi/efidef.h             |  196 +++
 linux-x86/gnu-efi/include/efi/efidevp.h            |  402 +++++
 linux-x86/gnu-efi/include/efi/efierr.h             |   60 +
 linux-x86/gnu-efi/include/efi/efifs.h              |  116 ++
 linux-x86/gnu-efi/include/efi/efigpt.h             |   68 +
 linux-x86/gnu-efi/include/efi/efilib.h             |  880 ++++++++++
 linux-x86/gnu-efi/include/efi/efilink.h            |  177 ++
 linux-x86/gnu-efi/include/efi/efinet.h             |  340 ++++
 linux-x86/gnu-efi/include/efi/efipart.h            |   61 +
 linux-x86/gnu-efi/include/efi/efipciio.h           |  219 +++
 linux-x86/gnu-efi/include/efi/efiprot.h            |  736 +++++++++
 linux-x86/gnu-efi/include/efi/efipxebc.h           |  463 ++++++
 linux-x86/gnu-efi/include/efi/efirtlib.h           |  141 ++
 linux-x86/gnu-efi/include/efi/efiser.h             |  132 ++
 linux-x86/gnu-efi/include/efi/efistdarg.h          |   33 +
 linux-x86/gnu-efi/include/efi/efiui.h              |   54 +
 linux-x86/gnu-efi/include/efi/ia32/efibind.h       |  282 ++++
 linux-x86/gnu-efi/include/efi/ia32/efilibplat.h    |   26 +
 linux-x86/gnu-efi/include/efi/ia32/pe.h            |  591 +++++++
 linux-x86/gnu-efi/include/efi/libsmbios.h          |  132 ++
 linux-x86/gnu-efi/include/efi/pci22.h              |  193 +++
 .../gnu-efi/include/efi/protocol/adapterdebug.h    |   32 +
 .../gnu-efi/include/efi/protocol/eficonsplit.h     |   32 +
 linux-x86/gnu-efi/include/efi/protocol/efidbg.h    |  210 +++
 linux-x86/gnu-efi/include/efi/protocol/efivar.h    |  133 ++
 linux-x86/gnu-efi/include/efi/protocol/intload.h   |   27 +
 .../gnu-efi/include/efi/protocol/legacyboot.h      |  119 ++
 linux-x86/gnu-efi/include/efi/protocol/piflash64.h |  121 ++
 linux-x86/gnu-efi/include/efi/protocol/vgaclass.h  |   95 ++
 linux-x86/gnu-efi/include/efi/romload.h            |   41 +
 linux-x86/gnu-efi/lib/crt0-efi-ia32.o              |  Bin 0 -> 868 bytes
 linux-x86/gnu-efi/lib/elf_ia32_efi.lds             |   75 +
 linux-x86/gnu-efi/lib/libefi.a                     |  Bin 0 -> 89884 bytes
 linux-x86/gnu-efi/lib/libgnuefi.a                  |  Bin 0 -> 1884 bytes
 linux-x86_64/gnu-efi/include/efi/efi.h             |   50 +
 linux-x86_64/gnu-efi/include/efi/efi_nii.h         |   74 +
 linux-x86_64/gnu-efi/include/efi/efi_pxe.h         | 1743 ++++++++++++++++++++
 linux-x86_64/gnu-efi/include/efi/efiapi.h          | 1003 +++++++++++
 linux-x86_64/gnu-efi/include/efi/eficon.h          |  302 ++++
 linux-x86_64/gnu-efi/include/efi/efidebug.h        |  110 ++
 linux-x86_64/gnu-efi/include/efi/efidef.h          |  196 +++
 linux-x86_64/gnu-efi/include/efi/efidevp.h         |  402 +++++
 linux-x86_64/gnu-efi/include/efi/efierr.h          |   60 +
 linux-x86_64/gnu-efi/include/efi/efifs.h           |  116 ++
 linux-x86_64/gnu-efi/include/efi/efigpt.h          |   68 +
 linux-x86_64/gnu-efi/include/efi/efilib.h          |  880 ++++++++++
 linux-x86_64/gnu-efi/include/efi/efilink.h         |  177 ++
 linux-x86_64/gnu-efi/include/efi/efinet.h          |  340 ++++
 linux-x86_64/gnu-efi/include/efi/efipart.h         |   61 +
 linux-x86_64/gnu-efi/include/efi/efipciio.h        |  219 +++
 linux-x86_64/gnu-efi/include/efi/efiprot.h         |  736 +++++++++
 linux-x86_64/gnu-efi/include/efi/efipxebc.h        |  463 ++++++
 linux-x86_64/gnu-efi/include/efi/efirtlib.h        |  141 ++
 linux-x86_64/gnu-efi/include/efi/efiser.h          |  132 ++
 linux-x86_64/gnu-efi/include/efi/efistdarg.h       |   33 +
 linux-x86_64/gnu-efi/include/efi/efiui.h           |   54 +
 linux-x86_64/gnu-efi/include/efi/libsmbios.h       |  132 ++
 linux-x86_64/gnu-efi/include/efi/pci22.h           |  193 +++
 .../gnu-efi/include/efi/protocol/adapterdebug.h    |   32 +
 .../gnu-efi/include/efi/protocol/eficonsplit.h     |   32 +
 linux-x86_64/gnu-efi/include/efi/protocol/efidbg.h |  210 +++
 linux-x86_64/gnu-efi/include/efi/protocol/efivar.h |  133 ++
 .../gnu-efi/include/efi/protocol/intload.h         |   27 +
 .../gnu-efi/include/efi/protocol/legacyboot.h      |  119 ++
 .../gnu-efi/include/efi/protocol/piflash64.h       |  121 ++
 .../gnu-efi/include/efi/protocol/vgaclass.h        |   95 ++
 linux-x86_64/gnu-efi/include/efi/romload.h         |   41 +
 linux-x86_64/gnu-efi/include/efi/x86_64/efibind.h  |  285 ++++
 .../gnu-efi/include/efi/x86_64/efilibplat.h        |   26 +
 linux-x86_64/gnu-efi/include/efi/x86_64/pe.h       |  591 +++++++
 linux-x86_64/gnu-efi/lib/crt0-efi-x86_64.o         |  Bin 0 -> 1328 bytes
 linux-x86_64/gnu-efi/lib/elf_x86_64_efi.lds        |   63 +
 linux-x86_64/gnu-efi/lib/libefi.a                  |  Bin 0 -> 114950 bytes
 linux-x86_64/gnu-efi/lib/libgnuefi.a               |  Bin 0 -> 2480 bytes
 80 files changed, 18929 insertions(+), 0 deletions(-)
 create mode 100644 linux-x86/gnu-efi/include/efi/efi.h
 create mode 100644 linux-x86/gnu-efi/include/efi/efi_nii.h
 create mode 100644 linux-x86/gnu-efi/include/efi/efi_pxe.h
 create mode 100644 linux-x86/gnu-efi/include/efi/efiapi.h
 create mode 100644 linux-x86/gnu-efi/include/efi/eficon.h
 create mode 100644 linux-x86/gnu-efi/include/efi/efidebug.h
 create mode 100644 linux-x86/gnu-efi/include/efi/efidef.h
 create mode 100644 linux-x86/gnu-efi/include/efi/efidevp.h
 create mode 100644 linux-x86/gnu-efi/include/efi/efierr.h
 create mode 100644 linux-x86/gnu-efi/include/efi/efifs.h
 create mode 100644 linux-x86/gnu-efi/include/efi/efigpt.h
 create mode 100644 linux-x86/gnu-efi/include/efi/efilib.h
 create mode 100644 linux-x86/gnu-efi/include/efi/efilink.h
 create mode 100644 linux-x86/gnu-efi/include/efi/efinet.h
 create mode 100644 linux-x86/gnu-efi/include/efi/efipart.h
 create mode 100644 linux-x86/gnu-efi/include/efi/efipciio.h
 create mode 100644 linux-x86/gnu-efi/include/efi/efiprot.h
 create mode 100644 linux-x86/gnu-efi/include/efi/efipxebc.h
 create mode 100644 linux-x86/gnu-efi/include/efi/efirtlib.h
 create mode 100644 linux-x86/gnu-efi/include/efi/efiser.h
 create mode 100644 linux-x86/gnu-efi/include/efi/efistdarg.h
 create mode 100644 linux-x86/gnu-efi/include/efi/efiui.h
 create mode 100644 linux-x86/gnu-efi/include/efi/ia32/efibind.h
 create mode 100644 linux-x86/gnu-efi/include/efi/ia32/efilibplat.h
 create mode 100644 linux-x86/gnu-efi/include/efi/ia32/pe.h
 create mode 100644 linux-x86/gnu-efi/include/efi/libsmbios.h
 create mode 100644 linux-x86/gnu-efi/include/efi/pci22.h
 create mode 100644 linux-x86/gnu-efi/include/efi/protocol/adapterdebug.h
 create mode 100644 linux-x86/gnu-efi/include/efi/protocol/eficonsplit.h
 create mode 100644 linux-x86/gnu-efi/include/efi/protocol/efidbg.h
 create mode 100644 linux-x86/gnu-efi/include/efi/protocol/efivar.h
 create mode 100644 linux-x86/gnu-efi/include/efi/protocol/intload.h
 create mode 100644 linux-x86/gnu-efi/include/efi/protocol/legacyboot.h
 create mode 100644 linux-x86/gnu-efi/include/efi/protocol/piflash64.h
 create mode 100644 linux-x86/gnu-efi/include/efi/protocol/vgaclass.h
 create mode 100644 linux-x86/gnu-efi/include/efi/romload.h
 create mode 100644 linux-x86/gnu-efi/lib/crt0-efi-ia32.o
 create mode 100644 linux-x86/gnu-efi/lib/elf_ia32_efi.lds
 create mode 100644 linux-x86/gnu-efi/lib/libefi.a
 create mode 100644 linux-x86/gnu-efi/lib/libgnuefi.a
 create mode 100644 linux-x86_64/gnu-efi/include/efi/efi.h
 create mode 100644 linux-x86_64/gnu-efi/include/efi/efi_nii.h
 create mode 100644 linux-x86_64/gnu-efi/include/efi/efi_pxe.h
 create mode 100644 linux-x86_64/gnu-efi/include/efi/efiapi.h
 create mode 100644 linux-x86_64/gnu-efi/include/efi/eficon.h
 create mode 100644 linux-x86_64/gnu-efi/include/efi/efidebug.h
 create mode 100644 linux-x86_64/gnu-efi/include/efi/efidef.h
 create mode 100644 linux-x86_64/gnu-efi/include/efi/efidevp.h
 create mode 100644 linux-x86_64/gnu-efi/include/efi/efierr.h
 create mode 100644 linux-x86_64/gnu-efi/include/efi/efifs.h
 create mode 100644 linux-x86_64/gnu-efi/include/efi/efigpt.h
 create mode 100644 linux-x86_64/gnu-efi/include/efi/efilib.h
 create mode 100644 linux-x86_64/gnu-efi/include/efi/efilink.h
 create mode 100644 linux-x86_64/gnu-efi/include/efi/efinet.h
 create mode 100644 linux-x86_64/gnu-efi/include/efi/efipart.h
 create mode 100644 linux-x86_64/gnu-efi/include/efi/efipciio.h
 create mode 100644 linux-x86_64/gnu-efi/include/efi/efiprot.h
 create mode 100644 linux-x86_64/gnu-efi/include/efi/efipxebc.h
 create mode 100644 linux-x86_64/gnu-efi/include/efi/efirtlib.h
 create mode 100644 linux-x86_64/gnu-efi/include/efi/efiser.h
 create mode 100644 linux-x86_64/gnu-efi/include/efi/efistdarg.h
 create mode 100644 linux-x86_64/gnu-efi/include/efi/efiui.h
 create mode 100644 linux-x86_64/gnu-efi/include/efi/libsmbios.h
 create mode 100644 linux-x86_64/gnu-efi/include/efi/pci22.h
 create mode 100644 linux-x86_64/gnu-efi/include/efi/protocol/adapterdebug.h
 create mode 100644 linux-x86_64/gnu-efi/include/efi/protocol/eficonsplit.h
 create mode 100644 linux-x86_64/gnu-efi/include/efi/protocol/efidbg.h
 create mode 100644 linux-x86_64/gnu-efi/include/efi/protocol/efivar.h
 create mode 100644 linux-x86_64/gnu-efi/include/efi/protocol/intload.h
 create mode 100644 linux-x86_64/gnu-efi/include/efi/protocol/legacyboot.h
 create mode 100644 linux-x86_64/gnu-efi/include/efi/protocol/piflash64.h
 create mode 100644 linux-x86_64/gnu-efi/include/efi/protocol/vgaclass.h
 create mode 100644 linux-x86_64/gnu-efi/include/efi/romload.h
 create mode 100644 linux-x86_64/gnu-efi/include/efi/x86_64/efibind.h
 create mode 100644 linux-x86_64/gnu-efi/include/efi/x86_64/efilibplat.h
 create mode 100644 linux-x86_64/gnu-efi/include/efi/x86_64/pe.h
 create mode 100644 linux-x86_64/gnu-efi/lib/crt0-efi-x86_64.o
 create mode 100644 linux-x86_64/gnu-efi/lib/elf_x86_64_efi.lds
 create mode 100644 linux-x86_64/gnu-efi/lib/libefi.a
 create mode 100644 linux-x86_64/gnu-efi/lib/libgnuefi.a

diff --git a/linux-x86/gnu-efi/include/efi/efi.h b/linux-x86/gnu-efi/include/efi/efi.h
new file mode 100644
index 0000000..e9de37b
--- /dev/null
+++ b/linux-x86/gnu-efi/include/efi/efi.h
@@ -0,0 +1,50 @@
+/*++
+
+Copyright (c) 1998  Intel Corporation
+
+Module Name:
+
+    efi.h
+
+Abstract:
+
+    Public EFI header files
+
+
+
+Revision History
+
+--*/
+
+//
+// Build flags on input
+//  EFI32
+//  EFI_DEBUG               - Enable debugging code
+//  EFI_NT_EMULATOR         - Building for running under NT
+//
+
+
+#ifndef _EFI_INCLUDE_
+#define _EFI_INCLUDE_
+
+#define EFI_FIRMWARE_VENDOR         L"INTEL"
+#define EFI_FIRMWARE_MAJOR_REVISION 12
+#define EFI_FIRMWARE_MINOR_REVISION 33
+#define EFI_FIRMWARE_REVISION ((EFI_FIRMWARE_MAJOR_REVISION <<16) | (EFI_FIRMWARE_MINOR_REVISION))
+
+#include "efibind.h"
+#include "efidef.h"
+#include "efidevp.h"
+#include "efipciio.h"
+#include "efiprot.h"
+#include "eficon.h"
+#include "efiser.h"
+#include "efi_nii.h"
+#include "efipxebc.h"
+#include "efinet.h"
+#include "efiapi.h"
+#include "efifs.h"
+#include "efierr.h"
+#include "efiui.h"
+
+#endif
diff --git a/linux-x86/gnu-efi/include/efi/efi_nii.h b/linux-x86/gnu-efi/include/efi/efi_nii.h
new file mode 100644
index 0000000..ba7a5b2
--- /dev/null
+++ b/linux-x86/gnu-efi/include/efi/efi_nii.h
@@ -0,0 +1,74 @@
+#ifndef _EFI_NII_H
+#define _EFI_NII_H
+
+/*++
+Copyright (c) 2000  Intel Corporation
+
+Module name:
+    efi_nii.h
+
+Abstract:
+
+Revision history:
+    2000-Feb-18 M(f)J   GUID updated.
+                Structure order changed for machine word alignment.
+                Added StringId[4] to structure.
+                
+    2000-Feb-14 M(f)J   Genesis.
+--*/
+
+#define EFI_NETWORK_INTERFACE_IDENTIFIER_PROTOCOL \
+    { 0xE18541CD, 0xF755, 0x4f73, {0x92, 0x8D, 0x64, 0x3C, 0x8A, 0x79, 0xB2, 0x29} }
+
+#define EFI_NETWORK_INTERFACE_IDENTIFIER_INTERFACE_REVISION 0x00010000
+
+typedef enum {
+    EfiNetworkInterfaceUndi = 1
+} EFI_NETWORK_INTERFACE_TYPE;
+
+typedef struct {
+
+    UINT64 Revision;
+    // Revision of the network interface identifier protocol interface.
+
+    UINT64 ID;
+    // Address of the first byte of the identifying structure for this
+    // network interface.  This is set to zero if there is no structure.
+    //
+    // For PXE/UNDI this is the first byte of the !PXE structure.
+
+    UINT64 ImageAddr;
+    // Address of the UNrelocated driver/ROM image.  This is set
+    // to zero if there is no driver/ROM image.
+    //
+    // For 16-bit UNDI, this is the first byte of the option ROM in
+    // upper memory.
+    //
+    // For 32/64-bit S/W UNDI, this is the first byte of the EFI ROM
+    // image.
+    //
+    // For H/W UNDI, this is set to zero.
+
+    UINT32 ImageSize;
+    // Size of the UNrelocated driver/ROM image of this network interface.
+    // This is set to zero if there is no driver/ROM image.
+
+    CHAR8 StringId[4];
+    // 4 char ASCII string to go in class identifier (option 60) in DHCP
+    // and Boot Server discover packets.
+    // For EfiNetworkInterfaceUndi this field is "UNDI".
+    // For EfiNetworkInterfaceSnp this field is "SNPN".
+
+    UINT8 Type;
+    UINT8 MajorVer;
+    UINT8 MinorVer;
+    // Information to be placed into the PXE DHCP and Discover packets.
+    // This is the network interface type and version number that will
+    // be placed into DHCP option 94 (client network interface identifier).
+    BOOLEAN Ipv6Supported;
+	UINT8   IfNum;	// interface number to be used with pxeid structure
+} EFI_NETWORK_INTERFACE_IDENTIFIER_INTERFACE;
+
+extern EFI_GUID NetworkInterfaceIdentifierProtocol;
+
+#endif // _EFI_NII_H
diff --git a/linux-x86/gnu-efi/include/efi/efi_pxe.h b/linux-x86/gnu-efi/include/efi/efi_pxe.h
new file mode 100644
index 0000000..d24251f
--- /dev/null
+++ b/linux-x86/gnu-efi/include/efi/efi_pxe.h
@@ -0,0 +1,1743 @@
+#ifndef _EFI_PXE_H
+#define _EFI_PXE_H
+
+
+/*++
+Copyright (c) Intel  1999
+
+Module name:
+    efi_pxe.h
+
+32/64-bit PXE specification:
+    alpha-4, 99-Dec-17
+
+Abstract:
+    This header file contains all of the PXE type definitions,
+    structure prototypes, global variables and constants that
+    are needed for porting PXE to EFI.
+--*/
+
+#pragma pack(1)
+
+#define PXE_INTEL_ORDER         1   // Intel order
+//#define PXE_NETWORK_ORDER         1   // network order
+
+#define PXE_UINT64_SUPPORT          1   // UINT64 supported
+//#define PXE_NO_UINT64_SUPPORT     1   // UINT64 not supported
+
+#define PXE_BUSTYPE(a,b,c,d)            \
+((((PXE_UINT32)(d) & 0xFF) << 24) | \
+(((PXE_UINT32)(c) & 0xFF) << 16) |  \
+(((PXE_UINT32)(b) & 0xFF) << 8) |       \
+((PXE_UINT32)(a) & 0xFF))
+
+//
+// UNDI ROM ID and devive ID signature
+//
+#define PXE_BUSTYPE_PXE         PXE_BUSTYPE('!', 'P', 'X', 'E')
+
+//
+// BUS ROM ID signatures
+//
+#define PXE_BUSTYPE_PCI         PXE_BUSTYPE('P', 'C', 'I', 'R')
+#define PXE_BUSTYPE_PC_CARD     PXE_BUSTYPE('P', 'C', 'C', 'R')
+#define PXE_BUSTYPE_USB         PXE_BUSTYPE('U', 'S', 'B', 'R')
+#define PXE_BUSTYPE_1394        PXE_BUSTYPE('1', '3', '9', '4')
+
+#define PXE_SWAP_UINT16(n)          \
+((((PXE_UINT16)(n) & 0x00FF) << 8) |    \
+(((PXE_UINT16)(n) & 0xFF00) >> 8))
+
+#define PXE_SWAP_UINT32(n)              \
+((((PXE_UINT32)(n) & 0x000000FF) << 24) |   \
+(((PXE_UINT32)(n) & 0x0000FF00) << 8) |     \
+(((PXE_UINT32)(n) & 0x00FF0000) >> 8) |     \
+(((PXE_UINT32)(n) & 0xFF000000) >> 24))
+
+#if PXE_UINT64_SUPPORT != 0
+#define PXE_SWAP_UINT64(n)                  \
+((((PXE_UINT64)(n) & 0x00000000000000FF) << 56) |   \
+(((PXE_UINT64)(n) & 0x000000000000FF00) << 40) |    \
+(((PXE_UINT64)(n) & 0x0000000000FF0000) << 24) |    \
+(((PXE_UINT64)(n) & 0x00000000FF000000) << 8) | \
+(((PXE_UINT64)(n) & 0x000000FF00000000) >> 8) | \
+(((PXE_UINT64)(n) & 0x0000FF0000000000) >> 24) |    \
+(((PXE_UINT64)(n) & 0x00FF000000000000) >> 40) |    \
+(((PXE_UINT64)(n) & 0xFF00000000000000) >> 56))
+#endif // PXE_UINT64_SUPPORT
+
+#if PXE_NO_UINT64_SUPPORT != 0
+#define PXE_SWAP_UINT64(n)                      \
+{                                       \
+PXE_UINT32 tmp = (PXE_UINT64)(n)[1];                \
+(PXE_UINT64)(n)[1] = PXE_SWAP_UINT32((PXE_UINT64)(n)[0]);   \
+(PXE_UINT64)(n)[0] = tmp;                       \
+}
+#endif // PXE_NO_UINT64_SUPPORT
+
+#define PXE_CPBSIZE_NOT_USED            0   // zero
+#define PXE_DBSIZE_NOT_USED         0   // zero
+#define PXE_CPBADDR_NOT_USED        (PXE_UINT64)0       // zero
+#define PXE_DBADDR_NOT_USED     (PXE_UINT64)0       // zero
+
+#define PXE_CONST const
+
+#define PXE_VOLATILE volatile
+
+typedef void PXE_VOID;
+
+typedef unsigned char PXE_UINT8;
+
+typedef unsigned short PXE_UINT16;
+
+typedef unsigned PXE_UINT32;
+
+#if PXE_UINT64_SUPPORT != 0
+// typedef unsigned long PXE_UINT64;
+typedef UINT64 PXE_UINT64;
+#endif // PXE_UINT64_SUPPORT
+
+#if PXE_NO_UINT64_SUPPORT != 0
+typedef PXE_UINT32 PXE_UINT64[2];
+#endif // PXE_NO_UINT64_SUPPORT
+
+typedef unsigned PXE_UINTN;
+
+typedef PXE_UINT8 PXE_BOOL;
+
+#define PXE_FALSE               0   // zero
+#define PXE_TRUE                    (!PXE_FALSE)
+
+typedef PXE_UINT16 PXE_OPCODE;
+
+//
+// Return UNDI operational state.
+//
+#define PXE_OPCODE_GET_STATE                    0x0000
+
+//
+// Change UNDI operational state from Stopped to Started.
+//
+#define PXE_OPCODE_START                    0x0001
+
+//
+// Change UNDI operational state from Started to Stopped.
+//
+#define PXE_OPCODE_STOP                     0x0002
+
+//
+// Get UNDI initialization information.
+//
+#define PXE_OPCODE_GET_INIT_INFO                0x0003
+
+//
+// Get NIC configuration information.
+//
+#define PXE_OPCODE_GET_CONFIG_INFO              0x0004
+
+//
+// Changed UNDI operational state from Started to Initialized.
+//
+#define PXE_OPCODE_INITIALIZE                   0x0005
+
+//
+// Re-initialize the NIC H/W.
+//
+#define PXE_OPCODE_RESET                    0x0006
+
+//
+// Change the UNDI operational state from Initialized to Started.
+//
+#define PXE_OPCODE_SHUTDOWN                 0x0007
+
+//
+// Read & change state of external interrupt enables.
+//
+#define PXE_OPCODE_INTERRUPT_ENABLES                0x0008
+
+//
+// Read & change state of packet receive filters.
+//
+#define PXE_OPCODE_RECEIVE_FILTERS              0x0009
+
+//
+// Read & change station MAC address.
+//
+#define PXE_OPCODE_STATION_ADDRESS              0x000A
+
+//
+// Read traffic statistics.
+//
+#define PXE_OPCODE_STATISTICS                   0x000B
+
+//
+// Convert multicast IP address to multicast MAC address.
+//
+#define PXE_OPCODE_MCAST_IP_TO_MAC              0x000C
+
+//
+// Read or change non-volatile storage on the NIC.
+//
+#define PXE_OPCODE_NVDATA                   0x000D
+
+//
+// Get & clear interrupt status.
+//
+#define PXE_OPCODE_GET_STATUS                   0x000E
+
+//
+// Fill media header in packet for transmit.
+//
+#define PXE_OPCODE_FILL_HEADER              0x000F
+
+//
+// Transmit packet(s).
+//
+#define PXE_OPCODE_TRANSMIT                 0x0010
+
+//
+// Receive packet.
+//
+#define PXE_OPCODE_RECEIVE                  0x0011
+
+// last valid opcode:
+#define PXE_OPCODE_VALID_MAX                    0x0011
+
+//
+// Last valid PXE UNDI OpCode number.
+//
+#define PXE_OPCODE_LAST_VALID                   0x0011
+
+typedef PXE_UINT16 PXE_OPFLAGS;
+
+#define PXE_OPFLAGS_NOT_USED                    0x0000
+
+////////////////////////////////////////
+// UNDI Get State
+//
+
+// No OpFlags
+
+////////////////////////////////////////
+// UNDI Start
+//
+
+// No OpFlags
+
+////////////////////////////////////////
+// UNDI Stop
+//
+
+// No OpFlags
+
+////////////////////////////////////////
+// UNDI Get Init Info
+//
+
+// No Opflags
+
+////////////////////////////////////////
+// UNDI Get Config Info
+//
+
+// No Opflags
+
+////////////////////////////////////////
+// UNDI Initialize
+//
+
+#define PXE_OPFLAGS_INITIALIZE_CABLE_DETECT_MASK    0x0001
+#define PXE_OPFLAGS_INITIALIZE_DETECT_CABLE         0x0000
+#define PXE_OPFLAGS_INITIALIZE_DO_NOT_DETECT_CABLE  0x0001
+
+////////////////////////////////////////
+// UNDI Reset
+//
+
+#define PXE_OPFLAGS_RESET_DISABLE_INTERRUPTS        0x0001
+#define PXE_OPFLAGS_RESET_DISABLE_FILTERS           0x0002
+
+////////////////////////////////////////
+// UNDI Shutdown
+//
+
+// No OpFlags
+
+////////////////////////////////////////
+// UNDI Interrupt Enables
+//
+
+//
+// Select whether to enable or disable external interrupt signals.
+// Setting both enable and disable will return PXE_STATCODE_INVALID_OPFLAGS.
+//
+#define PXE_OPFLAGS_INTERRUPT_OPMASK                0xC000
+#define PXE_OPFLAGS_INTERRUPT_ENABLE                0x8000
+#define PXE_OPFLAGS_INTERRUPT_DISABLE           0x4000
+#define PXE_OPFLAGS_INTERRUPT_READ              0x0000
+
+//
+// Enable receive interrupts.  An external interrupt will be generated
+// after a complete non-error packet has been received.
+//
+#define PXE_OPFLAGS_INTERRUPT_RECEIVE           0x0001
+
+//
+// Enable transmit interrupts.  An external interrupt will be generated
+// after a complete non-error packet has been transmitted.
+//
+#define PXE_OPFLAGS_INTERRUPT_TRANSMIT          0x0002
+
+//
+// Enable command interrupts.  An external interrupt will be generated
+// when command execution stops.
+//
+#define PXE_OPFLAGS_INTERRUPT_COMMAND           0x0004
+
+//
+// Generate software interrupt.  Setting this bit generates an external
+// interrupt, if it is supported by the hardware.
+//
+#define PXE_OPFLAGS_INTERRUPT_SOFTWARE          0x0008
+
+////////////////////////////////////////
+// UNDI Receive Filters
+//
+
+//
+// Select whether to enable or disable receive filters.
+// Setting both enable and disable will return PXE_STATCODE_INVALID_OPCODE.
+//
+#define PXE_OPFLAGS_RECEIVE_FILTER_OPMASK           0xC000
+#define PXE_OPFLAGS_RECEIVE_FILTER_ENABLE           0x8000
+#define PXE_OPFLAGS_RECEIVE_FILTER_DISABLE          0x4000
+#define PXE_OPFLAGS_RECEIVE_FILTER_READ         0x0000
+
+//
+// To reset the contents of the multicast MAC address filter list,
+// set this OpFlag:
+//
+#define PXE_OPFLAGS_RECEIVE_FILTER_RESET_MCAST_LIST 0x2000
+
+//
+// Enable unicast packet receiving.  Packets sent to the current station
+// MAC address will be received.
+//
+#define PXE_OPFLAGS_RECEIVE_FILTER_UNICAST          0x0001
+
+//
+// Enable broadcast packet receiving.  Packets sent to the broadcast 
+// MAC address will be received.
+//
+#define PXE_OPFLAGS_RECEIVE_FILTER_BROADCAST        0x0002
+
+//
+// Enable filtered multicast packet receiving.  Packets sent to any
+// of the multicast MAC addresses in the multicast MAC address filter
+// list will be received.  If the filter list is empty, no multicast
+//
+#define PXE_OPFLAGS_RECEIVE_FILTER_FILTERED_MULTICAST   0x0004
+
+//
+// Enable promiscuous packet receiving.  All packets will be received.
+//
+#define PXE_OPFLAGS_RECEIVE_FILTER_PROMISCUOUS      0x0008
+
+//
+// Enable promiscuous multicast packet receiving.  All multicast
+// packets will be received.
+//
+#define PXE_OPFLAGS_RECEIVE_FILTER_ALL_MULTICAST        0x0010
+
+////////////////////////////////////////
+// UNDI Station Address
+//
+
+#define PXE_OPFLAGS_STATION_ADDRESS_READ            0x0000
+#define PXE_OPFLAGS_STATION_ADDRESS_RESET           0x0001
+
+////////////////////////////////////////
+// UNDI Statistics
+//
+
+#define PXE_OPFLAGS_STATISTICS_READ             0x0000
+#define PXE_OPFLAGS_STATISTICS_RESET                0x0001
+
+////////////////////////////////////////
+// UNDI MCast IP to MAC
+//
+
+//
+// Identify the type of IP address in the CPB.
+//
+#define PXE_OPFLAGS_MCAST_IP_TO_MAC_OPMASK          0x0003
+#define PXE_OPFLAGS_MCAST_IPV4_TO_MAC           0x0000
+#define PXE_OPFLAGS_MCAST_IPV6_TO_MAC           0x0001
+
+////////////////////////////////////////
+// UNDI NvData
+//
+
+//
+// Select the type of non-volatile data operation.
+//
+#define PXE_OPFLAGS_NVDATA_OPMASK               0x0001
+#define PXE_OPFLAGS_NVDATA_READ             0x0000
+#define PXE_OPFLAGS_NVDATA_WRITE                0x0001
+
+////////////////////////////////////////
+// UNDI Get Status
+//
+
+//
+// Return current interrupt status.  This will also clear any interrupts
+// that are currently set.  This can be used in a polling routine.  The
+// interrupt flags are still set and cleared even when the interrupts
+// are disabled.
+//
+#define PXE_OPFLAGS_GET_INTERRUPT_STATUS            0x0001
+
+//
+// Return list of transmitted buffers for recycling.  Transmit buffers
+// must not be changed or unallocated until they have recycled.  After
+// issuing a transmit command, wait for a transmit complete interrupt.
+// When a transmit complete interrupt is received, read the transmitted
+// buffers.  Do not plan on getting one buffer per interrupt.  Some
+// NICs and UNDIs may transmit multiple buffers per interrupt.
+//
+#define PXE_OPFLAGS_GET_TRANSMITTED_BUFFERS         0x0002
+
+////////////////////////////////////////
+// UNDI Fill Header
+//
+
+#define PXE_OPFLAGS_FILL_HEADER_OPMASK          0x0001
+#define PXE_OPFLAGS_FILL_HEADER_FRAGMENTED          0x0001
+#define PXE_OPFLAGS_FILL_HEADER_WHOLE           0x0000
+
+////////////////////////////////////////
+// UNDI Transmit
+//
+
+//
+// S/W UNDI only.  Return after the packet has been transmitted.  A
+// transmit complete interrupt will still be generated and the transmit
+// buffer will have to be recycled.
+//
+#define PXE_OPFLAGS_SWUNDI_TRANSMIT_OPMASK          0x0001
+#define PXE_OPFLAGS_TRANSMIT_BLOCK              0x0001
+#define PXE_OPFLAGS_TRANSMIT_DONT_BLOCK         0x0000
+
+//
+//
+//
+#define PXE_OPFLAGS_TRANSMIT_OPMASK             0x0002
+#define PXE_OPFLAGS_TRANSMIT_FRAGMENTED         0x0002
+#define PXE_OPFLAGS_TRANSMIT_WHOLE              0x0000
+
+////////////////////////////////////////
+// UNDI Receive
+//
+
+// No OpFlags
+
+typedef PXE_UINT16 PXE_STATFLAGS;
+
+#define PXE_STATFLAGS_INITIALIZE                0x0000
+
+////////////////////////////////////////
+// Common StatFlags that can be returned by all commands.
+//
+
+//
+// The COMMAND_COMPLETE and COMMAND_FAILED status flags must be
+// implemented by all UNDIs.  COMMAND_QUEUED is only needed by UNDIs
+// that support command queuing.
+//
+#define PXE_STATFLAGS_STATUS_MASK               0xC000
+#define PXE_STATFLAGS_COMMAND_COMPLETE          0xC000
+#define PXE_STATFLAGS_COMMAND_FAILED                0x8000
+#define PXE_STATFLAGS_COMMAND_QUEUED                0x4000
+//#define PXE_STATFLAGS_INITIALIZE              0x0000
+
+#define PXE_STATFLAGS_DB_WRITE_TRUNCATED            0x2000
+
+////////////////////////////////////////
+// UNDI Get State
+//
+
+#define PXE_STATFLAGS_GET_STATE_MASK                0x0003
+#define PXE_STATFLAGS_GET_STATE_INITIALIZED         0x0002
+#define PXE_STATFLAGS_GET_STATE_STARTED         0x0001
+#define PXE_STATFLAGS_GET_STATE_STOPPED         0x0000
+
+////////////////////////////////////////
+// UNDI Start
+//
+
+// No additional StatFlags
+
+////////////////////////////////////////
+// UNDI Get Init Info
+//
+
+#define PXE_STATFLAGS_CABLE_DETECT_MASK          0x0001
+#define PXE_STATFLAGS_CABLE_DETECT_NOT_SUPPORTED 0x0000
+#define PXE_STATFLAGS_CABLE_DETECT_SUPPORTED     0x0001
+
+
+////////////////////////////////////////
+// UNDI Initialize
+//
+
+#define PXE_STATFLAGS_INITIALIZED_NO_MEDIA          0x0001
+
+////////////////////////////////////////
+// UNDI Reset
+//
+
+#define PXE_STATFLAGS_RESET_NO_MEDIA                0x0001
+
+////////////////////////////////////////
+// UNDI Shutdown
+//
+
+// No additional StatFlags
+
+////////////////////////////////////////
+// UNDI Interrupt Enables
+//
+
+//
+// If set, receive interrupts are enabled.
+//
+#define PXE_STATFLAGS_INTERRUPT_RECEIVE         0x0001
+
+//
+// If set, transmit interrupts are enabled.
+//
+#define PXE_STATFLAGS_INTERRUPT_TRANSMIT            0x0002
+
+//
+// If set, command interrupts are enabled.
+//
+#define PXE_STATFLAGS_INTERRUPT_COMMAND         0x0004
+
+
+////////////////////////////////////////
+// UNDI Receive Filters
+//
+
+//
+// If set, unicast packets will be received.
+//
+#define PXE_STATFLAGS_RECEIVE_FILTER_UNICAST        0x0001
+
+//
+// If set, broadcast packets will be received.
+//
+#define PXE_STATFLAGS_RECEIVE_FILTER_BROADCAST      0x0002
+
+//
+// If set, multicast packets that match up with the multicast address
+// filter list will be received.
+//
+#define PXE_STATFLAGS_RECEIVE_FILTER_FILTERED_MULTICAST 0x0004
+
+//
+// If set, all packets will be received.
+//
+#define PXE_STATFLAGS_RECEIVE_FILTER_PROMISCUOUS        0x0008
+
+//
+// If set, all multicast packets will be received.
+//
+#define PXE_STATFLAGS_RECEIVE_FILTER_ALL_MULTICAST  0x0010
+
+////////////////////////////////////////
+// UNDI Station Address
+//
+
+// No additional StatFlags
+
+////////////////////////////////////////
+// UNDI Statistics
+//
+
+// No additional StatFlags
+
+////////////////////////////////////////
+// UNDI MCast IP to MAC
+//
+
+// No additional StatFlags
+
+////////////////////////////////////////
+// UNDI NvData
+//
+
+// No additional StatFlags
+
+
+////////////////////////////////////////
+// UNDI Get Status
+//
+
+//
+// Use to determine if an interrupt has occurred.
+//
+#define PXE_STATFLAGS_GET_STATUS_INTERRUPT_MASK     0x000F
+#define PXE_STATFLAGS_GET_STATUS_NO_INTERRUPTS      0x0000
+
+//
+// If set, at least one receive interrupt occurred.
+//
+#define PXE_STATFLAGS_GET_STATUS_RECEIVE            0x0001
+
+//
+// If set, at least one transmit interrupt occurred.
+//
+#define PXE_STATFLAGS_GET_STATUS_TRANSMIT           0x0002
+
+//
+// If set, at least one command interrupt occurred.
+//
+#define PXE_STATFLAGS_GET_STATUS_COMMAND            0x0004
+
+//
+// If set, at least one software interrupt occurred.
+//
+#define PXE_STATFLAGS_GET_STATUS_SOFTWARE           0x0008
+
+//
+// This flag is set if the transmitted buffer queue is empty.  This flag
+// will be set if all transmitted buffer addresses get written into the DB.
+//
+#define PXE_STATFLAGS_GET_STATUS_TXBUF_QUEUE_EMPTY  0x0010
+
+//
+// This flag is set if no transmitted buffer addresses were written
+// into the DB.  (This could be because DBsize was too small.)
+//
+#define PXE_STATFLAGS_GET_STATUS_NO_TXBUFS_WRITTEN  0x0020
+
+////////////////////////////////////////
+// UNDI Fill Header
+//
+
+// No additional StatFlags
+
+////////////////////////////////////////
+// UNDI Transmit
+//
+
+// No additional StatFlags.
+
+////////////////////////////////////////
+// UNDI Receive
+//
+
+// No additional StatFlags.
+
+typedef PXE_UINT16 PXE_STATCODE;
+
+#define PXE_STATCODE_INITIALIZE             0x0000
+
+////////////////////////////////////////
+// Common StatCodes returned by all UNDI commands, UNDI protocol functions
+// and BC protocol functions.
+//
+
+#define PXE_STATCODE_SUCCESS                    0x0000
+
+#define PXE_STATCODE_INVALID_CDB                0x0001
+#define PXE_STATCODE_INVALID_CPB                0x0002
+#define PXE_STATCODE_BUSY                   	0x0003
+#define PXE_STATCODE_QUEUE_FULL             	0x0004
+#define PXE_STATCODE_ALREADY_STARTED            0x0005
+#define PXE_STATCODE_NOT_STARTED                0x0006
+#define PXE_STATCODE_NOT_SHUTDOWN               0x0007
+#define PXE_STATCODE_ALREADY_INITIALIZED        0x0008
+#define PXE_STATCODE_NOT_INITIALIZED            0x0009
+#define PXE_STATCODE_DEVICE_FAILURE             0x000A
+#define PXE_STATCODE_NVDATA_FAILURE             0x000B
+#define PXE_STATCODE_UNSUPPORTED                0x000C
+#define PXE_STATCODE_BUFFER_FULL                0x000D
+#define PXE_STATCODE_INVALID_PARAMETER		0x000E
+#define PXE_STATCODE_INVALID_UNDI		0x000F
+#define PXE_STATCODE_IPV4_NOT_SUPPORTED		0x0010
+#define PXE_STATCODE_IPV6_NOT_SUPPORTED		0x0011
+#define PXE_STATCODE_NOT_ENOUGH_MEMORY		0x0012
+#define PXE_STATCODE_NO_DATA			0x0013
+
+
+typedef PXE_UINT16 PXE_IFNUM;
+
+//
+// This interface number must be passed to the S/W UNDI Start command.
+//
+#define PXE_IFNUM_START                     0x0000
+
+//
+// This interface number is returned by the S/W UNDI Get State and
+// Start commands if information in the CDB, CPB or DB is invalid.
+//
+#define PXE_IFNUM_INVALID                   0x0000
+
+typedef PXE_UINT16 PXE_CONTROL;
+
+//
+// Setting this flag directs the UNDI to queue this command for later
+// execution if the UNDI is busy and it supports command queuing.
+// If queuing is not supported, a PXE_STATCODE_INVALID_CONTROL error
+// is returned.  If the queue is full, a PXE_STATCODE_CDB_QUEUE_FULL 
+// error is returned.
+//
+#define PXE_CONTROL_QUEUE_IF_BUSY               0x0002
+
+//
+// These two bit values are used to determine if there are more UNDI
+// CDB structures following this one.  If the link bit is set, there
+// must be a CDB structure following this one.  Execution will start
+// on the next CDB structure as soon as this one completes successfully.
+// If an error is generated by this command, execution will stop.
+//
+#define PXE_CONTROL_LINK                    0x0001
+#define PXE_CONTROL_LAST_CDB_IN_LIST                0x0000
+
+typedef PXE_UINT8 PXE_FRAME_TYPE;
+
+#define PXE_FRAME_TYPE_NONE                 0x00
+#define PXE_FRAME_TYPE_UNICAST              0x01
+#define PXE_FRAME_TYPE_BROADCAST                0x02
+#define PXE_FRAME_TYPE_MULTICAST            0x03
+#define PXE_FRAME_TYPE_PROMISCUOUS              0x04
+
+typedef PXE_UINT32 PXE_IPV4;
+
+typedef PXE_UINT32 PXE_IPV6[4];
+#define PXE_MAC_LENGTH 32
+
+typedef PXE_UINT8 PXE_MAC_ADDR[PXE_MAC_LENGTH];
+
+typedef PXE_UINT8 PXE_IFTYPE;
+typedef PXE_UINT16 PXE_MEDIA_PROTOCOL;
+
+//
+// This information is from the ARP section of RFC 1700.
+//
+//     1 Ethernet (10Mb)                                    [JBP]
+//     2 Experimental Ethernet (3Mb)                        [JBP]
+//     3 Amateur Radio AX.25                                [PXK]
+//     4 Proteon ProNET Token Ring                          [JBP]
+//     5 Chaos                                              [GXP]
+//     6 IEEE 802 Networks                                  [JBP]
+//     7 ARCNET                                             [JBP]
+//     8 Hyperchannel                                       [JBP]
+//     9 Lanstar                                             [TU]
+//    10 Autonet Short Address                             [MXB1]
+//    11 LocalTalk                                         [JKR1]
+//    12 LocalNet (IBM PCNet or SYTEK LocalNET)             [JXM]
+//    13 Ultra link                                        [RXD2]
+//    14 SMDS                                              [GXC1]
+//    15 Frame Relay                                        [AGM]
+//    16 Asynchronous Transmission Mode (ATM)              [JXB2]
+//    17 HDLC                                               [JBP]
+//    18 Fibre Channel                            [Yakov Rekhter]
+//    19 Asynchronous Transmission Mode (ATM)      [Mark Laubach]
+//    20 Serial Line                                        [JBP]
+//    21 Asynchronous Transmission Mode (ATM)              [MXB1]
+//
+
+#define PXE_IFTYPE_ETHERNET                 0x01
+#define PXE_IFTYPE_TOKENRING                    0x04
+#define PXE_IFTYPE_FIBRE_CHANNEL                0x12
+
+typedef struct s_pxe_hw_undi {
+PXE_UINT32 Signature;       // PXE_ROMID_SIGNATURE
+PXE_UINT8 Len;          // sizeof(PXE_HW_UNDI)
+PXE_UINT8 Fudge;            // makes 8-bit cksum equal zero
+PXE_UINT8 Rev;          // PXE_ROMID_REV
+PXE_UINT8 IFcnt;            // physical connector count
+PXE_UINT8 MajorVer;         // PXE_ROMID_MAJORVER
+PXE_UINT8 MinorVer;         // PXE_ROMID_MINORVER
+PXE_UINT16 reserved;        // zero, not used
+PXE_UINT32 Implementation;      // implementation flags
+// reserved             // vendor use
+// PXE_UINT32 Status;       // status port
+// PXE_UINT32 Command;      // command port
+// PXE_UINT64 CDBaddr;      // CDB address port
+} PXE_HW_UNDI;
+
+//
+// Status port bit definitions
+//
+
+//
+// UNDI operation state
+//
+#define PXE_HWSTAT_STATE_MASK                   0xC0000000
+#define PXE_HWSTAT_BUSY                     0xC0000000
+#define PXE_HWSTAT_INITIALIZED              0x80000000
+#define PXE_HWSTAT_STARTED                  0x40000000
+#define PXE_HWSTAT_STOPPED                  0x00000000
+
+//
+// If set, last command failed
+//
+#define PXE_HWSTAT_COMMAND_FAILED               0x20000000
+
+//
+// If set, identifies enabled receive filters
+//
+#define PXE_HWSTAT_PROMISCUOUS_MULTICAST_RX_ENABLED 0x00001000
+#define PXE_HWSTAT_PROMISCUOUS_RX_ENABLED           0x00000800
+#define PXE_HWSTAT_BROADCAST_RX_ENABLED         0x00000400
+#define PXE_HWSTAT_MULTICAST_RX_ENABLED         0x00000200
+#define PXE_HWSTAT_UNICAST_RX_ENABLED           0x00000100
+
+//
+// If set, identifies enabled external interrupts
+//
+#define PXE_HWSTAT_SOFTWARE_INT_ENABLED         0x00000080
+#define PXE_HWSTAT_TX_COMPLETE_INT_ENABLED          0x00000040
+#define PXE_HWSTAT_PACKET_RX_INT_ENABLED            0x00000020
+#define PXE_HWSTAT_CMD_COMPLETE_INT_ENABLED         0x00000010
+
+//
+// If set, identifies pending interrupts
+//
+#define PXE_HWSTAT_SOFTWARE_INT_PENDING         0x00000008
+#define PXE_HWSTAT_TX_COMPLETE_INT_PENDING          0x00000004
+#define PXE_HWSTAT_PACKET_RX_INT_PENDING            0x00000002
+#define PXE_HWSTAT_CMD_COMPLETE_INT_PENDING         0x00000001
+
+//
+// Command port definitions
+//
+
+//
+// If set, CDB identified in CDBaddr port is given to UNDI.
+// If not set, other bits in this word will be processed.
+//
+#define PXE_HWCMD_ISSUE_COMMAND             0x80000000
+#define PXE_HWCMD_INTS_AND_FILTS                0x00000000
+
+//
+// Use these to enable/disable receive filters.
+//
+#define PXE_HWCMD_PROMISCUOUS_MULTICAST_RX_ENABLE       0x00001000
+#define PXE_HWCMD_PROMISCUOUS_RX_ENABLE         0x00000800
+#define PXE_HWCMD_BROADCAST_RX_ENABLE           0x00000400
+#define PXE_HWCMD_MULTICAST_RX_ENABLE           0x00000200
+#define PXE_HWCMD_UNICAST_RX_ENABLE             0x00000100
+
+//
+// Use these to enable/disable external interrupts
+//
+#define PXE_HWCMD_SOFTWARE_INT_ENABLE           0x00000080
+#define PXE_HWCMD_TX_COMPLETE_INT_ENABLE            0x00000040
+#define PXE_HWCMD_PACKET_RX_INT_ENABLE          0x00000020
+#define PXE_HWCMD_CMD_COMPLETE_INT_ENABLE           0x00000010
+
+//
+// Use these to clear pending external interrupts
+//
+#define PXE_HWCMD_CLEAR_SOFTWARE_INT                0x00000008
+#define PXE_HWCMD_CLEAR_TX_COMPLETE_INT         0x00000004
+#define PXE_HWCMD_CLEAR_PACKET_RX_INT           0x00000002
+#define PXE_HWCMD_CLEAR_CMD_COMPLETE_INT            0x00000001
+
+typedef struct s_pxe_sw_undi {
+PXE_UINT32 Signature;       // PXE_ROMID_SIGNATURE
+PXE_UINT8 Len;          // sizeof(PXE_SW_UNDI)
+PXE_UINT8 Fudge;            // makes 8-bit cksum zero
+PXE_UINT8 Rev;          // PXE_ROMID_REV
+PXE_UINT8 IFcnt;            // physical connector count
+PXE_UINT8 MajorVer;         // PXE_ROMID_MAJORVER
+PXE_UINT8 MinorVer;         // PXE_ROMID_MINORVER
+PXE_UINT16 reserved1;       // zero, not used
+PXE_UINT32 Implementation;      // Implementation flags
+PXE_UINT64 EntryPoint;      // API entry point
+PXE_UINT8 reserved2[3];     // zero, not used
+PXE_UINT8 BusCnt;           // number of bustypes supported
+PXE_UINT32 BusType[1];      // list of supported bustypes
+} PXE_SW_UNDI;
+
+typedef union u_pxe_undi {
+PXE_HW_UNDI hw;
+PXE_SW_UNDI sw;
+} PXE_UNDI;
+
+//
+// Signature of !PXE structure
+//
+#define PXE_ROMID_SIGNATURE     PXE_BUSTYPE('!', 'P', 'X', 'E')
+
+//
+// !PXE structure format revision
+//
+#define PXE_ROMID_REV                       0x02
+
+//
+// UNDI command interface revision.  These are the values that get sent
+// in option 94 (Client Network Interface Identifier) in the DHCP Discover
+// and PXE Boot Server Request packets.
+//
+#define PXE_ROMID_MAJORVER                  0x03
+#define PXE_ROMID_MINORVER                  0x00
+
+//
+// Implementation flags
+//
+#define PXE_ROMID_IMP_HW_UNDI                   0x80000000
+#define PXE_ROMID_IMP_SW_VIRT_ADDR              0x40000000
+#define PXE_ROMID_IMP_64BIT_DEVICE              0x00010000
+#define PXE_ROMID_IMP_FRAG_SUPPORTED                0x00008000
+#define PXE_ROMID_IMP_CMD_LINK_SUPPORTED            0x00004000
+#define PXE_ROMID_IMP_CMD_QUEUE_SUPPORTED           0x00002000
+#define PXE_ROMID_IMP_MULTI_FRAME_SUPPORTED         0x00001000
+#define PXE_ROMID_IMP_NVDATA_SUPPORT_MASK           0x00000C00
+#define PXE_ROMID_IMP_NVDATA_BULK_WRITABLE          0x00000C00
+#define PXE_ROMID_IMP_NVDATA_SPARSE_WRITABLE        0x00000800
+#define PXE_ROMID_IMP_NVDATA_READ_ONLY          0x00000400
+#define PXE_ROMID_IMP_NVDATA_NOT_AVAILABLE          0x00000000
+#define PXE_ROMID_IMP_STATISTICS_SUPPORTED          0x00000200
+#define PXE_ROMID_IMP_STATION_ADDR_SETTABLE         0x00000100
+#define PXE_ROMID_IMP_PROMISCUOUS_MULTICAST_RX_SUPPORTED    0x00000080
+#define PXE_ROMID_IMP_PROMISCUOUS_RX_SUPPORTED      0x00000040
+#define PXE_ROMID_IMP_BROADCAST_RX_SUPPORTED        0x00000020
+#define PXE_ROMID_IMP_FILTERED_MULTICAST_RX_SUPPORTED   0x00000010
+#define PXE_ROMID_IMP_SOFTWARE_INT_SUPPORTED        0x00000008
+#define PXE_ROMID_IMP_TX_COMPLETE_INT_SUPPORTED     0x00000004
+#define PXE_ROMID_IMP_PACKET_RX_INT_SUPPORTED       0x00000002
+#define PXE_ROMID_IMP_CMD_COMPLETE_INT_SUPPORTED        0x00000001
+
+ 
+typedef struct s_pxe_cdb {
+PXE_OPCODE OpCode;
+PXE_OPFLAGS OpFlags;
+PXE_UINT16 CPBsize;
+PXE_UINT16 DBsize;
+UINT64 CPBaddr;
+UINT64 DBaddr;
+PXE_STATCODE StatCode;
+PXE_STATFLAGS StatFlags;
+PXE_UINT16 IFnum;
+PXE_CONTROL Control;
+} PXE_CDB;
+
+
+typedef union u_pxe_ip_addr {
+PXE_IPV6 IPv6;
+PXE_IPV4 IPv4;
+} PXE_IP_ADDR;
+
+typedef union pxe_device {
+//
+// PCI and PC Card NICs are both identified using bus, device
+// and function numbers.  For PC Card, this may require PC
+// Card services to be loaded in the BIOS or preboot
+// environment.
+//
+struct {
+//
+// See S/W UNDI ROMID structure definition for PCI and
+// PCC BusType definitions.
+//
+PXE_UINT32 BusType;
+
+//
+// Bus, device & function numbers that locate this device.
+//
+PXE_UINT16 Bus;
+PXE_UINT8 Device;
+PXE_UINT8 Function;
+} PCI, PCC;
+
+//
+// %%TBD - More information is needed about enumerating
+// USB and 1394 devices.
+//
+struct {
+PXE_UINT32 BusType;
+PXE_UINT32 tdb;
+} USB, _1394;
+} PXE_DEVICE;
+
+// cpb and db definitions
+
+#define MAX_PCI_CONFIG_LEN 64   // # of dwords
+#define MAX_EEPROM_LEN 128       // #of dwords
+#define MAX_XMIT_BUFFERS    32  // recycling Q length for xmit_done
+#define MAX_MCAST_ADDRESS_CNT 8
+
+typedef struct s_pxe_cpb_start {
+    //
+    // PXE_VOID Delay(PXE_UINT64 microseconds);
+    //
+    // UNDI will never request a delay smaller than 10 microseconds
+    // and will always request delays in increments of 10 microseconds.
+    // The Delay() CallBack routine must delay between n and n + 10 
+    // microseconds before returning control to the UNDI.
+    //
+    // This field cannot be set to zero.
+    //
+    PXE_UINT64 Delay;
+
+    //
+    // PXE_VOID Block(PXE_UINT32 enable);
+    //
+    // UNDI may need to block multi-threaded/multi-processor access to
+    // critical code sections when programming or accessing the network
+    // device.  To this end, a blocking service is needed by the UNDI.
+    // When UNDI needs a block, it will call Block() passing a non-zero
+    // value.  When UNDI no longer needs a block, it will call Block()
+    // with a zero value.  When called, if the Block() is already enabled,
+    // do not return control to the UNDI until the previous Block() is
+    // disabled.
+    //
+    // This field cannot be set to zero.
+    //
+    PXE_UINT64 Block;
+
+    //
+    // PXE_VOID Virt2Phys(PXE_UINT64 virtual, PXE_UINT64 physical_ptr);
+    //
+    // UNDI will pass the virtual address of a buffer and the virtual
+    // address of a 64-bit physical buffer.  Convert the virtual address
+    // to a physical address and write the result to the physical address
+    // buffer.  If virtual and physical addresses are the same, just
+    // copy the virtual address to the physical address buffer.
+    //
+    // This field can be set to zero if virtual and physical addresses 
+    // are equal.
+    //
+    PXE_UINT64 Virt2Phys;
+    //
+    // PXE_VOID Mem_IO(PXE_UINT8 read_write, PXE_UINT8 len, PXE_UINT64 port, 
+    //              PXE_UINT64 buf_addr);
+    //
+    // UNDI will read or write the device io space using this call back 
+    // function. It passes the number of bytes as the len parameter and it 
+    // will be either 1,2,4 or 8.
+    //
+    // This field can not be set to zero.
+    //
+    PXE_UINT64 Mem_IO;
+} PXE_CPB_START;
+
+#define PXE_DELAY_MILLISECOND                   1000
+#define PXE_DELAY_SECOND                    1000000
+#define PXE_IO_READ                     0
+#define PXE_IO_WRITE                        1
+#define PXE_MEM_READ                        2
+#define PXE_MEM_WRITE                       4
+
+
+typedef struct s_pxe_db_get_init_info {
+    //
+    // Minimum length of locked memory buffer that must be given to
+    // the Initialize command. Giving UNDI more memory will generally
+    // give better performance.
+    //
+    // If MemoryRequired is zero, the UNDI does not need and will not
+    // use system memory to receive and transmit packets.
+    //
+    PXE_UINT32 MemoryRequired;
+
+    //
+    // Maximum frame data length for Tx/Rx excluding the media header.
+    //
+    PXE_UINT32 FrameDataLen;
+
+    //
+    // Supported link speeds are in units of mega bits.  Common ethernet
+    // values are 10, 100 and 1000.  Unused LinkSpeeds[] entries are zero
+    // filled.
+    //
+    PXE_UINT32 LinkSpeeds[4];
+
+    //
+    // Number of non-volatile storage items.
+    //
+    PXE_UINT32 NvCount;
+
+    //
+    // Width of non-volatile storage item in bytes.  0, 1, 2 or 4
+    //
+    PXE_UINT16 NvWidth;
+
+    //
+    // Media header length.  This is the typical media header length for
+    // this UNDI.  This information is needed when allocating receive
+    // and transmit buffers.
+    //
+    PXE_UINT16 MediaHeaderLen;
+
+    //
+    // Number of bytes in the NIC hardware (MAC) address.
+    //
+    PXE_UINT16 HWaddrLen;
+
+    //
+    // Maximum number of multicast MAC addresses in the multicast
+    // MAC address filter list.
+    //
+    PXE_UINT16 MCastFilterCnt;
+
+    //
+    // Default number and size of transmit and receive buffers that will 
+    // be allocated by the UNDI.  If MemoryRequired is non-zero, this 
+    // allocation will come out of the memory buffer given to the Initialize 
+    // command.  If MemoryRequired is zero, this allocation will come out of 
+    // memory on the NIC.
+    //
+    PXE_UINT16 TxBufCnt;
+    PXE_UINT16 TxBufSize;
+    PXE_UINT16 RxBufCnt;
+    PXE_UINT16 RxBufSize;
+
+    //
+    // Hardware interface types defined in the Assigned Numbers RFC
+    // and used in DHCP and ARP packets.
+    // See the PXE_IFTYPE typedef and PXE_IFTYPE_xxx macros.
+    //
+    PXE_UINT8 IFtype;
+
+    //
+    // Supported duplex.  See PXE_DUPLEX_xxxxx #defines below.
+    //
+    PXE_UINT8 Duplex;
+
+    //
+    // Supported loopback options.  See PXE_LOOPBACK_xxxxx #defines below.
+    //
+    PXE_UINT8 LoopBack;
+} PXE_DB_GET_INIT_INFO;
+
+#define PXE_MAX_TXRX_UNIT_ETHER             1500
+
+#define PXE_HWADDR_LEN_ETHER                    0x0006
+#define PXE_MAC_HEADER_LEN_ETHER                0x000E
+
+#define PXE_DUPLEX_ENABLE_FULL_SUPPORTED            1
+#define PXE_DUPLEX_FORCE_FULL_SUPPORTED         2
+
+#define PXE_LOOPBACK_INTERNAL_SUPPORTED         1
+#define PXE_LOOPBACK_EXTERNAL_SUPPORTED         2
+
+
+typedef struct s_pxe_pci_config_info {
+    //
+    // This is the flag field for the PXE_DB_GET_CONFIG_INFO union.
+    // For PCI bus devices, this field is set to PXE_BUSTYPE_PCI.
+    //
+    PXE_UINT32 BusType;
+
+    //
+    // This identifies the PCI network device that this UNDI interface
+    // is bound to.
+    //
+    PXE_UINT16 Bus;
+    PXE_UINT8 Device;
+    PXE_UINT8 Function;
+
+    //
+    // This is a copy of the PCI configuration space for this 
+    // network device.
+    //
+    union {
+        PXE_UINT8 Byte[256];
+        PXE_UINT16 Word[128];
+        PXE_UINT32 Dword[64];
+    } Config;
+} PXE_PCI_CONFIG_INFO;
+
+
+typedef struct s_pxe_pcc_config_info {
+    //
+    // This is the flag field for the PXE_DB_GET_CONFIG_INFO union.
+    // For PCC bus devices, this field is set to PXE_BUSTYPE_PCC.
+    //
+    PXE_UINT32 BusType;
+    
+    //
+    // This identifies the PCC network device that this UNDI interface
+    // is bound to.
+    //
+    PXE_UINT16 Bus;
+    PXE_UINT8 Device;
+    PXE_UINT8 Function;
+
+    //
+    // This is a copy of the PCC configuration space for this 
+    // network device.
+    //
+    union {
+        PXE_UINT8 Byte[256];
+        PXE_UINT16 Word[128];
+        PXE_UINT32 Dword[64];
+    } Config;
+} PXE_PCC_CONFIG_INFO;
+
+
+typedef struct s_pxe_usb_config_info {
+    PXE_UINT32 BusType;
+    // %%TBD What should we return here...
+} PXE_USB_CONFIG_INFO;
+
+
+typedef struct s_pxe_1394_config_info {
+    PXE_UINT32 BusType;
+    // %%TBD What should we return here...
+} PXE_1394_CONFIG_INFO;
+
+
+typedef union u_pxe_db_get_config_info {
+    PXE_PCI_CONFIG_INFO pci;
+    PXE_PCC_CONFIG_INFO pcc;
+    PXE_USB_CONFIG_INFO usb;
+    PXE_1394_CONFIG_INFO _1394;
+} PXE_DB_GET_CONFIG_INFO;
+
+
+typedef struct s_pxe_cpb_initialize {
+    //
+    // Address of first (lowest) byte of the memory buffer.  This buffer must
+    // be in contiguous physical memory and cannot be swapped out.  The UNDI
+    // will be using this for transmit and receive buffering.
+    //
+    PXE_UINT64 MemoryAddr;
+
+    //
+    // MemoryLength must be greater than or equal to MemoryRequired
+    // returned by the Get Init Info command.
+    //
+    PXE_UINT32 MemoryLength;
+
+    //
+    // Desired link speed in Mbit/sec.  Common ethernet values are 10, 100
+    // and 1000.  Setting a value of zero will auto-detect and/or use the
+    // default link speed (operation depends on UNDI/NIC functionality).
+    //
+    PXE_UINT32 LinkSpeed;
+
+    //
+    // Suggested number and size of receive and transmit buffers to
+    // allocate.  If MemoryAddr and MemoryLength are non-zero, this
+    // allocation comes out of the supplied memory buffer.  If MemoryAddr 
+    // and MemoryLength are zero, this allocation comes out of memory
+    // on the NIC.
+    //
+    // If these fields are set to zero, the UNDI will allocate buffer
+    // counts and sizes as it sees fit.
+    //
+    PXE_UINT16 TxBufCnt;
+    PXE_UINT16 TxBufSize;
+    PXE_UINT16 RxBufCnt;
+    PXE_UINT16 RxBufSize;
+
+    //
+    // The following configuration parameters are optional and must be zero 
+    // to use the default values.
+    //
+    PXE_UINT8 Duplex; 
+
+    PXE_UINT8 LoopBack;
+} PXE_CPB_INITIALIZE;
+
+
+#define PXE_DUPLEX_DEFAULT                  0x00
+#define PXE_FORCE_FULL_DUPLEX                   0x01
+#define PXE_ENABLE_FULL_DUPLEX              0x02
+
+#define LOOPBACK_NORMAL 0
+#define LOOPBACK_INTERNAL 1
+#define LOOPBACK_EXTERNAL 2
+
+
+typedef struct s_pxe_db_initialize {
+    //
+    // Actual amount of memory used from the supplied memory buffer.  This
+    // may be less that the amount of memory suppllied and may be zero if
+    // the UNDI and network device do not use external memory buffers.
+    //
+    // Memory used by the UNDI and network device is allocated from the 
+    // lowest memory buffer address.
+    //
+    PXE_UINT32 MemoryUsed;
+
+    //
+    // Actual number and size of receive and transmit buffers that were
+    // allocated.
+    //
+    PXE_UINT16 TxBufCnt;
+    PXE_UINT16 TxBufSize;
+    PXE_UINT16 RxBufCnt;
+    PXE_UINT16 RxBufSize;
+} PXE_DB_INITIALIZE;
+
+
+typedef struct s_pxe_cpb_receive_filters {
+    //
+    // List of multicast MAC addresses.  This list, if present, will
+    // replace the existing multicast MAC address filter list.
+    //
+    PXE_MAC_ADDR MCastList[MAX_MCAST_ADDRESS_CNT];
+} PXE_CPB_RECEIVE_FILTERS;
+
+
+typedef struct s_pxe_db_receive_filters {
+    //
+    // Filtered multicast MAC address list.
+    //
+    PXE_MAC_ADDR MCastList[MAX_MCAST_ADDRESS_CNT];
+} PXE_DB_RECEIVE_FILTERS;
+
+
+typedef struct s_pxe_cpb_station_address {
+    //
+    // If supplied and supported, the current station MAC address
+    // will be changed.
+    //
+    PXE_MAC_ADDR StationAddr;
+} PXE_CPB_STATION_ADDRESS;
+
+
+typedef struct s_pxe_dpb_station_address {
+    //
+    // Current station MAC address.
+    //
+    PXE_MAC_ADDR StationAddr;
+
+    //
+    // Station broadcast MAC address.
+    //
+    PXE_MAC_ADDR BroadcastAddr;
+
+    //
+    // Permanent station MAC address.
+    //
+    PXE_MAC_ADDR PermanentAddr;
+} PXE_DB_STATION_ADDRESS;
+
+
+typedef struct s_pxe_db_statistics {
+    //
+    // Bit field identifying what statistic data is collected by the 
+    // UNDI/NIC.
+    // If bit 0x00 is set, Data[0x00] is collected.
+    // If bit 0x01 is set, Data[0x01] is collected.
+    // If bit 0x20 is set, Data[0x20] is collected.
+    // If bit 0x21 is set, Data[0x21] is collected.
+    // Etc.
+    //
+    PXE_UINT64 Supported;
+
+    //
+    // Statistic data.
+    //
+    PXE_UINT64 Data[64];
+} PXE_DB_STATISTICS;
+
+//
+// Total number of frames received.  Includes frames with errors and
+// dropped frames.
+//
+#define PXE_STATISTICS_RX_TOTAL_FRAMES          0x00
+
+//
+// Number of valid frames received and copied into receive buffers.
+//
+#define PXE_STATISTICS_RX_GOOD_FRAMES           0x01
+
+//
+// Number of frames below the minimum length for the media.
+// This would be <64 for ethernet.
+//
+#define PXE_STATISTICS_RX_UNDERSIZE_FRAMES          0x02
+
+//
+// Number of frames longer than the maxminum length for the
+// media.  This would be >1500 for ethernet.
+//
+#define PXE_STATISTICS_RX_OVERSIZE_FRAMES           0x03
+
+//
+// Valid frames that were dropped because receive buffers were full.
+//
+#define PXE_STATISTICS_RX_DROPPED_FRAMES            0x04
+
+//
+// Number of valid unicast frames received and not dropped.
+//
+#define PXE_STATISTICS_RX_UNICAST_FRAMES            0x05
+
+//
+// Number of valid broadcast frames received and not dropped.
+//
+#define PXE_STATISTICS_RX_BROADCAST_FRAMES          0x06
+
+//
+// Number of valid mutlicast frames received and not dropped.
+//
+#define PXE_STATISTICS_RX_MULTICAST_FRAMES          0x07
+
+//
+// Number of frames w/ CRC or alignment errors.
+//
+#define PXE_STATISTICS_RX_CRC_ERROR_FRAMES          0x08
+
+//
+// Total number of bytes received.  Includes frames with errors
+// and dropped frames.
+//
+#define PXE_STATISTICS_RX_TOTAL_BYTES           0x09
+
+//
+// Transmit statistics.
+//
+#define PXE_STATISTICS_TX_TOTAL_FRAMES          0x0A
+#define PXE_STATISTICS_TX_GOOD_FRAMES           0x0B
+#define PXE_STATISTICS_TX_UNDERSIZE_FRAMES          0x0C
+#define PXE_STATISTICS_TX_OVERSIZE_FRAMES           0x0D
+#define PXE_STATISTICS_TX_DROPPED_FRAMES            0x0E
+#define PXE_STATISTICS_TX_UNICAST_FRAMES            0x0F
+#define PXE_STATISTICS_TX_BROADCAST_FRAMES          0x10
+#define PXE_STATISTICS_TX_MULTICAST_FRAMES          0x11
+#define PXE_STATISTICS_TX_CRC_ERROR_FRAMES          0x12
+#define PXE_STATISTICS_TX_TOTAL_BYTES           0x13
+
+//
+// Number of collisions detection on this subnet.
+//
+#define PXE_STATISTICS_COLLISIONS               0x14
+
+//
+// Number of frames destined for unsupported protocol.
+//
+#define PXE_STATISTICS_UNSUPPORTED_PROTOCOL         0x15
+
+
+typedef struct s_pxe_cpb_mcast_ip_to_mac {
+    //
+    // Multicast IP address to be converted to multicast MAC address.
+    //
+    PXE_IP_ADDR IP;
+} PXE_CPB_MCAST_IP_TO_MAC;
+
+
+typedef struct s_pxe_db_mcast_ip_to_mac {
+    //
+    // Multicast MAC address.
+    //
+    PXE_MAC_ADDR MAC;
+} PXE_DB_MCAST_IP_TO_MAC;
+
+
+typedef struct s_pxe_cpb_nvdata_sparse {
+    //
+    // NvData item list.  Only items in this list will be updated.
+    //
+    struct {
+        //  Non-volatile storage address to be changed.
+        PXE_UINT32 Addr;
+
+        // Data item to write into above storage address.
+    
+        union {
+            PXE_UINT8 Byte;
+            PXE_UINT16 Word;
+            PXE_UINT32 Dword;
+        } Data;
+    } Item[MAX_EEPROM_LEN];
+} PXE_CPB_NVDATA_SPARSE;
+
+
+//
+// When using bulk update, the size of the CPB structure must be
+// the same size as the non-volatile NIC storage.
+//
+typedef union u_pxe_cpb_nvdata_bulk {
+    //
+    // Array of byte-wide data items.
+    //
+    PXE_UINT8 Byte[MAX_EEPROM_LEN << 2];
+
+    //
+    // Array of word-wide data items.
+    //
+    PXE_UINT16 Word[MAX_EEPROM_LEN << 1];
+
+    //
+    // Array of dword-wide data items.
+    //
+    PXE_UINT32 Dword[MAX_EEPROM_LEN];
+} PXE_CPB_NVDATA_BULK;
+
+typedef struct s_pxe_db_nvdata {
+
+    // Arrays of data items from non-volatile storage.
+
+    union {
+        //
+        // Array of byte-wide data items.
+        //
+        PXE_UINT8 Byte[MAX_EEPROM_LEN << 2];
+
+        //
+        // Array of word-wide data items.
+        //
+        PXE_UINT16 Word[MAX_EEPROM_LEN << 1];
+
+        // Array of dword-wide data items.
+
+        PXE_UINT32 Dword[MAX_EEPROM_LEN];
+    } Data;
+} PXE_DB_NVDATA;
+
+
+typedef struct s_pxe_db_get_status {
+    //
+    // Length of next receive frame (header + data).  If this is zero,
+    // there is no next receive frame available.
+    //
+    PXE_UINT32 RxFrameLen;
+
+    //
+    // Reserved, set to zero.
+    //
+    PXE_UINT32 reserved;
+
+    //
+    //  Addresses of transmitted buffers that need to be recycled.
+    //
+    PXE_UINT64 TxBuffer[MAX_XMIT_BUFFERS];
+} PXE_DB_GET_STATUS;
+
+
+
+typedef struct s_pxe_cpb_fill_header {
+    //
+    // Source and destination MAC addresses.  These will be copied into
+    // the media header without doing byte swapping.
+    //
+    PXE_MAC_ADDR SrcAddr;
+    PXE_MAC_ADDR DestAddr;
+
+    //
+    // Address of first byte of media header.  The first byte of packet data
+    // follows the last byte of the media header.
+    //
+    PXE_UINT64 MediaHeader;
+
+    //
+    // Length of packet data in bytes (not including the media header).
+    //
+    PXE_UINT32 PacketLen;
+
+    //
+    // Protocol type.  This will be copied into the media header without
+    // doing byte swapping.  Protocol type numbers can be obtained from
+    // the Assigned Numbers RFC 1700.
+    //
+    PXE_UINT16 Protocol;
+
+    //
+    // Length of the media header in bytes.
+    //
+    PXE_UINT16 MediaHeaderLen;
+} PXE_CPB_FILL_HEADER;
+
+
+#define PXE_PROTOCOL_ETHERNET_IP                0x0800
+#define PXE_PROTOCOL_ETHERNET_ARP               0x0806
+#define MAX_XMIT_FRAGMENTS 16
+
+typedef struct s_pxe_cpb_fill_header_fragmented {
+    //
+    // Source and destination MAC addresses.  These will be copied into
+    // the media header without doing byte swapping.
+    //
+    PXE_MAC_ADDR SrcAddr;
+    PXE_MAC_ADDR DestAddr;
+
+    //
+    // Length of packet data in bytes (not including the media header).
+    //
+    PXE_UINT32 PacketLen;
+
+    //
+    // Protocol type.  This will be copied into the media header without
+    // doing byte swapping.  Protocol type numbers can be obtained from
+    // the Assigned Numbers RFC 1700.
+    //
+    PXE_MEDIA_PROTOCOL Protocol;
+
+    //
+    // Length of the media header in bytes.
+    //
+    PXE_UINT16 MediaHeaderLen;
+
+    //
+    // Number of packet fragment descriptors.
+    //
+    PXE_UINT16 FragCnt;
+
+    //
+    // Reserved, must be set to zero.
+    //
+    PXE_UINT16 reserved;
+
+    //
+    // Array of packet fragment descriptors.  The first byte of the media
+    // header is the first byte of the first fragment.
+    //
+    struct {
+        //
+        // Address of this packet fragment.
+        //
+        PXE_UINT64 FragAddr;
+
+        //
+        // Length of this packet fragment.
+        //
+        PXE_UINT32 FragLen;
+
+        //
+        // Reserved, must be set to zero.
+        //
+        PXE_UINT32 reserved;
+    } FragDesc[MAX_XMIT_FRAGMENTS];
+} PXE_CPB_FILL_HEADER_FRAGMENTED;
+
+
+
+typedef struct s_pxe_cpb_transmit {
+    //
+    // Address of first byte of frame buffer.  This is also the first byte
+    // of the media header.
+    //
+    PXE_UINT64 FrameAddr;
+
+    //
+    // Length of the data portion of the frame buffer in bytes.  Do not
+    // include the length of the media header.
+    //
+    PXE_UINT32 DataLen;
+
+    //
+    // Length of the media header in bytes.
+    //
+    PXE_UINT16 MediaheaderLen;
+
+    //
+    // Reserved, must be zero.
+    //
+    PXE_UINT16 reserved;
+} PXE_CPB_TRANSMIT;
+
+
+
+typedef struct s_pxe_cpb_transmit_fragments {
+    //
+    // Length of packet data in bytes (not including the media header).
+    //
+    PXE_UINT32 FrameLen;
+
+    //
+    // Length of the media header in bytes.
+    //
+    PXE_UINT16 MediaheaderLen;
+
+    //
+    // Number of packet fragment descriptors.
+    //
+    PXE_UINT16 FragCnt;
+
+    //
+    // Array of frame fragment descriptors.  The first byte of the first
+    // fragment is also the first byte of the media header.
+    //
+    struct {
+        //
+        // Address of this frame fragment.
+        //
+        PXE_UINT64 FragAddr;
+
+        //
+        // Length of this frame fragment.
+        //
+        PXE_UINT32 FragLen;
+
+        //
+        // Reserved, must be set to zero.
+        //
+        PXE_UINT32 reserved;
+    } FragDesc[MAX_XMIT_FRAGMENTS];
+} PXE_CPB_TRANSMIT_FRAGMENTS;
+
+
+typedef struct s_pxe_cpb_receive {
+    //
+    // Address of first byte of receive buffer.  This is also the first byte
+    // of the frame header.
+    //
+    PXE_UINT64 BufferAddr;
+
+    //
+    // Length of receive buffer.  This must be large enough to hold the
+    // received frame (media header + data).  If the length of smaller than
+    // the received frame, data will be lost.
+    //
+    PXE_UINT32 BufferLen;
+
+    //
+    // Reserved, must be set to zero.
+    //
+    PXE_UINT32 reserved;
+} PXE_CPB_RECEIVE;
+
+
+typedef struct s_pxe_db_receive {
+    //
+    // Source and destination MAC addresses from media header.
+    //
+    PXE_MAC_ADDR SrcAddr;
+    PXE_MAC_ADDR DestAddr;
+
+    //
+    // Length of received frame.  May be larger than receive buffer size.
+    // The receive buffer will not be overwritten.  This is how to tell
+    // if data was lost because the receive buffer was too small.
+    //
+    PXE_UINT32 FrameLen;
+
+    //
+    // Protocol type from media header.
+    //
+    PXE_MEDIA_PROTOCOL Protocol;
+
+    //
+    // Length of media header in received frame.
+    //
+    PXE_UINT16 MediaHeaderLen;
+
+    //
+    // Type of receive frame.
+    //
+    PXE_FRAME_TYPE Type;
+
+    //
+    // Reserved, must be zero.
+    //
+    PXE_UINT8 reserved[7];
+
+} PXE_DB_RECEIVE;
+
+#pragma pack()
+
+/* EOF - efi_pxe.h */
+#endif /* _EFI_PXE_H */
+
diff --git a/linux-x86/gnu-efi/include/efi/efiapi.h b/linux-x86/gnu-efi/include/efi/efiapi.h
new file mode 100644
index 0000000..7f46e0d
--- /dev/null
+++ b/linux-x86/gnu-efi/include/efi/efiapi.h
@@ -0,0 +1,1003 @@
+#ifndef _EFI_API_H
+#define _EFI_API_H
+
+/*++
+
+Copyright (c) 1998  Intel Corporation
+
+Module Name:
+
+    efiapi.h
+
+Abstract:
+
+    Global EFI runtime & boot service interfaces
+
+
+
+
+Revision History
+
+--*/
+
+//
+// EFI Specification Revision
+//
+#define EFI_SYSTEM_TABLE_SIGNATURE 0x5453595320494249
+#define EFI_2_31_SYSTEM_TABLE_REVISION ((2<<16) | (31))
+#define EFI_2_30_SYSTEM_TABLE_REVISION ((2<<16) | (30))
+#define EFI_2_20_SYSTEM_TABLE_REVISION ((2<<16) | (20))
+#define EFI_2_10_SYSTEM_TABLE_REVISION ((2<<16) | (10))
+#define EFI_2_00_SYSTEM_TABLE_REVISION ((2<<16) | (00))
+#define EFI_1_10_SYSTEM_TABLE_REVISION ((1<<16) | (10))
+#define EFI_1_02_SYSTEM_TABLE_REVISION ((1<<16) | (02))
+#define EFI_SYSTEM_TABLE_REVISION EFI_2_31_SYSTEM_TABLE_REVISION
+#define EFI_SPECIFICATION_VERSION EFI_SYSTEM_TABLE_REVISION
+
+
+
+//
+// Declare forward referenced data structures
+//
+
+INTERFACE_DECL(_EFI_SYSTEM_TABLE);
+
+//
+// EFI Memory
+//
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_ALLOCATE_PAGES) (
+    IN EFI_ALLOCATE_TYPE            Type,
+    IN EFI_MEMORY_TYPE              MemoryType,
+    IN UINTN                        NoPages,
+    OUT EFI_PHYSICAL_ADDRESS        *Memory
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_FREE_PAGES) (
+    IN EFI_PHYSICAL_ADDRESS         Memory,
+    IN UINTN                        NoPages
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_GET_MEMORY_MAP) (
+    IN OUT UINTN                    *MemoryMapSize,
+    IN OUT EFI_MEMORY_DESCRIPTOR    *MemoryMap,
+    OUT UINTN                       *MapKey,
+    OUT UINTN                       *DescriptorSize,
+    OUT UINT32                      *DescriptorVersion
+    );
+
+#define NextMemoryDescriptor(Ptr,Size)  ((EFI_MEMORY_DESCRIPTOR *) (((UINT8 *) Ptr) + Size))
+
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_ALLOCATE_POOL) (
+    IN EFI_MEMORY_TYPE              PoolType,
+    IN UINTN                        Size,
+    OUT VOID                        **Buffer
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_FREE_POOL) (
+    IN VOID                         *Buffer
+    );
+
+typedef 
+EFI_STATUS
+(EFIAPI *EFI_SET_VIRTUAL_ADDRESS_MAP) (
+    IN UINTN                        MemoryMapSize,
+    IN UINTN                        DescriptorSize,
+    IN UINT32                       DescriptorVersion,
+    IN EFI_MEMORY_DESCRIPTOR        *VirtualMap
+    );
+
+
+#define EFI_OPTIONAL_PTR            0x00000001
+#define EFI_INTERNAL_FNC            0x00000002      // Pointer to internal runtime fnc
+#define EFI_INTERNAL_PTR            0x00000004      // Pointer to internal runtime data
+
+
+typedef 
+EFI_STATUS
+(EFIAPI *EFI_CONVERT_POINTER) (
+    IN UINTN                        DebugDisposition,
+    IN OUT VOID                     **Address
+    );
+
+
+//
+// EFI Events
+//
+
+
+
+#define EVT_TIMER                           0x80000000
+#define EVT_RUNTIME                         0x40000000
+#define EVT_RUNTIME_CONTEXT                 0x20000000
+
+#define EVT_NOTIFY_WAIT                     0x00000100
+#define EVT_NOTIFY_SIGNAL                   0x00000200
+
+#define EVT_SIGNAL_EXIT_BOOT_SERVICES       0x00000201
+#define EVT_SIGNAL_VIRTUAL_ADDRESS_CHANGE   0x60000202
+
+#define EVT_EFI_SIGNAL_MASK                 0x000000FF
+#define EVT_EFI_SIGNAL_MAX                  2
+
+typedef
+VOID
+(EFIAPI *EFI_EVENT_NOTIFY) (
+    IN EFI_EVENT                Event,
+    IN VOID                     *Context
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_CREATE_EVENT) (
+    IN UINT32                       Type,
+    IN EFI_TPL                      NotifyTpl,
+    IN EFI_EVENT_NOTIFY             NotifyFunction,
+    IN VOID                         *NotifyContext,
+    OUT EFI_EVENT                   *Event
+    );
+
+typedef enum {
+    TimerCancel,
+    TimerPeriodic,
+    TimerRelative,
+    TimerTypeMax
+} EFI_TIMER_DELAY;
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_SET_TIMER) (
+    IN EFI_EVENT                Event,
+    IN EFI_TIMER_DELAY          Type,
+    IN UINT64                   TriggerTime
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_SIGNAL_EVENT) (
+    IN EFI_EVENT                Event
+    );
+
+typedef 
+EFI_STATUS
+(EFIAPI *EFI_WAIT_FOR_EVENT) (
+    IN UINTN                    NumberOfEvents,
+    IN EFI_EVENT                *Event,
+    OUT UINTN                   *Index
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_CLOSE_EVENT) (
+    IN EFI_EVENT                Event
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_CHECK_EVENT) (
+    IN EFI_EVENT                Event
+    );
+
+//
+// Task priority level
+//
+
+#define TPL_APPLICATION    4
+#define TPL_CALLBACK       8
+#define TPL_NOTIFY        16 
+#define TPL_HIGH_LEVEL    31 
+
+typedef
+EFI_TPL
+(EFIAPI *EFI_RAISE_TPL) (
+    IN EFI_TPL      NewTpl
+    );
+
+typedef
+VOID
+(EFIAPI *EFI_RESTORE_TPL) (
+    IN EFI_TPL      OldTpl
+    );
+
+
+//
+// EFI platform varibles
+//
+
+#define EFI_GLOBAL_VARIABLE     \
+    { 0x8BE4DF61, 0x93CA, 0x11d2, {0xAA, 0x0D, 0x00, 0xE0, 0x98, 0x03, 0x2B, 0x8C} }
+
+// Variable attributes
+#define EFI_VARIABLE_NON_VOLATILE           0x00000001
+#define EFI_VARIABLE_BOOTSERVICE_ACCESS     0x00000002
+#define EFI_VARIABLE_RUNTIME_ACCESS         0x00000004
+
+// Variable size limitation
+#define EFI_MAXIMUM_VARIABLE_SIZE           1024
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_GET_VARIABLE) (
+    IN CHAR16                       *VariableName,
+    IN EFI_GUID                     *VendorGuid,
+    OUT UINT32                      *Attributes OPTIONAL,
+    IN OUT UINTN                    *DataSize,
+    OUT VOID                        *Data
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_GET_NEXT_VARIABLE_NAME) (
+    IN OUT UINTN                    *VariableNameSize,
+    IN OUT CHAR16                   *VariableName,
+    IN OUT EFI_GUID                 *VendorGuid
+    );
+
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_SET_VARIABLE) (
+    IN CHAR16                       *VariableName,
+    IN EFI_GUID                     *VendorGuid,
+    IN UINT32                       Attributes,
+    IN UINTN                        DataSize,
+    IN VOID                         *Data
+    );
+
+
+//
+// EFI Time
+//
+
+typedef struct {
+        UINT32                      Resolution;     // 1e-6 parts per million
+        UINT32                      Accuracy;       // hertz
+        BOOLEAN                     SetsToZero;     // Set clears sub-second time
+} EFI_TIME_CAPABILITIES;
+
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_GET_TIME) (
+    OUT EFI_TIME                    *Time,
+    OUT EFI_TIME_CAPABILITIES       *Capabilities OPTIONAL
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_SET_TIME) (
+    IN EFI_TIME                     *Time
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_GET_WAKEUP_TIME) (
+    OUT BOOLEAN                     *Enabled,
+    OUT BOOLEAN                     *Pending,
+    OUT EFI_TIME                    *Time
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_SET_WAKEUP_TIME) (
+    IN BOOLEAN                      Enable,
+    IN EFI_TIME                     *Time OPTIONAL
+    );
+
+
+//
+// Image functions
+//
+
+
+// PE32+ Subsystem type for EFI images
+
+#if !defined(IMAGE_SUBSYSTEM_EFI_APPLICATION)
+#define IMAGE_SUBSYSTEM_EFI_APPLICATION             10
+#define IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER     11
+#define IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER          12
+#endif
+
+// PE32+ Machine type for EFI images
+
+#if !defined(EFI_IMAGE_MACHINE_IA32)
+#define EFI_IMAGE_MACHINE_IA32      0x014c
+#endif
+
+#if !defined(EFI_IMAGE_MACHINE_IA64)
+#define EFI_IMAGE_MACHINE_IA64      0x0200
+#endif
+
+// Image Entry prototype
+
+typedef 
+EFI_STATUS
+(EFIAPI *EFI_IMAGE_ENTRY_POINT) (
+    IN EFI_HANDLE                   ImageHandle,
+    IN struct _EFI_SYSTEM_TABLE     *SystemTable
+    );
+
+typedef 
+EFI_STATUS
+(EFIAPI *EFI_IMAGE_LOAD) (
+    IN BOOLEAN                      BootPolicy,
+    IN EFI_HANDLE                   ParentImageHandle,
+    IN EFI_DEVICE_PATH              *FilePath,
+    IN VOID                         *SourceBuffer   OPTIONAL,
+    IN UINTN                        SourceSize,
+    OUT EFI_HANDLE                  *ImageHandle
+    );
+
+typedef 
+EFI_STATUS
+(EFIAPI *EFI_IMAGE_START) (
+    IN EFI_HANDLE                   ImageHandle,
+    OUT UINTN                       *ExitDataSize,
+    OUT CHAR16                      **ExitData  OPTIONAL
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_EXIT) (
+    IN EFI_HANDLE                   ImageHandle,
+    IN EFI_STATUS                   ExitStatus,
+    IN UINTN                        ExitDataSize,
+    IN CHAR16                       *ExitData OPTIONAL
+    );
+
+typedef 
+EFI_STATUS
+(EFIAPI *EFI_IMAGE_UNLOAD) (
+    IN EFI_HANDLE                   ImageHandle
+    );
+
+
+// Image handle
+#define LOADED_IMAGE_PROTOCOL      \
+    { 0x5B1B31A1, 0x9562, 0x11d2, {0x8E, 0x3F, 0x00, 0xA0, 0xC9, 0x69, 0x72, 0x3B} }
+
+#define EFI_IMAGE_INFORMATION_REVISION      0x1000
+typedef struct {
+    UINT32                          Revision;
+    EFI_HANDLE                      ParentHandle;
+    struct _EFI_SYSTEM_TABLE        *SystemTable;
+
+    // Source location of image
+    EFI_HANDLE                      DeviceHandle;
+    EFI_DEVICE_PATH                 *FilePath;
+    VOID                            *Reserved;
+
+    // Images load options
+    UINT32                          LoadOptionsSize;
+    VOID                            *LoadOptions;
+
+    // Location of where image was loaded
+    VOID                            *ImageBase;
+    UINT64                          ImageSize;
+    EFI_MEMORY_TYPE                 ImageCodeType;
+    EFI_MEMORY_TYPE                 ImageDataType;
+
+    // If the driver image supports a dynamic unload request
+    EFI_IMAGE_UNLOAD                Unload;
+
+} EFI_LOADED_IMAGE;
+
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_EXIT_BOOT_SERVICES) (
+    IN EFI_HANDLE                   ImageHandle,
+    IN UINTN                        MapKey
+    );
+
+//
+// Misc
+//
+
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_STALL) (
+    IN UINTN                    Microseconds
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_SET_WATCHDOG_TIMER) (
+    IN UINTN                    Timeout,
+    IN UINT64                   WatchdogCode,
+    IN UINTN                    DataSize,
+    IN CHAR16                   *WatchdogData OPTIONAL
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_CONNECT_CONTROLLER) (
+    IN EFI_HANDLE               ControllerHandle,
+    IN EFI_HANDLE               *DriverImageHandle OPTIONAL,
+    IN EFI_DEVICE_PATH          *RemainingDevicePath OPTIONAL,
+    IN BOOLEAN                  Recursive
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_DISCONNECT_CONTROLLER) (
+    IN EFI_HANDLE               ControllerHandle,
+    IN EFI_HANDLE               DriverImageHandle OPTIONAL,
+    IN EFI_HANDLE               ChildHandle OPTIONAL
+    );
+
+#define EFI_OPEN_PROTOCOL_BY_HANDLE_PROTOCOL  0x00000001
+#define EFI_OPEN_PROTOCOL_GET_PROTOCOL        0x00000002
+#define EFI_OPEN_PROTOCOL_TEST_PROTOCOL       0x00000004
+#define EFI_OPEN_PROTOCOL_BY_CHILD_CONTROLLER 0x00000008
+#define EFI_OPEN_PROTOCOL_BY_DRIVER           0x00000010
+#define EFI_OPEN_PROTOCOL_EXCLUSIVE           0x00000020
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_OPEN_PROTOCOL) (
+    IN EFI_HANDLE               Handle,
+    IN EFI_GUID                 *Protocol,
+    OUT VOID                    **Interface OPTIONAL,
+    IN EFI_HANDLE               AgentHandle,
+    IN EFI_HANDLE               ControllerHandle,
+    IN UINT32                   Attributes
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_CLOSE_PROTOCOL) (
+    IN EFI_HANDLE               Handle,
+    IN EFI_GUID                 *Protocol,
+    IN EFI_HANDLE               AgentHandle,
+    IN EFI_HANDLE               ControllerHandle
+    );
+
+typedef struct {
+    EFI_HANDLE                  AgentHandle;
+    EFI_HANDLE                  ControllerHandle;
+    UINT32                      Attributes;
+    UINT32                      OpenCount;
+} EFI_OPEN_PROTOCOL_INFORMATION_ENTRY;
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_OPEN_PROTOCOL_INFORMATION) (
+    IN EFI_HANDLE               Handle,
+    IN EFI_GUID                 *Protocol,
+    OUT EFI_OPEN_PROTOCOL_INFORMATION_ENTRY **EntryBuffer,
+    OUT UINTN                   *EntryCount
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PROTOCOLS_PER_HANDLE) (
+    IN EFI_HANDLE               Handle,
+    OUT EFI_GUID                ***ProtocolBuffer,
+    OUT UINTN                   *ProtocolBufferCount
+    );
+
+typedef enum {
+    AllHandles,
+    ByRegisterNotify,
+    ByProtocol
+} EFI_LOCATE_SEARCH_TYPE;
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_LOCATE_HANDLE_BUFFER) (
+    IN EFI_LOCATE_SEARCH_TYPE   SearchType,
+    IN EFI_GUID                 *Protocol OPTIONAL,
+    IN VOID                     *SearchKey OPTIONAL,
+    IN OUT UINTN                *NoHandles,
+    OUT EFI_HANDLE              **Buffer
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_LOCATE_PROTOCOL) (
+    IN EFI_GUID                 *Protocol,
+    IN VOID                     *Registration OPTIONAL,
+    OUT VOID                    **Interface
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_INSTALL_MULTIPLE_PROTOCOL_INTERFACES) (
+    IN OUT EFI_HANDLE           *Handle,
+    ...
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_UNINSTALL_MULTIPLE_PROTOCOL_INTERFACES) (
+    IN OUT EFI_HANDLE           Handle,
+    ...
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_CALCULATE_CRC32) (
+    IN VOID                     *Data,
+    IN UINTN                    DataSize,
+    OUT UINT32                  *Crc32
+    );
+
+typedef
+VOID
+(EFIAPI *EFI_COPY_MEM) (
+    IN VOID                     *Destination,
+    IN VOID                     *Source,
+    IN UINTN                    Length
+    );
+
+typedef
+VOID
+(EFIAPI *EFI_SET_MEM) (
+    IN VOID                     *Buffer,
+    IN UINTN                    Size,
+    IN UINT8                    Value
+    );
+
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_CREATE_EVENT_EX) (
+    IN UINT32                   Type,
+    IN EFI_TPL                  NotifyTpl,
+    IN EFI_EVENT_NOTIFY         NotifyFunction OPTIONAL,
+    IN const VOID               *NotifyContext OPTIONAL,
+    IN const EFI_GUID           EventGroup OPTIONAL,
+    OUT EFI_EVENT               *Event
+    );
+
+typedef enum {
+    EfiResetCold,
+    EfiResetWarm,
+    EfiResetShutdown
+} EFI_RESET_TYPE;
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_RESET_SYSTEM) (
+    IN EFI_RESET_TYPE           ResetType,
+    IN EFI_STATUS               ResetStatus,
+    IN UINTN                    DataSize,
+    IN CHAR16                   *ResetData OPTIONAL
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_GET_NEXT_MONOTONIC_COUNT) (
+    OUT UINT64                  *Count
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_GET_NEXT_HIGH_MONO_COUNT) (
+    OUT UINT32                  *HighCount
+    );
+
+typedef struct {
+  UINT64                            Length;
+  union {
+    EFI_PHYSICAL_ADDRESS  DataBlock;
+    EFI_PHYSICAL_ADDRESS  ContinuationPointer;
+  } Union;
+} EFI_CAPSULE_BLOCK_DESCRIPTOR;
+
+typedef struct {
+  EFI_GUID          CapsuleGuid;
+  UINT32            HeaderSize;
+  UINT32            Flags;
+  UINT32            CapsuleImageSize;
+} EFI_CAPSULE_HEADER;
+
+//
+// The EFI System Table entry must point to an array of capsules
+// that contain the same CapsuleGuid value. The array must be
+// prefixed by a UINT32 that represents the size of the array of capsules.
+//
+typedef struct {
+  UINT32   CapsuleArrayNumber;
+  VOID*    CapsulePtr[1];
+} EFI_CAPSULE_TABLE;
+
+#define CAPSULE_FLAGS_PERSIST_ACROSS_RESET          0x00010000
+#define CAPSULE_FLAGS_POPULATE_SYSTEM_TABLE         0x00020000
+#define CAPSULE_FLAGS_INITIATE_RESET                0x00040000
+
+
+/**
+  Passes capsules to the firmware with both virtual and physical mapping. Depending on the intended
+  consumption, the firmware may process the capsule immediately. If the payload should persist
+  across a system reset, the reset value returned from EFI_QueryCapsuleCapabilities must
+  be passed into ResetSystem() and will cause the capsule to be processed by the firmware as
+  part of the reset process.
+
+  @param  CapsuleHeaderArray    Virtual pointer to an array of virtual pointers to the capsules
+                                being passed into update capsule.
+  @param  CapsuleCount          Number of pointers to EFI_CAPSULE_HEADER in
+                                CaspuleHeaderArray.
+  @param  ScatterGatherList     Physical pointer to a set of
+                                EFI_CAPSULE_BLOCK_DESCRIPTOR that describes the
+                                location in physical memory of a set of capsules.
+
+  @retval EFI_SUCCESS           Valid capsule was passed. If
+                                CAPSULE_FLAGS_PERSIT_ACROSS_RESET is not set, the
+                                capsule has been successfully processed by the firmware.
+  @retval EFI_DEVICE_ERROR      The capsule update was started, but failed due to a device error.
+  @retval EFI_INVALID_PARAMETER CapsuleSize is NULL.
+  @retval EFI_UNSUPPORTED       The capsule type is not supported on this platform.
+  @retval EFI_OUT_OF_RESOURCES  There were insufficient resources to process the capsule.
+
+**/
+typedef
+EFI_STATUS
+(EFIAPI *EFI_UPDATE_CAPSULE)(
+  IN EFI_CAPSULE_HEADER     **CapsuleHeaderArray,
+  IN UINTN                  CapsuleCount,
+  IN EFI_PHYSICAL_ADDRESS   ScatterGatherList   OPTIONAL
+  );
+
+/**
+  Returns if the capsule can be supported via UpdateCapsule().
+
+  @param  CapsuleHeaderArray    Virtual pointer to an array of virtual pointers to the capsules
+                                being passed into update capsule.
+  @param  CapsuleCount          Number of pointers to EFI_CAPSULE_HEADER in
+                                CaspuleHeaderArray.
+  @param  MaxiumCapsuleSize     On output the maximum size that UpdateCapsule() can
+                                support as an argument to UpdateCapsule() via
+                                CapsuleHeaderArray and ScatterGatherList.
+  @param  ResetType             Returns the type of reset required for the capsule update.
+
+  @retval EFI_SUCCESS           Valid answer returned.
+  @retval EFI_UNSUPPORTED       The capsule type is not supported on this platform, and
+                                MaximumCapsuleSize and ResetType are undefined.
+  @retval EFI_INVALID_PARAMETER MaximumCapsuleSize is NULL.
+  @retval EFI_OUT_OF_RESOURCES  There were insufficient resources to process the query request.
+
+**/
+typedef
+EFI_STATUS
+(EFIAPI *EFI_QUERY_CAPSULE_CAPABILITIES)(
+  IN  EFI_CAPSULE_HEADER     **CapsuleHeaderArray,
+  IN  UINTN                  CapsuleCount,
+  OUT UINT64                 *MaximumCapsuleSize,
+  OUT EFI_RESET_TYPE         *ResetType
+  );
+
+//
+// Protocol handler functions
+//
+
+typedef enum {
+    EFI_NATIVE_INTERFACE,
+    EFI_PCODE_INTERFACE
+} EFI_INTERFACE_TYPE;
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_INSTALL_PROTOCOL_INTERFACE) (
+    IN OUT EFI_HANDLE           *Handle,
+    IN EFI_GUID                 *Protocol,
+    IN EFI_INTERFACE_TYPE       InterfaceType,
+    IN VOID                     *Interface
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_REINSTALL_PROTOCOL_INTERFACE) (
+    IN EFI_HANDLE               Handle,
+    IN EFI_GUID                 *Protocol,
+    IN VOID                     *OldInterface,
+    IN VOID                     *NewInterface
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_UNINSTALL_PROTOCOL_INTERFACE) (
+    IN EFI_HANDLE               Handle,
+    IN EFI_GUID                 *Protocol,
+    IN VOID                     *Interface
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_HANDLE_PROTOCOL) (
+    IN EFI_HANDLE               Handle,
+    IN EFI_GUID                 *Protocol,
+    OUT VOID                    **Interface
+    );
+
+typedef
+EFI_STATUS 
+(EFIAPI *EFI_REGISTER_PROTOCOL_NOTIFY) (
+    IN EFI_GUID                 *Protocol,
+    IN EFI_EVENT                Event,
+    OUT VOID                    **Registration
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_LOCATE_HANDLE) (
+    IN EFI_LOCATE_SEARCH_TYPE   SearchType,
+    IN EFI_GUID                 *Protocol OPTIONAL,
+    IN VOID                     *SearchKey OPTIONAL,
+    IN OUT UINTN                *BufferSize,
+    OUT EFI_HANDLE              *Buffer
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_LOCATE_DEVICE_PATH) (
+    IN EFI_GUID                 *Protocol,
+    IN OUT EFI_DEVICE_PATH      **DevicePath,
+    OUT EFI_HANDLE              *Device
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_INSTALL_CONFIGURATION_TABLE) (
+    IN EFI_GUID                 *Guid,
+    IN VOID                     *Table
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_RESERVED_SERVICE) (
+    );
+
+//
+// Standard EFI table header
+//
+typedef
+EFI_STATUS
+(EFIAPI *EFI_QUERY_VARIABLE_INFO)(
+  IN  UINT32            Attributes,
+  OUT UINT64            *MaximumVariableStorageSize,
+  OUT UINT64            *RemainingVariableStorageSize,
+  OUT UINT64            *MaximumVariableSize
+  );
+
+typedef struct _EFI_TABLE_HEARDER {
+    UINT64                      Signature;
+    UINT32                      Revision;
+    UINT32                      HeaderSize;
+    UINT32                      CRC32;
+    UINT32                      Reserved;
+} EFI_TABLE_HEADER;
+
+
+//
+// EFI Runtime Serivces Table
+//
+
+#define EFI_RUNTIME_SERVICES_SIGNATURE 0x56524553544e5552
+#define EFI_RUNTIME_SERVICES_REVISION EFI_SPECIFICATION_VERSION
+
+
+typedef struct  {
+    EFI_TABLE_HEADER                Hdr;
+
+    //
+    // Time services
+    //
+
+    EFI_GET_TIME                    GetTime;
+    EFI_SET_TIME                    SetTime;
+    EFI_GET_WAKEUP_TIME             GetWakeupTime;
+    EFI_SET_WAKEUP_TIME             SetWakeupTime;
+
+    //
+    // Virtual memory services
+    //
+
+    EFI_SET_VIRTUAL_ADDRESS_MAP     SetVirtualAddressMap;
+    EFI_CONVERT_POINTER             ConvertPointer;
+
+    //
+    // Variable serviers
+    //
+
+    EFI_GET_VARIABLE                GetVariable;
+    EFI_GET_NEXT_VARIABLE_NAME      GetNextVariableName;
+    EFI_SET_VARIABLE                SetVariable;
+
+    //
+    // Misc
+    //
+
+    EFI_GET_NEXT_HIGH_MONO_COUNT    GetNextHighMonotonicCount;
+    EFI_RESET_SYSTEM                ResetSystem;
+    //
+    // UEFI 2.0 Capsule Services
+    //
+    EFI_UPDATE_CAPSULE              UpdateCapsule;
+    EFI_QUERY_CAPSULE_CAPABILITIES  QueryCapsuleCapabilities;
+
+    //
+    // Miscellaneous UEFI 2.0 Service
+    //
+    EFI_QUERY_VARIABLE_INFO         QueryVariableInfo;
+
+} EFI_RUNTIME_SERVICES;
+
+
+//
+// EFI Boot Services Table
+//
+
+
+#define EFI_BOOT_SERVICES_SIGNATURE 0x56524553544f4f42
+#define EFI_BOOT_SERVICES_REVISION EFI_SPECIFICATION_VERSION
+
+typedef struct _EFI_BOOT_SERVICES {
+
+    EFI_TABLE_HEADER                Hdr;
+
+    //
+    // Task priority functions
+    //
+
+    EFI_RAISE_TPL                   RaiseTPL;
+    EFI_RESTORE_TPL                 RestoreTPL;
+
+    //
+    // Memory functions
+    //
+
+    EFI_ALLOCATE_PAGES              AllocatePages;
+    EFI_FREE_PAGES                  FreePages;
+    EFI_GET_MEMORY_MAP              GetMemoryMap;
+    EFI_ALLOCATE_POOL               AllocatePool;
+    EFI_FREE_POOL                   FreePool;
+
+    //
+    // Event & timer functions
+    //
+
+    EFI_CREATE_EVENT                CreateEvent;
+    EFI_SET_TIMER                   SetTimer;
+    EFI_WAIT_FOR_EVENT              WaitForEvent;
+    EFI_SIGNAL_EVENT                SignalEvent;
+    EFI_CLOSE_EVENT                 CloseEvent;
+    EFI_CHECK_EVENT                 CheckEvent;
+
+    //
+    // Protocol handler functions
+    //
+
+    EFI_INSTALL_PROTOCOL_INTERFACE  InstallProtocolInterface;
+    EFI_REINSTALL_PROTOCOL_INTERFACE ReinstallProtocolInterface;
+    EFI_UNINSTALL_PROTOCOL_INTERFACE UninstallProtocolInterface;
+    EFI_HANDLE_PROTOCOL             HandleProtocol;
+    EFI_HANDLE_PROTOCOL             PCHandleProtocol;
+    EFI_REGISTER_PROTOCOL_NOTIFY    RegisterProtocolNotify;
+    EFI_LOCATE_HANDLE               LocateHandle;
+    EFI_LOCATE_DEVICE_PATH          LocateDevicePath;
+    EFI_INSTALL_CONFIGURATION_TABLE InstallConfigurationTable;
+
+    //
+    // Image functions
+    //
+
+    EFI_IMAGE_LOAD                  LoadImage;
+    EFI_IMAGE_START                 StartImage;
+    EFI_EXIT                        Exit;
+    EFI_IMAGE_UNLOAD                UnloadImage;
+    EFI_EXIT_BOOT_SERVICES          ExitBootServices;
+
+    //
+    // Misc functions
+    //
+
+    EFI_GET_NEXT_MONOTONIC_COUNT    GetNextMonotonicCount;
+    EFI_STALL                       Stall;
+    EFI_SET_WATCHDOG_TIMER          SetWatchdogTimer;
+
+    //
+    // DriverSupport Services
+    //
+
+    EFI_CONNECT_CONTROLLER          ConnectController;
+    EFI_DISCONNECT_CONTROLLER       DisconnectController;
+
+    //
+    // Open and Close Protocol Services
+    //
+    EFI_OPEN_PROTOCOL               OpenProtocol;
+    EFI_CLOSE_PROTOCOL              CloseProtocol;
+    EFI_OPEN_PROTOCOL_INFORMATION   OpenProtocolInformation;
+
+    //
+    // Library Services
+    //
+    EFI_PROTOCOLS_PER_HANDLE        ProtocolsPerHandle;
+    EFI_LOCATE_HANDLE_BUFFER        LocateHandleBuffer;
+    EFI_LOCATE_PROTOCOL             LocateProtocol;
+    EFI_INSTALL_MULTIPLE_PROTOCOL_INTERFACES InstallMultipleProtocolInterfaces;
+    EFI_UNINSTALL_MULTIPLE_PROTOCOL_INTERFACES UninstallMultipleProtocolInterfaces;
+
+    //
+    // 32-bit CRC Services
+    //
+    EFI_CALCULATE_CRC32             CalculateCrc32;
+
+    //
+    // Misc Services
+    //
+    EFI_COPY_MEM                    CopyMem;
+    EFI_SET_MEM                     SetMem;
+    EFI_CREATE_EVENT_EX             CreateEventEx;
+} EFI_BOOT_SERVICES;
+
+
+//
+// EFI Configuration Table and GUID definitions
+//
+
+#define MPS_TABLE_GUID    \
+    { 0xeb9d2d2f, 0x2d88, 0x11d3, {0x9a, 0x16, 0x0, 0x90, 0x27, 0x3f, 0xc1, 0x4d} }
+
+#define ACPI_TABLE_GUID    \
+    { 0xeb9d2d30, 0x2d88, 0x11d3, {0x9a, 0x16, 0x0, 0x90, 0x27, 0x3f, 0xc1, 0x4d} }
+
+#define ACPI_20_TABLE_GUID  \
+    { 0x8868e871, 0xe4f1, 0x11d3, {0xbc, 0x22, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81} }
+
+#define SMBIOS_TABLE_GUID    \
+    { 0xeb9d2d31, 0x2d88, 0x11d3, {0x9a, 0x16, 0x0, 0x90, 0x27, 0x3f, 0xc1, 0x4d} }
+
+#define SAL_SYSTEM_TABLE_GUID    \
+    { 0xeb9d2d32, 0x2d88, 0x11d3, {0x9a, 0x16, 0x0, 0x90, 0x27, 0x3f, 0xc1, 0x4d} }
+
+
+typedef struct _EFI_CONFIGURATION_TABLE {
+    EFI_GUID                VendorGuid;
+    VOID                    *VendorTable;
+} EFI_CONFIGURATION_TABLE;
+
+
+//
+// EFI System Table
+//
+
+typedef struct _EFI_SYSTEM_TABLE {
+    EFI_TABLE_HEADER                Hdr;
+
+    CHAR16                          *FirmwareVendor;
+    UINT32                          FirmwareRevision;
+
+    EFI_HANDLE                      ConsoleInHandle;
+    SIMPLE_INPUT_INTERFACE          *ConIn;
+
+    EFI_HANDLE                      ConsoleOutHandle;
+    SIMPLE_TEXT_OUTPUT_INTERFACE    *ConOut;
+
+    EFI_HANDLE                      StandardErrorHandle;
+    SIMPLE_TEXT_OUTPUT_INTERFACE    *StdErr;
+
+    EFI_RUNTIME_SERVICES            *RuntimeServices;
+    EFI_BOOT_SERVICES               *BootServices;
+
+    UINTN                           NumberOfTableEntries;
+    EFI_CONFIGURATION_TABLE         *ConfigurationTable;
+
+} EFI_SYSTEM_TABLE;
+
+#endif
+
diff --git a/linux-x86/gnu-efi/include/efi/eficon.h b/linux-x86/gnu-efi/include/efi/eficon.h
new file mode 100644
index 0000000..089db98
--- /dev/null
+++ b/linux-x86/gnu-efi/include/efi/eficon.h
@@ -0,0 +1,302 @@
+#ifndef _EFI_CON_H
+#define _EFI_CON_H
+
+/*++
+
+Copyright (c) 1998  Intel Corporation
+
+Module Name:
+
+    eficon.h
+
+Abstract:
+
+    EFI console protocols
+
+
+
+Revision History
+
+--*/
+
+//
+// Text output protocol
+//
+
+#define SIMPLE_TEXT_OUTPUT_PROTOCOL \
+    { 0x387477c2, 0x69c7, 0x11d2, {0x8e, 0x39, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b} }
+
+INTERFACE_DECL(_SIMPLE_TEXT_OUTPUT_INTERFACE);
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_TEXT_RESET) (
+    IN struct _SIMPLE_TEXT_OUTPUT_INTERFACE     *This,
+    IN BOOLEAN                      ExtendedVerification
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_TEXT_OUTPUT_STRING) (
+    IN struct _SIMPLE_TEXT_OUTPUT_INTERFACE     *This,
+    IN CHAR16                       *String
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_TEXT_TEST_STRING) (
+    IN struct _SIMPLE_TEXT_OUTPUT_INTERFACE     *This,
+    IN CHAR16                       *String
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_TEXT_QUERY_MODE) (
+    IN struct _SIMPLE_TEXT_OUTPUT_INTERFACE     *This,
+    IN UINTN                        ModeNumber,
+    OUT UINTN                       *Columns,
+    OUT UINTN                       *Rows
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_TEXT_SET_MODE) (
+    IN struct _SIMPLE_TEXT_OUTPUT_INTERFACE     *This,
+    IN UINTN                        ModeNumber
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_TEXT_SET_ATTRIBUTE) (
+    IN struct _SIMPLE_TEXT_OUTPUT_INTERFACE     *This,
+    IN UINTN                        Attribute
+    );
+
+#define EFI_BLACK   0x00
+#define EFI_BLUE    0x01
+#define EFI_GREEN   0x02
+#define EFI_CYAN            (EFI_BLUE | EFI_GREEN)
+#define EFI_RED     0x04
+#define EFI_MAGENTA         (EFI_BLUE | EFI_RED)
+#define EFI_BROWN           (EFI_GREEN | EFI_RED)
+#define EFI_LIGHTGRAY       (EFI_BLUE | EFI_GREEN | EFI_RED)
+#define EFI_BRIGHT  0x08
+#define EFI_DARKGRAY        (EFI_BRIGHT)
+#define EFI_LIGHTBLUE       (EFI_BLUE | EFI_BRIGHT)
+#define EFI_LIGHTGREEN      (EFI_GREEN | EFI_BRIGHT)
+#define EFI_LIGHTCYAN       (EFI_CYAN | EFI_BRIGHT)
+#define EFI_LIGHTRED        (EFI_RED | EFI_BRIGHT)
+#define EFI_LIGHTMAGENTA    (EFI_MAGENTA | EFI_BRIGHT)
+#define EFI_YELLOW          (EFI_BROWN | EFI_BRIGHT)
+#define EFI_WHITE           (EFI_BLUE | EFI_GREEN | EFI_RED | EFI_BRIGHT)
+
+#define EFI_TEXT_ATTR(f,b)  ((f) | ((b) << 4))
+
+#define EFI_BACKGROUND_BLACK        0x00
+#define EFI_BACKGROUND_BLUE         0x10
+#define EFI_BACKGROUND_GREEN        0x20
+#define EFI_BACKGROUND_CYAN         (EFI_BACKGROUND_BLUE | EFI_BACKGROUND_GREEN)
+#define EFI_BACKGROUND_RED          0x40
+#define EFI_BACKGROUND_MAGENTA      (EFI_BACKGROUND_BLUE | EFI_BACKGROUND_RED)
+#define EFI_BACKGROUND_BROWN        (EFI_BACKGROUND_GREEN | EFI_BACKGROUND_RED)
+#define EFI_BACKGROUND_LIGHTGRAY    (EFI_BACKGROUND_BLUE | EFI_BACKGROUND_GREEN | EFI_BACKGROUND_RED)
+
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_TEXT_CLEAR_SCREEN) (
+    IN struct _SIMPLE_TEXT_OUTPUT_INTERFACE     *This
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_TEXT_SET_CURSOR_POSITION) (
+    IN struct _SIMPLE_TEXT_OUTPUT_INTERFACE     *This,
+    IN UINTN                        Column,
+    IN UINTN                        Row
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_TEXT_ENABLE_CURSOR) (
+    IN struct _SIMPLE_TEXT_OUTPUT_INTERFACE     *This,
+    IN BOOLEAN                      Enable
+    );
+
+typedef struct {
+    INT32                           MaxMode;
+    // current settings
+    INT32                           Mode;
+    INT32                           Attribute;
+    INT32                           CursorColumn;
+    INT32                           CursorRow;
+    BOOLEAN                         CursorVisible;
+} SIMPLE_TEXT_OUTPUT_MODE;
+
+typedef struct _SIMPLE_TEXT_OUTPUT_INTERFACE {
+    EFI_TEXT_RESET                  Reset;
+
+    EFI_TEXT_OUTPUT_STRING          OutputString;
+    EFI_TEXT_TEST_STRING            TestString;
+
+    EFI_TEXT_QUERY_MODE             QueryMode;
+    EFI_TEXT_SET_MODE               SetMode;
+    EFI_TEXT_SET_ATTRIBUTE          SetAttribute;
+
+    EFI_TEXT_CLEAR_SCREEN           ClearScreen;
+    EFI_TEXT_SET_CURSOR_POSITION    SetCursorPosition;
+    EFI_TEXT_ENABLE_CURSOR          EnableCursor;
+
+    // Current mode
+    SIMPLE_TEXT_OUTPUT_MODE         *Mode;
+} SIMPLE_TEXT_OUTPUT_INTERFACE;
+
+//
+// Define's for required EFI Unicode Box Draw character
+//
+
+#define BOXDRAW_HORIZONTAL                  0x2500
+#define BOXDRAW_VERTICAL                    0x2502
+#define BOXDRAW_DOWN_RIGHT                  0x250c
+#define BOXDRAW_DOWN_LEFT                   0x2510
+#define BOXDRAW_UP_RIGHT                    0x2514
+#define BOXDRAW_UP_LEFT                     0x2518
+#define BOXDRAW_VERTICAL_RIGHT              0x251c
+#define BOXDRAW_VERTICAL_LEFT               0x2524
+#define BOXDRAW_DOWN_HORIZONTAL             0x252c
+#define BOXDRAW_UP_HORIZONTAL               0x2534
+#define BOXDRAW_VERTICAL_HORIZONTAL         0x253c
+
+#define BOXDRAW_DOUBLE_HORIZONTAL           0x2550
+#define BOXDRAW_DOUBLE_VERTICAL             0x2551
+#define BOXDRAW_DOWN_RIGHT_DOUBLE           0x2552
+#define BOXDRAW_DOWN_DOUBLE_RIGHT           0x2553
+#define BOXDRAW_DOUBLE_DOWN_RIGHT           0x2554
+
+#define BOXDRAW_DOWN_LEFT_DOUBLE            0x2555
+#define BOXDRAW_DOWN_DOUBLE_LEFT            0x2556
+#define BOXDRAW_DOUBLE_DOWN_LEFT            0x2557
+
+#define BOXDRAW_UP_RIGHT_DOUBLE             0x2558
+#define BOXDRAW_UP_DOUBLE_RIGHT             0x2559
+#define BOXDRAW_DOUBLE_UP_RIGHT             0x255a
+
+#define BOXDRAW_UP_LEFT_DOUBLE              0x255b
+#define BOXDRAW_UP_DOUBLE_LEFT              0x255c
+#define BOXDRAW_DOUBLE_UP_LEFT              0x255d
+
+#define BOXDRAW_VERTICAL_RIGHT_DOUBLE       0x255e
+#define BOXDRAW_VERTICAL_DOUBLE_RIGHT       0x255f
+#define BOXDRAW_DOUBLE_VERTICAL_RIGHT       0x2560
+
+#define BOXDRAW_VERTICAL_LEFT_DOUBLE        0x2561
+#define BOXDRAW_VERTICAL_DOUBLE_LEFT        0x2562
+#define BOXDRAW_DOUBLE_VERTICAL_LEFT        0x2563
+
+#define BOXDRAW_DOWN_HORIZONTAL_DOUBLE      0x2564
+#define BOXDRAW_DOWN_DOUBLE_HORIZONTAL      0x2565
+#define BOXDRAW_DOUBLE_DOWN_HORIZONTAL      0x2566
+
+#define BOXDRAW_UP_HORIZONTAL_DOUBLE        0x2567
+#define BOXDRAW_UP_DOUBLE_HORIZONTAL        0x2568
+#define BOXDRAW_DOUBLE_UP_HORIZONTAL        0x2569
+
+#define BOXDRAW_VERTICAL_HORIZONTAL_DOUBLE  0x256a
+#define BOXDRAW_VERTICAL_DOUBLE_HORIZONTAL  0x256b
+#define BOXDRAW_DOUBLE_VERTICAL_HORIZONTAL  0x256c
+
+//
+// EFI Required Block Elements Code Chart
+//
+
+#define BLOCKELEMENT_FULL_BLOCK             0x2588
+#define BLOCKELEMENT_LIGHT_SHADE            0x2591
+//
+// EFI Required Geometric Shapes Code Chart
+//
+
+#define GEOMETRICSHAPE_UP_TRIANGLE           0x25b2
+#define GEOMETRICSHAPE_RIGHT_TRIANGLE        0x25ba
+#define GEOMETRICSHAPE_DOWN_TRIANGLE         0x25bc
+#define GEOMETRICSHAPE_LEFT_TRIANGLE         0x25c4
+
+//
+// EFI Required Arrow shapes
+//
+
+#define ARROW_UP                            0x2191
+#define ARROW_DOWN                          0x2193
+
+//
+// Text input protocol
+//
+
+#define SIMPLE_TEXT_INPUT_PROTOCOL  \
+    { 0x387477c1, 0x69c7, 0x11d2, {0x8e, 0x39, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b} }
+
+INTERFACE_DECL(_SIMPLE_INPUT_INTERFACE);
+
+typedef struct {
+    UINT16                              ScanCode;
+    CHAR16                              UnicodeChar;
+} EFI_INPUT_KEY;
+
+//
+// Baseline unicode control chars
+//
+
+#define CHAR_NULL                       0x0000
+#define CHAR_BACKSPACE                  0x0008
+#define CHAR_TAB                        0x0009
+#define CHAR_LINEFEED                   0x000A
+#define CHAR_CARRIAGE_RETURN            0x000D
+
+//
+// Scan codes for base line keys
+//
+
+#define SCAN_NULL                       0x0000
+#define SCAN_UP                         0x0001
+#define SCAN_DOWN                       0x0002
+#define SCAN_RIGHT                      0x0003
+#define SCAN_LEFT                       0x0004
+#define SCAN_HOME                       0x0005
+#define SCAN_END                        0x0006
+#define SCAN_INSERT                     0x0007
+#define SCAN_DELETE                     0x0008
+#define SCAN_PAGE_UP                    0x0009
+#define SCAN_PAGE_DOWN                  0x000A
+#define SCAN_F1                         0x000B
+#define SCAN_F2                         0x000C
+#define SCAN_F3                         0x000D
+#define SCAN_F4                         0x000E
+#define SCAN_F5                         0x000F
+#define SCAN_F6                         0x0010
+#define SCAN_F7                         0x0011
+#define SCAN_F8                         0x0012
+#define SCAN_F9                         0x0013
+#define SCAN_F10                        0x0014
+#define SCAN_ESC                        0x0017
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_INPUT_RESET) (
+    IN struct _SIMPLE_INPUT_INTERFACE   *This,
+    IN BOOLEAN                          ExtendedVerification
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_INPUT_READ_KEY) (
+    IN struct _SIMPLE_INPUT_INTERFACE   *This,
+    OUT EFI_INPUT_KEY                   *Key
+    );
+
+typedef struct _SIMPLE_INPUT_INTERFACE {
+    EFI_INPUT_RESET                     Reset;
+    EFI_INPUT_READ_KEY                  ReadKeyStroke;
+    EFI_EVENT                           WaitForKey;
+} SIMPLE_INPUT_INTERFACE;
+
+#endif
+
diff --git a/linux-x86/gnu-efi/include/efi/efidebug.h b/linux-x86/gnu-efi/include/efi/efidebug.h
new file mode 100644
index 0000000..f95d492
--- /dev/null
+++ b/linux-x86/gnu-efi/include/efi/efidebug.h
@@ -0,0 +1,110 @@
+#ifndef _EFI_DEBUG_H
+#define _EFI_DEBUG_H
+
+/*++
+
+Copyright (c) 1998  Intel Corporation
+
+Module Name:
+
+    efidebug.h
+
+Abstract:
+
+    EFI library debug functions
+
+
+
+Revision History
+
+--*/
+
+extern UINTN     EFIDebug;
+
+#if EFI_DEBUG
+
+    #define DBGASSERT(a)        DbgAssert(__FILE__, __LINE__, #a)
+    #define DEBUG(a)            DbgPrint a
+    
+#else
+
+    #define DBGASSERT(a)
+    #define DEBUG(a)
+    
+#endif
+
+#if EFI_DEBUG_CLEAR_MEMORY
+
+    #define DBGSETMEM(a,l)      SetMem(a,l,(CHAR8)BAD_POINTER)
+
+#else
+
+    #define DBGSETMEM(a,l)
+
+#endif
+
+#define D_INIT        0x00000001          // Initialization style messages
+#define D_WARN        0x00000002          // Warnings
+#define D_LOAD        0x00000004          // Load events
+#define D_FS          0x00000008          // EFI File system
+#define D_POOL        0x00000010          // Alloc & Free's
+#define D_PAGE        0x00000020          // Alloc & Free's
+#define D_INFO        0x00000040          // Verbose
+#define D_VAR         0x00000100          // Variable
+#define D_PARSE       0x00000200          // Command parsing
+#define D_BM          0x00000400          // Boot manager
+#define D_BLKIO       0x00001000          // BlkIo Driver
+#define D_BLKIO_ULTRA 0x00002000          // BlkIo Driver
+#define D_NET         0x00004000          // SNI Driver
+#define D_NET_ULTRA   0x00008000          // SNI Driver
+#define D_TXTIN       0x00010000          // Simple Input Driver
+#define D_TXTOUT      0x00020000          // Simple Text Output Driver
+#define D_ERROR_ATA	  0x00040000		  		// ATA error messages 
+#define D_ERROR       0x80000000          // Error
+
+#define D_RESERVED    0x7fffC880          // Bits not reserved above
+
+//
+// Current Debug level of the system, value of EFIDebug
+//
+//#define EFI_DBUG_MASK   (D_ERROR | D_WARN | D_LOAD | D_BLKIO | D_INIT)
+#define EFI_DBUG_MASK   (D_ERROR)
+
+//
+//
+//
+
+#if EFI_DEBUG
+
+    #define ASSERT(a)               if(!(a))       DBGASSERT(a)
+    #define ASSERT_LOCKED(l)        if(!(l)->Lock) DBGASSERT(l not locked)
+    #define ASSERT_STRUCT(p,t)      DBGASSERT(t not structure), p
+
+#else
+
+    #define ASSERT(a)               
+    #define ASSERT_LOCKED(l)        
+    #define ASSERT_STRUCT(p,t)      
+
+#endif
+
+//
+// Prototypes
+//
+
+INTN
+DbgAssert (
+    CHAR8   *file,
+    INTN    lineno,
+    CHAR8   *string
+    );
+
+INTN
+DbgPrint (
+    INTN    mask,
+    CHAR8   *format,
+    ...
+    );
+
+#endif
+
diff --git a/linux-x86/gnu-efi/include/efi/efidef.h b/linux-x86/gnu-efi/include/efi/efidef.h
new file mode 100644
index 0000000..07fdf0d
--- /dev/null
+++ b/linux-x86/gnu-efi/include/efi/efidef.h
@@ -0,0 +1,196 @@
+#ifndef _EFI_DEF_H
+#define _EFI_DEF_H
+
+/*++
+
+Copyright (c) 1998  Intel Corporation
+
+Module Name:
+
+    efidef.h
+
+Abstract:
+
+    EFI definitions
+
+
+
+
+Revision History
+
+--*/
+
+typedef UINT16          CHAR16;
+typedef UINT8           CHAR8;
+typedef UINT8           BOOLEAN;
+
+#ifndef TRUE
+    #define TRUE    ((BOOLEAN) 1)
+    #define FALSE   ((BOOLEAN) 0)
+#endif
+
+#ifndef NULL
+    #define NULL    ((VOID *) 0)
+#endif
+
+typedef UINTN           EFI_STATUS;
+typedef UINT64          EFI_LBA;
+typedef UINTN           EFI_TPL;
+typedef VOID            *EFI_HANDLE;
+typedef VOID            *EFI_EVENT;
+
+
+//
+// Prototype argument decoration for EFI parameters to indicate
+// their direction
+//
+// IN - argument is passed into the function
+// OUT - argument (pointer) is returned from the function
+// OPTIONAL - argument is optional
+//
+
+#ifndef IN
+    #define IN
+    #define OUT
+    #define OPTIONAL
+#endif
+
+
+//
+// A GUID
+//
+
+typedef struct {          
+    UINT32  Data1;
+    UINT16  Data2;
+    UINT16  Data3;
+    UINT8   Data4[8]; 
+} EFI_GUID;
+
+
+//
+// Time
+//
+
+typedef struct {          
+    UINT16      Year;       // 1998 - 20XX
+    UINT8       Month;      // 1 - 12
+    UINT8       Day;        // 1 - 31
+    UINT8       Hour;       // 0 - 23
+    UINT8       Minute;     // 0 - 59
+    UINT8       Second;     // 0 - 59
+    UINT8       Pad1;
+    UINT32      Nanosecond; // 0 - 999,999,999
+    INT16       TimeZone;   // -1440 to 1440 or 2047
+    UINT8       Daylight;
+    UINT8       Pad2;
+} EFI_TIME;
+
+// Bit definitions for EFI_TIME.Daylight
+#define EFI_TIME_ADJUST_DAYLIGHT    0x01
+#define EFI_TIME_IN_DAYLIGHT        0x02
+
+// Value definition for EFI_TIME.TimeZone
+#define EFI_UNSPECIFIED_TIMEZONE    0x07FF
+
+
+
+//
+// Networking
+//
+
+typedef struct {
+    UINT8                   Addr[4];
+} EFI_IPv4_ADDRESS;
+
+typedef struct {
+    UINT8                   Addr[16];
+} EFI_IPv6_ADDRESS;
+
+typedef struct {
+    UINT8                   Addr[32];
+} EFI_MAC_ADDRESS;
+
+//
+// Memory
+//
+
+typedef UINT64          EFI_PHYSICAL_ADDRESS;
+typedef UINT64          EFI_VIRTUAL_ADDRESS;
+
+typedef enum {
+    AllocateAnyPages,
+    AllocateMaxAddress,
+    AllocateAddress,
+    MaxAllocateType
+} EFI_ALLOCATE_TYPE;
+
+//Preseve the attr on any range supplied.
+//ConventialMemory must have WB,SR,SW when supplied.
+//When allocating from ConventialMemory always make it WB,SR,SW
+//When returning to ConventialMemory always make it WB,SR,SW
+//When getting the memory map, or on RT for runtime types
+
+
+typedef enum {
+    EfiReservedMemoryType,
+    EfiLoaderCode,
+    EfiLoaderData,
+    EfiBootServicesCode,
+    EfiBootServicesData,
+    EfiRuntimeServicesCode,
+    EfiRuntimeServicesData,
+    EfiConventionalMemory,
+    EfiUnusableMemory,
+    EfiACPIReclaimMemory,
+    EfiACPIMemoryNVS,
+    EfiMemoryMappedIO,
+    EfiMemoryMappedIOPortSpace,
+    EfiPalCode,
+    EfiMaxMemoryType
+} EFI_MEMORY_TYPE;
+
+// possible caching types for the memory range
+#define EFI_MEMORY_UC           0x0000000000000001
+#define EFI_MEMORY_WC           0x0000000000000002
+#define EFI_MEMORY_WT           0x0000000000000004
+#define EFI_MEMORY_WB           0x0000000000000008
+#define EFI_MEMORY_UCE          0x0000000000000010  
+
+// physical memory protection on range 
+#define EFI_MEMORY_WP           0x0000000000001000
+#define EFI_MEMORY_RP           0x0000000000002000
+#define EFI_MEMORY_XP           0x0000000000004000
+
+// range requires a runtime mapping
+#define EFI_MEMORY_RUNTIME      0x8000000000000000
+
+#define EFI_MEMORY_DESCRIPTOR_VERSION  1
+typedef struct {
+    UINT32                          Type;           // Field size is 32 bits followed by 32 bit pad
+    UINT32                          Pad;
+    EFI_PHYSICAL_ADDRESS            PhysicalStart;  // Field size is 64 bits
+    EFI_VIRTUAL_ADDRESS             VirtualStart;   // Field size is 64 bits
+    UINT64                          NumberOfPages;  // Field size is 64 bits
+    UINT64                          Attribute;      // Field size is 64 bits
+} EFI_MEMORY_DESCRIPTOR;
+
+//
+// International Language
+//
+
+typedef UINT8   ISO_639_2;
+#define ISO_639_2_ENTRY_SIZE    3
+
+//
+//
+//
+
+#define EFI_PAGE_SIZE   4096
+#define EFI_PAGE_MASK   0xFFF
+#define EFI_PAGE_SHIFT  12
+
+#define EFI_SIZE_TO_PAGES(a)  \
+    ( ((a) >> EFI_PAGE_SHIFT) + ((a) & EFI_PAGE_MASK ? 1 : 0) )
+
+#endif
diff --git a/linux-x86/gnu-efi/include/efi/efidevp.h b/linux-x86/gnu-efi/include/efi/efidevp.h
new file mode 100644
index 0000000..beb5785
--- /dev/null
+++ b/linux-x86/gnu-efi/include/efi/efidevp.h
@@ -0,0 +1,402 @@
+#ifndef _DEVPATH_H
+#define _DEVPATH_H
+
+/*++
+
+Copyright (c) 1998  Intel Corporation
+
+Module Name:
+
+    devpath.h
+
+Abstract:
+
+    Defines for parsing the EFI Device Path structures
+
+
+
+Revision History
+
+--*/
+
+//
+// Device Path structures - Section C
+//
+
+typedef struct _EFI_DEVICE_PATH {
+        UINT8                           Type;
+        UINT8                           SubType;
+        UINT8                           Length[2];
+} EFI_DEVICE_PATH;
+
+#define EFI_DP_TYPE_MASK                    0x7F
+#define EFI_DP_TYPE_UNPACKED                0x80
+
+//#define END_DEVICE_PATH_TYPE                0xff
+#define END_DEVICE_PATH_TYPE                0x7f
+//#define END_DEVICE_PATH_TYPE_UNPACKED       0x7f
+
+#define END_ENTIRE_DEVICE_PATH_SUBTYPE      0xff
+#define END_INSTANCE_DEVICE_PATH_SUBTYPE    0x01
+#define END_DEVICE_PATH_LENGTH              (sizeof(EFI_DEVICE_PATH))
+
+
+#define DP_IS_END_TYPE(a)
+#define DP_IS_END_SUBTYPE(a)        ( ((a)->SubType == END_ENTIRE_DEVICE_PATH_SUBTYPE )
+
+#define DevicePathType(a)           ( ((a)->Type) & EFI_DP_TYPE_MASK )
+#define DevicePathSubType(a)        ( (a)->SubType )
+#define DevicePathNodeLength(a)     ( ((a)->Length[0]) | ((a)->Length[1] << 8) )
+#define NextDevicePathNode(a)       ( (EFI_DEVICE_PATH *) ( ((UINT8 *) (a)) + DevicePathNodeLength(a)))
+//#define IsDevicePathEndType(a)      ( DevicePathType(a) == END_DEVICE_PATH_TYPE_UNPACKED )
+#define IsDevicePathEndType(a)      ( DevicePathType(a) == END_DEVICE_PATH_TYPE )
+#define IsDevicePathEndSubType(a)   ( (a)->SubType == END_ENTIRE_DEVICE_PATH_SUBTYPE )
+#define IsDevicePathEnd(a)          ( IsDevicePathEndType(a) && IsDevicePathEndSubType(a) )
+#define IsDevicePathUnpacked(a)     ( (a)->Type & EFI_DP_TYPE_UNPACKED )
+
+
+#define SetDevicePathNodeLength(a,l) {                  \
+            (a)->Length[0] = (UINT8) (l);               \
+            (a)->Length[1] = (UINT8) ((l) >> 8);        \
+            }
+
+#define SetDevicePathEndNode(a)  {                      \
+            (a)->Type = END_DEVICE_PATH_TYPE;           \
+            (a)->SubType = END_ENTIRE_DEVICE_PATH_SUBTYPE;     \
+            (a)->Length[0] = sizeof(EFI_DEVICE_PATH);   \
+            (a)->Length[1] = 0;                         \
+            }
+
+
+
+/*
+ *
+ */
+#define HARDWARE_DEVICE_PATH            0x01
+
+#define HW_PCI_DP                       0x01
+typedef struct _PCI_DEVICE_PATH {
+        EFI_DEVICE_PATH                 Header;
+        UINT8                           Function;
+        UINT8                           Device;
+} PCI_DEVICE_PATH;
+
+#define HW_PCCARD_DP                    0x02
+typedef struct _PCCARD_DEVICE_PATH {
+        EFI_DEVICE_PATH                 Header;
+        UINT8                           SocketNumber;
+} PCCARD_DEVICE_PATH;
+
+#define HW_MEMMAP_DP                    0x03
+typedef struct _MEMMAP_DEVICE_PATH {
+        EFI_DEVICE_PATH                 Header;
+        UINT32                          MemoryType;
+        EFI_PHYSICAL_ADDRESS            StartingAddress;
+        EFI_PHYSICAL_ADDRESS            EndingAddress;
+} MEMMAP_DEVICE_PATH;
+
+#define HW_VENDOR_DP                    0x04
+typedef struct _VENDOR_DEVICE_PATH {
+        EFI_DEVICE_PATH                 Header;
+        EFI_GUID                        Guid;
+} VENDOR_DEVICE_PATH;
+
+#define UNKNOWN_DEVICE_GUID \
+    { 0xcf31fac5, 0xc24e, 0x11d2,  {0x85, 0xf3, 0x0, 0xa0, 0xc9, 0x3e, 0xc9, 0x3b}  }
+
+typedef struct _UKNOWN_DEVICE_VENDOR_DP {
+    VENDOR_DEVICE_PATH      DevicePath;
+    UINT8                   LegacyDriveLetter;
+} UNKNOWN_DEVICE_VENDOR_DEVICE_PATH;
+
+#define HW_CONTROLLER_DP            0x05
+typedef struct _CONTROLLER_DEVICE_PATH {
+        EFI_DEVICE_PATH     Header;
+        UINT32              Controller;
+} CONTROLLER_DEVICE_PATH;
+
+/*
+ *
+ */
+#define ACPI_DEVICE_PATH                 0x02
+
+#define ACPI_DP                         0x01
+typedef struct _ACPI_HID_DEVICE_PATH {
+        EFI_DEVICE_PATH                 Header;
+        UINT32                          HID;
+        UINT32                          UID;
+} ACPI_HID_DEVICE_PATH;
+
+#define EXPANDED_ACPI_DP		0x02
+typedef struct _EXPANDED_ACPI_HID_DEVICE_PATH {
+	EFI_DEVICE_PATH			Header;
+	UINT32				HID;
+	UINT32				UID;
+	UINT32				CID;
+	UINT8				HidStr[1];
+} EXPANDED_ACPI_HID_DEVICE_PATH;
+
+//
+// EISA ID Macro
+// EISA ID Definition 32-bits
+//  bits[15:0] - three character compressed ASCII EISA ID.
+//  bits[31:16] - binary number
+//   Compressed ASCII is 5 bits per character 0b00001 = 'A' 0b11010 = 'Z'
+//
+#define PNP_EISA_ID_CONST       0x41d0    
+#define EISA_ID(_Name, _Num)    ((UINT32) ((_Name) | (_Num) << 16))   
+#define EISA_PNP_ID(_PNPId)     (EISA_ID(PNP_EISA_ID_CONST, (_PNPId)))
+
+#define PNP_EISA_ID_MASK        0xffff
+#define EISA_ID_TO_NUM(_Id)     ((_Id) >> 16)
+/*
+ *
+ */
+#define MESSAGING_DEVICE_PATH           0x03 
+
+#define MSG_ATAPI_DP                    0x01
+typedef struct _ATAPI_DEVICE_PATH {
+        EFI_DEVICE_PATH                 Header;
+        UINT8                           PrimarySecondary;
+        UINT8                           SlaveMaster;
+        UINT16                          Lun;
+} ATAPI_DEVICE_PATH;
+
+#define MSG_SCSI_DP                     0x02
+typedef struct _SCSI_DEVICE_PATH {
+        EFI_DEVICE_PATH                 Header;
+        UINT16                          Pun;
+        UINT16                          Lun; 
+} SCSI_DEVICE_PATH;
+
+#define MSG_FIBRECHANNEL_DP             0x03
+typedef struct _FIBRECHANNEL_DEVICE_PATH {
+        EFI_DEVICE_PATH                 Header;
+        UINT32                          Reserved;
+        UINT64                          WWN;
+        UINT64                          Lun;
+} FIBRECHANNEL_DEVICE_PATH;
+
+#define MSG_1394_DP                     0x04
+typedef struct _F1394_DEVICE_PATH {
+        EFI_DEVICE_PATH                 Header;
+        UINT32                          Reserved;
+        UINT64                          Guid;
+} F1394_DEVICE_PATH;
+
+#define MSG_USB_DP                      0x05
+typedef struct _USB_DEVICE_PATH {
+        EFI_DEVICE_PATH                 Header;
+        UINT8                           Port;
+        UINT8                           Endpoint;
+} USB_DEVICE_PATH;
+
+#define MSG_USB_CLASS_DP                0x0F
+typedef struct _USB_CLASS_DEVICE_PATH {
+        EFI_DEVICE_PATH                 Header;
+        UINT16                          VendorId;
+        UINT16                          ProductId;
+        UINT8                           DeviceClass;
+        UINT8                           DeviceSubclass;
+        UINT8                           DeviceProtocol;
+} USB_CLASS_DEVICE_PATH;
+
+#define MSG_I2O_DP                      0x06
+typedef struct _I2O_DEVICE_PATH {
+        EFI_DEVICE_PATH                 Header;
+        UINT32                          Tid;
+} I2O_DEVICE_PATH;
+
+#define MSG_MAC_ADDR_DP                 0x0b
+typedef struct _MAC_ADDR_DEVICE_PATH {
+        EFI_DEVICE_PATH                 Header;
+        EFI_MAC_ADDRESS                 MacAddress;
+        UINT8                           IfType;
+} MAC_ADDR_DEVICE_PATH;
+
+#define MSG_IPv4_DP                     0x0c
+typedef struct _IPv4_DEVICE_PATH {
+        EFI_DEVICE_PATH                 Header;
+        EFI_IPv4_ADDRESS                LocalIpAddress;
+        EFI_IPv4_ADDRESS                RemoteIpAddress;
+        UINT16                          LocalPort;
+        UINT16                          RemotePort;
+        UINT16                          Protocol;
+        BOOLEAN                         StaticIpAddress;
+} IPv4_DEVICE_PATH;
+
+#define MSG_IPv6_DP                     0x0d
+typedef struct _IPv6_DEVICE_PATH {
+        EFI_DEVICE_PATH                 Header;
+        EFI_IPv6_ADDRESS                LocalIpAddress;
+        EFI_IPv6_ADDRESS                RemoteIpAddress;
+        UINT16                          LocalPort;
+        UINT16                          RemotePort;
+        UINT16                          Protocol;
+        BOOLEAN                         StaticIpAddress;
+} IPv6_DEVICE_PATH;
+
+#define MSG_INFINIBAND_DP               0x09
+typedef struct _INFINIBAND_DEVICE_PATH {
+        EFI_DEVICE_PATH                 Header;
+        UINT32                          Reserved;
+        UINT64                          NodeGuid;
+        UINT64                          IocGuid;
+        UINT64                          DeviceId;
+} INFINIBAND_DEVICE_PATH;
+
+#define MSG_UART_DP                     0x0e
+typedef struct _UART_DEVICE_PATH {
+        EFI_DEVICE_PATH                 Header;
+        UINT32                          Reserved;
+        UINT64                          BaudRate;
+        UINT8                           DataBits;
+        UINT8                           Parity;
+        UINT8                           StopBits;
+} UART_DEVICE_PATH;
+
+#define MSG_VENDOR_DP                   0x0A
+/* Use VENDOR_DEVICE_PATH struct */
+
+#define DEVICE_PATH_MESSAGING_PC_ANSI \
+    { 0xe0c14753, 0xf9be, 0x11d2,  {0x9a, 0x0c, 0x00, 0x90, 0x27, 0x3f, 0xc1, 0x4d}  }
+
+#define DEVICE_PATH_MESSAGING_VT_100 \
+    { 0xdfa66065, 0xb419, 0x11d3,  {0x9a, 0x2d, 0x00, 0x90, 0x27, 0x3f, 0xc1, 0x4d}  }
+
+
+
+#define MEDIA_DEVICE_PATH               0x04
+
+#define MEDIA_HARDDRIVE_DP              0x01
+typedef struct _HARDDRIVE_DEVICE_PATH {
+        EFI_DEVICE_PATH                 Header;
+        UINT32                          PartitionNumber;
+        UINT64                          PartitionStart;
+        UINT64                          PartitionSize;
+        UINT8                           Signature[16];
+        UINT8                           MBRType;
+        UINT8                           SignatureType;
+} HARDDRIVE_DEVICE_PATH;
+
+#define MBR_TYPE_PCAT                       0x01
+#define MBR_TYPE_EFI_PARTITION_TABLE_HEADER 0x02
+
+#define SIGNATURE_TYPE_MBR                  0x01
+#define SIGNATURE_TYPE_GUID                 0x02
+
+#define MEDIA_CDROM_DP                  0x02
+typedef struct _CDROM_DEVICE_PATH {
+        EFI_DEVICE_PATH                 Header;
+        UINT32                          BootEntry;
+        UINT64                          PartitionStart;
+        UINT64                          PartitionSize;
+} CDROM_DEVICE_PATH;
+
+#define MEDIA_VENDOR_DP                 0x03
+/* Use VENDOR_DEVICE_PATH struct */
+
+#define MEDIA_FILEPATH_DP               0x04
+typedef struct _FILEPATH_DEVICE_PATH {
+        EFI_DEVICE_PATH                 Header;
+        CHAR16                          PathName[1];
+} FILEPATH_DEVICE_PATH;
+
+#define SIZE_OF_FILEPATH_DEVICE_PATH EFI_FIELD_OFFSET(FILEPATH_DEVICE_PATH,PathName)
+
+#define MEDIA_PROTOCOL_DP               0x05
+typedef struct _MEDIA_PROTOCOL_DEVICE_PATH {
+        EFI_DEVICE_PATH                 Header;
+        EFI_GUID                        Protocol;
+} MEDIA_PROTOCOL_DEVICE_PATH;
+
+
+#define BBS_DEVICE_PATH                 0x05
+#define BBS_BBS_DP                      0x01
+typedef struct _BBS_BBS_DEVICE_PATH {
+        EFI_DEVICE_PATH                 Header;
+        UINT16                          DeviceType;
+        UINT16                          StatusFlag;
+        CHAR8                           String[1];
+} BBS_BBS_DEVICE_PATH;
+
+/* DeviceType definitions - from BBS specification */
+#define BBS_TYPE_FLOPPY                 0x01
+#define BBS_TYPE_HARDDRIVE              0x02
+#define BBS_TYPE_CDROM                  0x03
+#define BBS_TYPE_PCMCIA                 0x04
+#define BBS_TYPE_USB                    0x05
+#define BBS_TYPE_EMBEDDED_NETWORK       0x06
+#define BBS_TYPE_DEV                    0x80
+#define BBS_TYPE_UNKNOWN                0xFF
+
+typedef union {
+    EFI_DEVICE_PATH                      DevPath;
+    PCI_DEVICE_PATH                      Pci;
+    PCCARD_DEVICE_PATH                   PcCard;
+    MEMMAP_DEVICE_PATH                   MemMap;
+    VENDOR_DEVICE_PATH                   Vendor;
+    UNKNOWN_DEVICE_VENDOR_DEVICE_PATH    UnknownVendor;   
+    CONTROLLER_DEVICE_PATH               Controller;
+    ACPI_HID_DEVICE_PATH                 Acpi;
+
+    ATAPI_DEVICE_PATH                    Atapi;
+    SCSI_DEVICE_PATH                     Scsi;
+    FIBRECHANNEL_DEVICE_PATH             FibreChannel;
+
+    F1394_DEVICE_PATH                    F1394;
+    USB_DEVICE_PATH                      Usb;
+    USB_CLASS_DEVICE_PATH                UsbClass;
+    I2O_DEVICE_PATH                      I2O;
+    MAC_ADDR_DEVICE_PATH                 MacAddr;
+    IPv4_DEVICE_PATH                     Ipv4;
+    IPv6_DEVICE_PATH                     Ipv6;
+    INFINIBAND_DEVICE_PATH               InfiniBand;
+    UART_DEVICE_PATH                     Uart;
+
+    HARDDRIVE_DEVICE_PATH                HardDrive;
+    CDROM_DEVICE_PATH                    CD;
+
+    FILEPATH_DEVICE_PATH                 FilePath;
+    MEDIA_PROTOCOL_DEVICE_PATH           MediaProtocol;
+
+    BBS_BBS_DEVICE_PATH                  Bbs;
+
+} EFI_DEV_PATH;
+
+typedef union {
+    EFI_DEVICE_PATH                      *DevPath;
+    PCI_DEVICE_PATH                      *Pci;
+    PCCARD_DEVICE_PATH                   *PcCard;
+    MEMMAP_DEVICE_PATH                   *MemMap;
+    VENDOR_DEVICE_PATH                   *Vendor;
+    UNKNOWN_DEVICE_VENDOR_DEVICE_PATH    *UnknownVendor;   
+    CONTROLLER_DEVICE_PATH               *Controller;
+    ACPI_HID_DEVICE_PATH                 *Acpi;
+
+    ATAPI_DEVICE_PATH                    *Atapi;
+    SCSI_DEVICE_PATH                     *Scsi;
+    FIBRECHANNEL_DEVICE_PATH             *FibreChannel;
+
+    F1394_DEVICE_PATH                    *F1394;
+    USB_DEVICE_PATH                      *Usb;
+    USB_CLASS_DEVICE_PATH                *UsbClass;
+    I2O_DEVICE_PATH                      *I2O;
+    MAC_ADDR_DEVICE_PATH                 *MacAddr;
+    IPv4_DEVICE_PATH                     *Ipv4;
+    IPv6_DEVICE_PATH                     *Ipv6;
+    INFINIBAND_DEVICE_PATH               *InfiniBand;
+    UART_DEVICE_PATH                     *Uart;
+
+    HARDDRIVE_DEVICE_PATH                *HardDrive;
+
+    FILEPATH_DEVICE_PATH                 *FilePath;
+    MEDIA_PROTOCOL_DEVICE_PATH           *MediaProtocol;
+
+    CDROM_DEVICE_PATH                    *CD;
+    BBS_BBS_DEVICE_PATH                  *Bbs;
+
+} EFI_DEV_PATH_PTR;
+
+
+#endif
diff --git a/linux-x86/gnu-efi/include/efi/efierr.h b/linux-x86/gnu-efi/include/efi/efierr.h
new file mode 100644
index 0000000..669d7ba
--- /dev/null
+++ b/linux-x86/gnu-efi/include/efi/efierr.h
@@ -0,0 +1,60 @@
+#ifndef _EFI_ERR_H
+#define _EFI_ERR_H
+
+/*++
+
+Copyright (c) 1998  Intel Corporation
+
+Module Name:
+
+    efierr.h
+
+Abstract:
+
+    EFI error codes
+
+
+
+
+Revision History
+
+--*/
+
+
+#define EFIWARN(a)                            (a)
+#define EFI_ERROR(a)              (((INTN) a) < 0)
+
+
+#define EFI_SUCCESS                             0
+#define EFI_LOAD_ERROR                  EFIERR(1)
+#define EFI_INVALID_PARAMETER           EFIERR(2)
+#define EFI_UNSUPPORTED                 EFIERR(3)
+#define EFI_BAD_BUFFER_SIZE             EFIERR(4)
+#define EFI_BUFFER_TOO_SMALL            EFIERR(5)
+#define EFI_NOT_READY                   EFIERR(6)
+#define EFI_DEVICE_ERROR                EFIERR(7)
+#define EFI_WRITE_PROTECTED             EFIERR(8)
+#define EFI_OUT_OF_RESOURCES            EFIERR(9)
+#define EFI_VOLUME_CORRUPTED            EFIERR(10)
+#define EFI_VOLUME_FULL                 EFIERR(11)
+#define EFI_NO_MEDIA                    EFIERR(12)
+#define EFI_MEDIA_CHANGED               EFIERR(13)
+#define EFI_NOT_FOUND                   EFIERR(14)
+#define EFI_ACCESS_DENIED               EFIERR(15)
+#define EFI_NO_RESPONSE                 EFIERR(16)
+#define EFI_NO_MAPPING                  EFIERR(17)
+#define EFI_TIMEOUT                     EFIERR(18)
+#define EFI_NOT_STARTED                 EFIERR(19)
+#define EFI_ALREADY_STARTED             EFIERR(20)
+#define EFI_ABORTED                     EFIERR(21)
+#define EFI_ICMP_ERROR                  EFIERR(22)
+#define EFI_TFTP_ERROR                  EFIERR(23)
+#define EFI_PROTOCOL_ERROR              EFIERR(24)
+
+#define EFI_WARN_UNKOWN_GLYPH           EFIWARN(1)
+#define EFI_WARN_DELETE_FAILURE         EFIWARN(2)
+#define EFI_WARN_WRITE_FAILURE          EFIWARN(3)
+#define EFI_WARN_BUFFER_TOO_SMALL       EFIWARN(4)
+
+#endif
+
diff --git a/linux-x86/gnu-efi/include/efi/efifs.h b/linux-x86/gnu-efi/include/efi/efifs.h
new file mode 100644
index 0000000..fc595d1
--- /dev/null
+++ b/linux-x86/gnu-efi/include/efi/efifs.h
@@ -0,0 +1,116 @@
+#ifndef _EFI_FS_H
+#define _EFI_FS_H
+
+/*++
+
+Copyright (c) 1998  Intel Corporation
+
+Module Name:
+
+    efifs.h
+
+Abstract:
+
+    EFI File System structures
+
+
+
+Revision History
+
+--*/
+
+
+//
+// EFI Partition header (normaly starts in LBA 1)
+//
+
+#define EFI_PARTITION_SIGNATURE         0x5053595320494249
+#define EFI_PARTITION_REVISION          0x00010001
+#define MIN_EFI_PARTITION_BLOCK_SIZE    512
+#define EFI_PARTITION_LBA               1
+
+typedef struct _EFI_PARTITION_HEADER {
+    EFI_TABLE_HEADER    Hdr;
+    UINT32              DirectoryAllocationNumber;
+    UINT32              BlockSize;
+    EFI_LBA             FirstUsableLba;
+    EFI_LBA             LastUsableLba;
+    EFI_LBA             UnusableSpace;
+    EFI_LBA             FreeSpace;
+    EFI_LBA             RootFile;
+    EFI_LBA             SecutiryFile;
+} EFI_PARTITION_HEADER;
+
+
+//
+// File header
+//
+
+#define EFI_FILE_HEADER_SIGNATURE   0x454c494620494249
+#define EFI_FILE_HEADER_REVISION    0x00010000
+#define EFI_FILE_STRING_SIZE        260
+
+typedef struct _EFI_FILE_HEADER {
+    EFI_TABLE_HEADER    Hdr;
+    UINT32              Class;
+    UINT32              LBALOffset;
+    EFI_LBA             Parent;
+    UINT64              FileSize;
+    UINT64              FileAttributes;
+    EFI_TIME            FileCreateTime;
+    EFI_TIME            FileModificationTime;
+    EFI_GUID            VendorGuid;
+    CHAR16              FileString[EFI_FILE_STRING_SIZE];
+} EFI_FILE_HEADER;
+
+
+//
+// Return the file's first LBAL which is in the same
+// logical block as the file header
+//
+
+#define EFI_FILE_LBAL(a)    ((EFI_LBAL *) (((CHAR8 *) (a)) + (a)->LBALOffset))
+
+#define EFI_FILE_CLASS_FREE_SPACE   1
+#define EFI_FILE_CLASS_EMPTY        2
+#define EFI_FILE_CLASS_NORMAL       3
+
+
+//
+// Logical Block Address List - the fundemental block
+// description structure
+//
+
+#define EFI_LBAL_SIGNATURE      0x4c41424c20494249
+#define EFI_LBAL_REVISION       0x00010000
+
+typedef struct _EFI_LBAL {
+    EFI_TABLE_HEADER    Hdr;
+    UINT32              Class;
+    EFI_LBA             Parent;
+    EFI_LBA             Next;
+    UINT32              ArraySize;
+    UINT32              ArrayCount;
+} EFI_LBAL;
+
+// Array size 
+#define EFI_LBAL_ARRAY_SIZE(lbal,offs,blks)  \
+        (((blks) - (offs) - (lbal)->Hdr.HeaderSize) / sizeof(EFI_RL))
+
+//
+// Logical Block run-length
+//
+
+typedef struct {
+    EFI_LBA     Start;
+    UINT64      Length;
+} EFI_RL;
+
+//
+// Return the run-length structure from an LBAL header
+//
+
+#define EFI_LBAL_RL(a)      ((EFI_RL*) (((CHAR8 *) (a)) + (a)->Hdr.HeaderSize))
+
+#endif
+
diff --git a/linux-x86/gnu-efi/include/efi/efigpt.h b/linux-x86/gnu-efi/include/efi/efigpt.h
new file mode 100644
index 0000000..d1694ae
--- /dev/null
+++ b/linux-x86/gnu-efi/include/efi/efigpt.h
@@ -0,0 +1,68 @@
+#ifndef _EFI_GPT_H
+#define _EFI_GPT_H
+/*++
+
+Copyright (c) 1998  Intel Corporation
+
+Module Name:
+
+    EfiGpt.h
+    
+Abstract:
+    Include file for EFI partitioning scheme
+
+
+
+Revision History
+
+--*/
+
+#define PRIMARY_PART_HEADER_LBA         1
+
+typedef struct {
+    EFI_TABLE_HEADER    Header;
+    EFI_LBA             MyLBA;
+    EFI_LBA             AlternateLBA;
+    EFI_LBA             FirstUsableLBA;
+    EFI_LBA             LastUsableLBA;
+    EFI_GUID            DiskGUID;
+    EFI_LBA             PartitionEntryLBA;
+    UINT32              NumberOfPartitionEntries;
+    UINT32              SizeOfPartitionEntry;
+    UINT32              PartitionEntryArrayCRC32;
+} EFI_PARTITION_TABLE_HEADER;
+
+#define EFI_PTAB_HEADER_ID  "EFI PART"
+
+typedef struct {
+    EFI_GUID    PartitionTypeGUID;
+    EFI_GUID    UniquePartitionGUID;
+    EFI_LBA     StartingLBA;
+    EFI_LBA     EndingLBA;
+    UINT64      Attributes;
+    CHAR16      PartitionName[36];
+} EFI_PARTITION_ENTRY;
+
+//
+// EFI Partition Attributes
+//
+#define EFI_PART_USED_BY_EFI            0x0000000000000001
+#define EFI_PART_REQUIRED_TO_FUNCTION   0x0000000000000002
+#define EFI_PART_USED_BY_OS             0x0000000000000004
+#define EFI_PART_REQUIRED_BY_OS         0x0000000000000008
+#define EFI_PART_BACKUP_REQUIRED        0x0000000000000010
+#define EFI_PART_USER_DATA              0x0000000000000020
+#define EFI_PART_CRITICAL_USER_DATA     0x0000000000000040
+#define EFI_PART_REDUNDANT_PARTITION    0x0000000000000080
+
+#define EFI_PART_TYPE_UNUSED_GUID   \
+    { 0x00000000, 0x0000, 0x0000, {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00} }
+    
+#define EFI_PART_TYPE_EFI_SYSTEM_PART_GUID  \
+    { 0xc12a7328, 0xf81f, 0x11d2, {0xba, 0x4b, 0x00, 0xa0, 0xc9, 0x3e, 0xc9, 0x3b} }
+
+#define EFI_PART_TYPE_LEGACY_MBR_GUID   \
+    { 0x024dee41, 0x33e7, 0x11d3, {0x9d, 0x69, 0x00, 0x08, 0xc7, 0x81, 0xf3, 0x9f} }
+
+#endif
+
diff --git a/linux-x86/gnu-efi/include/efi/efilib.h b/linux-x86/gnu-efi/include/efi/efilib.h
new file mode 100644
index 0000000..740c2ff
--- /dev/null
+++ b/linux-x86/gnu-efi/include/efi/efilib.h
@@ -0,0 +1,880 @@
+#ifndef _EFILIB_INCLUDE_
+#define _EFILIB_INCLUDE_
+
+/*++
+
+Copyright (c) 2000  Intel Corporation
+
+Module Name:
+
+    efilib.h
+
+Abstract:
+
+    EFI library functions
+
+
+
+Revision History
+
+--*/
+
+#include "efidebug.h"
+#include "efipart.h"
+#include "efilibplat.h"
+#include "efilink.h"
+#include "efirtlib.h"
+#include "pci22.h"
+#include "libsmbios.h"
+
+//
+// Public read-only data in the EFI library
+//
+
+extern EFI_SYSTEM_TABLE         *ST;
+extern EFI_BOOT_SERVICES        *BS;
+extern EFI_RUNTIME_SERVICES     *RT;
+
+extern EFI_GUID DevicePathProtocol;
+extern EFI_GUID LoadedImageProtocol;
+extern EFI_GUID TextInProtocol;
+extern EFI_GUID TextOutProtocol;
+extern EFI_GUID BlockIoProtocol;
+extern EFI_GUID DiskIoProtocol;
+extern EFI_GUID FileSystemProtocol;
+extern EFI_GUID LoadFileProtocol;
+extern EFI_GUID DeviceIoProtocol;
+extern EFI_GUID VariableStoreProtocol;
+extern EFI_GUID LegacyBootProtocol;
+extern EFI_GUID UnicodeCollationProtocol;
+extern EFI_GUID SerialIoProtocol;
+extern EFI_GUID VgaClassProtocol;
+extern EFI_GUID TextOutSpliterProtocol;
+extern EFI_GUID ErrorOutSpliterProtocol;
+extern EFI_GUID TextInSpliterProtocol;
+extern EFI_GUID SimpleNetworkProtocol;
+extern EFI_GUID PxeBaseCodeProtocol;
+extern EFI_GUID PxeCallbackProtocol;
+extern EFI_GUID NetworkInterfaceIdentifierProtocol;
+extern EFI_GUID UiProtocol;
+extern EFI_GUID InternalShellProtocol;
+extern EFI_GUID PciIoProtocol;
+
+extern EFI_GUID EfiGlobalVariable;
+extern EFI_GUID GenericFileInfo;
+extern EFI_GUID FileSystemInfo;
+extern EFI_GUID FileSystemVolumeLabelInfo;
+extern EFI_GUID PcAnsiProtocol;
+extern EFI_GUID Vt100Protocol;
+extern EFI_GUID NullGuid;
+extern EFI_GUID UnknownDevice;
+
+extern EFI_GUID EfiPartTypeSystemPartitionGuid;
+extern EFI_GUID EfiPartTypeLegacyMbrGuid;
+
+extern EFI_GUID MpsTableGuid;
+extern EFI_GUID AcpiTableGuid;
+extern EFI_GUID SMBIOSTableGuid;
+extern EFI_GUID SalSystemTableGuid;
+
+//
+// EFI Variable strings
+//
+#define LOAD_OPTION_ACTIVE      0x00000001
+
+#define VarLanguageCodes       L"LangCodes"
+#define VarLanguage            L"Lang"
+#define VarTimeout             L"Timeout"
+#define VarConsoleInp          L"ConIn"
+#define VarConsoleOut          L"ConOut"
+#define VarErrorOut            L"ErrOut"
+#define VarBootOption          L"Boot%04x"
+#define VarBootOrder           L"BootOrder"
+#define VarBootNext            L"BootNext"
+#define VarBootCurrent         L"BootCurrent"
+#define VarDriverOption        L"Driver%04x"
+#define VarDriverOrder         L"DriverOrder"
+#define VarConsoleInpDev       L"ConInDev"
+#define VarConsoleOutDev       L"ConOutDev"
+#define VarErrorOutDev         L"ErrOutDev"
+
+#define LanguageCodeEnglish    "eng"
+
+extern EFI_DEVICE_PATH RootDevicePath[];
+extern EFI_DEVICE_PATH EndDevicePath[];
+extern EFI_DEVICE_PATH EndInstanceDevicePath[];
+
+//
+// Other public data in the EFI library
+//
+
+extern EFI_MEMORY_TYPE PoolAllocationType;
+
+//
+// STATIC - Name is internal to the module
+// INTERNAL - Name is internal to the component (i.e., directory)
+// BOOTSERVCE - Name of a boot service function
+//
+
+#define STATIC
+#define INTERNAL
+#define BOOTSERVICE
+
+//
+// Prototypes
+//
+
+VOID
+InitializeLib (
+    IN EFI_HANDLE           ImageHandle,
+    IN EFI_SYSTEM_TABLE     *SystemTable
+    );
+
+VOID
+InitializeUnicodeSupport (
+    CHAR8 *LangCode
+    );
+
+VOID
+EFIDebugVariable (
+    VOID
+    );
+
+VOID
+SetCrc (
+    IN OUT EFI_TABLE_HEADER *Hdr
+    );
+
+VOID
+SetCrcAltSize (
+    IN UINTN                 Size,
+    IN OUT EFI_TABLE_HEADER *Hdr
+    );
+
+BOOLEAN
+CheckCrc (
+    IN UINTN                 MaxSize,
+    IN OUT EFI_TABLE_HEADER *Hdr
+    );
+
+BOOLEAN
+CheckCrcAltSize (
+    IN UINTN                 MaxSize,
+    IN UINTN                 Size,
+    IN OUT EFI_TABLE_HEADER *Hdr
+    );
+
+UINT32
+CalculateCrc (
+    UINT8 *pt,
+    UINTN Size
+    );
+
+VOID
+ZeroMem (
+    IN VOID     *Buffer,
+    IN UINTN     Size
+    );
+
+VOID
+SetMem (
+    IN VOID     *Buffer,
+    IN UINTN    Size,
+    IN UINT8    Value    
+    );
+
+VOID
+CopyMem (
+    IN VOID     *Dest,
+    IN VOID     *Src,
+    IN UINTN    len
+    );
+
+INTN
+CompareMem (
+    IN VOID     *Dest,
+    IN VOID     *Src,
+    IN UINTN    len
+    );
+
+INTN
+StrCmp (
+    IN CHAR16   *s1,
+    IN CHAR16   *s2
+    );
+
+INTN
+StrnCmp (
+    IN CHAR16   *s1,
+    IN CHAR16   *s2,
+    IN UINTN    len
+    );
+
+INTN
+StriCmp (
+    IN CHAR16   *s1,
+    IN CHAR16   *s2
+    );
+
+VOID
+StrLwr (
+    IN CHAR16   *Str
+    );
+
+VOID
+StrUpr (
+    IN CHAR16   *Str
+    );
+
+VOID
+StrCpy (
+    IN CHAR16   *Dest,
+    IN CHAR16    *Src
+    );
+
+VOID
+StrCat (
+    IN CHAR16   *Dest,
+    IN CHAR16   *Src
+    );
+
+UINTN
+StrLen (
+    IN CHAR16   *s1
+    );
+
+UINTN
+StrSize (
+    IN CHAR16   *s1
+    );
+
+CHAR16 *
+StrDuplicate (
+    IN CHAR16   *Src
+    );
+
+UINTN
+strlena (
+    IN CHAR8    *s1
+    );
+    
+UINTN
+strcmpa (
+    IN CHAR8    *s1,
+    IN CHAR8    *s2
+    );
+
+UINTN
+strncmpa (
+    IN CHAR8    *s1,
+    IN CHAR8    *s2,
+    IN UINTN    len
+    );
+
+UINTN
+xtoi (
+    CHAR16      *str
+    );
+
+UINTN
+Atoi (
+    CHAR16  *str
+    );
+
+BOOLEAN 
+MetaMatch (
+    IN CHAR16   *String,
+    IN CHAR16   *Pattern
+    );
+
+BOOLEAN 
+MetaiMatch (
+    IN CHAR16   *String,
+    IN CHAR16   *Pattern
+    );
+
+UINT64
+LShiftU64 (
+    IN UINT64   Operand,
+    IN UINTN    Count
+    );
+
+UINT64
+RShiftU64 (
+    IN UINT64   Operand,
+    IN UINTN    Count
+    );
+
+UINT64
+MultU64x32 (
+    IN UINT64   Multiplicand,
+    IN UINTN    Multiplier
+    );
+
+UINT64
+DivU64x32 (
+    IN UINT64   Dividend,
+    IN UINTN    Divisor,
+    OUT UINTN   *Remainder OPTIONAL
+    );
+
+VOID
+InitializeLock (
+    IN OUT FLOCK    *Lock,
+    IN EFI_TPL  Priority
+    );
+
+VOID
+AcquireLock (
+    IN FLOCK    *Lock
+    );
+
+VOID
+ReleaseLock (
+    IN FLOCK    *Lock
+    );
+
+
+INTN
+CompareGuid(
+    IN EFI_GUID     *Guid1,
+    IN EFI_GUID     *Guid2
+    );
+
+VOID *
+AllocatePool (
+    IN UINTN     Size
+    );
+
+VOID *
+AllocateZeroPool (
+    IN UINTN     Size
+    );
+
+VOID *
+ReallocatePool (
+    IN VOID                 *OldPool,
+    IN UINTN                OldSize,
+    IN UINTN                NewSize
+    );
+
+VOID
+FreePool (
+    IN VOID     *p
+    );
+
+
+VOID
+Output (
+    IN CHAR16   *Str
+    );
+
+VOID
+Input (
+    IN CHAR16   *Prompt OPTIONAL,
+    OUT CHAR16  *InStr,
+    IN UINTN    StrLen
+    );
+
+VOID
+IInput (
+    IN SIMPLE_TEXT_OUTPUT_INTERFACE     *ConOut,
+    IN SIMPLE_INPUT_INTERFACE           *ConIn,
+    IN CHAR16                           *Prompt OPTIONAL,
+    OUT CHAR16                          *InStr,
+    IN UINTN                            StrLen
+    );
+
+UINTN
+Print (
+    IN CHAR16   *fmt,
+    ...
+    );
+
+UINTN
+SPrint (
+    OUT CHAR16  *Str,
+    IN UINTN    StrSize,
+    IN CHAR16   *fmt,
+    ...
+    );
+
+CHAR16 *
+PoolPrint (
+    IN CHAR16           *fmt,
+    ...
+    );
+
+typedef struct {
+    CHAR16      *str;
+    UINTN       len;
+    UINTN       maxlen;
+} POOL_PRINT;
+
+CHAR16 *
+CatPrint (
+    IN OUT POOL_PRINT   *Str,
+    IN CHAR16           *fmt,
+    ...
+    );
+
+UINTN
+PrintAt (
+    IN UINTN    Column,
+    IN UINTN    Row,
+    IN CHAR16   *fmt,
+    ...
+    );
+
+UINTN
+IPrint (
+    IN SIMPLE_TEXT_OUTPUT_INTERFACE    *Out,
+    IN CHAR16                          *fmt,
+    ...
+    );
+
+UINTN
+IPrintAt (
+    IN SIMPLE_TEXT_OUTPUT_INTERFACE     *Out,
+    IN UINTN                            Column,
+    IN UINTN                            Row,
+    IN CHAR16                           *fmt,
+    ...
+    );
+
+UINTN
+APrint (
+    IN CHAR8    *fmt,
+    ...
+    );
+
+VOID
+ValueToHex (
+    IN CHAR16   *Buffer,
+    IN UINT64   v
+    );
+
+VOID
+ValueToString (
+    IN CHAR16   *Buffer,
+    IN BOOLEAN  Comma,
+    IN INT64    v
+    );
+
+VOID
+TimeToString (
+    OUT CHAR16      *Buffer,
+    IN EFI_TIME     *Time
+    );
+
+VOID
+GuidToString (
+    OUT CHAR16      *Buffer,
+    IN EFI_GUID     *Guid
+    );
+
+VOID
+StatusToString (
+    OUT CHAR16      *Buffer,
+    EFI_STATUS      Status
+    );
+
+VOID
+DumpHex (
+    IN UINTN        Indent,
+    IN UINTN        Offset,
+    IN UINTN        DataSize,
+    IN VOID         *UserData
+    );
+
+BOOLEAN
+GrowBuffer(
+    IN OUT EFI_STATUS   *Status,
+    IN OUT VOID         **Buffer,
+    IN UINTN            BufferSize
+    );
+
+EFI_MEMORY_DESCRIPTOR *
+LibMemoryMap (
+    OUT UINTN               *NoEntries,
+    OUT UINTN               *MapKey,
+    OUT UINTN               *DescriptorSize,
+    OUT UINT32              *DescriptorVersion
+    );
+
+VOID *
+LibGetVariable (
+    IN CHAR16               *Name,
+    IN EFI_GUID             *VendorGuid
+    );
+
+VOID *
+LibGetVariableAndSize (
+    IN CHAR16               *Name,
+    IN EFI_GUID             *VendorGuid,
+    OUT UINTN               *VarSize
+    );
+
+EFI_STATUS
+LibDeleteVariable (
+    IN CHAR16   *VarName,
+    IN EFI_GUID *VarGuid
+    );
+
+EFI_STATUS
+LibInsertToTailOfBootOrder (
+    IN  UINT16  BootOption,
+    IN  BOOLEAN OnlyInsertIfEmpty
+    );
+
+EFI_STATUS
+LibLocateProtocol (
+    IN  EFI_GUID    *ProtocolGuid,
+    OUT VOID        **Interface
+    );
+
+EFI_STATUS
+LibLocateHandle (
+    IN EFI_LOCATE_SEARCH_TYPE   SearchType,
+    IN EFI_GUID                 *Protocol OPTIONAL,
+    IN VOID                     *SearchKey OPTIONAL,
+    IN OUT UINTN                *NoHandles,
+    OUT EFI_HANDLE              **Buffer
+    );
+
+EFI_STATUS
+LibLocateHandleByDiskSignature (
+    IN UINT8                        MBRType,
+    IN UINT8                        SignatureType,
+    IN VOID                         *Signature,
+    IN OUT UINTN                    *NoHandles,
+    OUT EFI_HANDLE                  **Buffer
+    );
+
+EFI_STATUS
+LibInstallProtocolInterfaces (
+    IN OUT EFI_HANDLE       *Handle,
+    ...
+    );
+
+VOID
+LibUninstallProtocolInterfaces (
+    IN EFI_HANDLE           Handle,
+    ...
+    );
+
+EFI_STATUS
+LibReinstallProtocolInterfaces (
+    IN OUT EFI_HANDLE           *Handle,
+    ...
+    );
+
+EFI_EVENT
+LibCreateProtocolNotifyEvent (
+    IN EFI_GUID             *ProtocolGuid,
+    IN EFI_TPL              NotifyTpl,
+    IN EFI_EVENT_NOTIFY     NotifyFunction,
+    IN VOID                 *NotifyContext,
+    OUT VOID                *Registration
+    );
+
+EFI_STATUS
+WaitForSingleEvent (
+    IN EFI_EVENT        Event,
+    IN UINT64           Timeout OPTIONAL
+    );
+
+VOID
+WaitForEventWithTimeout (
+    IN  EFI_EVENT       Event,
+    IN  UINTN           Timeout,
+    IN  UINTN           Row,
+    IN  UINTN           Column,
+    IN  CHAR16          *String,
+    IN  EFI_INPUT_KEY   TimeoutKey,
+    OUT EFI_INPUT_KEY   *Key
+    );
+
+EFI_FILE_HANDLE
+LibOpenRoot (
+    IN EFI_HANDLE           DeviceHandle
+    );
+
+EFI_FILE_INFO *
+LibFileInfo (
+    IN EFI_FILE_HANDLE      FHand
+    );
+
+EFI_FILE_SYSTEM_INFO *
+LibFileSystemInfo (
+    IN EFI_FILE_HANDLE      FHand
+    );
+
+EFI_FILE_SYSTEM_VOLUME_LABEL_INFO *
+LibFileSystemVolumeLabelInfo (
+    IN EFI_FILE_HANDLE      FHand
+    );
+
+BOOLEAN
+ValidMBR(
+    IN  MASTER_BOOT_RECORD  *Mbr,
+    IN  EFI_BLOCK_IO        *BlkIo
+    );
+
+BOOLEAN
+LibMatchDevicePaths (
+    IN  EFI_DEVICE_PATH *Multi,
+    IN  EFI_DEVICE_PATH *Single
+    );
+
+EFI_DEVICE_PATH *
+LibDuplicateDevicePathInstance (
+    IN EFI_DEVICE_PATH  *DevPath
+    );
+
+EFI_DEVICE_PATH *
+DevicePathFromHandle (
+    IN EFI_HANDLE           Handle
+    );
+
+EFI_DEVICE_PATH *
+DevicePathInstance (
+    IN OUT EFI_DEVICE_PATH  **DevicePath,
+    OUT UINTN               *Size
+    );
+
+UINTN
+DevicePathInstanceCount (
+    IN EFI_DEVICE_PATH      *DevicePath
+    );
+
+EFI_DEVICE_PATH *
+AppendDevicePath (
+    IN EFI_DEVICE_PATH      *Src1,
+    IN EFI_DEVICE_PATH      *Src2
+    );
+
+EFI_DEVICE_PATH *
+AppendDevicePathNode (
+    IN EFI_DEVICE_PATH      *Src1,
+    IN EFI_DEVICE_PATH      *Src2
+    );
+
+EFI_DEVICE_PATH*
+AppendDevicePathInstance (
+    IN EFI_DEVICE_PATH  *Src,
+    IN EFI_DEVICE_PATH  *Instance
+    );
+
+EFI_DEVICE_PATH *
+FileDevicePath (
+    IN EFI_HANDLE           Device  OPTIONAL,
+    IN CHAR16               *FileName
+    );
+
+UINTN
+DevicePathSize (
+    IN EFI_DEVICE_PATH      *DevPath
+    );
+
+EFI_DEVICE_PATH *
+DuplicateDevicePath (
+    IN EFI_DEVICE_PATH      *DevPath
+    );
+
+EFI_DEVICE_PATH *
+UnpackDevicePath (
+    IN EFI_DEVICE_PATH      *DevPath
+    );
+
+EFI_STATUS
+LibDevicePathToInterface (
+    IN EFI_GUID             *Protocol,
+    IN EFI_DEVICE_PATH      *FilePath,
+    OUT VOID                **Interface
+    );
+
+CHAR16 *
+DevicePathToStr (
+    EFI_DEVICE_PATH         *DevPath
+    );
+
+//
+// BugBug: I need my own include files
+//
+typedef struct {
+    UINT8   Register;
+    UINT8   Function;
+    UINT8   Device;
+    UINT8   Bus;
+    UINT32  Reserved;
+} EFI_ADDRESS;
+
+typedef union {
+    UINT64          Address;
+    EFI_ADDRESS     EfiAddress;
+} EFI_PCI_ADDRESS_UNION;
+
+
+EFI_STATUS
+PciFindDeviceClass (
+    IN  OUT EFI_PCI_ADDRESS_UNION   *Address,
+    IN      UINT8                   BaseClass,
+    IN      UINT8                   SubClass
+    );
+
+EFI_STATUS
+PciFindDevice (
+    IN  OUT EFI_PCI_ADDRESS_UNION   *DeviceAddress,
+    IN      UINT16                  VendorId,
+    IN      UINT16                  DeviceId,
+    IN OUT  PCI_TYPE00              *Pci
+    );
+
+//
+// SIMPLE_READ_FILE object used to access files
+//
+
+typedef VOID        *SIMPLE_READ_FILE;
+
+EFI_STATUS
+OpenSimpleReadFile (
+    IN BOOLEAN                  BootPolicy,
+    IN VOID                     *SourceBuffer   OPTIONAL,
+    IN UINTN                    SourceSize,
+    IN OUT EFI_DEVICE_PATH      **FilePath,
+    OUT EFI_HANDLE              *DeviceHandle,    
+    OUT SIMPLE_READ_FILE        *SimpleReadHandle
+    );
+
+EFI_STATUS
+ReadSimpleReadFile (
+    IN SIMPLE_READ_FILE     SimpleReadHandle,
+    IN UINTN                Offset,
+    IN OUT UINTN            *ReadSize,
+    OUT VOID                *Buffer
+    );
+
+
+VOID
+CloseSimpleReadFile (
+    IN SIMPLE_READ_FILE     SimpleReadHandle
+    );
+
+VOID
+InitializeGuid (
+    VOID
+    );
+
+UINT8
+DecimaltoBCD(
+    IN  UINT8 DecValue
+    );
+
+UINT8
+BCDtoDecimal(
+    IN  UINT8 BcdValue
+    );
+
+EFI_STATUS
+LibGetSystemConfigurationTable(
+    IN EFI_GUID *TableGuid,
+    IN OUT VOID **Table
+    );
+
+BOOLEAN
+LibIsValidTextGraphics (
+    IN  CHAR16  Graphic,   
+    OUT CHAR8   *PcAnsi,    OPTIONAL
+    OUT CHAR8   *Ascii      OPTIONAL
+    );
+
+BOOLEAN
+IsValidAscii (
+    IN  CHAR16  Ascii
+    );
+
+BOOLEAN
+IsValidEfiCntlChar (
+    IN  CHAR16  c
+    );
+
+CHAR16 *
+LibGetUiString (
+    IN  EFI_HANDLE      Handle,
+    IN  UI_STRING_TYPE  StringType,
+    IN  ISO_639_2       *LangCode,
+    IN  BOOLEAN         ReturnDevicePathStrOnMismatch
+    );
+
+CHAR8*
+LibGetSmbiosString (
+    IN  SMBIOS_STRUCTURE_POINTER    *Smbios,
+    IN  UINT16                      StringNumber
+    );
+
+EFI_STATUS
+LibGetSmbiosSystemGuidAndSerialNumber (
+    IN  EFI_GUID    *SystemGuid,
+    OUT CHAR8       **SystemSerialNumber
+    );
+
+
+EFI_STATUS
+InitializeGlobalIoDevice (
+        IN  EFI_DEVICE_PATH             *DevicePath,
+        IN  EFI_GUID                    *Protocol,
+        IN  CHAR8                       *ErrorStr,
+        OUT EFI_DEVICE_IO_INTERFACE     **GlobalIoFncs 
+        );
+
+UINT32 
+ReadPort (
+        IN  EFI_DEVICE_IO_INTERFACE     *GlobalIoFncs, 
+        IN  EFI_IO_WIDTH                Width,
+        IN  UINTN                       Port
+        );
+
+UINT32 
+WritePort (
+        IN  EFI_DEVICE_IO_INTERFACE     *GlobalIoFncs, 
+        IN  EFI_IO_WIDTH                Width,
+        IN  UINTN                       Port,
+        IN  UINTN                       Data
+        );
+
+UINT32 
+ReadPciConfig (
+        IN  EFI_DEVICE_IO_INTERFACE     *GlobalIoFncs, 
+        IN  EFI_IO_WIDTH                Width,
+        IN  UINTN                       Port
+        );
+
+UINT32 
+WritePciConfig (
+        IN  EFI_DEVICE_IO_INTERFACE     *GlobalIoFncs, 
+        IN  EFI_IO_WIDTH                Width,
+        IN  UINTN                       Port,
+        IN  UINTN                       Data
+        );
+
+extern EFI_DEVICE_IO_INTERFACE  *GlobalIoFncs;
+
+#define outp(_Port, _DataByte)  (UINT8)WritePort(GlobalIoFncs,  IO_UINT8,  (UINTN)_Port, (UINTN)_DataByte)
+#define inp(_Port)              (UINT8)ReadPort(GlobalIoFncs,   IO_UINT8,  (UINTN)_Port)
+#define outpw(_Port, _DataByte) (UINT16)WritePort(GlobalIoFncs, IO_UINT16, (UINTN)_Port, (UINTN)_DataByte)
+#define inpw(_Port)             (UINT16)ReadPort(GlobalIoFncs,  IO_UINT16, (UINTN)_Port)
+#define outpd(_Port, _DataByte) (UINT32)WritePort(GlobalIoFncs, IO_UINT32, (UINTN)_Port, (UINTN)_DataByte)
+#define inpd(_Port)             (UINT32)ReadPort(GlobalIoFncs,  IO_UINT32, (UINTN)_Port)
+
+#define writepci8(_Addr, _DataByte)  (UINT8)WritePciConfig(GlobalIoFncs,  IO_UINT8,  (UINTN)_Addr, (UINTN)_DataByte)
+#define readpci8(_Addr)              (UINT8)ReadPciConfig(GlobalIoFncs,   IO_UINT8,  (UINTN)_Addr)
+#define writepci16(_Addr, _DataByte) (UINT16)WritePciConfig(GlobalIoFncs, IO_UINT16, (UINTN)_Addr, (UINTN)_DataByte)
+#define readpci16(_Addr)             (UINT16)ReadPciConfig(GlobalIoFncs,  IO_UINT16, (UINTN)_Addr)
+#define writepci32(_Addr, _DataByte) (UINT32)WritePciConfig(GlobalIoFncs, IO_UINT32, (UINTN)_Addr, (UINTN)_DataByte)
+#define readpci32(_Addr)             (UINT32)ReadPciConfig(GlobalIoFncs,  IO_UINT32, (UINTN)_Addr)
+
+#define Pause()             WaitForSingleEvent (ST->ConIn->WaitForKey, 0)
+#define Port80(_PostCode)   GlobalIoFncs->Io.Write (GlobalIoFncs, IO_UINT16, (UINT64)0x80, 1, &(_PostCode))
+
+#endif
diff --git a/linux-x86/gnu-efi/include/efi/efilink.h b/linux-x86/gnu-efi/include/efi/efilink.h
new file mode 100644
index 0000000..b2ff4fa
--- /dev/null
+++ b/linux-x86/gnu-efi/include/efi/efilink.h
@@ -0,0 +1,177 @@
+#ifndef _EFI_LINK_H
+#define _EFI_LINK_H
+
+/*++
+
+Copyright (c) 1998  Intel Corporation
+
+Module Name:
+
+    link.h (renamed efilink.h to avoid conflicts)
+
+Abstract:
+
+    EFI link list macro's
+
+
+
+Revision History
+
+--*/
+
+#ifndef EFI_NT_EMUL
+
+//
+// List entry - doubly linked list
+//
+
+typedef struct _LIST_ENTRY {
+    struct _LIST_ENTRY  *Flink;
+    struct _LIST_ENTRY  *Blink;
+} LIST_ENTRY;
+
+#endif 
+
+
+//
+//  VOID
+//  InitializeListHead(
+//      LIST_ENTRY *ListHead
+//      );
+//
+
+#define InitializeListHead(ListHead) \
+    (ListHead)->Flink = ListHead;    \
+    (ListHead)->Blink = ListHead;
+
+//
+//  BOOLEAN
+//  IsListEmpty(
+//      PLIST_ENTRY ListHead
+//      );
+//
+
+#define IsListEmpty(ListHead) \
+    ((ListHead)->Flink == (ListHead))
+
+//
+//  VOID
+//  RemoveEntryList(
+//      PLIST_ENTRY Entry
+//      );
+//
+
+#define _RemoveEntryList(Entry) {       \
+        LIST_ENTRY *_Blink, *_Flink;    \
+        _Flink = (Entry)->Flink;        \
+        _Blink = (Entry)->Blink;        \
+        _Blink->Flink = _Flink;         \
+        _Flink->Blink = _Blink;         \
+        }
+
+#if EFI_DEBUG
+    #define RemoveEntryList(Entry)                      \
+        _RemoveEntryList(Entry);                        \
+        (Entry)->Flink = (LIST_ENTRY *) BAD_POINTER;    \
+        (Entry)->Blink = (LIST_ENTRY *) BAD_POINTER; 
+#else
+    #define RemoveEntryList(Entry)      \
+        _RemoveEntryList(Entry);
+#endif
+
+//
+//  VOID
+//  InsertTailList(
+//      PLIST_ENTRY ListHead,
+//      PLIST_ENTRY Entry
+//      );
+//
+
+#define InsertTailList(ListHead,Entry) {\
+    LIST_ENTRY *_ListHead, *_Blink;     \
+    _ListHead = (ListHead);             \
+    _Blink = _ListHead->Blink;          \
+    (Entry)->Flink = _ListHead;         \
+    (Entry)->Blink = _Blink;            \
+    _Blink->Flink = (Entry);            \
+    _ListHead->Blink = (Entry);         \
+    }
+
+//
+//  VOID
+//  InsertHeadList(
+//      PLIST_ENTRY ListHead,
+//      PLIST_ENTRY Entry
+//      );
+//
+
+#define InsertHeadList(ListHead,Entry) {\
+    LIST_ENTRY *_ListHead, *_Flink;     \
+    _ListHead = (ListHead);             \
+    _Flink = _ListHead->Flink;          \
+    (Entry)->Flink = _Flink;            \
+    (Entry)->Blink = _ListHead;         \
+    _Flink->Blink = (Entry);            \
+    _ListHead->Flink = (Entry);         \
+    }
+
+//  VOID
+//  SwapListEntries(
+//      PLIST_ENTRY Entry1,
+//      PLIST_ENTRY Entry2
+//      );
+//
+// Put Entry2 before Entry1
+//
+#define SwapListEntries(Entry1,Entry2) {\
+    LIST_ENTRY *Entry1Flink, *Entry1Blink;     \
+    LIST_ENTRY *Entry2Flink, *Entry2Blink;     \
+    Entry2Flink = (Entry2)->Flink;             \
+    Entry2Blink = (Entry2)->Blink;             \
+    Entry1Flink = (Entry1)->Flink;             \
+    Entry1Blink = (Entry1)->Blink;             \
+    Entry2Blink->Flink = Entry2Flink;       \
+    Entry2Flink->Blink = Entry2Blink;        \
+    (Entry2)->Flink = Entry1;               \
+    (Entry2)->Blink = Entry1Blink;          \
+    Entry1Blink->Flink = (Entry2);            \
+    (Entry1)->Blink = (Entry2);             \
+    }
+
+//
+//  EFI_FIELD_OFFSET - returns the byte offset to a field within a structure
+//
+
+#define EFI_FIELD_OFFSET(TYPE,Field) ((UINTN)(&(((TYPE *) 0)->Field)))
+
+//
+//  CONTAINING_RECORD - returns a pointer to the structure
+//      from one of it's elements.
+//
+
+#define _CR(Record, TYPE, Field)  \
+    ((TYPE *) ( (CHAR8 *)(Record) - (CHAR8 *) &(((TYPE *) 0)->Field)))
+
+#if EFI_DEBUG
+    #define CR(Record, TYPE, Field, Sig)     \
+        _CR(Record, TYPE, Field)->Signature != Sig ?        \
+            (TYPE *) ASSERT_STRUCT(_CR(Record, TYPE, Field), Record) : \
+            _CR(Record, TYPE, Field)
+#else
+    #define CR(Record, TYPE, Field, Signature)   \
+        _CR(Record, TYPE, Field)                           
+#endif
+
+
+//
+// A lock structure
+//
+
+typedef struct _FLOCK {
+    EFI_TPL     Tpl;
+    EFI_TPL     OwnerTpl;
+    UINTN       Lock;
+} FLOCK;
+
+#endif
+
diff --git a/linux-x86/gnu-efi/include/efi/efinet.h b/linux-x86/gnu-efi/include/efi/efinet.h
new file mode 100644
index 0000000..b2e5aa8
--- /dev/null
+++ b/linux-x86/gnu-efi/include/efi/efinet.h
@@ -0,0 +1,340 @@
+#ifndef _EFINET_H
+#define _EFINET_H
+
+
+/*++
+Copyright (c) 1999  Intel Corporation
+
+Module Name:
+    efinet.h
+
+Abstract:
+    EFI Simple Network protocol
+
+Revision History
+--*/
+
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//      Simple Network Protocol
+//
+
+#define EFI_SIMPLE_NETWORK_PROTOCOL \
+    { 0xA19832B9, 0xAC25, 0x11D3, {0x9A, 0x2D, 0x00, 0x90, 0x27, 0x3F, 0xC1, 0x4D} }
+
+
+INTERFACE_DECL(_EFI_SIMPLE_NETWORK);
+
+///////////////////////////////////////////////////////////////////////////////
+//
+
+typedef struct {
+    //
+    // Total number of frames received.  Includes frames with errors and
+    // dropped frames.
+    //
+    UINT64  RxTotalFrames;
+
+    //
+    // Number of valid frames received and copied into receive buffers.
+    //
+    UINT64  RxGoodFrames;
+
+    //
+    // Number of frames below the minimum length for the media.
+    // This would be <64 for ethernet.
+    //
+    UINT64  RxUndersizeFrames;
+
+    //
+    // Number of frames longer than the maxminum length for the
+    // media.  This would be >1500 for ethernet.
+    //
+    UINT64  RxOversizeFrames;
+
+    //
+    // Valid frames that were dropped because receive buffers were full.
+    //
+    UINT64  RxDroppedFrames;
+
+    //
+    // Number of valid unicast frames received and not dropped.
+    //
+    UINT64  RxUnicastFrames;
+
+    //
+    // Number of valid broadcast frames received and not dropped.
+    //
+    UINT64  RxBroadcastFrames;
+
+    //
+    // Number of valid mutlicast frames received and not dropped.
+    //
+    UINT64  RxMulticastFrames;
+
+    //
+    // Number of frames w/ CRC or alignment errors.
+    //
+    UINT64  RxCrcErrorFrames;
+
+    //
+    // Total number of bytes received.  Includes frames with errors
+    // and dropped frames.
+    //
+    UINT64  RxTotalBytes;
+
+    //
+    // Transmit statistics.
+    //
+    UINT64  TxTotalFrames;
+    UINT64  TxGoodFrames;
+    UINT64  TxUndersizeFrames;
+    UINT64  TxOversizeFrames;
+    UINT64  TxDroppedFrames;
+    UINT64  TxUnicastFrames;
+    UINT64  TxBroadcastFrames;
+    UINT64  TxMulticastFrames;
+    UINT64  TxCrcErrorFrames;
+    UINT64  TxTotalBytes;
+
+    //
+    // Number of collisions detection on this subnet.
+    //
+    UINT64  Collisions;
+
+    //
+    // Number of frames destined for unsupported protocol.
+    //
+    UINT64  UnsupportedProtocol;
+
+} EFI_NETWORK_STATISTICS;
+
+///////////////////////////////////////////////////////////////////////////////
+//
+
+typedef enum {
+    EfiSimpleNetworkStopped,
+    EfiSimpleNetworkStarted,
+    EfiSimpleNetworkInitialized,
+    EfiSimpleNetworkMaxState
+} EFI_SIMPLE_NETWORK_STATE;
+
+///////////////////////////////////////////////////////////////////////////////
+//
+
+#define EFI_SIMPLE_NETWORK_RECEIVE_UNICAST               0x01
+#define EFI_SIMPLE_NETWORK_RECEIVE_MULTICAST             0x02
+#define EFI_SIMPLE_NETWORK_RECEIVE_BROADCAST             0x04
+#define EFI_SIMPLE_NETWORK_RECEIVE_PROMISCUOUS           0x08
+#define EFI_SIMPLE_NETWORK_RECEIVE_PROMISCUOUS_MULTICAST 0x10
+
+///////////////////////////////////////////////////////////////////////////////
+//
+
+#define EFI_SIMPLE_NETWORK_RECEIVE_INTERRUPT        0x01
+#define EFI_SIMPLE_NETWORK_TRANSMIT_INTERRUPT       0x02
+#define EFI_SIMPLE_NETWORK_COMMAND_INTERRUPT        0x04
+#define EFI_SIMPLE_NETWORK_SOFTWARE_INTERRUPT       0x08
+
+///////////////////////////////////////////////////////////////////////////////
+//
+#define MAX_MCAST_FILTER_CNT    16
+typedef struct {
+    UINT32                      State;
+    UINT32                      HwAddressSize;
+    UINT32                      MediaHeaderSize;
+    UINT32                      MaxPacketSize;
+    UINT32                      NvRamSize;
+    UINT32                      NvRamAccessSize;
+    UINT32                      ReceiveFilterMask;
+    UINT32                      ReceiveFilterSetting;
+    UINT32                      MaxMCastFilterCount;
+    UINT32                      MCastFilterCount;
+    EFI_MAC_ADDRESS             MCastFilter[MAX_MCAST_FILTER_CNT];
+    EFI_MAC_ADDRESS             CurrentAddress;
+    EFI_MAC_ADDRESS             BroadcastAddress;
+    EFI_MAC_ADDRESS             PermanentAddress;
+    UINT8                       IfType;
+    BOOLEAN                     MacAddressChangeable;
+    BOOLEAN                     MultipleTxSupported;
+    BOOLEAN                     MediaPresentSupported;
+    BOOLEAN                     MediaPresent;
+} EFI_SIMPLE_NETWORK_MODE;
+
+///////////////////////////////////////////////////////////////////////////////
+//
+
+typedef 
+EFI_STATUS 
+(EFIAPI *EFI_SIMPLE_NETWORK_START) (
+    IN struct _EFI_SIMPLE_NETWORK  *This
+);
+
+///////////////////////////////////////////////////////////////////////////////
+//
+
+typedef 
+EFI_STATUS 
+(EFIAPI *EFI_SIMPLE_NETWORK_STOP) (
+    IN struct _EFI_SIMPLE_NETWORK  *This
+);
+
+///////////////////////////////////////////////////////////////////////////////
+//
+
+typedef 
+EFI_STATUS 
+(EFIAPI *EFI_SIMPLE_NETWORK_INITIALIZE) (
+    IN struct _EFI_SIMPLE_NETWORK  *This,
+    IN UINTN                       ExtraRxBufferSize  OPTIONAL,
+    IN UINTN                       ExtraTxBufferSize  OPTIONAL
+);
+
+///////////////////////////////////////////////////////////////////////////////
+//
+
+typedef 
+EFI_STATUS 
+(EFIAPI *EFI_SIMPLE_NETWORK_RESET) (
+    IN struct _EFI_SIMPLE_NETWORK   *This,
+    IN BOOLEAN                      ExtendedVerification
+);
+
+///////////////////////////////////////////////////////////////////////////////
+//
+
+typedef 
+EFI_STATUS 
+(EFIAPI *EFI_SIMPLE_NETWORK_SHUTDOWN) (
+    IN struct _EFI_SIMPLE_NETWORK  *This
+);
+
+///////////////////////////////////////////////////////////////////////////////
+//
+
+typedef 
+EFI_STATUS 
+(EFIAPI *EFI_SIMPLE_NETWORK_RECEIVE_FILTERS) (
+    IN struct _EFI_SIMPLE_NETWORK   *This,
+    IN UINT32                       Enable,
+    IN UINT32                       Disable,
+    IN BOOLEAN                      ResetMCastFilter,
+    IN UINTN                        MCastFilterCnt     OPTIONAL,
+    IN EFI_MAC_ADDRESS              *MCastFilter       OPTIONAL
+);
+
+///////////////////////////////////////////////////////////////////////////////
+//
+
+typedef 
+EFI_STATUS 
+(EFIAPI *EFI_SIMPLE_NETWORK_STATION_ADDRESS) (
+    IN struct _EFI_SIMPLE_NETWORK   *This,
+    IN BOOLEAN                      Reset,
+    IN EFI_MAC_ADDRESS              *New      OPTIONAL
+);
+
+///////////////////////////////////////////////////////////////////////////////
+//
+
+typedef 
+EFI_STATUS 
+(EFIAPI *EFI_SIMPLE_NETWORK_STATISTICS) (
+    IN struct _EFI_SIMPLE_NETWORK   *This,
+    IN BOOLEAN                      Reset,
+    IN OUT UINTN                    *StatisticsSize   OPTIONAL,
+    OUT EFI_NETWORK_STATISTICS      *StatisticsTable  OPTIONAL
+);
+
+///////////////////////////////////////////////////////////////////////////////
+//
+
+typedef 
+EFI_STATUS 
+(EFIAPI *EFI_SIMPLE_NETWORK_MCAST_IP_TO_MAC) (
+    IN struct _EFI_SIMPLE_NETWORK   *This,
+    IN BOOLEAN                      IPv6,
+    IN EFI_IP_ADDRESS               *IP,
+    OUT EFI_MAC_ADDRESS             *MAC
+);
+
+///////////////////////////////////////////////////////////////////////////////
+//
+
+typedef 
+EFI_STATUS 
+(EFIAPI *EFI_SIMPLE_NETWORK_NVDATA) (
+    IN struct _EFI_SIMPLE_NETWORK  *This,
+    IN BOOLEAN                     ReadWrite,
+    IN UINTN                       Offset,
+    IN UINTN                       BufferSize,
+    IN OUT VOID                    *Buffer
+);
+
+///////////////////////////////////////////////////////////////////////////////
+//
+
+typedef 
+EFI_STATUS 
+(EFIAPI *EFI_SIMPLE_NETWORK_GET_STATUS) (
+    IN struct _EFI_SIMPLE_NETWORK  *This,
+    OUT UINT32                     *InterruptStatus  OPTIONAL,
+    OUT VOID                       **TxBuf           OPTIONAL
+);
+
+///////////////////////////////////////////////////////////////////////////////
+//
+
+typedef 
+EFI_STATUS 
+(EFIAPI *EFI_SIMPLE_NETWORK_TRANSMIT) (
+    IN struct _EFI_SIMPLE_NETWORK   *This,
+    IN UINTN                        HeaderSize,
+    IN UINTN                        BufferSize,
+    IN VOID                         *Buffer,
+    IN EFI_MAC_ADDRESS              *SrcAddr     OPTIONAL,
+    IN EFI_MAC_ADDRESS              *DestAddr    OPTIONAL,
+    IN UINT16                       *Protocol    OPTIONAL
+);
+
+///////////////////////////////////////////////////////////////////////////////
+//
+
+typedef 
+EFI_STATUS 
+(EFIAPI *EFI_SIMPLE_NETWORK_RECEIVE) (
+    IN struct _EFI_SIMPLE_NETWORK   *This,
+    OUT UINTN                       *HeaderSize  OPTIONAL,
+    IN OUT UINTN                    *BufferSize,
+    OUT VOID                        *Buffer,
+    OUT EFI_MAC_ADDRESS             *SrcAddr     OPTIONAL,
+    OUT EFI_MAC_ADDRESS             *DestAddr    OPTIONAL,
+    OUT UINT16                      *Protocol    OPTIONAL
+);
+
+///////////////////////////////////////////////////////////////////////////////
+//
+
+#define EFI_SIMPLE_NETWORK_INTERFACE_REVISION   0x00010000
+
+typedef struct _EFI_SIMPLE_NETWORK {
+    UINT64                              Revision;
+    EFI_SIMPLE_NETWORK_START            Start;
+    EFI_SIMPLE_NETWORK_STOP             Stop;
+    EFI_SIMPLE_NETWORK_INITIALIZE       Initialize;
+    EFI_SIMPLE_NETWORK_RESET            Reset;
+    EFI_SIMPLE_NETWORK_SHUTDOWN         Shutdown;
+    EFI_SIMPLE_NETWORK_RECEIVE_FILTERS  ReceiveFilters;
+    EFI_SIMPLE_NETWORK_STATION_ADDRESS  StationAddress;
+    EFI_SIMPLE_NETWORK_STATISTICS       Statistics;
+    EFI_SIMPLE_NETWORK_MCAST_IP_TO_MAC  MCastIpToMac;
+    EFI_SIMPLE_NETWORK_NVDATA           NvData;
+    EFI_SIMPLE_NETWORK_GET_STATUS       GetStatus;
+    EFI_SIMPLE_NETWORK_TRANSMIT         Transmit;
+    EFI_SIMPLE_NETWORK_RECEIVE          Receive;
+    EFI_EVENT                           WaitForPacket;
+    EFI_SIMPLE_NETWORK_MODE             *Mode;
+} EFI_SIMPLE_NETWORK;
+
+#endif /* _EFINET_H */
diff --git a/linux-x86/gnu-efi/include/efi/efipart.h b/linux-x86/gnu-efi/include/efi/efipart.h
new file mode 100644
index 0000000..d4c5573
--- /dev/null
+++ b/linux-x86/gnu-efi/include/efi/efipart.h
@@ -0,0 +1,61 @@
+#ifndef _EFI_PART_H
+#define _EFI_PART_H
+
+/*++
+
+Copyright (c) 1998  Intel Corporation
+
+Module Name:
+
+    efipart.h
+    
+Abstract:   
+    Info about disk partitions and Master Boot Records
+
+
+
+
+Revision History
+
+--*/
+
+//
+//
+//
+
+#define EFI_PARTITION   0xef
+#define MBR_SIZE        512
+
+#pragma pack(1)
+
+typedef struct {
+    UINT8       BootIndicator;
+    UINT8       StartHead;
+    UINT8       StartSector;
+    UINT8       StartTrack;
+    UINT8       OSIndicator;
+    UINT8       EndHead;
+    UINT8       EndSector;
+    UINT8       EndTrack;
+    UINT8       StartingLBA[4];
+    UINT8       SizeInLBA[4];
+} MBR_PARTITION_RECORD;
+
+#define EXTRACT_UINT32(D) (UINT32)(D[0] | (D[1] << 8) | (D[2] << 16) | (D[3] << 24))
+
+#define MBR_SIGNATURE           0xaa55
+#define MIN_MBR_DEVICE_SIZE     0x80000
+#define MBR_ERRATA_PAD          0x40000 // 128 MB
+
+#define MAX_MBR_PARTITIONS  4   
+typedef struct {
+    UINT8                   BootStrapCode[440];
+    UINT8                   UniqueMbrSignature[4];
+    UINT8                   Unknown[2];
+    MBR_PARTITION_RECORD    Partition[MAX_MBR_PARTITIONS];
+    UINT16                  Signature;
+} MASTER_BOOT_RECORD;
+#pragma pack()
+
+
+#endif
diff --git a/linux-x86/gnu-efi/include/efi/efipciio.h b/linux-x86/gnu-efi/include/efi/efipciio.h
new file mode 100644
index 0000000..0724f95
--- /dev/null
+++ b/linux-x86/gnu-efi/include/efi/efipciio.h
@@ -0,0 +1,219 @@
+#ifndef _EFI_PCI_IO_H
+#define _EFI_PCI_IO_H
+
+#define EFI_PCI_IO_PROTOCOL \
+    { 0x4cf5b200, 0x68b8, 0x4ca5, {0x9e, 0xec, 0xb2, 0x3e, 0x3f, 0x50, 0x02, 0x9a} }
+
+INTERFACE_DECL(_EFI_PCI_IO);
+
+typedef enum {
+    EfiPciIoWidthUint8,
+    EfiPciIoWidthUint16,
+    EfiPciIoWidthUint32,
+    EfiPciIoWidthUint64,
+    EfiPciIoWidthFifoUint8,
+    EfiPciIoWidthFifoUint16,
+    EfiPciIoWidthFifoUint32,
+    EfiPciIoWidthFifoUint64,
+    EfiPciIoWidthFillUint8,
+    EfiPciIoWidthFillUint16,
+    EfiPciIoWidthFillUint32,
+    EfiPciIoWidthFillUint64,
+    EfiPciIoWidthMaximum
+} EFI_PCI_IO_PROTOCOL_WIDTH;
+
+#define EFI_PCI_IO_PASS_THROUGH_BAR 0xff
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PCI_IO_PROTOCOL_POLL_IO_MEM) (
+  IN struct _EFI_PCI_IO *This,
+  IN EFI_PCI_IO_PROTOCOL_WIDTH  Width,
+  IN UINT8                      BarIndex,
+  IN UINT64                     Offset,
+  IN UINT64                     Mask,
+  IN UINT64                     Value,
+  IN UINT64                     Delay,
+  OUT UINT64                    *Result
+  );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PCI_IO_PROTOCOL_IO_MEM) (
+  IN struct _EFI_PCI_IO *This,
+  IN EFI_PCI_IO_PROTOCOL_WIDTH  Width,
+  IN UINT8                      BarIndex,
+  IN UINT64                     Offset,
+  IN UINTN                      Count,
+  IN OUT VOID                   *Buffer
+);
+
+typedef struct {
+  EFI_PCI_IO_PROTOCOL_IO_MEM    Read;
+  EFI_PCI_IO_PROTOCOL_IO_MEM    Write;
+} EFI_PCI_IO_PROTOCOL_ACCESS;
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PCI_IO_PROTOCOL_CONFIG) (
+  IN struct _EFI_PCI_IO *This,
+  IN EFI_PCI_IO_PROTOCOL_WIDTH  Width,
+  IN UINT32                     Offset,
+  IN UINTN                      Count,
+  IN OUT VOID                   *Buffer
+);
+
+typedef struct {
+  EFI_PCI_IO_PROTOCOL_CONFIG Read;
+  EFI_PCI_IO_PROTOCOL_CONFIG Write;
+} EFI_PCI_IO_PROTOCOL_CONFIG_ACCESS;
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PCI_IO_PROTOCOL_COPY_MEM) (
+  IN struct _EFI_PCI_IO *This,
+  IN EFI_PCI_IO_PROTOCOL_WIDTH  Width,
+  IN UINT8                      DestBarIndex,
+  IN UINT64                     DestOffset,
+  IN UINT8                      SrcBarIndex,
+  IN UINT64                     SrcOffset,
+  IN UINTN                      Count
+  );
+
+typedef enum {
+    EfiPciIoOperationBusMasterRead,
+    EfiPciIoOperationBusMasterWrite,
+    EfiPciIoOperationBusMasterCommonBuffer,
+    EfiPciIoOperationMaximum
+} EFI_PCI_IO_PROTOCOL_OPERATION;
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PCI_IO_PROTOCOL_MAP) (
+  IN struct _EFI_PCI_IO    *This,
+  IN EFI_PCI_IO_PROTOCOL_OPERATION Operation,
+  IN VOID                          *HostAddress,
+  IN OUT UINTN                     *NumberOfBytes,
+  OUT EFI_PHYSICAL_ADDRESS         *DeviceAddress,
+  OUT VOID                         **Mapping
+  );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PCI_IO_PROTOCOL_UNMAP) (
+  IN struct _EFI_PCI_IO *This,
+  IN VOID                       *Mapping
+);
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PCI_IO_PROTOCOL_ALLOCATE_BUFFER) (
+  IN struct _EFI_PCI_IO *This,
+  IN EFI_ALLOCATE_TYPE          Type,
+  IN EFI_MEMORY_TYPE            MemoryType,
+  IN UINTN                      Pages,
+  OUT VOID                      **HostAddress,
+  IN UINT64                     Attributes
+  );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PCI_IO_PROTOCOL_FREE_BUFFER) (
+  IN struct _EFI_PCI_IO *This,
+  IN UINTN                      Pages,
+  IN VOID                       *HostAddress
+  );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PCI_IO_PROTOCOL_FLUSH) (
+  IN struct _EFI_PCI_IO *This
+  );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PCI_IO_PROTOCOL_GET_LOCATION) (
+  IN struct _EFI_PCI_IO *This,
+  OUT UINTN                     *SegmentNumber,
+  OUT UINTN                     *BusNumber,
+  OUT UINTN                     *DeviceNumber,
+  OUT UINTN                     *FunctionNumber
+  );
+
+#define EFI_PCI_IO_ATTRIBUTE_ISA_IO               0x0002
+#define EFI_PCI_IO_ATTRIBUTE_VGA_PALETTE_IO       0x0004
+#define EFI_PCI_IO_ATTRIBUTE_VGA_MEMORY           0x0008
+#define EFI_PCI_IO_ATTRIBUTE_VGA_IO               0x0010
+#define EFI_PCI_IO_ATTRIBUTE_IDE_PRIMARY_IO       0x0020
+#define EFI_PCI_IO_ATTRIBUTE_IDE_SECONDARY_IO     0x0040
+#define EFI_PCI_IO_ATTRIBUTE_MEMORY_WRITE_COMBINE 0x0080
+#define EFI_PCI_IO_ATTRIBUTE_IO                   0x0100
+#define EFI_PCI_IO_ATTRIBUTE_MEMORY               0x0200
+#define EFI_PCI_IO_ATTRIBUTE_BUS_MASTER           0x0400
+#define EFI_PCI_IO_ATTRIBUTE_MEMORY_CACHED        0x0800
+#define EFI_PCI_IO_ATTRIBUTE_MEMORY_DISABLE       0x1000
+#define EFI_PCI_IO_ATTRIBUTE_EMBEDDED_DEVICE      0x2000
+#define EFI_PCI_IO_ATTRIBUTE_EMBEDDED_ROM         0x4000
+#define EFI_PCI_IO_ATTRIBUTE_DUAL_ADDRESS_CYCLE   0x8000
+#define EFI_PCI_IO_ATTRIBUTE_ISA_IO_16            0x10000
+#define EFI_PCI_IO_ATTRIBUTE_VGA_PALETTE_IO_16    0x20000
+#define EFI_PCI_IO_ATTRIBUTE_VGA_IO_16            0x40000
+
+typedef enum {
+    EfiPciIoAttributeOperationGet,
+    EfiPciIoAttributeOperationSet,
+    EfiPciIoAttributeOperationEnable,
+    EfiPciIoAttributeOperationDisable,
+    EfiPciIoAttributeOperationSupported,
+    EfiPciIoAttributeOperationMaximum
+} EFI_PCI_IO_PROTOCOL_ATTRIBUTE_OPERATION;
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PCI_IO_PROTOCOL_ATTRIBUTES) (
+  IN struct _EFI_PCI_IO             *This,
+  IN EFI_PCI_IO_PROTOCOL_ATTRIBUTE_OPERATION Operation,
+  IN UINT64                                  Attributes,
+  OUT UINT64                                 *Result OPTIONAL
+  );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PCI_IO_PROTOCOL_GET_BAR_ATTRIBUTES) (
+  IN struct _EFI_PCI_IO *This,
+  IN UINT8                      BarIndex,
+  OUT UINT64                    *Supports OPTIONAL,
+  OUT VOID                      **Resources OPTIONAL
+  );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PCI_IO_PROTOCOL_SET_BAR_ATTRIBUTES) (
+  IN struct _EFI_PCI_IO *This,
+  IN UINT64                     Attributes,
+  IN UINT8                      BarIndex,
+  IN OUT UINT64                 *Offset,
+  IN OUT UINT64                 *Length
+  );
+
+typedef struct _EFI_PCI_IO {
+  EFI_PCI_IO_PROTOCOL_POLL_IO_MEM        PollMem;
+  EFI_PCI_IO_PROTOCOL_POLL_IO_MEM        PollIo;
+  EFI_PCI_IO_PROTOCOL_ACCESS             Mem;
+  EFI_PCI_IO_PROTOCOL_ACCESS             Io;
+  EFI_PCI_IO_PROTOCOL_CONFIG_ACCESS      Pci;
+  EFI_PCI_IO_PROTOCOL_COPY_MEM           CopyMem;
+  EFI_PCI_IO_PROTOCOL_MAP                Map;
+  EFI_PCI_IO_PROTOCOL_UNMAP              Unmap;
+  EFI_PCI_IO_PROTOCOL_ALLOCATE_BUFFER    AllocateBuffer;
+  EFI_PCI_IO_PROTOCOL_FREE_BUFFER        FreeBuffer;
+  EFI_PCI_IO_PROTOCOL_FLUSH              Flush;
+  EFI_PCI_IO_PROTOCOL_GET_LOCATION       GetLocation;
+  EFI_PCI_IO_PROTOCOL_ATTRIBUTES         Attributes;
+  EFI_PCI_IO_PROTOCOL_GET_BAR_ATTRIBUTES GetBarAttributes;
+  EFI_PCI_IO_PROTOCOL_SET_BAR_ATTRIBUTES SetBarAttributes;
+  UINT64                                 RomSize;
+  VOID                                   *RomImage;
+} EFI_PCI_IO;
+
+#endif /* _EFI_PCI_IO_H */
diff --git a/linux-x86/gnu-efi/include/efi/efiprot.h b/linux-x86/gnu-efi/include/efi/efiprot.h
new file mode 100644
index 0000000..a6df337
--- /dev/null
+++ b/linux-x86/gnu-efi/include/efi/efiprot.h
@@ -0,0 +1,736 @@
+#ifndef _EFI_PROT_H
+#define _EFI_PROT_H
+
+/*++
+
+Copyright (c) 1998  Intel Corporation
+
+Module Name:
+
+    efiprot.h
+
+Abstract:
+
+    EFI Protocols
+
+
+
+Revision History
+
+--*/
+
+//
+//  FPSWA library protocol
+//
+#define FPSWA_PROTOCOL          \
+    { 0xc41b6531, 0x97b9, 0x11d3, {0x9a, 0x29, 0x0, 0x90, 0x27, 0x3f, 0xc1, 0x4d} }
+
+//
+// Device Path protocol
+//
+
+#define DEVICE_PATH_PROTOCOL    \
+    { 0x9576e91, 0x6d3f, 0x11d2, {0x8e, 0x39, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b} }
+
+
+//
+// Block IO protocol
+//
+
+#define BLOCK_IO_PROTOCOL \
+    { 0x964e5b21, 0x6459, 0x11d2, {0x8e, 0x39, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b} }
+#define EFI_BLOCK_IO_INTERFACE_REVISION   0x00010000
+#define EFI_BLOCK_IO_INTERFACE_REVISION2  0x00020001
+#define EFI_BLOCK_IO_INTERFACE_REVISION3  ((2<<16) | 31)
+
+INTERFACE_DECL(_EFI_BLOCK_IO);
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_BLOCK_RESET) (
+    IN struct _EFI_BLOCK_IO     *This,
+    IN BOOLEAN                  ExtendedVerification
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_BLOCK_READ) (
+    IN struct _EFI_BLOCK_IO     *This,
+    IN UINT32                   MediaId,
+    IN EFI_LBA                  LBA,
+    IN UINTN                    BufferSize,
+    OUT VOID                    *Buffer
+    );
+
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_BLOCK_WRITE) (
+    IN struct _EFI_BLOCK_IO     *This,
+    IN UINT32                   MediaId,
+    IN EFI_LBA                  LBA,
+    IN UINTN                    BufferSize,
+    IN VOID                     *Buffer
+    );
+
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_BLOCK_FLUSH) (
+    IN struct _EFI_BLOCK_IO     *This
+    );
+
+
+
+typedef struct {
+    UINT32              MediaId;
+    BOOLEAN             RemovableMedia;
+    BOOLEAN             MediaPresent;
+
+    BOOLEAN             LogicalPartition;
+    BOOLEAN             ReadOnly;
+    BOOLEAN             WriteCaching;
+
+    UINT32              BlockSize;
+    UINT32              IoAlign;
+
+    EFI_LBA             LastBlock;
+
+    /* revision 2 */
+    EFI_LBA             LowestAlignedLba;
+    UINT32              LogicalBlocksPerPhysicalBlock;
+    /* revision 3 */
+    UINT32              OptimalTransferLengthGranularity;
+} EFI_BLOCK_IO_MEDIA;
+
+typedef struct _EFI_BLOCK_IO {
+    UINT64                  Revision;
+
+    EFI_BLOCK_IO_MEDIA      *Media;
+
+    EFI_BLOCK_RESET         Reset;
+    EFI_BLOCK_READ          ReadBlocks;
+    EFI_BLOCK_WRITE         WriteBlocks;
+    EFI_BLOCK_FLUSH         FlushBlocks;
+
+} EFI_BLOCK_IO;
+
+
+
+//
+// Disk Block IO protocol
+//
+
+#define DISK_IO_PROTOCOL \
+    { 0xce345171, 0xba0b, 0x11d2,  {0x8e, 0x4f, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b} }
+#define EFI_DISK_IO_INTERFACE_REVISION   0x00010000
+
+INTERFACE_DECL(_EFI_DISK_IO);
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_DISK_READ) (
+    IN struct _EFI_DISK_IO      *This,
+    IN UINT32                   MediaId,
+    IN UINT64                   Offset,
+    IN UINTN                    BufferSize,
+    OUT VOID                    *Buffer
+    );
+
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_DISK_WRITE) (
+    IN struct _EFI_DISK_IO      *This,
+    IN UINT32                   MediaId,
+    IN UINT64                   Offset,
+    IN UINTN                    BufferSize,
+    IN VOID                     *Buffer
+    );
+
+
+typedef struct _EFI_DISK_IO {
+    UINT64              Revision;
+    EFI_DISK_READ       ReadDisk;
+    EFI_DISK_WRITE      WriteDisk;
+} EFI_DISK_IO;
+
+
+//
+// Simple file system protocol
+//
+
+#define SIMPLE_FILE_SYSTEM_PROTOCOL \
+    { 0x964e5b22, 0x6459, 0x11d2, {0x8e, 0x39, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b} }
+
+INTERFACE_DECL(_EFI_FILE_IO_INTERFACE);
+INTERFACE_DECL(_EFI_FILE_HANDLE);
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_VOLUME_OPEN) (
+    IN struct _EFI_FILE_IO_INTERFACE    *This,
+    OUT struct _EFI_FILE_HANDLE         **Root
+    );
+
+#define EFI_FILE_IO_INTERFACE_REVISION   0x00010000
+
+typedef struct _EFI_FILE_IO_INTERFACE {
+    UINT64                  Revision;
+    EFI_VOLUME_OPEN         OpenVolume;
+} EFI_FILE_IO_INTERFACE;
+
+//
+//
+//
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_FILE_OPEN) (
+    IN struct _EFI_FILE_HANDLE  *File,
+    OUT struct _EFI_FILE_HANDLE **NewHandle,
+    IN CHAR16                   *FileName,
+    IN UINT64                   OpenMode,
+    IN UINT64                   Attributes
+    );
+
+// Open modes
+#define EFI_FILE_MODE_READ      0x0000000000000001
+#define EFI_FILE_MODE_WRITE     0x0000000000000002
+#define EFI_FILE_MODE_CREATE    0x8000000000000000
+
+// File attributes
+#define EFI_FILE_READ_ONLY      0x0000000000000001
+#define EFI_FILE_HIDDEN         0x0000000000000002
+#define EFI_FILE_SYSTEM         0x0000000000000004
+#define EFI_FILE_RESERVIED      0x0000000000000008
+#define EFI_FILE_DIRECTORY      0x0000000000000010
+#define EFI_FILE_ARCHIVE        0x0000000000000020
+#define EFI_FILE_VALID_ATTR     0x0000000000000037
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_FILE_CLOSE) (
+    IN struct _EFI_FILE_HANDLE  *File
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_FILE_DELETE) (
+    IN struct _EFI_FILE_HANDLE  *File
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_FILE_READ) (
+    IN struct _EFI_FILE_HANDLE  *File,
+    IN OUT UINTN                *BufferSize,
+    OUT VOID                    *Buffer
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_FILE_WRITE) (
+    IN struct _EFI_FILE_HANDLE  *File,
+    IN OUT UINTN                *BufferSize,
+    IN VOID                     *Buffer
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_FILE_SET_POSITION) (
+    IN struct _EFI_FILE_HANDLE  *File,
+    IN UINT64                   Position
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_FILE_GET_POSITION) (
+    IN struct _EFI_FILE_HANDLE  *File,
+    OUT UINT64                  *Position
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_FILE_GET_INFO) (
+    IN struct _EFI_FILE_HANDLE  *File,
+    IN EFI_GUID                 *InformationType,
+    IN OUT UINTN                *BufferSize,
+    OUT VOID                    *Buffer
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_FILE_SET_INFO) (
+    IN struct _EFI_FILE_HANDLE  *File,
+    IN EFI_GUID                 *InformationType,
+    IN UINTN                    BufferSize,
+    IN VOID                     *Buffer
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_FILE_FLUSH) (
+    IN struct _EFI_FILE_HANDLE  *File
+    );
+
+
+
+#define EFI_FILE_HANDLE_REVISION         0x00010000
+typedef struct _EFI_FILE_HANDLE {
+    UINT64                  Revision;
+    EFI_FILE_OPEN           Open;
+    EFI_FILE_CLOSE          Close;
+    EFI_FILE_DELETE         Delete;
+    EFI_FILE_READ           Read;
+    EFI_FILE_WRITE          Write;
+    EFI_FILE_GET_POSITION   GetPosition;
+    EFI_FILE_SET_POSITION   SetPosition;
+    EFI_FILE_GET_INFO       GetInfo;
+    EFI_FILE_SET_INFO       SetInfo;
+    EFI_FILE_FLUSH          Flush;
+} EFI_FILE, *EFI_FILE_HANDLE;
+
+
+//
+// File information types
+//
+
+#define EFI_FILE_INFO_ID   \
+    { 0x9576e92, 0x6d3f, 0x11d2, {0x8e, 0x39, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b} }
+
+typedef struct {
+    UINT64                  Size;
+    UINT64                  FileSize;
+    UINT64                  PhysicalSize;
+    EFI_TIME                CreateTime;
+    EFI_TIME                LastAccessTime;
+    EFI_TIME                ModificationTime;
+    UINT64                  Attribute;
+    CHAR16                  FileName[1];
+} EFI_FILE_INFO;
+
+//
+// The FileName field of the EFI_FILE_INFO data structure is variable length.
+// Whenever code needs to know the size of the EFI_FILE_INFO data structure, it needs to
+// be the size of the data structure without the FileName field.  The following macro 
+// computes this size correctly no matter how big the FileName array is declared.
+// This is required to make the EFI_FILE_INFO data structure ANSI compilant. 
+//
+
+#define SIZE_OF_EFI_FILE_INFO EFI_FIELD_OFFSET(EFI_FILE_INFO,FileName)
+
+#define EFI_FILE_SYSTEM_INFO_ID    \
+    { 0x9576e93, 0x6d3f, 0x11d2, {0x8e, 0x39, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b} }
+
+typedef struct {
+    UINT64                  Size;
+    BOOLEAN                 ReadOnly;
+    UINT64                  VolumeSize;
+    UINT64                  FreeSpace;
+    UINT32                  BlockSize;
+    CHAR16                  VolumeLabel[1];
+} EFI_FILE_SYSTEM_INFO;
+
+//
+// The VolumeLabel field of the EFI_FILE_SYSTEM_INFO data structure is variable length.
+// Whenever code needs to know the size of the EFI_FILE_SYSTEM_INFO data structure, it needs
+// to be the size of the data structure without the VolumeLable field.  The following macro 
+// computes this size correctly no matter how big the VolumeLable array is declared.
+// This is required to make the EFI_FILE_SYSTEM_INFO data structure ANSI compilant. 
+//
+
+#define SIZE_OF_EFI_FILE_SYSTEM_INFO EFI_FIELD_OFFSET(EFI_FILE_SYSTEM_INFO,VolumeLabel)
+
+#define EFI_FILE_SYSTEM_VOLUME_LABEL_INFO_ID    \
+    { 0xDB47D7D3,0xFE81, 0x11d3, {0x9A, 0x35, 0x00, 0x90, 0x27, 0x3F, 0xC1, 0x4D} }
+
+typedef struct {
+    CHAR16                  VolumeLabel[1];
+} EFI_FILE_SYSTEM_VOLUME_LABEL_INFO;
+
+#define SIZE_OF_EFI_FILE_SYSTEM_VOLUME_LABEL_INFO EFI_FIELD_OFFSET(EFI_FILE_SYSTEM_VOLUME_LABEL_INFO,VolumeLabel)
+
+//
+// Load file protocol
+//
+
+
+#define LOAD_FILE_PROTOCOL \
+    { 0x56EC3091, 0x954C, 0x11d2, {0x8E, 0x3F, 0x00, 0xA0, 0xC9, 0x69, 0x72, 0x3B} }
+
+INTERFACE_DECL(_EFI_LOAD_FILE_INTERFACE);
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_LOAD_FILE) (
+    IN struct _EFI_LOAD_FILE_INTERFACE  *This,
+    IN EFI_DEVICE_PATH                  *FilePath,
+    IN BOOLEAN                          BootPolicy,
+    IN OUT UINTN                        *BufferSize,
+    IN VOID                             *Buffer OPTIONAL
+    );
+
+typedef struct _EFI_LOAD_FILE_INTERFACE {
+    EFI_LOAD_FILE                       LoadFile;
+} EFI_LOAD_FILE_INTERFACE;
+
+
+//
+// Device IO protocol
+//
+
+#define DEVICE_IO_PROTOCOL \
+    { 0xaf6ac311, 0x84c3, 0x11d2, {0x8e, 0x3c, 0x00, 0xa0, 0xc9, 0x69, 0x72, 0x3b} }
+
+INTERFACE_DECL(_EFI_DEVICE_IO_INTERFACE);
+
+typedef enum {
+    IO_UINT8,
+    IO_UINT16,
+    IO_UINT32,
+    IO_UINT64,
+//
+// Specification Change: Copy from MMIO to MMIO vs. MMIO to buffer, buffer to MMIO
+//
+    MMIO_COPY_UINT8,
+    MMIO_COPY_UINT16,
+    MMIO_COPY_UINT32,
+    MMIO_COPY_UINT64
+} EFI_IO_WIDTH;
+
+#define EFI_PCI_ADDRESS(_bus,_dev,_func) \
+    ( (UINT64) ( (((UINTN)_bus) << 24) + (((UINTN)_dev) << 16) + (((UINTN)_func) << 8) ) )
+
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_DEVICE_IO) (
+    IN struct _EFI_DEVICE_IO_INTERFACE *This,
+    IN EFI_IO_WIDTH                 Width,
+    IN UINT64                       Address,
+    IN UINTN                        Count,
+    IN OUT VOID                     *Buffer
+    );
+
+typedef struct {
+    EFI_DEVICE_IO                   Read;
+    EFI_DEVICE_IO                   Write;
+} EFI_IO_ACCESS;
+
+typedef 
+EFI_STATUS
+(EFIAPI *EFI_PCI_DEVICE_PATH) (
+    IN struct _EFI_DEVICE_IO_INTERFACE  *This,
+    IN UINT64                           Address,
+    IN OUT EFI_DEVICE_PATH              **PciDevicePath
+    );
+
+typedef enum {
+    EfiBusMasterRead,
+    EfiBusMasterWrite,
+    EfiBusMasterCommonBuffer
+} EFI_IO_OPERATION_TYPE;
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_IO_MAP) (
+    IN struct _EFI_DEVICE_IO_INTERFACE  *This,
+    IN EFI_IO_OPERATION_TYPE            Operation,
+    IN EFI_PHYSICAL_ADDRESS             *HostAddress,
+    IN OUT UINTN                        *NumberOfBytes,
+    OUT EFI_PHYSICAL_ADDRESS            *DeviceAddress,
+    OUT VOID                            **Mapping
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_IO_UNMAP) (
+    IN struct _EFI_DEVICE_IO_INTERFACE  *This,
+    IN VOID                             *Mapping
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_IO_ALLOCATE_BUFFER) (
+    IN struct _EFI_DEVICE_IO_INTERFACE  *This,
+    IN EFI_ALLOCATE_TYPE                Type,
+    IN EFI_MEMORY_TYPE                  MemoryType,
+    IN UINTN                            Pages,
+    IN OUT EFI_PHYSICAL_ADDRESS         *HostAddress
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_IO_FLUSH) (
+    IN struct _EFI_DEVICE_IO_INTERFACE  *This
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_IO_FREE_BUFFER) (
+    IN struct _EFI_DEVICE_IO_INTERFACE  *This,
+    IN UINTN                            Pages,
+    IN EFI_PHYSICAL_ADDRESS             HostAddress
+    );
+
+typedef struct _EFI_DEVICE_IO_INTERFACE {
+    EFI_IO_ACCESS                       Mem;
+    EFI_IO_ACCESS                       Io;
+    EFI_IO_ACCESS                       Pci;
+    EFI_IO_MAP                          Map;
+    EFI_PCI_DEVICE_PATH                 PciDevicePath;
+    EFI_IO_UNMAP                        Unmap;
+    EFI_IO_ALLOCATE_BUFFER              AllocateBuffer;
+    EFI_IO_FLUSH                        Flush;
+    EFI_IO_FREE_BUFFER                  FreeBuffer;
+} EFI_DEVICE_IO_INTERFACE;
+
+
+//
+// Unicode Collation protocol
+//
+
+#define UNICODE_COLLATION_PROTOCOL \
+    { 0x1d85cd7f, 0xf43d, 0x11d2, {0x9a, 0xc,  0x0, 0x90, 0x27, 0x3f, 0xc1, 0x4d} }
+
+#define UNICODE_BYTE_ORDER_MARK       (CHAR16)(0xfeff)
+
+INTERFACE_DECL(_EFI_UNICODE_COLLATION_INTERFACE);
+
+typedef
+INTN
+(EFIAPI *EFI_UNICODE_STRICOLL) (
+    IN struct _EFI_UNICODE_COLLATION_INTERFACE  *This,
+    IN CHAR16                         *s1,
+    IN CHAR16                         *s2
+    );
+
+typedef
+BOOLEAN
+(EFIAPI *EFI_UNICODE_METAIMATCH) (
+    IN struct _EFI_UNICODE_COLLATION_INTERFACE  *This,
+    IN CHAR16                         *String,
+    IN CHAR16                         *Pattern
+    );
+
+typedef
+VOID
+(EFIAPI *EFI_UNICODE_STRLWR) (
+    IN struct _EFI_UNICODE_COLLATION_INTERFACE  *This,
+    IN OUT CHAR16                       *Str
+    );
+
+typedef
+VOID
+(EFIAPI *EFI_UNICODE_STRUPR) (
+    IN struct _EFI_UNICODE_COLLATION_INTERFACE  *This,
+    IN OUT CHAR16                       *Str
+    );
+
+typedef
+VOID
+(EFIAPI *EFI_UNICODE_FATTOSTR) (
+    IN struct _EFI_UNICODE_COLLATION_INTERFACE  *This,
+    IN UINTN                            FatSize,
+    IN CHAR8                            *Fat,
+    OUT CHAR16                          *String
+    );
+
+typedef
+BOOLEAN
+(EFIAPI *EFI_UNICODE_STRTOFAT) (
+    IN struct _EFI_UNICODE_COLLATION_INTERFACE  *This,
+    IN CHAR16                           *String,
+    IN UINTN                            FatSize,
+    OUT CHAR8                           *Fat
+    );
+
+
+typedef struct _EFI_UNICODE_COLLATION_INTERFACE {
+
+    // general
+    EFI_UNICODE_STRICOLL                StriColl;
+    EFI_UNICODE_METAIMATCH              MetaiMatch;
+    EFI_UNICODE_STRLWR                  StrLwr;
+    EFI_UNICODE_STRUPR                  StrUpr;
+
+    // for supporting fat volumes
+    EFI_UNICODE_FATTOSTR                FatToStr;
+    EFI_UNICODE_STRTOFAT                StrToFat;
+
+    CHAR8                               *SupportedLanguages;
+} EFI_UNICODE_COLLATION_INTERFACE;
+
+/* Graphics output protocol */
+#define EFI_GRAPHICS_OUTPUT_PROTOCOL_GUID \
+  { \
+    0x9042a9de, 0x23dc, 0x4a38, {0x96, 0xfb, 0x7a, 0xde, 0xd0, 0x80, 0x51, 0x6a } \
+  }
+
+typedef struct _EFI_GRAPHICS_OUTPUT_PROTOCOL EFI_GRAPHICS_OUTPUT_PROTOCOL;
+
+typedef struct {
+  UINT32            RedMask;
+  UINT32            GreenMask;
+  UINT32            BlueMask;
+  UINT32            ReservedMask;
+} EFI_PIXEL_BITMASK;
+
+typedef enum {
+  PixelRedGreenBlueReserved8BitPerColor,
+  PixelBlueGreenRedReserved8BitPerColor,
+  PixelBitMask,
+  PixelBltOnly,
+  PixelFormatMax
+} EFI_GRAPHICS_PIXEL_FORMAT;
+
+typedef struct {
+  UINT32                     Version;
+  UINT32                     HorizontalResolution;
+  UINT32                     VerticalResolution;
+  EFI_GRAPHICS_PIXEL_FORMAT  PixelFormat;
+  EFI_PIXEL_BITMASK          PixelInformation;
+  UINT32                     PixelsPerScanLine;
+} EFI_GRAPHICS_OUTPUT_MODE_INFORMATION;
+
+/**
+  Return the current video mode information.
+
+  @param  This       Protocol instance pointer.
+  @param  ModeNumber The mode number to return information on.
+  @param  SizeOfInfo A pointer to the size, in bytes, of the Info buffer.
+  @param  Info       A pointer to callee allocated buffer that returns information about ModeNumber.
+
+  @retval EFI_SUCCESS           Mode information returned.
+  @retval EFI_BUFFER_TOO_SMALL  The Info buffer was too small.
+  @retval EFI_DEVICE_ERROR      A hardware error occurred trying to retrieve the video mode.
+  @retval EFI_NOT_STARTED       Video display is not initialized. Call SetMode ()
+  @retval EFI_INVALID_PARAMETER One of the input args was NULL.
+
+**/
+typedef
+EFI_STATUS
+(EFIAPI *EFI_GRAPHICS_OUTPUT_PROTOCOL_QUERY_MODE) (
+  IN  EFI_GRAPHICS_OUTPUT_PROTOCOL          *This,
+  IN  UINT32                                ModeNumber,
+  OUT UINTN                                 *SizeOfInfo,
+  OUT EFI_GRAPHICS_OUTPUT_MODE_INFORMATION  **Info
+  )
+;
+
+/**
+  Return the current video mode information.
+
+  @param  This              Protocol instance pointer.
+  @param  ModeNumber        The mode number to be set.
+
+  @retval EFI_SUCCESS       Graphics mode was changed.
+  @retval EFI_DEVICE_ERROR  The device had an error and could not complete the request.
+  @retval EFI_UNSUPPORTED   ModeNumber is not supported by this device.
+
+**/
+typedef
+EFI_STATUS
+(EFIAPI *EFI_GRAPHICS_OUTPUT_PROTOCOL_SET_MODE) (
+  IN  EFI_GRAPHICS_OUTPUT_PROTOCOL *This,
+  IN  UINT32                       ModeNumber
+  )
+;
+
+typedef struct {
+  UINT8 Blue;
+  UINT8 Green;
+  UINT8 Red;
+  UINT8 Reserved;
+} EFI_GRAPHICS_OUTPUT_BLT_PIXEL;
+
+typedef union {
+  EFI_GRAPHICS_OUTPUT_BLT_PIXEL Pixel;
+  UINT32                        Raw;
+} EFI_GRAPHICS_OUTPUT_BLT_PIXEL_UNION;
+
+typedef enum {
+  EfiBltVideoFill,
+  EfiBltVideoToBltBuffer,
+  EfiBltBufferToVideo, 
+  EfiBltVideoToVideo,
+  EfiGraphicsOutputBltOperationMax
+} EFI_GRAPHICS_OUTPUT_BLT_OPERATION;
+
+/**
+  The following table defines actions for BltOperations:
+
+  <B>EfiBltVideoFill</B> - Write data from the  BltBuffer pixel (SourceX, SourceY) 
+  directly to every pixel of the video display rectangle 
+  (DestinationX, DestinationY) (DestinationX + Width, DestinationY + Height). 
+  Only one pixel will be used from the BltBuffer. Delta is NOT used.
+
+  <B>EfiBltVideoToBltBuffer</B> - Read data from the video display rectangle 
+  (SourceX, SourceY) (SourceX + Width, SourceY + Height) and place it in 
+  the BltBuffer rectangle (DestinationX, DestinationY ) 
+  (DestinationX + Width, DestinationY + Height). If DestinationX or 
+  DestinationY is not zero then Delta must be set to the length in bytes 
+  of a row in the BltBuffer.
+
+  <B>EfiBltBufferToVideo</B> - Write data from the  BltBuffer rectangle 
+  (SourceX, SourceY) (SourceX + Width, SourceY + Height) directly to the 
+  video display rectangle (DestinationX, DestinationY) 
+  (DestinationX + Width, DestinationY + Height). If SourceX or SourceY is 
+  not zero then Delta must be set to the length in bytes of a row in the 
+  BltBuffer.
+
+  <B>EfiBltVideoToVideo</B> - Copy from the video display rectangle (SourceX, SourceY)
+  (SourceX + Width, SourceY + Height) .to the video display rectangle 
+  (DestinationX, DestinationY) (DestinationX + Width, DestinationY + Height). 
+  The BltBuffer and Delta  are not used in this mode.
+
+  @param  This         Protocol instance pointer.
+  @param  BltBuffer    Buffer containing data to blit into video buffer. This
+                       buffer has a size of Width*Height*sizeof(EFI_GRAPHICS_OUTPUT_BLT_PIXEL)
+  @param  BltOperation Operation to perform on BlitBuffer and video memory
+  @param  SourceX      X coordinate of source for the BltBuffer.
+  @param  SourceY      Y coordinate of source for the BltBuffer.
+  @param  DestinationX X coordinate of destination for the BltBuffer.
+  @param  DestinationY Y coordinate of destination for the BltBuffer.
+  @param  Width        Width of rectangle in BltBuffer in pixels.
+  @param  Height       Hight of rectangle in BltBuffer in pixels.
+  @param  Delta        OPTIONAL
+
+  @retval EFI_SUCCESS           The Blt operation completed.
+  @retval EFI_INVALID_PARAMETER BltOperation is not valid.
+  @retval EFI_DEVICE_ERROR      A hardware error occured writting to the video buffer.
+
+**/
+typedef
+EFI_STATUS
+(EFIAPI *EFI_GRAPHICS_OUTPUT_PROTOCOL_BLT) (
+  IN  EFI_GRAPHICS_OUTPUT_PROTOCOL            *This,
+  IN  EFI_GRAPHICS_OUTPUT_BLT_PIXEL           *BltBuffer,   OPTIONAL
+  IN  EFI_GRAPHICS_OUTPUT_BLT_OPERATION       BltOperation,
+  IN  UINTN                                   SourceX,
+  IN  UINTN                                   SourceY,
+  IN  UINTN                                   DestinationX,
+  IN  UINTN                                   DestinationY,
+  IN  UINTN                                   Width,
+  IN  UINTN                                   Height,
+  IN  UINTN                                   Delta         OPTIONAL
+  );
+
+typedef struct {
+  UINT32                                 MaxMode;
+  UINT32                                 Mode;
+  EFI_GRAPHICS_OUTPUT_MODE_INFORMATION   *Info;
+  UINTN                                  SizeOfInfo;
+  EFI_PHYSICAL_ADDRESS                   FrameBufferBase;
+  UINTN                                  FrameBufferSize;
+} EFI_GRAPHICS_OUTPUT_PROTOCOL_MODE;
+
+struct _EFI_GRAPHICS_OUTPUT_PROTOCOL {
+  EFI_GRAPHICS_OUTPUT_PROTOCOL_QUERY_MODE  QueryMode;
+  EFI_GRAPHICS_OUTPUT_PROTOCOL_SET_MODE    SetMode;
+  EFI_GRAPHICS_OUTPUT_PROTOCOL_BLT         Blt;
+  EFI_GRAPHICS_OUTPUT_PROTOCOL_MODE        *Mode;
+};
+#endif
+
diff --git a/linux-x86/gnu-efi/include/efi/efipxebc.h b/linux-x86/gnu-efi/include/efi/efipxebc.h
new file mode 100644
index 0000000..792d323
--- /dev/null
+++ b/linux-x86/gnu-efi/include/efi/efipxebc.h
@@ -0,0 +1,463 @@
+#ifndef _EFIPXEBC_H
+#define _EFIPXEBC_H
+
+/*++
+
+Copyright (c) 1998  Intel Corporation
+
+Module Name:
+
+    efipxebc.h
+
+Abstract:
+
+    EFI PXE Base Code Protocol
+
+
+
+Revision History
+
+--*/
+
+//
+// PXE Base Code protocol
+//
+
+#define EFI_PXE_BASE_CODE_PROTOCOL \
+    { 0x03c4e603, 0xac28, 0x11d3, {0x9a, 0x2d, 0x00, 0x90, 0x27, 0x3f, 0xc1, 0x4d} }
+
+INTERFACE_DECL(_EFI_PXE_BASE_CODE);
+
+#define DEFAULT_TTL 4
+#define DEFAULT_ToS 0
+//
+// Address definitions
+//
+
+typedef union {
+    UINT32      Addr[4];
+    EFI_IPv4_ADDRESS    v4;
+    EFI_IPv6_ADDRESS    v6;
+} EFI_IP_ADDRESS;
+
+typedef UINT16 EFI_PXE_BASE_CODE_UDP_PORT;
+
+//
+// Packet definitions
+//
+
+typedef struct {
+    UINT8                           BootpOpcode;
+    UINT8                           BootpHwType;
+    UINT8                           BootpHwAddrLen;
+    UINT8                           BootpGateHops;
+    UINT32                          BootpIdent;
+    UINT16                          BootpSeconds;
+    UINT16                          BootpFlags;
+    UINT8                           BootpCiAddr[4];
+    UINT8                           BootpYiAddr[4];
+    UINT8                           BootpSiAddr[4];
+    UINT8                           BootpGiAddr[4];
+    UINT8                           BootpHwAddr[16];
+    UINT8                           BootpSrvName[64];
+    UINT8                           BootpBootFile[128];
+    UINT32                          DhcpMagik;
+    UINT8                           DhcpOptions[56];
+} EFI_PXE_BASE_CODE_DHCPV4_PACKET;
+
+// TBD in EFI v1.1
+//typedef struct {
+//    UINT8                           reserved;
+//} EFI_PXE_BASE_CODE_DHCPV6_PACKET;
+
+typedef union {
+    UINT8                               Raw[1472];
+    EFI_PXE_BASE_CODE_DHCPV4_PACKET     Dhcpv4;
+//    EFI_PXE_BASE_CODE_DHCPV6_PACKET     Dhcpv6;
+} EFI_PXE_BASE_CODE_PACKET;
+
+typedef struct {
+    UINT8                   Type;
+    UINT8                   Code;
+    UINT16                  Checksum;
+    union {
+        UINT32              reserved;
+        UINT32              Mtu;
+        UINT32              Pointer;
+        struct {
+            UINT16          Identifier;
+            UINT16          Sequence;
+        } Echo;
+    } u;
+    UINT8                   Data[494];
+} EFI_PXE_BASE_CODE_ICMP_ERROR;
+
+typedef struct {
+    UINT8                   ErrorCode;
+    CHAR8                   ErrorString[127];
+} EFI_PXE_BASE_CODE_TFTP_ERROR;
+
+//
+// IP Receive Filter definitions
+//
+#define EFI_PXE_BASE_CODE_MAX_IPCNT             8
+typedef struct {
+    UINT8                       Filters;
+    UINT8                       IpCnt;
+    UINT16                      reserved;
+    EFI_IP_ADDRESS              IpList[EFI_PXE_BASE_CODE_MAX_IPCNT];
+} EFI_PXE_BASE_CODE_IP_FILTER;
+
+#define EFI_PXE_BASE_CODE_IP_FILTER_STATION_IP             0x0001
+#define EFI_PXE_BASE_CODE_IP_FILTER_BROADCAST              0x0002
+#define EFI_PXE_BASE_CODE_IP_FILTER_PROMISCUOUS            0x0004
+#define EFI_PXE_BASE_CODE_IP_FILTER_PROMISCUOUS_MULTICAST  0x0008
+
+//
+// ARP Cache definitions
+//
+
+typedef struct {
+    EFI_IP_ADDRESS       IpAddr;
+    EFI_MAC_ADDRESS      MacAddr;
+} EFI_PXE_BASE_CODE_ARP_ENTRY;
+
+typedef struct {
+    EFI_IP_ADDRESS       IpAddr;
+    EFI_IP_ADDRESS       SubnetMask;
+    EFI_IP_ADDRESS       GwAddr;
+} EFI_PXE_BASE_CODE_ROUTE_ENTRY;
+
+//
+// UDP definitions
+//
+
+#define EFI_PXE_BASE_CODE_UDP_OPFLAGS_ANY_SRC_IP    0x0001
+#define EFI_PXE_BASE_CODE_UDP_OPFLAGS_ANY_SRC_PORT  0x0002
+#define EFI_PXE_BASE_CODE_UDP_OPFLAGS_ANY_DEST_IP   0x0004
+#define EFI_PXE_BASE_CODE_UDP_OPFLAGS_ANY_DEST_PORT 0x0008
+#define EFI_PXE_BASE_CODE_UDP_OPFLAGS_USE_FILTER    0x0010
+#define EFI_PXE_BASE_CODE_UDP_OPFLAGS_MAY_FRAGMENT  0x0020
+
+//
+// Discover() definitions
+//
+
+#define EFI_PXE_BASE_CODE_BOOT_TYPE_BOOTSTRAP           0   
+#define EFI_PXE_BASE_CODE_BOOT_TYPE_MS_WINNT_RIS        1
+#define EFI_PXE_BASE_CODE_BOOT_TYPE_INTEL_LCM           2
+#define EFI_PXE_BASE_CODE_BOOT_TYPE_DOSUNDI             3
+#define EFI_PXE_BASE_CODE_BOOT_TYPE_NEC_ESMPRO          4
+#define EFI_PXE_BASE_CODE_BOOT_TYPE_IBM_WSoD            5
+#define EFI_PXE_BASE_CODE_BOOT_TYPE_IBM_LCCM            6
+#define EFI_PXE_BASE_CODE_BOOT_TYPE_CA_UNICENTER_TNG    7
+#define EFI_PXE_BASE_CODE_BOOT_TYPE_HP_OPENVIEW         8
+#define EFI_PXE_BASE_CODE_BOOT_TYPE_ALTIRIS_9           9
+#define EFI_PXE_BASE_CODE_BOOT_TYPE_ALTIRIS_10          10
+#define EFI_PXE_BASE_CODE_BOOT_TYPE_ALTIRIS_11          11
+#define EFI_PXE_BASE_CODE_BOOT_TYPE_NOT_USED_12         12
+#define EFI_PXE_BASE_CODE_BOOT_TYPE_REDHAT_INSTALL      13
+#define EFI_PXE_BASE_CODE_BOOT_TYPE_REDHAT_BOOT         14
+#define EFI_PXE_BASE_CODE_BOOT_TYPE_REMBO               15
+#define EFI_PXE_BASE_CODE_BOOT_TYPE_BEOBOOT             16
+//
+// 17 through 32767 are reserved
+// 32768 through 65279 are for vendor use
+// 65280 through 65534 are reserved
+//
+#define EFI_PXE_BASE_CODE_BOOT_TYPE_PXETEST             65535
+
+#define EFI_PXE_BASE_CODE_BOOT_LAYER_MASK               0x7FFF
+#define EFI_PXE_BASE_CODE_BOOT_LAYER_INITIAL            0x0000
+
+
+typedef struct {
+    UINT16                      Type;
+    BOOLEAN                     AcceptAnyResponse;
+    UINT8                       Reserved;
+    EFI_IP_ADDRESS              IpAddr;
+} EFI_PXE_BASE_CODE_SRVLIST;
+
+typedef struct {
+    BOOLEAN                     UseMCast;
+    BOOLEAN                     UseBCast;
+    BOOLEAN                     UseUCast;
+    BOOLEAN                     MustUseList;
+    EFI_IP_ADDRESS              ServerMCastIp;
+    UINT16                      IpCnt;
+    EFI_PXE_BASE_CODE_SRVLIST   SrvList[1];
+} EFI_PXE_BASE_CODE_DISCOVER_INFO;
+
+//
+// Mtftp() definitions
+//
+
+typedef enum {
+    EFI_PXE_BASE_CODE_TFTP_FIRST,
+    EFI_PXE_BASE_CODE_TFTP_GET_FILE_SIZE,
+    EFI_PXE_BASE_CODE_TFTP_READ_FILE,
+    EFI_PXE_BASE_CODE_TFTP_WRITE_FILE,
+    EFI_PXE_BASE_CODE_TFTP_READ_DIRECTORY,
+    EFI_PXE_BASE_CODE_MTFTP_GET_FILE_SIZE,
+    EFI_PXE_BASE_CODE_MTFTP_READ_FILE,
+    EFI_PXE_BASE_CODE_MTFTP_READ_DIRECTORY,
+    EFI_PXE_BASE_CODE_MTFTP_LAST
+} EFI_PXE_BASE_CODE_TFTP_OPCODE;
+
+typedef struct {
+    EFI_IP_ADDRESS   MCastIp;
+    EFI_PXE_BASE_CODE_UDP_PORT  CPort;
+    EFI_PXE_BASE_CODE_UDP_PORT  SPort;
+    UINT16                      ListenTimeout;
+    UINT16                      TransmitTimeout;
+} EFI_PXE_BASE_CODE_MTFTP_INFO;
+
+//
+// PXE Base Code Mode structure
+//
+
+#define EFI_PXE_BASE_CODE_MAX_ARP_ENTRIES       8
+#define EFI_PXE_BASE_CODE_MAX_ROUTE_ENTRIES     8
+
+typedef struct {
+    BOOLEAN                         Started;
+    BOOLEAN                         Ipv6Available;
+    BOOLEAN                         Ipv6Supported;
+    BOOLEAN                         UsingIpv6;
+    BOOLEAN                         BisSupported;
+    BOOLEAN                         BisDetected;
+    BOOLEAN                         AutoArp;
+    BOOLEAN                         SendGUID;
+    BOOLEAN                         DhcpDiscoverValid;
+    BOOLEAN                         DhcpAckReceived;
+    BOOLEAN                         ProxyOfferReceived;
+    BOOLEAN                         PxeDiscoverValid;
+    BOOLEAN                         PxeReplyReceived;
+    BOOLEAN                         PxeBisReplyReceived;
+    BOOLEAN                         IcmpErrorReceived;
+    BOOLEAN                         TftpErrorReceived;
+    BOOLEAN                         MakeCallbacks;
+    UINT8                           TTL;
+    UINT8                           ToS;
+    EFI_IP_ADDRESS                  StationIp;
+    EFI_IP_ADDRESS                  SubnetMask;
+    EFI_PXE_BASE_CODE_PACKET        DhcpDiscover;
+    EFI_PXE_BASE_CODE_PACKET        DhcpAck;
+    EFI_PXE_BASE_CODE_PACKET        ProxyOffer;
+    EFI_PXE_BASE_CODE_PACKET        PxeDiscover;
+    EFI_PXE_BASE_CODE_PACKET        PxeReply;
+    EFI_PXE_BASE_CODE_PACKET        PxeBisReply;
+    EFI_PXE_BASE_CODE_IP_FILTER     IpFilter;
+    UINT32                          ArpCacheEntries;
+    EFI_PXE_BASE_CODE_ARP_ENTRY     ArpCache[EFI_PXE_BASE_CODE_MAX_ARP_ENTRIES];
+    UINT32                          RouteTableEntries;
+    EFI_PXE_BASE_CODE_ROUTE_ENTRY   RouteTable[EFI_PXE_BASE_CODE_MAX_ROUTE_ENTRIES];
+    EFI_PXE_BASE_CODE_ICMP_ERROR    IcmpError;
+    EFI_PXE_BASE_CODE_TFTP_ERROR    TftpError;
+} EFI_PXE_BASE_CODE_MODE;
+
+//
+// PXE Base Code Interface Function definitions
+//
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PXE_BASE_CODE_START) (
+    IN struct _EFI_PXE_BASE_CODE    *This,
+    IN BOOLEAN                      UseIpv6
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PXE_BASE_CODE_STOP) (
+    IN struct _EFI_PXE_BASE_CODE    *This
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PXE_BASE_CODE_DHCP) (
+    IN struct _EFI_PXE_BASE_CODE    *This,
+    IN BOOLEAN                      SortOffers
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PXE_BASE_CODE_DISCOVER) (
+    IN struct _EFI_PXE_BASE_CODE            *This,
+    IN UINT16                               Type,
+    IN UINT16                               *Layer,
+    IN BOOLEAN                              UseBis,
+    IN OUT EFI_PXE_BASE_CODE_DISCOVER_INFO  *Info   OPTIONAL
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PXE_BASE_CODE_MTFTP) (
+    IN struct _EFI_PXE_BASE_CODE        *This,
+    IN EFI_PXE_BASE_CODE_TFTP_OPCODE    Operation,
+    IN OUT VOID                         *BufferPtr  OPTIONAL,
+    IN BOOLEAN                          Overwrite,
+    IN OUT UINTN                        *BufferSize,
+    IN UINTN                            *BlockSize  OPTIONAL,
+    IN EFI_IP_ADDRESS                   *ServerIp,
+    IN UINT8                            *Filename,
+    IN EFI_PXE_BASE_CODE_MTFTP_INFO     *Info       OPTIONAL,
+    IN BOOLEAN                          DontUseBuffer
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PXE_BASE_CODE_UDP_WRITE) (
+    IN struct _EFI_PXE_BASE_CODE        *This,
+    IN UINT16                           OpFlags,
+    IN EFI_IP_ADDRESS                   *DestIp,
+    IN EFI_PXE_BASE_CODE_UDP_PORT       *DestPort,
+    IN EFI_IP_ADDRESS                   *GatewayIp,  OPTIONAL
+    IN EFI_IP_ADDRESS                   *SrcIp,      OPTIONAL
+    IN OUT EFI_PXE_BASE_CODE_UDP_PORT   *SrcPort,    OPTIONAL
+    IN UINTN                            *HeaderSize, OPTIONAL
+    IN VOID                             *HeaderPtr,  OPTIONAL
+    IN UINTN                            *BufferSize,
+    IN VOID                             *BufferPtr
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PXE_BASE_CODE_UDP_READ) (
+    IN struct _EFI_PXE_BASE_CODE        *This,
+    IN UINT16                           OpFlags,
+    IN OUT EFI_IP_ADDRESS               *DestIp,      OPTIONAL
+    IN OUT EFI_PXE_BASE_CODE_UDP_PORT   *DestPort,    OPTIONAL
+    IN OUT EFI_IP_ADDRESS               *SrcIp,       OPTIONAL
+    IN OUT EFI_PXE_BASE_CODE_UDP_PORT   *SrcPort,     OPTIONAL
+    IN UINTN                            *HeaderSize,  OPTIONAL
+    IN VOID                             *HeaderPtr,   OPTIONAL
+    IN OUT UINTN                        *BufferSize,
+    IN VOID                             *BufferPtr
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PXE_BASE_CODE_SET_IP_FILTER) (
+    IN struct _EFI_PXE_BASE_CODE    *This,
+    IN EFI_PXE_BASE_CODE_IP_FILTER  *NewFilter
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PXE_BASE_CODE_ARP) (
+    IN struct _EFI_PXE_BASE_CODE    *This,
+    IN EFI_IP_ADDRESS               *IpAddr,      
+    IN EFI_MAC_ADDRESS              *MacAddr      OPTIONAL
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PXE_BASE_CODE_SET_PARAMETERS) (
+    IN struct _EFI_PXE_BASE_CODE    *This,
+    IN BOOLEAN                      *NewAutoArp,    OPTIONAL
+    IN BOOLEAN                      *NewSendGUID,   OPTIONAL
+    IN UINT8                        *NewTTL,        OPTIONAL
+    IN UINT8                        *NewToS,        OPTIONAL
+    IN BOOLEAN                      *NewMakeCallback    OPTIONAL
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PXE_BASE_CODE_SET_STATION_IP) (
+    IN struct _EFI_PXE_BASE_CODE    *This,
+    IN EFI_IP_ADDRESS               *NewStationIp,  OPTIONAL
+    IN EFI_IP_ADDRESS               *NewSubnetMask  OPTIONAL
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PXE_BASE_CODE_SET_PACKETS) (
+    IN struct _EFI_PXE_BASE_CODE    *This,
+    BOOLEAN                         *NewDhcpDiscoverValid,  OPTIONAL
+    BOOLEAN                         *NewDhcpAckReceived,    OPTIONAL
+    BOOLEAN                         *NewProxyOfferReceived, OPTIONAL
+    BOOLEAN                         *NewPxeDiscoverValid,   OPTIONAL
+    BOOLEAN                         *NewPxeReplyReceived,   OPTIONAL
+    BOOLEAN                         *NewPxeBisReplyReceived,OPTIONAL
+    IN EFI_PXE_BASE_CODE_PACKET     *NewDhcpDiscover, OPTIONAL
+    IN EFI_PXE_BASE_CODE_PACKET     *NewDhcpAck,      OPTIONAL
+    IN EFI_PXE_BASE_CODE_PACKET     *NewProxyOffer,   OPTIONAL
+    IN EFI_PXE_BASE_CODE_PACKET     *NewPxeDiscover,  OPTIONAL
+    IN EFI_PXE_BASE_CODE_PACKET     *NewPxeReply,     OPTIONAL
+    IN EFI_PXE_BASE_CODE_PACKET     *NewPxeBisReply   OPTIONAL
+    );
+
+//
+// PXE Base Code Protocol structure
+//
+
+#define EFI_PXE_BASE_CODE_INTERFACE_REVISION    0x00010000
+
+typedef struct _EFI_PXE_BASE_CODE {
+    UINT64                              Revision;
+    EFI_PXE_BASE_CODE_START             Start;
+    EFI_PXE_BASE_CODE_STOP              Stop;
+    EFI_PXE_BASE_CODE_DHCP              Dhcp;
+    EFI_PXE_BASE_CODE_DISCOVER          Discover;
+    EFI_PXE_BASE_CODE_MTFTP             Mtftp;
+    EFI_PXE_BASE_CODE_UDP_WRITE         UdpWrite;
+    EFI_PXE_BASE_CODE_UDP_READ          UdpRead;
+    EFI_PXE_BASE_CODE_SET_IP_FILTER     SetIpFilter;
+    EFI_PXE_BASE_CODE_ARP               Arp;
+    EFI_PXE_BASE_CODE_SET_PARAMETERS    SetParameters;
+    EFI_PXE_BASE_CODE_SET_STATION_IP    SetStationIp;
+    EFI_PXE_BASE_CODE_SET_PACKETS       SetPackets;
+    EFI_PXE_BASE_CODE_MODE              *Mode;
+} EFI_PXE_BASE_CODE;
+
+//
+// Call Back Definitions
+//
+
+#define EFI_PXE_BASE_CODE_CALLBACK_PROTOCOL \
+    { 0x245dca21, 0xfb7b, 0x11d3, {0x8f, 0x01, 0x00, 0xa0, 0xc9, 0x69, 0x72, 0x3b} }
+
+//
+// Revision Number
+//
+
+#define EFI_PXE_BASE_CODE_CALLBACK_INTERFACE_REVISION   0x00010000
+
+INTERFACE_DECL(_EFI_PXE_BASE_CODE_CALLBACK);
+
+typedef enum {
+    EFI_PXE_BASE_CODE_FUNCTION_FIRST,
+    EFI_PXE_BASE_CODE_FUNCTION_DHCP,
+    EFI_PXE_BASE_CODE_FUNCTION_DISCOVER,
+    EFI_PXE_BASE_CODE_FUNCTION_MTFTP,
+    EFI_PXE_BASE_CODE_FUNCTION_UDP_WRITE,
+    EFI_PXE_BASE_CODE_FUNCTION_UDP_READ,
+    EFI_PXE_BASE_CODE_FUNCTION_ARP,
+    EFI_PXE_BASE_CODE_FUNCTION_IGMP,
+    EFI_PXE_BASE_CODE_PXE_FUNCTION_LAST
+} EFI_PXE_BASE_CODE_FUNCTION;
+
+typedef enum {
+    EFI_PXE_BASE_CODE_CALLBACK_STATUS_FIRST,
+    EFI_PXE_BASE_CODE_CALLBACK_STATUS_CONTINUE,
+    EFI_PXE_BASE_CODE_CALLBACK_STATUS_ABORT,
+    EFI_PXE_BASE_CODE_CALLBACK_STATUS_LAST
+} EFI_PXE_BASE_CODE_CALLBACK_STATUS;
+
+typedef
+EFI_PXE_BASE_CODE_CALLBACK_STATUS 
+(EFIAPI *EFI_PXE_CALLBACK) (
+    IN struct _EFI_PXE_BASE_CODE_CALLBACK   *This,
+    IN EFI_PXE_BASE_CODE_FUNCTION           Function,
+    IN BOOLEAN                              Received,
+    IN UINT32                               PacketLen,
+    IN EFI_PXE_BASE_CODE_PACKET             *Packet     OPTIONAL
+    );
+
+typedef struct _EFI_PXE_BASE_CODE_CALLBACK {
+    UINT64                      Revision;
+    EFI_PXE_CALLBACK            Callback;
+} EFI_PXE_BASE_CODE_CALLBACK;
+
+#endif /* _EFIPXEBC_H */
diff --git a/linux-x86/gnu-efi/include/efi/efirtlib.h b/linux-x86/gnu-efi/include/efi/efirtlib.h
new file mode 100644
index 0000000..0100180
--- /dev/null
+++ b/linux-x86/gnu-efi/include/efi/efirtlib.h
@@ -0,0 +1,141 @@
+#ifndef _EFI_RT_LIB_INCLUDE_
+#define _EFI_RT_LIB_INCLUDE_
+/*++
+
+Copyright (c) 1998  Intel Corporation
+
+Module Name:
+
+    efilib.h
+
+Abstract:
+
+    EFI Runtime library functions
+
+
+
+Revision History
+
+--*/
+
+#include "efidebug.h"
+#include "efipart.h"
+#include "efilibplat.h"
+
+
+VOID
+RUNTIMEFUNCTION
+RtZeroMem (
+    IN VOID     *Buffer,
+    IN UINTN     Size
+    );
+
+VOID
+RUNTIMEFUNCTION
+RtSetMem (
+    IN VOID     *Buffer,
+    IN UINTN    Size,
+    IN UINT8    Value    
+    );
+
+VOID
+RUNTIMEFUNCTION
+RtCopyMem (
+    IN VOID     *Dest,
+    IN VOID     *Src,
+    IN UINTN    len
+    );
+
+INTN
+RUNTIMEFUNCTION
+RtCompareMem (
+    IN VOID     *Dest,
+    IN VOID     *Src,
+    IN UINTN    len
+    );
+
+INTN
+RUNTIMEFUNCTION
+RtStrCmp (
+    IN CHAR16   *s1,
+    IN CHAR16   *s2
+    );
+
+
+VOID
+RUNTIMEFUNCTION
+RtStrCpy (
+    IN CHAR16   *Dest,
+    IN CHAR16    *Src
+    );
+
+VOID
+RUNTIMEFUNCTION
+RtStrCat (
+    IN CHAR16   *Dest,
+    IN CHAR16   *Src
+    );
+
+UINTN
+RUNTIMEFUNCTION
+RtStrLen (
+    IN CHAR16   *s1
+    );
+
+UINTN
+RUNTIMEFUNCTION
+RtStrSize (
+    IN CHAR16   *s1
+    );
+
+INTN
+RUNTIMEFUNCTION
+RtCompareGuid (
+    IN EFI_GUID     *Guid1,
+    IN EFI_GUID     *Guid2
+    );
+
+UINT8
+RUNTIMEFUNCTION
+RtDecimaltoBCD(
+    IN  UINT8 BcdValue
+    );
+
+UINT8
+RUNTIMEFUNCTION
+RtBCDtoDecimal(
+    IN  UINT8 BcdValue
+    );
+
+//
+// Virtual mapping transition support.  (Only used during
+// the virtual address change transisition)
+//
+
+VOID
+RUNTIMEFUNCTION
+RtLibEnableVirtualMappings (
+    VOID
+    );
+
+VOID
+RUNTIMEFUNCTION
+RtConvertList (
+    IN UINTN            DebugDisposition,
+    IN OUT LIST_ENTRY   *ListHead
+    );
+
+VOID
+RUNTIMEFUNCTION
+RtAcquireLock (
+    IN FLOCK    *Lock
+    );
+
+VOID
+RUNTIMEFUNCTION
+RtReleaseLock (
+    IN FLOCK    *Lock
+    );
+
+
+#endif
diff --git a/linux-x86/gnu-efi/include/efi/efiser.h b/linux-x86/gnu-efi/include/efi/efiser.h
new file mode 100644
index 0000000..fcc97a1
--- /dev/null
+++ b/linux-x86/gnu-efi/include/efi/efiser.h
@@ -0,0 +1,132 @@
+#ifndef _EFI_SER_H
+#define _EFI_SER_H
+
+/*++
+
+Copyright (c) 1998  Intel Corporation
+
+Module Name:
+
+    efiser.h
+
+Abstract:
+
+    EFI serial protocol
+
+Revision History
+
+--*/
+
+//
+// Serial protocol
+//
+
+#define SERIAL_IO_PROTOCOL \
+    { 0xBB25CF6F, 0xF1D4, 0x11D2, {0x9A, 0x0C, 0x00, 0x90, 0x27, 0x3F, 0xC1, 0xFD} }
+
+INTERFACE_DECL(_SERIAL_IO_INTERFACE);
+
+typedef enum {
+    DefaultParity,      
+    NoParity,           
+    EvenParity,
+    OddParity,
+    MarkParity,
+    SpaceParity
+} EFI_PARITY_TYPE;
+
+typedef enum {
+    DefaultStopBits,        
+    OneStopBit,         // 1 stop bit
+    OneFiveStopBits,    // 1.5 stop bits
+    TwoStopBits         // 2 stop bits
+} EFI_STOP_BITS_TYPE;
+
+#define EFI_SERIAL_CLEAR_TO_SEND                   0x0010  // RO
+#define EFI_SERIAL_DATA_SET_READY                  0x0020  // RO
+#define EFI_SERIAL_RING_INDICATE                   0x0040  // RO
+#define EFI_SERIAL_CARRIER_DETECT                  0x0080  // RO
+#define EFI_SERIAL_REQUEST_TO_SEND                 0x0002  // WO
+#define EFI_SERIAL_DATA_TERMINAL_READY             0x0001  // WO
+#define EFI_SERIAL_INPUT_BUFFER_EMPTY              0x0100  // RO
+#define EFI_SERIAL_OUTPUT_BUFFER_EMPTY             0x0200  // RO
+#define EFI_SERIAL_HARDWARE_LOOPBACK_ENABLE        0x1000  // RW
+#define EFI_SERIAL_SOFTWARE_LOOPBACK_ENABLE        0x2000  // RW
+#define EFI_SERIAL_HARDWARE_FLOW_CONTROL_ENABLE    0x4000  // RW
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_SERIAL_RESET) (
+    IN struct _SERIAL_IO_INTERFACE  *This
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_SERIAL_SET_ATTRIBUTES) (
+    IN struct _SERIAL_IO_INTERFACE  *This,
+    IN UINT64                       BaudRate,
+    IN UINT32                       ReceiveFifoDepth,
+    IN UINT32                       Timeout,
+    IN EFI_PARITY_TYPE              Parity,
+    IN UINT8                        DataBits,
+    IN EFI_STOP_BITS_TYPE           StopBits
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_SERIAL_SET_CONTROL_BITS) (
+    IN struct _SERIAL_IO_INTERFACE  *This,
+    IN UINT32                       Control
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_SERIAL_GET_CONTROL_BITS) (
+    IN struct _SERIAL_IO_INTERFACE  *This,
+    OUT UINT32                      *Control
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_SERIAL_WRITE) (
+    IN struct _SERIAL_IO_INTERFACE  *This,
+    IN OUT UINTN                    *BufferSize,
+    IN VOID                         *Buffer
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_SERIAL_READ) (
+    IN struct _SERIAL_IO_INTERFACE  *This,
+    IN OUT UINTN                    *BufferSize,
+    OUT VOID                        *Buffer
+    );
+
+typedef struct {
+    UINT32                  ControlMask;
+
+    // current Attributes
+    UINT32                  Timeout;
+    UINT64                  BaudRate;
+    UINT32                  ReceiveFifoDepth;
+    UINT32                  DataBits;
+    UINT32                  Parity;
+    UINT32                  StopBits;
+} SERIAL_IO_MODE;
+
+#define SERIAL_IO_INTERFACE_REVISION    0x00010000
+
+typedef struct _SERIAL_IO_INTERFACE {
+    UINT32                       Revision;
+    EFI_SERIAL_RESET             Reset;
+    EFI_SERIAL_SET_ATTRIBUTES    SetAttributes;
+    EFI_SERIAL_SET_CONTROL_BITS  SetControl;
+    EFI_SERIAL_GET_CONTROL_BITS  GetControl;
+    EFI_SERIAL_WRITE             Write;
+    EFI_SERIAL_READ              Read;
+
+    SERIAL_IO_MODE               *Mode;
+} SERIAL_IO_INTERFACE;
+
+#endif
+
diff --git a/linux-x86/gnu-efi/include/efi/efistdarg.h b/linux-x86/gnu-efi/include/efi/efistdarg.h
new file mode 100644
index 0000000..8a96b94
--- /dev/null
+++ b/linux-x86/gnu-efi/include/efi/efistdarg.h
@@ -0,0 +1,33 @@
+#ifndef _EFISTDARG_H_
+#define _EFISTDARG_H_
+
+/*++
+
+Copyright (c) 1998  Intel Corporation
+
+Module Name:
+
+    devpath.h
+
+Abstract:
+
+    Defines for parsing the EFI Device Path structures
+
+
+
+Revision History
+
+--*/
+#ifdef __GNUC__
+#include "stdarg.h"
+#else
+#define _INTSIZEOF(n)   ( (sizeof(n) + sizeof(UINTN) - 1) & ~(sizeof(UINTN) - 1) )
+
+typedef CHAR8 * va_list;
+
+#define va_start(ap,v)  ( ap = (va_list)&v + _INTSIZEOF(v) )
+#define va_arg(ap,t)    ( *(t *)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)) )
+#define va_end(ap)  ( ap = (va_list)0 )
+#endif
+
+#endif  /* _INC_STDARG */
diff --git a/linux-x86/gnu-efi/include/efi/efiui.h b/linux-x86/gnu-efi/include/efi/efiui.h
new file mode 100644
index 0000000..7341943
--- /dev/null
+++ b/linux-x86/gnu-efi/include/efi/efiui.h
@@ -0,0 +1,54 @@
+#ifndef _EFI_UI_H
+#define _EFI_UI_H
+
+/*++
+
+Copyright (c) 200  Intel Corporation
+
+Module Name:
+
+    EfiUi.h
+    
+Abstract:   
+    Protocol used to build User Interface (UI) stuff.
+
+    This protocol is just data. It is a multi dimentional array.
+    For each string there is an array of UI_STRING_ENTRY. Each string
+    is for a different language translation of the same string. The list 
+    is terminated by a NULL UiString. There can be any number of 
+    UI_STRING_ENTRY arrays. A NULL array terminates the list. A NULL array
+    entry contains all zeros.  
+
+    Thus the shortest possible EFI_UI_PROTOCOL has three UI_STRING_ENTRY.
+    The String, it's NULL terminator, and the NULL terminator for the entire 
+    thing.
+
+
+Revision History
+
+--*/
+
+#define EFI_UI_PROTOCOL \
+    { 0x32dd7981, 0x2d27, 0x11d4, {0xbc, 0x8b, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81} }
+
+
+typedef enum {
+    UiDeviceString,
+    UiVendorString,
+    UiMaxString
+} UI_STRING_TYPE;
+
+typedef struct {
+    ISO_639_2   *LangCode;
+    CHAR16      *UiString;
+} UI_STRING_ENTRY;
+
+#define EFI_UI_VERSION      0x00010000
+
+typedef struct _UI_INTERFACE {
+    UINT32          Version;
+    UI_STRING_ENTRY *Entry;
+} UI_INTERFACE;
+
+
+#endif
diff --git a/linux-x86/gnu-efi/include/efi/ia32/efibind.h b/linux-x86/gnu-efi/include/efi/ia32/efibind.h
new file mode 100644
index 0000000..0201ca1
--- /dev/null
+++ b/linux-x86/gnu-efi/include/efi/ia32/efibind.h
@@ -0,0 +1,282 @@
+/*++
+
+Copyright (c) 1998  Intel Corporation
+
+Module Name:
+
+    efefind.h
+
+Abstract:
+
+    EFI to compile bindings
+
+
+
+
+Revision History
+
+--*/
+
+#ifndef __GNUC__
+#pragma pack()
+#endif
+
+//
+// Basic int types of various widths
+//
+
+#if !defined(__STDC_VERSION__) || (__STDC_VERSION__ < 199901L )
+
+    // No ANSI C 1999/2000 stdint.h integer width declarations 
+
+    #if defined(_MSC_EXTENSIONS)
+
+        // Use Microsoft C compiler integer width declarations 
+
+        typedef unsigned __int64    uint64_t;
+        typedef __int64             int64_t;
+        typedef unsigned __int32    uint32_t;
+        typedef __int32             int32_t;
+        typedef unsigned short      uint16_t;
+        typedef short               int16_t;
+        typedef unsigned char       uint8_t;
+        typedef char                int8_t;
+    #elif defined(__GNUC__)
+        typedef unsigned long long  uint64_t __attribute__((aligned (8)));
+        typedef long long           int64_t __attribute__((aligned (8)));
+        typedef unsigned int        uint32_t;
+        typedef int                 int32_t;
+        typedef unsigned short      uint16_t;
+        typedef short               int16_t;
+        typedef unsigned char       uint8_t;
+        typedef char                int8_t;
+    #elif defined(UNIX_LP64)
+
+        /*  Use LP64 programming model from C_FLAGS for integer width declarations */
+
+       typedef unsigned long       uint64_t;
+       typedef long                int64_t;
+       typedef unsigned int        uint32_t;
+       typedef int                 int32_t;
+       typedef unsigned short      uint16_t;
+       typedef short               int16_t;
+       typedef unsigned char       uint8_t;
+       typedef char                int8_t;
+    #else
+
+       /*  Assume P64 programming model from C_FLAGS for integer width declarations */
+
+       typedef unsigned long long  uint64_t __attribute__((aligned (8)));
+       typedef long long           int64_t __attribute__((aligned (8)));
+       typedef unsigned int        uint32_t;
+       typedef int                 int32_t;
+       typedef unsigned short      uint16_t;
+       typedef short               int16_t;
+       typedef unsigned char       uint8_t;
+       typedef char                int8_t;
+    #endif
+#endif
+
+//
+// Basic EFI types of various widths
+//
+
+#ifndef __WCHAR_TYPE__
+# define __WCHAR_TYPE__ short
+#endif
+
+typedef uint64_t   UINT64;
+typedef int64_t    INT64;
+
+#ifndef _BASETSD_H_
+    typedef uint32_t   UINT32;
+    typedef int32_t    INT32;
+#endif
+
+typedef uint16_t   UINT16;
+typedef int16_t    INT16;
+typedef uint8_t    UINT8;
+typedef int8_t     INT8;
+typedef __WCHAR_TYPE__ WCHAR;
+
+#undef VOID
+#define VOID    void
+
+
+typedef int32_t    INTN;
+typedef uint32_t   UINTN;
+
+#ifdef EFI_NT_EMULATOR
+    #define POST_CODE(_Data)
+#else    
+    #ifdef EFI_DEBUG
+#define POST_CODE(_Data)    __asm mov eax,(_Data) __asm out 0x80,al
+    #else
+        #define POST_CODE(_Data)
+    #endif  
+#endif
+
+#define EFIERR(a)           (0x80000000 | a)
+#define EFI_ERROR_MASK      0x80000000
+#define EFIERR_OEM(a)       (0xc0000000 | a)      
+
+
+#define BAD_POINTER         0xFBFBFBFB
+#define MAX_ADDRESS         0xFFFFFFFF
+
+#ifdef EFI_NT_EMULATOR
+    #define BREAKPOINT()        __asm { int 3 }
+#else
+    #define BREAKPOINT()        while (TRUE);    // Make it hang on Bios[Dbg]32
+#endif
+
+//
+// Pointers must be aligned to these address to function
+//
+
+#define MIN_ALIGNMENT_SIZE  4
+
+#define ALIGN_VARIABLE(Value ,Adjustment) \
+            (UINTN)Adjustment = 0; \
+            if((UINTN)Value % MIN_ALIGNMENT_SIZE) \
+                (UINTN)Adjustment = MIN_ALIGNMENT_SIZE - ((UINTN)Value % MIN_ALIGNMENT_SIZE); \
+            Value = (UINTN)Value + (UINTN)Adjustment
+
+
+//
+// Define macros to build data structure signatures from characters.
+//
+
+#define EFI_SIGNATURE_16(A,B)             ((A) | (B<<8))
+#define EFI_SIGNATURE_32(A,B,C,D)         (EFI_SIGNATURE_16(A,B)     | (EFI_SIGNATURE_16(C,D)     << 16))
+#define EFI_SIGNATURE_64(A,B,C,D,E,F,G,H) (EFI_SIGNATURE_32(A,B,C,D) | ((UINT64)(EFI_SIGNATURE_32(E,F,G,H)) << 32))
+//
+// To export & import functions in the EFI emulator environment
+//
+
+#ifdef EFI_NT_EMULATOR
+    #define EXPORTAPI           __declspec( dllexport )
+#else
+    #define EXPORTAPI
+#endif
+
+
+//
+// EFIAPI - prototype calling convention for EFI function pointers
+// BOOTSERVICE - prototype for implementation of a boot service interface
+// RUNTIMESERVICE - prototype for implementation of a runtime service interface
+// RUNTIMEFUNCTION - prototype for implementation of a runtime function that is not a service
+// RUNTIME_CODE - pragma macro for declaring runtime code    
+//
+
+#ifndef EFIAPI                  // Forces EFI calling conventions reguardless of compiler options 
+    #ifdef _MSC_EXTENSIONS
+        #define EFIAPI __cdecl  // Force C calling convention for Microsoft C compiler 
+    #else
+        #define EFIAPI          // Substitute expresion to force C calling convention 
+    #endif
+#endif
+
+#define BOOTSERVICE
+//#define RUNTIMESERVICE(proto,a)    alloc_text("rtcode",a); proto a
+//#define RUNTIMEFUNCTION(proto,a)   alloc_text("rtcode",a); proto a
+#define RUNTIMESERVICE
+#define RUNTIMEFUNCTION
+
+
+#define RUNTIME_CODE(a)         alloc_text("rtcode", a)
+#define BEGIN_RUNTIME_DATA()    data_seg("rtdata")
+#define END_RUNTIME_DATA()      data_seg("")
+
+#define VOLATILE    volatile
+
+#define MEMORY_FENCE()    
+
+#ifdef EFI_NT_EMULATOR
+
+//
+// To help ensure proper coding of integrated drivers, they are
+// compiled as DLLs.  In NT they require a dll init entry pointer.
+// The macro puts a stub entry point into the DLL so it will load.
+//
+
+#define EFI_DRIVER_ENTRY_POINT(InitFunction)    \
+    UINTN                                       \
+    __stdcall                                   \
+    _DllMainCRTStartup (                        \
+        UINTN    Inst,                          \
+        UINTN    reason_for_call,               \
+        VOID    *rserved                        \
+        )                                       \
+    {                                           \
+        return 1;                               \
+    }                                           \
+                                                \
+    int                                         \
+    EXPORTAPI                                   \
+    __cdecl                                     \
+    InitializeDriver (                          \
+        void *ImageHandle,                      \
+        void *SystemTable                       \
+        )                                       \
+    {                                           \
+        return InitFunction(ImageHandle, SystemTable);       \
+    }
+
+
+    #define LOAD_INTERNAL_DRIVER(_if, type, name, entry)      \
+        (_if)->LoadInternal(type, name, NULL)             
+
+#else // EFI_NT_EMULATOR 
+
+//
+// When build similiar to FW, then link everything together as
+// one big module.
+//
+
+    #define EFI_DRIVER_ENTRY_POINT(InitFunction)    \
+        UINTN                                       \
+        InitializeDriver (                          \
+            VOID    *ImageHandle,                   \
+            VOID    *SystemTable                    \
+            )                                       \
+        {                                           \
+            return InitFunction(ImageHandle,        \
+                    SystemTable);                   \
+        }                                           \
+                                                    \
+        EFI_STATUS efi_main(                        \
+            EFI_HANDLE image,                       \
+            EFI_SYSTEM_TABLE *systab                \
+            ) __attribute__((weak,                  \
+                    alias ("InitializeDriver")));
+
+    #define LOAD_INTERNAL_DRIVER(_if, type, name, entry)    \
+            (_if)->LoadInternal(type, name, entry)
+
+#endif // EFI_FW_NT 
+
+//
+// Some compilers don't support the forward reference construct:
+//  typedef struct XXXXX
+//
+// The following macro provide a workaround for such cases.
+//
+#ifdef NO_INTERFACE_DECL
+#define INTERFACE_DECL(x)
+#else
+#ifdef __GNUC__
+#define INTERFACE_DECL(x) struct x
+#else
+#define INTERFACE_DECL(x) typedef struct x
+#endif
+#endif
+
+/* No efi call wrapper for IA32 architecture */
+#define uefi_call_wrapper(func, va_num, ...)	func(__VA_ARGS__)
+#define EFI_FUNCTION
+
+#ifdef _MSC_EXTENSIONS
+#pragma warning ( disable : 4731 )  // Suppress warnings about modification of EBP
+#endif
+
diff --git a/linux-x86/gnu-efi/include/efi/ia32/efilibplat.h b/linux-x86/gnu-efi/include/efi/ia32/efilibplat.h
new file mode 100644
index 0000000..3844578
--- /dev/null
+++ b/linux-x86/gnu-efi/include/efi/ia32/efilibplat.h
@@ -0,0 +1,26 @@
+/*++
+
+Copyright (c) 1998  Intel Corporation
+
+Module Name:
+
+    efilibplat.h
+
+Abstract:
+
+    EFI to compile bindings
+
+
+
+
+Revision History
+
+--*/
+
+VOID
+InitializeLibPlatform (
+    IN EFI_HANDLE           ImageHandle,
+    IN EFI_SYSTEM_TABLE     *SystemTable
+    );
+
+   
diff --git a/linux-x86/gnu-efi/include/efi/ia32/pe.h b/linux-x86/gnu-efi/include/efi/ia32/pe.h
new file mode 100644
index 0000000..16e40ef
--- /dev/null
+++ b/linux-x86/gnu-efi/include/efi/ia32/pe.h
@@ -0,0 +1,591 @@
+/* 
+    PE32+ header file
+ */
+#ifndef _PE_H
+#define _PE_H
+
+#define IMAGE_DOS_SIGNATURE                 0x5A4D      // MZ
+#define IMAGE_OS2_SIGNATURE                 0x454E      // NE
+#define IMAGE_OS2_SIGNATURE_LE              0x454C      // LE
+#define IMAGE_NT_SIGNATURE                  0x00004550  // PE00  
+#define IMAGE_EDOS_SIGNATURE                0x44454550  // PEED
+
+
+typedef struct _IMAGE_DOS_HEADER {      // DOS .EXE header
+    UINT16   e_magic;                     // Magic number
+    UINT16   e_cblp;                      // Bytes on last page of file
+    UINT16   e_cp;                        // Pages in file
+    UINT16   e_crlc;                      // Relocations
+    UINT16   e_cparhdr;                   // Size of header in paragraphs
+    UINT16   e_minalloc;                  // Minimum extra paragraphs needed
+    UINT16   e_maxalloc;                  // Maximum extra paragraphs needed
+    UINT16   e_ss;                        // Initial (relative) SS value
+    UINT16   e_sp;                        // Initial SP value
+    UINT16   e_csum;                      // Checksum
+    UINT16   e_ip;                        // Initial IP value
+    UINT16   e_cs;                        // Initial (relative) CS value
+    UINT16   e_lfarlc;                    // File address of relocation table
+    UINT16   e_ovno;                      // Overlay number
+    UINT16   e_res[4];                    // Reserved words
+    UINT16   e_oemid;                     // OEM identifier (for e_oeminfo)
+    UINT16   e_oeminfo;                   // OEM information; e_oemid specific
+    UINT16   e_res2[10];                  // Reserved words
+    UINT32   e_lfanew;                    // File address of new exe header
+  } IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;
+
+typedef struct _IMAGE_OS2_HEADER {      // OS/2 .EXE header
+    UINT16   ne_magic;                    // Magic number
+    UINT8    ne_ver;                      // Version number
+    UINT8    ne_rev;                      // Revision number
+    UINT16   ne_enttab;                   // Offset of Entry Table
+    UINT16   ne_cbenttab;                 // Number of bytes in Entry Table
+    UINT32   ne_crc;                      // Checksum of whole file
+    UINT16   ne_flags;                    // Flag UINT16
+    UINT16   ne_autodata;                 // Automatic data segment number
+    UINT16   ne_heap;                     // Initial heap allocation
+    UINT16   ne_stack;                    // Initial stack allocation
+    UINT32   ne_csip;                     // Initial CS:IP setting
+    UINT32   ne_sssp;                     // Initial SS:SP setting
+    UINT16   ne_cseg;                     // Count of file segments
+    UINT16   ne_cmod;                     // Entries in Module Reference Table
+    UINT16   ne_cbnrestab;                // Size of non-resident name table
+    UINT16   ne_segtab;                   // Offset of Segment Table
+    UINT16   ne_rsrctab;                  // Offset of Resource Table
+    UINT16   ne_restab;                   // Offset of resident name table
+    UINT16   ne_modtab;                   // Offset of Module Reference Table
+    UINT16   ne_imptab;                   // Offset of Imported Names Table
+    UINT32   ne_nrestab;                  // Offset of Non-resident Names Table
+    UINT16   ne_cmovent;                  // Count of movable entries
+    UINT16   ne_align;                    // Segment alignment shift count
+    UINT16   ne_cres;                     // Count of resource segments
+    UINT8    ne_exetyp;                   // Target Operating system
+    UINT8    ne_flagsothers;              // Other .EXE flags
+    UINT16   ne_pretthunks;               // offset to return thunks
+    UINT16   ne_psegrefbytes;             // offset to segment ref. bytes
+    UINT16   ne_swaparea;                 // Minimum code swap area size
+    UINT16   ne_expver;                   // Expected Windows version number
+  } IMAGE_OS2_HEADER, *PIMAGE_OS2_HEADER;
+
+//
+// File header format.
+//
+
+typedef struct _IMAGE_FILE_HEADER {
+    UINT16   Machine;
+    UINT16   NumberOfSections;
+    UINT32   TimeDateStamp;
+    UINT32   PointerToSymbolTable;
+    UINT32   NumberOfSymbols;
+    UINT16   SizeOfOptionalHeader;
+    UINT16   Characteristics;
+} IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;
+
+#define IMAGE_SIZEOF_FILE_HEADER             20
+
+#define IMAGE_FILE_RELOCS_STRIPPED           0x0001  // Relocation info stripped from file.
+#define IMAGE_FILE_EXECUTABLE_IMAGE          0x0002  // File is executable  (i.e. no unresolved externel references).
+#define IMAGE_FILE_LINE_NUMS_STRIPPED        0x0004  // Line nunbers stripped from file.
+#define IMAGE_FILE_LOCAL_SYMS_STRIPPED       0x0008  // Local symbols stripped from file.
+#define IMAGE_FILE_BYTES_REVERSED_LO         0x0080  // Bytes of machine word are reversed.
+#define IMAGE_FILE_32BIT_MACHINE             0x0100  // 32 bit word machine.
+#define IMAGE_FILE_DEBUG_STRIPPED            0x0200  // Debugging info stripped from file in .DBG file
+#define IMAGE_FILE_SYSTEM                    0x1000  // System File.
+#define IMAGE_FILE_DLL                       0x2000  // File is a DLL.
+#define IMAGE_FILE_BYTES_REVERSED_HI         0x8000  // Bytes of machine word are reversed.
+
+#define IMAGE_FILE_MACHINE_UNKNOWN           0
+#define IMAGE_FILE_MACHINE_I386              0x14c   // Intel 386.
+#define IMAGE_FILE_MACHINE_R3000             0x162   // MIPS little-endian, 0540 big-endian
+#define IMAGE_FILE_MACHINE_R4000             0x166   // MIPS little-endian
+#define IMAGE_FILE_MACHINE_ALPHA             0x184   // Alpha_AXP
+#define IMAGE_FILE_MACHINE_POWERPC           0x1F0   // IBM PowerPC Little-Endian
+#define IMAGE_FILE_MACHINE_TAHOE             0x7cc   // Intel EM machine
+//
+// Directory format.
+//
+
+typedef struct _IMAGE_DATA_DIRECTORY {
+    UINT32   VirtualAddress;
+    UINT32   Size;
+} IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;
+
+#define IMAGE_NUMBEROF_DIRECTORY_ENTRIES    16
+
+//
+// Optional header format.
+//
+
+typedef struct _IMAGE_OPTIONAL_HEADER {
+    //
+    // Standard fields.
+    //
+
+    UINT16    Magic;
+    UINT8     MajorLinkerVersion;
+    UINT8     MinorLinkerVersion;
+    UINT32    SizeOfCode;
+    UINT32    SizeOfInitializedData;
+    UINT32    SizeOfUninitializedData;
+    UINT32    AddressOfEntryPoint;
+    UINT32    BaseOfCode;
+    UINT32    BaseOfData;
+                
+    //
+    // NT additional fields.
+    //
+
+    UINT32   ImageBase;
+    UINT32   SectionAlignment;
+    UINT32   FileAlignment;
+    UINT16   MajorOperatingSystemVersion;
+    UINT16   MinorOperatingSystemVersion;
+    UINT16   MajorImageVersion;
+    UINT16   MinorImageVersion;
+    UINT16   MajorSubsystemVersion;
+    UINT16   MinorSubsystemVersion;
+    UINT32   Reserved1;
+    UINT32   SizeOfImage;
+    UINT32   SizeOfHeaders;
+    UINT32   CheckSum;
+    UINT16   Subsystem;
+    UINT16   DllCharacteristics;
+    UINT32   SizeOfStackReserve;
+    UINT32   SizeOfStackCommit;
+    UINT32   SizeOfHeapReserve;
+    UINT32   SizeOfHeapCommit;
+    UINT32   LoaderFlags;
+    UINT32   NumberOfRvaAndSizes;
+    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
+} IMAGE_OPTIONAL_HEADER, *PIMAGE_OPTIONAL_HEADER;
+
+typedef struct _IMAGE_ROM_OPTIONAL_HEADER {
+    UINT16  Magic;
+    UINT8   MajorLinkerVersion;
+    UINT8   MinorLinkerVersion;
+    UINT32  SizeOfCode;
+    UINT32  SizeOfInitializedData;
+    UINT32  SizeOfUninitializedData;
+    UINT32  AddressOfEntryPoint;
+    UINT32  BaseOfCode;
+    UINT32  BaseOfData;
+    UINT32  BaseOfBss;
+    UINT32  GprMask;
+    UINT32  CprMask[4];
+    UINT32  GpValue;
+} IMAGE_ROM_OPTIONAL_HEADER, *PIMAGE_ROM_OPTIONAL_HEADER;
+
+#define IMAGE_SIZEOF_ROM_OPTIONAL_HEADER      56
+#define IMAGE_SIZEOF_STD_OPTIONAL_HEADER      28
+#define IMAGE_SIZEOF_NT_OPTIONAL_HEADER      224
+
+#define IMAGE_NT_OPTIONAL_HDR_MAGIC        0x10b
+#define IMAGE_ROM_OPTIONAL_HDR_MAGIC       0x107
+
+typedef struct _IMAGE_NT_HEADERS {
+    UINT32 Signature;
+    IMAGE_FILE_HEADER FileHeader;
+    IMAGE_OPTIONAL_HEADER OptionalHeader;
+} IMAGE_NT_HEADERS, *PIMAGE_NT_HEADERS;
+
+typedef struct _IMAGE_ROM_HEADERS {
+    IMAGE_FILE_HEADER FileHeader;
+    IMAGE_ROM_OPTIONAL_HEADER OptionalHeader;
+} IMAGE_ROM_HEADERS, *PIMAGE_ROM_HEADERS;
+
+#define IMAGE_FIRST_SECTION( ntheader ) ((PIMAGE_SECTION_HEADER)        \
+    ((UINT32)ntheader +                                                  \
+     FIELD_OFFSET( IMAGE_NT_HEADERS, OptionalHeader ) +                 \
+     ((PIMAGE_NT_HEADERS)(ntheader))->FileHeader.SizeOfOptionalHeader   \
+    ))
+
+
+// Subsystem Values
+
+#define IMAGE_SUBSYSTEM_UNKNOWN              0   // Unknown subsystem.
+#define IMAGE_SUBSYSTEM_NATIVE               1   // Image doesn't require a subsystem.
+#define IMAGE_SUBSYSTEM_WINDOWS_GUI          2   // Image runs in the Windows GUI subsystem.
+#define IMAGE_SUBSYSTEM_WINDOWS_CUI          3   // Image runs in the Windows character subsystem.
+#define IMAGE_SUBSYSTEM_OS2_CUI              5   // image runs in the OS/2 character subsystem.
+#define IMAGE_SUBSYSTEM_POSIX_CUI            7   // image run  in the Posix character subsystem.
+
+
+// Directory Entries
+
+#define IMAGE_DIRECTORY_ENTRY_EXPORT         0   // Export Directory
+#define IMAGE_DIRECTORY_ENTRY_IMPORT         1   // Import Directory
+#define IMAGE_DIRECTORY_ENTRY_RESOURCE       2   // Resource Directory
+#define IMAGE_DIRECTORY_ENTRY_EXCEPTION      3   // Exception Directory
+#define IMAGE_DIRECTORY_ENTRY_SECURITY       4   // Security Directory
+#define IMAGE_DIRECTORY_ENTRY_BASERELOC      5   // Base Relocation Table
+#define IMAGE_DIRECTORY_ENTRY_DEBUG          6   // Debug Directory
+#define IMAGE_DIRECTORY_ENTRY_COPYRIGHT      7   // Description String
+#define IMAGE_DIRECTORY_ENTRY_GLOBALPTR      8   // Machine Value (MIPS GP)
+#define IMAGE_DIRECTORY_ENTRY_TLS            9   // TLS Directory
+#define IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG   10   // Load Configuration Directory
+
+//
+// Section header format.
+//
+
+#define IMAGE_SIZEOF_SHORT_NAME              8
+
+typedef struct _IMAGE_SECTION_HEADER {
+    UINT8   Name[IMAGE_SIZEOF_SHORT_NAME];
+    union {
+            UINT32   PhysicalAddress;
+            UINT32   VirtualSize;
+    } Misc;
+    UINT32   VirtualAddress;
+    UINT32   SizeOfRawData;
+    UINT32   PointerToRawData;
+    UINT32   PointerToRelocations;
+    UINT32   PointerToLinenumbers;
+    UINT16   NumberOfRelocations;
+    UINT16   NumberOfLinenumbers;
+    UINT32   Characteristics;
+} IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;
+
+#define IMAGE_SIZEOF_SECTION_HEADER          40
+
+#define IMAGE_SCN_TYPE_NO_PAD                0x00000008  // Reserved.
+
+#define IMAGE_SCN_CNT_CODE                   0x00000020  // Section contains code.
+#define IMAGE_SCN_CNT_INITIALIZED_DATA       0x00000040  // Section contains initialized data.
+#define IMAGE_SCN_CNT_UNINITIALIZED_DATA     0x00000080  // Section contains uninitialized data.
+
+#define IMAGE_SCN_LNK_OTHER                  0x00000100  // Reserved.
+#define IMAGE_SCN_LNK_INFO                   0x00000200  // Section contains comments or some other type of information.
+#define IMAGE_SCN_LNK_REMOVE                 0x00000800  // Section contents will not become part of image.
+#define IMAGE_SCN_LNK_COMDAT                 0x00001000  // Section contents comdat.
+
+#define IMAGE_SCN_ALIGN_1BYTES               0x00100000  //
+#define IMAGE_SCN_ALIGN_2BYTES               0x00200000  //
+#define IMAGE_SCN_ALIGN_4BYTES               0x00300000  //
+#define IMAGE_SCN_ALIGN_8BYTES               0x00400000  //
+#define IMAGE_SCN_ALIGN_16BYTES              0x00500000  // Default alignment if no others are specified.
+#define IMAGE_SCN_ALIGN_32BYTES              0x00600000  //
+#define IMAGE_SCN_ALIGN_64BYTES              0x00700000  //
+
+#define IMAGE_SCN_MEM_DISCARDABLE            0x02000000  // Section can be discarded.
+#define IMAGE_SCN_MEM_NOT_CACHED             0x04000000  // Section is not cachable.
+#define IMAGE_SCN_MEM_NOT_PAGED              0x08000000  // Section is not pageable.
+#define IMAGE_SCN_MEM_SHARED                 0x10000000  // Section is shareable.
+#define IMAGE_SCN_MEM_EXECUTE                0x20000000  // Section is executable.
+#define IMAGE_SCN_MEM_READ                   0x40000000  // Section is readable.
+#define IMAGE_SCN_MEM_WRITE                  0x80000000  // Section is writeable.
+
+//
+// Symbol format.
+//
+
+
+#define IMAGE_SIZEOF_SYMBOL                  18
+
+//
+// Section values.
+//
+// Symbols have a section number of the section in which they are
+// defined. Otherwise, section numbers have the following meanings:
+//
+
+#define IMAGE_SYM_UNDEFINED           (UINT16)0           // Symbol is undefined or is common.
+#define IMAGE_SYM_ABSOLUTE            (UINT16)-1          // Symbol is an absolute value.
+#define IMAGE_SYM_DEBUG               (UINT16)-2          // Symbol is a special debug item.
+
+//
+// Type (fundamental) values.
+//
+
+#define IMAGE_SYM_TYPE_NULL                  0           // no type.
+#define IMAGE_SYM_TYPE_VOID                  1           //
+#define IMAGE_SYM_TYPE_CHAR                  2           // type character.
+#define IMAGE_SYM_TYPE_SHORT                 3           // type short integer.
+#define IMAGE_SYM_TYPE_INT                   4           //
+#define IMAGE_SYM_TYPE_LONG                  5           //
+#define IMAGE_SYM_TYPE_FLOAT                 6           //
+#define IMAGE_SYM_TYPE_DOUBLE                7           //
+#define IMAGE_SYM_TYPE_STRUCT                8           //
+#define IMAGE_SYM_TYPE_UNION                 9           //
+#define IMAGE_SYM_TYPE_ENUM                  10          // enumeration.
+#define IMAGE_SYM_TYPE_MOE                   11          // member of enumeration.
+#define IMAGE_SYM_TYPE_BYTE                  12          //
+#define IMAGE_SYM_TYPE_WORD                  13          //
+#define IMAGE_SYM_TYPE_UINT                  14          //
+#define IMAGE_SYM_TYPE_DWORD                 15          //
+
+//
+// Type (derived) values.
+//
+
+#define IMAGE_SYM_DTYPE_NULL                 0           // no derived type.
+#define IMAGE_SYM_DTYPE_POINTER              1           // pointer.
+#define IMAGE_SYM_DTYPE_FUNCTION             2           // function.
+#define IMAGE_SYM_DTYPE_ARRAY                3           // array.
+
+//
+// Storage classes.
+//
+
+#define IMAGE_SYM_CLASS_END_OF_FUNCTION      (BYTE )-1
+#define IMAGE_SYM_CLASS_NULL                 0
+#define IMAGE_SYM_CLASS_AUTOMATIC            1
+#define IMAGE_SYM_CLASS_EXTERNAL             2
+#define IMAGE_SYM_CLASS_STATIC               3
+#define IMAGE_SYM_CLASS_REGISTER             4
+#define IMAGE_SYM_CLASS_EXTERNAL_DEF         5
+#define IMAGE_SYM_CLASS_LABEL                6
+#define IMAGE_SYM_CLASS_UNDEFINED_LABEL      7
+#define IMAGE_SYM_CLASS_MEMBER_OF_STRUCT     8
+#define IMAGE_SYM_CLASS_ARGUMENT             9
+#define IMAGE_SYM_CLASS_STRUCT_TAG           10
+#define IMAGE_SYM_CLASS_MEMBER_OF_UNION      11
+#define IMAGE_SYM_CLASS_UNION_TAG            12
+#define IMAGE_SYM_CLASS_TYPE_DEFINITION      13
+#define IMAGE_SYM_CLASS_UNDEFINED_STATIC     14
+#define IMAGE_SYM_CLASS_ENUM_TAG             15
+#define IMAGE_SYM_CLASS_MEMBER_OF_ENUM       16
+#define IMAGE_SYM_CLASS_REGISTER_PARAM       17
+#define IMAGE_SYM_CLASS_BIT_FIELD            18
+#define IMAGE_SYM_CLASS_BLOCK                100
+#define IMAGE_SYM_CLASS_FUNCTION             101
+#define IMAGE_SYM_CLASS_END_OF_STRUCT        102
+#define IMAGE_SYM_CLASS_FILE                 103
+// new
+#define IMAGE_SYM_CLASS_SECTION              104
+#define IMAGE_SYM_CLASS_WEAK_EXTERNAL        105
+
+// type packing constants
+
+#define N_BTMASK                            017
+#define N_TMASK                             060
+#define N_TMASK1                            0300
+#define N_TMASK2                            0360
+#define N_BTSHFT                            4
+#define N_TSHIFT                            2
+
+// MACROS
+
+//
+// Communal selection types.
+//
+
+#define IMAGE_COMDAT_SELECT_NODUPLICATES   1
+#define IMAGE_COMDAT_SELECT_ANY            2
+#define IMAGE_COMDAT_SELECT_SAME_SIZE      3
+#define IMAGE_COMDAT_SELECT_EXACT_MATCH    4
+#define IMAGE_COMDAT_SELECT_ASSOCIATIVE    5
+
+#define IMAGE_WEAK_EXTERN_SEARCH_NOLIBRARY 1
+#define IMAGE_WEAK_EXTERN_SEARCH_LIBRARY   2
+#define IMAGE_WEAK_EXTERN_SEARCH_ALIAS     3
+
+
+//
+// Relocation format.
+//
+
+typedef struct _IMAGE_RELOCATION {
+    UINT32   VirtualAddress;
+    UINT32   SymbolTableIndex;
+    UINT16    Type;
+} IMAGE_RELOCATION;
+
+#define IMAGE_SIZEOF_RELOCATION              10
+
+//
+// I386 relocation types.
+//
+
+#define IMAGE_REL_I386_ABSOLUTE              0           // Reference is absolute, no relocation is necessary
+#define IMAGE_REL_I386_DIR16                 01          // Direct 16-bit reference to the symbols virtual address
+#define IMAGE_REL_I386_REL16                 02          // PC-relative 16-bit reference to the symbols virtual address
+#define IMAGE_REL_I386_DIR32                 06          // Direct 32-bit reference to the symbols virtual address
+#define IMAGE_REL_I386_DIR32NB               07          // Direct 32-bit reference to the symbols virtual address, base not included
+#define IMAGE_REL_I386_SEG12                 011         // Direct 16-bit reference to the segment-selector bits of a 32-bit virtual address
+#define IMAGE_REL_I386_SECTION               012
+#define IMAGE_REL_I386_SECREL                013
+#define IMAGE_REL_I386_REL32                 024         // PC-relative 32-bit reference to the symbols virtual address
+
+//
+// MIPS relocation types.
+//
+
+#define IMAGE_REL_MIPS_ABSOLUTE              0           // Reference is absolute, no relocation is necessary
+#define IMAGE_REL_MIPS_REFHALF               01
+#define IMAGE_REL_MIPS_REFWORD               02
+#define IMAGE_REL_MIPS_JMPADDR               03
+#define IMAGE_REL_MIPS_REFHI                 04
+#define IMAGE_REL_MIPS_REFLO                 05
+#define IMAGE_REL_MIPS_GPREL                 06
+#define IMAGE_REL_MIPS_LITERAL               07
+#define IMAGE_REL_MIPS_SECTION               012
+#define IMAGE_REL_MIPS_SECREL                013
+#define IMAGE_REL_MIPS_REFWORDNB             042
+#define IMAGE_REL_MIPS_PAIR                  045
+
+//
+// Alpha Relocation types.
+//
+
+#define IMAGE_REL_ALPHA_ABSOLUTE             0x0
+#define IMAGE_REL_ALPHA_REFLONG              0x1
+#define IMAGE_REL_ALPHA_REFQUAD              0x2
+#define IMAGE_REL_ALPHA_GPREL32              0x3
+#define IMAGE_REL_ALPHA_LITERAL              0x4
+#define IMAGE_REL_ALPHA_LITUSE               0x5
+#define IMAGE_REL_ALPHA_GPDISP               0x6
+#define IMAGE_REL_ALPHA_BRADDR               0x7
+#define IMAGE_REL_ALPHA_HINT                 0x8
+#define IMAGE_REL_ALPHA_INLINE_REFLONG       0x9
+#define IMAGE_REL_ALPHA_REFHI                0xA
+#define IMAGE_REL_ALPHA_REFLO                0xB
+#define IMAGE_REL_ALPHA_PAIR                 0xC
+#define IMAGE_REL_ALPHA_MATCH                0xD
+#define IMAGE_REL_ALPHA_SECTION              0xE
+#define IMAGE_REL_ALPHA_SECREL               0xF
+#define IMAGE_REL_ALPHA_REFLONGNB            0x10
+
+//
+// IBM PowerPC relocation types.
+//
+
+#define IMAGE_REL_PPC_ABSOLUTE 0x0000  // NOP
+#define IMAGE_REL_PPC_ADDR64   0x0001  // 64-bit address
+#define IMAGE_REL_PPC_ADDR32   0x0002  // 32-bit address
+#define IMAGE_REL_PPC_ADDR24   0x0003  // 26-bit address, shifted left 2 (branch absolute)
+#define IMAGE_REL_PPC_ADDR16   0x0004  // 16-bit address
+#define IMAGE_REL_PPC_ADDR14   0x0005  // 16-bit address, shifted left 2 (load doubleword)
+#define IMAGE_REL_PPC_REL24    0x0006  // 26-bit PC-relative offset, shifted left 2 (branch relative)
+#define IMAGE_REL_PPC_REL14    0x0007  // 16-bit PC-relative offset, shifted left 2 (br cond relative)
+#define IMAGE_REL_PPC_TOCREL16 0x0008  // 16-bit offset from TOC base
+#define IMAGE_REL_PPC_TOCREL14 0x0009  // 16-bit offset from TOC base, shifted left 2 (load doubleword)
+
+#define IMAGE_REL_PPC_ADDR32NB 0x000A  // 32-bit addr w/o image base
+#define IMAGE_REL_PPC_SECREL   0x000B  // va of containing section (as in an image sectionhdr)
+#define IMAGE_REL_PPC_SECTION  0x000C  // sectionheader number
+#define IMAGE_REL_PPC_IFGLUE   0x000D  // substitute TOC restore instruction iff symbol is glue code
+#define IMAGE_REL_PPC_IMGLUE   0x000E  // symbol is glue code; virtual address is TOC restore instruction
+
+#define IMAGE_REL_PPC_TYPEMASK 0x00FF  // mask to isolate above values in IMAGE_RELOCATION.Type
+
+// Flag bits in IMAGE_RELOCATION.TYPE
+
+#define IMAGE_REL_PPC_NEG      0x0100  // subtract reloc value rather than adding it
+#define IMAGE_REL_PPC_BRTAKEN  0x0200  // fix branch prediction bit to predict branch taken
+#define IMAGE_REL_PPC_BRNTAKEN 0x0400  // fix branch prediction bit to predict branch not taken
+#define IMAGE_REL_PPC_TOCDEFN  0x0800  // toc slot defined in file (or, data in toc)
+
+//
+// Based relocation format.
+//
+
+typedef struct _IMAGE_BASE_RELOCATION {
+    UINT32   VirtualAddress;
+    UINT32   SizeOfBlock;
+//  UINT16    TypeOffset[1];
+} IMAGE_BASE_RELOCATION, *PIMAGE_BASE_RELOCATION;
+
+#define IMAGE_SIZEOF_BASE_RELOCATION         8
+
+//
+// Based relocation types.
+//
+
+#define IMAGE_REL_BASED_ABSOLUTE              0
+#define IMAGE_REL_BASED_HIGH                  1
+#define IMAGE_REL_BASED_LOW                   2
+#define IMAGE_REL_BASED_HIGHLOW               3
+#define IMAGE_REL_BASED_HIGHADJ               4
+#define IMAGE_REL_BASED_MIPS_JMPADDR          5
+#define IMAGE_REL_BASED_IA64_IMM64            9
+#define IMAGE_REL_BASED_DIR64                 10
+
+//
+// Line number format.
+//
+
+typedef struct _IMAGE_LINENUMBER {
+    union {
+        UINT32   SymbolTableIndex;               // Symbol table index of function name if Linenumber is 0.
+        UINT32   VirtualAddress;                 // Virtual address of line number.
+    } Type;
+    UINT16    Linenumber;                         // Line number.
+} IMAGE_LINENUMBER;
+
+#define IMAGE_SIZEOF_LINENUMBER              6
+
+//
+// Archive format.
+//
+
+#define IMAGE_ARCHIVE_START_SIZE             8
+#define IMAGE_ARCHIVE_START                  "!<arch>\n"
+#define IMAGE_ARCHIVE_END                    "`\n"
+#define IMAGE_ARCHIVE_PAD                    "\n"
+#define IMAGE_ARCHIVE_LINKER_MEMBER          "/               "
+#define IMAGE_ARCHIVE_LONGNAMES_MEMBER       "//              "
+
+typedef struct _IMAGE_ARCHIVE_MEMBER_HEADER {
+    UINT8     Name[16];                          // File member name - `/' terminated.
+    UINT8     Date[12];                          // File member date - decimal.
+    UINT8     UserID[6];                         // File member user id - decimal.
+    UINT8     GroupID[6];                        // File member group id - decimal.
+    UINT8     Mode[8];                           // File member mode - octal.
+    UINT8     Size[10];                          // File member size - decimal.
+    UINT8     EndHeader[2];                      // String to end header.
+} IMAGE_ARCHIVE_MEMBER_HEADER, *PIMAGE_ARCHIVE_MEMBER_HEADER;
+
+#define IMAGE_SIZEOF_ARCHIVE_MEMBER_HDR      60
+
+//
+// DLL support.
+//
+
+//
+// Export Format
+//
+
+typedef struct _IMAGE_EXPORT_DIRECTORY {
+    UINT32   Characteristics;
+    UINT32   TimeDateStamp;
+    UINT16   MajorVersion;
+    UINT16   MinorVersion;
+    UINT32   Name;
+    UINT32   Base;
+    UINT32   NumberOfFunctions;
+    UINT32   NumberOfNames;
+    UINT32   *AddressOfFunctions;
+    UINT32   *AddressOfNames;
+    UINT32   *AddressOfNameOrdinals;
+} IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;
+
+//
+// Import Format
+//
+
+typedef struct _IMAGE_IMPORT_BY_NAME {
+    UINT16    Hint;
+    UINT8     Name[1];
+} IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;
+
+typedef struct _IMAGE_THUNK_DATA {
+    union {
+        UINT32 Function;
+        UINT32 Ordinal;
+        PIMAGE_IMPORT_BY_NAME AddressOfData;
+    } u1;
+} IMAGE_THUNK_DATA, *PIMAGE_THUNK_DATA;
+
+#define IMAGE_ORDINAL_FLAG 0x80000000
+#define IMAGE_SNAP_BY_ORDINAL(Ordinal) ((Ordinal & IMAGE_ORDINAL_FLAG) != 0)
+#define IMAGE_ORDINAL(Ordinal) (Ordinal & 0xffff)
+
+typedef struct _IMAGE_IMPORT_DESCRIPTOR {
+    UINT32   Characteristics;
+    UINT32   TimeDateStamp;
+    UINT32   ForwarderChain;
+    UINT32   Name;
+    PIMAGE_THUNK_DATA FirstThunk;
+} IMAGE_IMPORT_DESCRIPTOR, *PIMAGE_IMPORT_DESCRIPTOR;
+
+#endif
diff --git a/linux-x86/gnu-efi/include/efi/libsmbios.h b/linux-x86/gnu-efi/include/efi/libsmbios.h
new file mode 100644
index 0000000..8f1a28e
--- /dev/null
+++ b/linux-x86/gnu-efi/include/efi/libsmbios.h
@@ -0,0 +1,132 @@
+#ifndef _LIB_SMBIOS_H
+#define _LIB_SMBIOS_H
+/*++
+
+Copyright (c) 2000  Intel Corporation
+
+Module Name:
+
+    LibSmbios.h
+    
+Abstract:
+
+    Lib include  for SMBIOS services. Used to get system serial number and GUID
+
+Revision History
+
+--*/
+
+//
+// Define SMBIOS tables.
+//
+#pragma pack(1)
+typedef struct {
+    UINT8   AnchorString[4];
+    UINT8   EntryPointStructureChecksum;
+    UINT8   EntryPointLength;
+    UINT8   MajorVersion;
+    UINT8   MinorVersion;
+    UINT16  MaxStructureSize;
+    UINT8   EntryPointRevision;
+    UINT8   FormattedArea[5];
+    UINT8   IntermediateAnchorString[5];
+    UINT8   IntermediateChecksum;
+    UINT16  TableLength;
+    UINT32  TableAddress;
+    UINT16  NumberOfSmbiosStructures;
+    UINT8   SmbiosBcdRevision;
+} SMBIOS_STRUCTURE_TABLE;
+
+//
+// Please note that SMBIOS structures can be odd byte aligned since the
+//  unformated section of each record is a set of arbitrary size strings.
+//
+
+typedef struct {
+    UINT8   Type;
+    UINT8   Length;
+    UINT8   Handle[2];
+} SMBIOS_HEADER;
+
+typedef UINT8   SMBIOS_STRING;
+
+typedef struct {
+    SMBIOS_HEADER   Hdr;
+    SMBIOS_STRING   Vendor;
+    SMBIOS_STRING   BiosVersion;
+    UINT8           BiosSegment[2];
+    SMBIOS_STRING   BiosReleaseDate;
+    UINT8           BiosSize;
+    UINT8           BiosCharacteristics[8];
+} SMBIOS_TYPE0;
+
+typedef struct {
+    SMBIOS_HEADER   Hdr;
+    SMBIOS_STRING   Manufacturer;
+    SMBIOS_STRING   ProductName;
+    SMBIOS_STRING   Version;
+    SMBIOS_STRING   SerialNumber;
+
+    //
+    // always byte copy this data to prevent alignment faults!
+    //
+    EFI_GUID        Uuid;
+    
+    UINT8           WakeUpType;
+} SMBIOS_TYPE1;
+
+typedef struct {
+    SMBIOS_HEADER   Hdr;
+    SMBIOS_STRING   Manufacturer;
+    SMBIOS_STRING   ProductName;
+    SMBIOS_STRING   Version;
+    SMBIOS_STRING   SerialNumber;
+} SMBIOS_TYPE2;
+
+typedef struct {
+    SMBIOS_HEADER   Hdr;
+    SMBIOS_STRING   Manufacturer;
+    UINT8           Type;
+    SMBIOS_STRING   Version;
+    SMBIOS_STRING   SerialNumber;
+    SMBIOS_STRING   AssetTag;
+    UINT8           BootupState;
+    UINT8           PowerSupplyState;
+    UINT8           ThermalState;
+    UINT8           SecurityStatus;
+    UINT8           OemDefined[4];
+} SMBIOS_TYPE3;
+
+typedef struct {
+    SMBIOS_HEADER   Hdr;
+    UINT8           Socket;
+    UINT8           ProcessorType;
+    UINT8           ProcessorFamily;
+    SMBIOS_STRING   ProcessorManufacture;
+    UINT8           ProcessorId[8];
+    SMBIOS_STRING   ProcessorVersion;
+    UINT8           Voltage;
+    UINT8           ExternalClock[2];
+    UINT8           MaxSpeed[2];
+    UINT8           CurrentSpeed[2];
+    UINT8           Status;
+    UINT8           ProcessorUpgrade;
+    UINT8           L1CacheHandle[2];
+    UINT8           L2CacheHandle[2];
+    UINT8           L3CacheHandle[2];
+} SMBIOS_TYPE4;
+
+typedef union {
+    SMBIOS_HEADER   *Hdr;
+    SMBIOS_TYPE0    *Type0;
+    SMBIOS_TYPE1    *Type1;
+    SMBIOS_TYPE2    *Type2;
+    SMBIOS_TYPE3    *Type3;
+    SMBIOS_TYPE4    *Type4;
+    UINT8           *Raw;
+} SMBIOS_STRUCTURE_POINTER;
+#pragma pack()
+
+
+#endif
+
diff --git a/linux-x86/gnu-efi/include/efi/pci22.h b/linux-x86/gnu-efi/include/efi/pci22.h
new file mode 100644
index 0000000..b94f519
--- /dev/null
+++ b/linux-x86/gnu-efi/include/efi/pci22.h
@@ -0,0 +1,193 @@
+#ifndef _PCI22_H
+#define _PCI22_H
+
+/*++
+
+Copyright (c) 1999  Intel Corporation
+
+Module Name:
+
+    pci22.h
+    
+Abstract:      
+    Support for PCI 2.2 standard.
+
+
+
+
+Revision History
+
+--*/
+
+#ifdef SOFT_SDV
+#define PCI_MAX_BUS     1
+#else
+#define PCI_MAX_BUS     255
+#endif
+
+#define PCI_MAX_DEVICE  31
+#define PCI_MAX_FUNC    7
+
+//
+// Command
+//
+#define PCI_VGA_PALETTE_SNOOP_DISABLED   0x20
+
+#pragma pack(1)
+typedef struct {
+    UINT16      VendorId;
+    UINT16      DeviceId;
+    UINT16      Command;
+    UINT16      Status;
+    UINT8       RevisionID;
+    UINT8       ClassCode[3];
+    UINT8       CacheLineSize;
+    UINT8       LaytencyTimer;
+    UINT8       HeaderType;
+    UINT8       BIST;
+} PCI_DEVICE_INDEPENDENT_REGION;
+
+typedef struct {
+    UINT32      Bar[6];
+    UINT32      CISPtr;
+    UINT16      SubsystemVendorID;
+    UINT16      SubsystemID;
+    UINT32      ExpansionRomBar;
+    UINT32      Reserved[2];
+    UINT8       InterruptLine;
+    UINT8       InterruptPin;
+    UINT8       MinGnt;
+    UINT8       MaxLat;     
+} PCI_DEVICE_HEADER_TYPE_REGION;
+
+typedef struct {
+    PCI_DEVICE_INDEPENDENT_REGION   Hdr;
+    PCI_DEVICE_HEADER_TYPE_REGION   Device;
+} PCI_TYPE00;
+
+typedef struct {              
+    UINT32      Bar[2];
+    UINT8       PrimaryBus;
+    UINT8       SecondaryBus;
+    UINT8       SubordinateBus;
+    UINT8       SecondaryLatencyTimer;
+    UINT8       IoBase;
+    UINT8       IoLimit;
+    UINT16      SecondaryStatus;
+    UINT16      MemoryBase;
+    UINT16      MemoryLimit;
+    UINT16      PrefetchableMemoryBase;
+    UINT16      PrefetchableMemoryLimit;
+    UINT32      PrefetchableBaseUpper32;
+    UINT32      PrefetchableLimitUpper32;
+    UINT16      IoBaseUpper16;
+    UINT16      IoLimitUpper16;
+    UINT32      Reserved;
+    UINT32      ExpansionRomBAR;
+    UINT8       InterruptLine;
+    UINT8       InterruptPin;
+    UINT16      BridgeControl;
+} PCI_BRIDGE_CONTROL_REGISTER;
+
+#define PCI_CLASS_DISPLAY_CTRL          0x03
+#define PCI_CLASS_VGA                   0x00
+
+#define PCI_CLASS_BRIDGE                0x06
+#define PCI_CLASS_ISA                   0x01
+#define PCI_CLASS_ISA_POSITIVE_DECODE   0x80
+
+#define PCI_CLASS_NETWORK               0x02 
+#define PCI_CLASS_ETHERNET              0x00
+        
+#define HEADER_TYPE_DEVICE              0x00
+#define HEADER_TYPE_PCI_TO_PCI_BRIDGE   0x01
+#define HEADER_TYPE_MULTI_FUNCTION      0x80
+#define HEADER_LAYOUT_CODE              0x7f
+
+#define IS_PCI_BRIDGE(_p) ((((_p)->Hdr.HeaderType) & HEADER_LAYOUT_CODE) == HEADER_TYPE_PCI_TO_PCI_BRIDGE)        
+#define IS_PCI_MULTI_FUNC(_p)   (((_p)->Hdr.HeaderType) & HEADER_TYPE_MULTI_FUNCTION)         
+
+typedef struct {
+    PCI_DEVICE_INDEPENDENT_REGION   Hdr;
+    PCI_BRIDGE_CONTROL_REGISTER     Bridge;
+} PCI_TYPE01;
+
+typedef struct {
+    UINT8   Register;
+    UINT8   Function;
+    UINT8   Device;
+    UINT8   Bus;
+    UINT8   Reserved[4];
+} DEFIO_PCI_ADDR;
+
+typedef struct {
+    UINT32  Reg     : 8;
+    UINT32  Func    : 3;
+    UINT32  Dev     : 5;
+    UINT32  Bus     : 8;
+    UINT32  Reserved: 7;
+    UINT32  Enable  : 1;
+} PCI_CONFIG_ACCESS_CF8;
+
+#pragma pack()
+
+#define EFI_ROOT_BRIDGE_LIST    'eprb'
+typedef struct {
+    UINTN           Signature;
+
+    UINT16          BridgeNumber;
+    UINT16          PrimaryBus;
+    UINT16          SubordinateBus;
+
+    EFI_DEVICE_PATH *DevicePath;
+
+    LIST_ENTRY      Link;
+} PCI_ROOT_BRIDGE_ENTRY;
+
+
+#define PCI_EXPANSION_ROM_HEADER_SIGNATURE        0xaa55
+#define EFI_PCI_EXPANSION_ROM_HEADER_EFISIGNATURE 0x0EF1
+#define PCI_DATA_STRUCTURE_SIGNATURE              EFI_SIGNATURE_32('P','C','I','R')
+
+#pragma pack(1)
+typedef struct {
+    UINT16          Signature;              // 0xaa55
+    UINT8           Reserved[0x16];
+    UINT16          PcirOffset;
+} PCI_EXPANSION_ROM_HEADER;
+
+
+typedef struct {
+    UINT16          Signature;              // 0xaa55
+    UINT16          InitializationSize;
+    UINT16          EfiSignature;           // 0x0EF1
+    UINT16          EfiSubsystem;
+    UINT16          EfiMachineType;
+    UINT8           Reserved[0x0A];
+    UINT16          EfiImageHeaderOffset;
+    UINT16          PcirOffset;
+} EFI_PCI_EXPANSION_ROM_HEADER;
+
+typedef struct {
+    UINT32          Signature;              // "PCIR" 
+    UINT16          VendorId;
+    UINT16          DeviceId;
+    UINT16          Reserved0;
+    UINT16          Length;
+    UINT8           Revision;
+    UINT8           ClassCode[3];
+    UINT16          ImageLength;
+    UINT16          CodeRevision;
+    UINT8           CodeType;
+    UINT8           Indicator;
+    UINT16          Reserved1;
+} PCI_DATA_STRUCTURE;
+#pragma pack()
+
+#endif
+    
+
+
+
+
+    
diff --git a/linux-x86/gnu-efi/include/efi/protocol/adapterdebug.h b/linux-x86/gnu-efi/include/efi/protocol/adapterdebug.h
new file mode 100644
index 0000000..d70af5d
--- /dev/null
+++ b/linux-x86/gnu-efi/include/efi/protocol/adapterdebug.h
@@ -0,0 +1,32 @@
+#ifndef _ADAPTER_DEBUG_H
+#define _ADAPTER_DEBUG_H
+
+/*++
+
+Copyright (c) 1999  Intel Corporation
+
+Module Name:
+
+    AdapterDebug.h
+    
+Abstract:
+
+    Protocol to debug the EDD 3.0 enablement of BIOS option ROMs
+
+
+
+Revision History
+
+--*/
+
+// {82F86881-282B-11d4-BC7D-0080C73C8881}
+#define ADAPTER_DEBUG_PROTOCOL \
+{ 0x82f86881, 0x282b, 0x11d4, {0xbc, 0x7d, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81} }
+
+//
+// This protocol points to the BIOS_LEGACY_DRIVE data structure
+//  see edd.h for more details
+//
+
+#endif
+
diff --git a/linux-x86/gnu-efi/include/efi/protocol/eficonsplit.h b/linux-x86/gnu-efi/include/efi/protocol/eficonsplit.h
new file mode 100644
index 0000000..15adb92
--- /dev/null
+++ b/linux-x86/gnu-efi/include/efi/protocol/eficonsplit.h
@@ -0,0 +1,32 @@
+#ifndef _EFI_CONFORK_H
+#define _EFI_CONFORK_H
+/*++
+
+Copyright (c) 1999  Intel Corporation
+
+Module Name:
+
+Abstract:
+
+
+
+Revision History
+
+--*/
+
+
+
+//
+// ConOut Forker Protocol
+//
+
+#define TEXT_OUT_SPLITER_PROTOCOL    \
+    { 0x56d830a0, 0x7e7a, 0x11d3, {0xbb, 0xa0, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b} }
+
+#define ERROR_OUT_SPLITER_PROTOCOL    \
+    { 0xf0ba9039, 0x68f1, 0x425e, {0xaa, 0x7f, 0xd9, 0xaa, 0xf9, 0x1b, 0x82, 0xa1}}
+
+#define TEXT_IN_SPLITER_PROTOCOL    \
+    { 0xf9a3c550, 0x7fb5, 0x11d3, {0xbb, 0xa0, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b} }
+
+#endif
diff --git a/linux-x86/gnu-efi/include/efi/protocol/efidbg.h b/linux-x86/gnu-efi/include/efi/protocol/efidbg.h
new file mode 100644
index 0000000..1f95a70
--- /dev/null
+++ b/linux-x86/gnu-efi/include/efi/protocol/efidbg.h
@@ -0,0 +1,210 @@
+/*
+ * Copyright (c) 1999, 2000
+ * Intel Corporation.
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ * 
+ *    This product includes software developed by Intel Corporation and
+ *    its contributors.
+ * 
+ * 4. Neither the name of Intel Corporation or its contributors may be
+ *    used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY INTEL CORPORATION AND CONTRIBUTORS ``AS IS''
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL INTEL CORPORATION OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * 
+ */
+
+
+#ifndef _EFIDBG_H_
+#define _EFIDBG_H_
+
+#include "eficontext.h"
+#include "efiser.h"
+
+typedef struct _DEBUGPORT_16550_CONFIG_DATA {
+        UINT32							PortAddress;
+        UINT64                          BaudRate;
+    	UINT32               			ReceiveFifoDepth;
+    	UINT32               			Timeout;
+        UINT8                           Parity;
+        UINT8                           DataBits;
+        UINT8                           StopBits;
+	    UINT32                       	ControlMask;
+        BOOLEAN							RtsCtsEnable;		// RTS, CTS control
+} DEBUGPORT_16550_CONFIG_DATA;
+
+typedef struct _DEBUGPORT_16550_DEVICE_PATH {
+        EFI_DEVICE_PATH                 Header;
+        DEBUGPORT_16550_CONFIG_DATA		ConfigData;
+} DEBUGPORT_16550_DEVICE_PATH;
+
+typedef union {
+    EFI_DEVICE_PATH                     DevPath;
+    DEBUGPORT_16550_DEVICE_PATH         Uart;
+    // add new types of debugport device paths to this union...
+} DEBUGPORT_DEV_PATH;
+
+
+//
+// Debug Support protocol {2755590C-6F3C-42FA-9EA4-A3BA543CDA25}
+//
+
+#define DEBUG_SUPPORT_PROTOCOL \
+{ 0x2755590C, 0x6F3C, 0x42fa, 0x9E, 0xA4, 0xA3, 0xBA, 0x54, 0x3C, 0xDA, 0x25 }
+
+
+typedef UINTN EXCEPTION_TYPE;
+
+typedef
+VOID
+(*EXCEPTION_HANDLER) (
+	IN EXCEPTION_TYPE ExceptionType,
+    IN SYSTEM_CONTEXT *SystemContext
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_REGISTER_TIMER_TICK_CALLBACK) (
+    IN struct _EFI_DEBUG_SUPPORT_INTERFACE  *This,
+    IN EXCEPTION_HANDLER	                TimerTickCallback
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_REGISTER_EXCEPTION_HANDLER) (
+    IN     struct _EFI_DEBUG_SUPPORT_INTERFACE  *This,
+    IN     EXCEPTION_HANDLER                    ExceptionHandler,
+    IN     EXCEPTION_TYPE                       ExceptionType
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_IP_CALL_TRACE) (
+    IN     struct _EFI_DEBUG_SUPPORT_INTERFACE  *This
+    );
+
+
+#define EFI_DEBUG_SUPPORT_INTERFACE_REVISION     0x00010000
+
+typedef struct _EFI_DEBUG_SUPPORT_INTERFACE {
+    UINT32                          	Revision;
+    EFI_REGISTER_TIMER_TICK_CALLBACK	RegisterTimerTickCallback;
+    EFI_REGISTER_EXCEPTION_HANDLER  	RegisterExceptionHandler;
+    EFI_IP_CALL_TRACE               	IpCallTrace;
+} EFI_DEBUG_SUPPORT_INTERFACE;
+
+
+//
+// Debugport io protocol {EBA4E8D2-3858-41EC-A281-2647BA9660D0}
+//
+
+#define DEBUGPORT_IO_PROTOCOL \
+{ 0XEBA4E8D2, 0X3858, 0X41EC, 0XA2, 0X81, 0X26, 0X47, 0XBA, 0X96, 0X60, 0XD0 }
+ 
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_DEBUGPORT_IO_RESET) (
+    IN struct _EFI_DEBUGPORT_IO_INTERFACE  	*This
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_DEBUGPORT_IO_READ) (
+    IN     struct _EFI_DEBUGPORT_IO_INTERFACE	*This,
+    IN OUT UINTN                    		*BufferSize,
+    OUT VOID                         		*Buffer
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_DEBUGPORT_IO_WRITE) (
+    IN     struct _EFI_DEBUGPORT_IO_INTERFACE *This,
+    IN OUT UINTN                    		*BufferSize,
+    IN VOID                         		*Buffer
+    );
+
+#define EFI_DEBUGPORT_IO_INTERFACE_REVISION   0x00010000
+
+typedef struct _EFI_DEBUGPORT_IO_INTERFACE {
+    UINT32                          		Revision;
+    EFI_DEBUGPORT_IO_READ					Read;
+    EFI_DEBUGPORT_IO_WRITE					Write;
+    EFI_DEBUGPORT_IO_RESET					Reset;
+} EFI_DEBUGPORT_IO_INTERFACE;
+
+
+//
+// Debugport UART16550 control protocol {628EA978-4C26-4605-BC02-A42A496917DD}
+//
+
+#define DEBUGPORT_UART16550_CONTROL_PROTOCOL \
+{ 0X628EA978, 0X4C26, 0X4605, 0XBC, 0X2, 0XA4, 0X2A, 0X49, 0X69, 0X17, 0XDD }
+ 
+// Note: The definitions for EFI_PARITY_TYPE, EFI_STOP_BITS_TYPE, and 
+// SERIAL_IO_MODE are included from efiser.h
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_UART16550_SET_ATTRIBUTES) (
+    IN struct _EFI_DEBUGPORT_UART16550_CONTROL_INTERFACE  	*This,
+    IN UINT64                       	BaudRate,
+    IN UINT32                       	ReceiveFifoDepth,
+    IN UINT32                       	Timeout,
+    IN EFI_PARITY_TYPE       			Parity,
+    IN UINT8                        	DataBits,
+    IN EFI_STOP_BITS_TYPE    			StopBits
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_UART16550_SET_CONTROL_BITS) (
+    IN struct _EFI_DEBUGPORT_UART16550_CONTROL_INTERFACE  	*This,
+    IN UINT32                       	Control
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_UART16550_GET_CONTROL_BITS) (
+    IN struct _EFI_DEBUGPORT_UART16550_CONTROL_INTERFACE	*This,
+    OUT UINT32                      	*Control
+    );
+
+#define EFI_DEBUGPORT_UART16550_CONTROL_INTERFACE_REVISION   0x00010000
+
+typedef struct _EFI_DEBUGPORT_UART16550_CONTROL_INTERFACE {
+    UINT32                          	Revision;
+	EFI_UART16550_SET_ATTRIBUTES		SetAttributes;
+	EFI_UART16550_SET_CONTROL_BITS		SetControl;
+	EFI_UART16550_GET_CONTROL_BITS 		GetControl;
+	DEBUGPORT_16550_CONFIG_DATA			*Mode;
+} EFI_DEBUGPORT_UART16550_CONTROL_INTERFACE;
+        
+
+#define DEVICE_PATH_DEBUGPORT DEBUGPORT_IO_PROTOCOL
+        
+#endif /* _EFIDBG_H_ */
diff --git a/linux-x86/gnu-efi/include/efi/protocol/efivar.h b/linux-x86/gnu-efi/include/efi/protocol/efivar.h
new file mode 100644
index 0000000..92dc506
--- /dev/null
+++ b/linux-x86/gnu-efi/include/efi/protocol/efivar.h
@@ -0,0 +1,133 @@
+/*++
+
+Copyright (c) 1998  Intel Corporation
+
+Module Name:
+
+Abstract:
+
+
+
+Revision History
+
+--*/
+
+
+
+//
+// The variable store protocol interface is specific to the reference
+// implementation.  The initialization code adds variable store devices
+// to the system, and the FW connects to the devices to provide the
+// variable store interfaces through these devices.
+//
+
+//
+// Variable Store Device protocol
+//
+
+#define VARIABLE_STORE_PROTOCOL    \
+    { 0xf088cd91, 0xa046, 0x11d2, {0x8e, 0x42, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b} }
+
+INTERFACE_DECL(_EFI_VARIABLE_STORE);
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_STORE_CLEAR) (
+    IN struct _EFI_VARIABLE_STORE   *This,
+    IN UINTN                        BankNo,
+    IN OUT VOID                     *Scratch
+    );
+
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_STORE_READ) (
+    IN struct _EFI_VARIABLE_STORE   *This,
+    IN UINTN                        BankNo,
+    IN UINTN                        Offset,
+    IN UINTN                        BufferSize,
+    OUT VOID                        *Buffer
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_STORE_UPDATE) (
+    IN struct _EFI_VARIABLE_STORE   *This,
+    IN UINTN                        BankNo,
+    IN UINTN                        Offset,
+    IN UINTN                        BufferSize,
+    IN VOID                         *Buffer
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_STORE_SIZE) (
+    IN struct _EFI_VARIABLE_STORE   *This,
+    IN UINTN                        NoBanks
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_TRANSACTION_UPDATE) (
+    IN struct _EFI_VARIABLE_STORE   *This,
+    IN UINTN                        BankNo,
+    IN VOID                         *NewContents
+    );
+
+typedef struct _EFI_VARIABLE_STORE {
+
+    //
+    // Number of banks and bank size
+    //
+
+    UINT32                      Attributes;
+    UINT32                      BankSize;
+    UINT32                      NoBanks;
+
+    //
+    // Functions to access the storage banks
+    //
+
+    EFI_STORE_CLEAR             ClearStore;
+    EFI_STORE_READ              ReadStore;
+    EFI_STORE_UPDATE            UpdateStore;
+    EFI_STORE_SIZE              SizeStore OPTIONAL;
+    EFI_TRANSACTION_UPDATE      TransactionUpdate OPTIONAL;
+
+} EFI_VARIABLE_STORE;
+
+
+//
+//
+// ClearStore()     - A function to clear the requested storage bank.  A cleared
+//      bank contains all "on" bits.
+//
+// ReadStore()      - Read data from the requested store.
+//
+// UpdateStore()    - Updates data on the requested store. The FW will only
+//      ever issue updates to clear bits in the store. Updates must be
+//      performed in LSb to MSb order of the update buffer.
+//
+// SizeStore()      - An optional function for non-runtime stores that can be
+//      dynamically sized.  The FW will only ever increase or decrease the store
+//      by 1 banksize at a time, and it is always adding or removing a bank from 
+//      the end of the store.
+//
+// By default the FW will update variables and storage banks in an
+// "atomic" manner by keeping 1 old copy of the data during an update,
+// and recovering appropiately if the power is lost during the middle
+// of an operation.  To do this the FW needs to have multiple banks
+// of storage dedicated to its use. If that's not possible, the driver 
+// can implement an atomic bank update function and the FW will allow 
+// 1 bank in this case.  (It will allow any number of banks,
+// but it won't require an "extra" bank to provide its bank transaction 
+// function).
+//
+// TransactionUpdate()  - An optional function that can clear & update an 
+//      entire bank in an "atomic" fashion.  If the operation fails in the 
+//      middle the driver is responsible for having either the previous copy 
+//      of the bank's data or the new copy.  A copy that's partially written
+//      is not valid as internal data settings may get lost.  Supply this
+//      function only when needed.
+//
+
diff --git a/linux-x86/gnu-efi/include/efi/protocol/intload.h b/linux-x86/gnu-efi/include/efi/protocol/intload.h
new file mode 100644
index 0000000..fb24e3f
--- /dev/null
+++ b/linux-x86/gnu-efi/include/efi/protocol/intload.h
@@ -0,0 +1,27 @@
+/*++
+
+Copyright (c) 1999 Intel Corporation
+
+Module Name:
+
+    intload
+
+Abstract:
+
+    EFI support for loading internally linked in apps
+
+
+
+Revision History
+
+--*/
+
+#ifndef _INTERNAL_LOAD_INCLUDE_
+#define _INTERNAL_LOAD_INCLUDE_
+
+// {D65A6B8C-71E5-4df0-A909-F0D2992B5AA9}
+#define INTERNAL_SHELL_GUID \
+    { 0xd65a6b8c, 0x71e5, 0x4df0, {0xa9, 0x09, 0xf0, 0xd2, 0x99, 0x2b, 0x5a, 0xa9} }
+
+
+#endif
diff --git a/linux-x86/gnu-efi/include/efi/protocol/legacyboot.h b/linux-x86/gnu-efi/include/efi/protocol/legacyboot.h
new file mode 100644
index 0000000..16e94e7
--- /dev/null
+++ b/linux-x86/gnu-efi/include/efi/protocol/legacyboot.h
@@ -0,0 +1,119 @@
+/*++
+
+Copyright (c) 1999 Intel Corporation
+
+Module Name:
+
+    legacyboot
+
+Abstract:
+
+    EFI support for legacy boot
+
+
+
+Revision History
+
+--*/
+
+#ifndef _LEGACY_BOOT_INCLUDE_
+#define _LEGACY_BOOT_INCLUDE_
+
+#define LEGACY_BOOT_PROTOCOL \
+    { 0x376e5eb2, 0x30e4, 0x11d3, { 0xba, 0xe5, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81 } }
+
+#pragma pack(1)
+
+//
+// BBS 1.01 (See Appendix A) IPL and BCV Table Entry Data structure.
+//  Seg:Off pointers have been converted to EFI pointers in this data structure
+//  This is the structure that also maps to the EFI device path for the boot selection
+//
+typedef struct {
+    UINT16  DeviceType;
+    UINT16  StatusFlag;
+    UINT32  Reserved;
+    VOID    *BootHandler;   // Not an EFI entry point
+    CHAR8   *DescString;
+} BBS_TABLE_ENTRY;
+#pragma pack()
+
+typedef
+EFI_STATUS
+(EFIAPI *LEGACY_BOOT_CALL) (
+    IN EFI_DEVICE_PATH      *DevicePath
+    );
+
+
+//
+// BBS support functions
+//  PnP Call numbers and BiosSelector hidden in implementation
+//
+
+typedef enum {
+    IplRelative,
+    BcvRelative
+} BBS_TYPE;
+
+INTERFACE_DECL(_LEGACY_BOOT_INTERFACE);
+
+//
+// == PnP Function 0x60 then BbsVersion == 0x0101 if this call fails then BbsVersion == 0x0000
+//
+
+//
+// == PnP Function 0x61
+//
+typedef
+EFI_STATUS
+(EFIAPI *GET_DEVICE_COUNT) (
+    IN  struct _LEGACY_BOOT_INTERFACE   *This,
+    IN  BBS_TYPE        *TableType,
+    OUT UINTN           *DeviceCount,
+    OUT UINTN           *MaxCount
+    );
+
+//
+// == PnP Function 0x62
+//
+typedef
+EFI_STATUS
+(EFIAPI *GET_PRIORITY_AND_TABLE) (
+    IN  struct _LEGACY_BOOT_INTERFACE   *This,
+    IN  BBS_TYPE        *TableType,
+    IN OUT  UINTN       *PrioritySize, // MaxCount * sizeof(UINT8)
+    OUT     UINTN       *Priority,
+    IN OUT  UINTN       *TableSize,    // MaxCount * sizeof(BBS_TABLE_ENTRY)
+    OUT BBS_TABLE_ENTRY *TableEntrySize
+    );
+
+//
+// == PnP Function 0x63
+//
+typedef
+EFI_STATUS
+(EFIAPI *SET_PRIORITY) (
+    IN  struct _LEGACY_BOOT_INTERFACE   *This,
+    IN  BBS_TYPE        *TableType,
+    IN OUT  UINTN       *PrioritySize,
+    OUT     UINTN       *Priority
+    );
+
+typedef struct _LEGACY_BOOT_INTERFACE {
+    LEGACY_BOOT_CALL    BootIt;
+
+    //
+    // New functions to allow BBS booting to be configured from EFI
+    //
+    UINTN                   BbsVersion;     // Currently 0x0101
+    GET_DEVICE_COUNT        GetDeviceCount;
+    GET_PRIORITY_AND_TABLE  GetPriorityAndTable;
+    SET_PRIORITY            SetPriority;   
+} LEGACY_BOOT_INTERFACE;
+
+EFI_STATUS
+PlInitializeLegacyBoot (
+    VOID
+    );
+
+#endif
diff --git a/linux-x86/gnu-efi/include/efi/protocol/piflash64.h b/linux-x86/gnu-efi/include/efi/protocol/piflash64.h
new file mode 100644
index 0000000..d521dfc
--- /dev/null
+++ b/linux-x86/gnu-efi/include/efi/protocol/piflash64.h
@@ -0,0 +1,121 @@
+#ifndef _PIFLASH64_H
+#define _PIFLASH64_H
+
+/*++
+
+Copyright (c) 1999  Intel Corporation
+
+Module Name:
+
+    PIflash64.h
+    
+Abstract:
+
+    Iflash64.efi protocol to abstract iflash from
+    the system.
+
+Revision History
+
+--*/
+
+//
+// Guid that identifies the IFLASH protocol
+//
+#define IFLASH64_PROTOCOL_PROTOCOL \
+    { 0x65cba110, 0x74ab, 0x11d3, 0xbb, 0x89, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81 };
+
+//
+// Unlock FLASH from StartAddress to EndAddress and return a LockKey
+//
+typedef
+EFI_STATUS
+(EFIAPI *UNLOCK_FLASH_API)(
+    IN struct _IFLASH64_PROTOCOL_INTERFACE  *This
+    );
+
+//
+// Lock the flash represented by the LockKey
+//
+typedef
+EFI_STATUS
+(EFIAPI *LOCK_FLASH_API)(
+    IN struct _IFLASH64_PROTOCOL_INTERFACE  *This
+    );
+
+//
+// Status callback for a utility like IFLASH64
+//
+//  Token would map to a list like Ted proposed. The utility has no idea what 
+//      happens on the other side.
+//  ErrorStatus - Level of Error or success. Independent of Token. If you 
+//      don't know the token you will at least know pass or fail.
+//  String - Optional extra information about the error. Could be used for 
+//      debug or future expansion
+//
+//  Attributes - Options screen attributes for String. Could allow the string to be different colors.
+//
+typedef
+EFI_STATUS
+(EFIAPI *UTILITY_PROGRESS_API)(
+    IN struct _IFLASH64_PROTOCOL_INTERFACE  *This,
+    IN  UINTN                               Token,
+    IN  EFI_STATUS                          ErrorStatus, 
+    IN  CHAR16                              *String,    OPTIONAL
+    IN  UINTN                               *Attributes OPTIONAL
+    );
+
+//
+// Token Values
+//
+// IFlash64 Token Codes
+#define IFLASH_TOKEN_IFLASHSTART    0xB0                // IFlash64 has started
+#define IFLASH_TOKEN_READINGFILE    0xB1                // Reading File
+#define IFLASH_TOKEN_INITVPP        0xB2                // Initializing Vpp
+#define IFLASH_TOKEN_DISABLEVPP     0x10                // Disable Vpp
+#define IFLASH_TOKEN_FLASHUNLOCK    0xB3                // Unlocking FLASH Devices
+#define IFLASH_TOKEN_FLASHERASE     0xB4                // Erasing FLASH Devices
+#define IFLASH_TOKEN_FLASHPROGRAM   0xB5                // Programming FLASH
+#define IFLASH_TOKEN_FLASHVERIFY    0xB6                // Verifying FLASH
+#define IFLASH_TOKEN_UPDATESUCCES   0xB7                // FLASH Updage Success!
+
+#define IFLASH_TOKEN_PROGRESS_READINGFILE   0x11        // % Reading File
+#define IFLASH_TOKEN_PROGRESS_FLASHUNLOCK   0x13        // % Unlocking FLASH Devices
+#define IFLASH_TOKEN_PROGRESS_FLASHERASE    0x14        // % Erasing FLASH Devices
+#define IFLASH_TOKEN_PROGRESS_FLASHPROGRAM  0x15        // % Programming FLASH
+#define IFLASH_TOKEN_PROGRESS_FLASHVERIFY   0x16        // % Verifying FLASH
+
+#define IFLASH_TOKEN_READINGFILE_ER 0xB8                // File Read Error
+#define IFLASH_TOKEN_INITVPP_ER     0xB9                // Initialization of IFB Error
+#define IFLASH_TOKEN_FLASHUNLOCK_ER 0xBA                // FLASH Unlock Error
+#define IFLASH_TOKEN_FLASHERASE_ER  0xBB                // FLASH Erase Error
+#define IFLASH_TOKEN_FLASHVERIFY_ER 0xBC                // FLASH Verify Error
+#define IFLASH_TOKEN_FLASHPROG_ER   0xBD                // FLASH Program Error
+
+#define IFLASH_TABLE_END            0x00
+
+//
+// If this number changes one of the existing API's has changes
+//
+#define IFLASH_PI_MAJOR_VERSION 0x01
+
+//
+// This number changes when new APIs or data variables get added to the end
+//  of the data structure
+//
+#define IFLASH_PI_MINOR_VERSION 0x01
+
+typedef struct _IFLASH64_PROTOCOL_INTERFACE {
+    UINT32                  MajorVersion;       
+    UINT32                  MinorVersion;   
+    UNLOCK_FLASH_API        UnlockFlash;
+    LOCK_FLASH_API          LockFlash;
+    UTILITY_PROGRESS_API    Progress;
+    
+    //
+    // Future expansion goes here
+    //
+
+} IFLASH64_PROTOCOL_INTERFACE;
+
+
+#endif
diff --git a/linux-x86/gnu-efi/include/efi/protocol/vgaclass.h b/linux-x86/gnu-efi/include/efi/protocol/vgaclass.h
new file mode 100644
index 0000000..d0deb5c
--- /dev/null
+++ b/linux-x86/gnu-efi/include/efi/protocol/vgaclass.h
@@ -0,0 +1,95 @@
+#ifndef _VGA_CLASS_H
+#define _VGA_CLASS_H
+
+/*++
+
+Copyright (c) 1999  Intel Corporation
+
+Module Name:
+
+    VgaClass.h
+    
+Abstract:
+
+    Vga Mini port binding to Vga Class protocol
+
+
+
+Revision History
+
+--*/
+
+//
+// VGA Device Structure
+//
+
+// {0E3D6310-6FE4-11d3-BB81-0080C73C8881}
+#define VGA_CLASS_DRIVER_PROTOCOL \
+    { 0xe3d6310, 0x6fe4, 0x11d3, {0xbb, 0x81, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81} }
+
+typedef 
+EFI_STATUS 
+(* INIT_VGA_CARD) (
+    IN  UINTN   VgaMode,
+    IN  VOID    *Context
+    );
+
+typedef struct {
+    UINTN   MaxColumns;
+    UINTN   MaxRows;
+} MAX_CONSOLE_GEOMETRY;
+
+#define VGA_CON_OUT_DEV_SIGNATURE   EFI_SIGNATURE_32('c','v','g','a')
+typedef struct {
+    UINTN                           Signature;
+
+    EFI_HANDLE                      Handle;
+    SIMPLE_TEXT_OUTPUT_INTERFACE    ConOut;
+    SIMPLE_TEXT_OUTPUT_MODE         ConOutMode;
+    EFI_DEVICE_PATH                 *DevicePath;
+
+    UINT8                           *Buffer;
+    EFI_DEVICE_IO_INTERFACE         *DeviceIo;
+
+    //
+    // Video Card Context
+    //
+    INIT_VGA_CARD                   InitVgaCard;
+    VOID                            *VgaCardContext;
+    MAX_CONSOLE_GEOMETRY            *Geometry;
+    //
+    // Video buffer normally 0xb8000
+    //
+    UINT64                          VideoBuffer;
+
+    //
+    // Clear Screen & Default Attribute
+    //
+    UINT32                          Attribute;
+
+    //
+    // -1 means search for active VGA device
+    //
+    EFI_PCI_ADDRESS_UNION           Pci;
+} VGA_CON_OUT_DEV;
+
+#define VGA_CON_OUT_DEV_FROM_THIS(a) CR(a, VGA_CON_OUT_DEV, ConOut, VGA_CON_OUT_DEV_SIGNATURE)
+
+//
+// Vga Class Driver Protocol. 
+// GUID defined in EFI Lib
+//
+
+typedef 
+EFI_STATUS
+(EFIAPI *INSTALL_VGA_DRIVER) (
+    IN  VGA_CON_OUT_DEV    *ConOutDev 
+    );
+
+typedef struct {
+    UINT32               Version;
+    INSTALL_VGA_DRIVER   InstallGenericVgaDriver;
+} INSTALL_VGA_DRIVER_INTERFACE;
+
+#endif
+
diff --git a/linux-x86/gnu-efi/include/efi/romload.h b/linux-x86/gnu-efi/include/efi/romload.h
new file mode 100644
index 0000000..0506011
--- /dev/null
+++ b/linux-x86/gnu-efi/include/efi/romload.h
@@ -0,0 +1,41 @@
+#ifndef _EFI_ROMLOAD_H
+#define _EFI_ROMLOAD_H
+
+#define ROM_SIGNATURE 0xaa55
+#define PCIDS_SIGNATURE "PCIR"
+#pragma pack(push)
+#pragma pack(1)
+typedef struct 
+{
+    UINT8    Pcids_Sig[4];
+    UINT16  VendId;
+    UINT16  DevId;
+    UINT16  Vpd_Off;
+    UINT16  Size;
+    UINT8 Rev;
+    UINT8 Class_Code[3];
+    UINT16  Image_Len;
+    UINT16  Rev_Lvl;
+    UINT8 Code_Type;
+    UINT8 Indi;
+    UINT16  Rsvd;
+}PciDataStructure;
+typedef struct
+{
+    UINT16 Size;
+    UINT32 Header_Sig;
+    UINT16 SubSystem;
+    UINT16 MachineType;
+    UINT8  Resvd[10];
+    UINT16 EfiOffset;
+}ArchData;
+typedef struct 
+{
+    UINT16 Rom_Sig;
+    ArchData Arch_Data;
+    UINT16 Pcids_Off;
+    UINT8 resvd[38];
+}RomHeader;
+#pragma pack(pop)
+
+#endif
diff --git a/linux-x86/gnu-efi/lib/crt0-efi-ia32.o b/linux-x86/gnu-efi/lib/crt0-efi-ia32.o
new file mode 100644
index 0000000000000000000000000000000000000000..bea9af3545fea37ccefe1a82a58ad74346508402
GIT binary patch
literal 868
zcma)4%Syvg5S_G*tyMwAg&?RKQ51rLD|O);3MzsKN`;WxXbVOmxq)^iE?o3){DeYR
zeu&VI5aKy$ZktvY4$M90%*>rkr}y>b?9?y}(Pl_i21?{3No>csCPm51b?Yk%C!?^?
zW$>oeF>}DTP7&wTW%oOZqH_7Y9hx!y?68W)Jj@E3o^mQc<@d0rneRSX%55mIs*ZBR
zssw>p48mXTd)NPWE}@LSV=O7>{F@0UaAMj5d^~2oV=pVR3|fHmKI_O=5{-0hRh+s9
z1DbDuvtHNLm`s_j<2>m-vo6_BT+JN&aOU)UcWBHw-Gs9r`3zit6I6WoE=gkgTf~eG
z0{0=>Kz<_+XTRx0r~9$_4&vH$Kdt}5;g`huhB`v!;vHE1%SJpyU;e5$WonSboQBK|
zX_3Vdy*i?|MzmONqpqYHdR|lPKsmmWlIJ|Shfd&%eSCXya9%nRJAQzUa>ae9+n!T@
bMxR-D2Fsr(Vu5^f8T^Us#0eZQ1N;2}jT=ZD

literal 0
HcmV?d00001

diff --git a/linux-x86/gnu-efi/lib/elf_ia32_efi.lds b/linux-x86/gnu-efi/lib/elf_ia32_efi.lds
new file mode 100644
index 0000000..975e36c
--- /dev/null
+++ b/linux-x86/gnu-efi/lib/elf_ia32_efi.lds
@@ -0,0 +1,75 @@
+OUTPUT_FORMAT("elf32-i386", "elf32-i386", "elf32-i386")
+OUTPUT_ARCH(i386)
+ENTRY(_start)
+SECTIONS
+{
+  . = 0;
+  ImageBase = .;
+  .hash : { *(.hash) }	/* this MUST come first! */
+  . = ALIGN(4096);
+  .text :
+  {
+   *(.text)
+   *(.text.*)
+   *(.gnu.linkonce.t.*)
+  }
+  . = ALIGN(4096);
+  .sdata :
+  {
+   *(.got.plt)
+   *(.got)
+   *(.srodata)
+   *(.sdata)
+   *(.sbss)
+   *(.scommon)
+  }
+  . = ALIGN(4096);
+  .data :
+  {
+   *(.rodata*)
+   *(.data)
+   *(.data1)
+   *(.data.*)
+   *(.sdata)
+   *(.got.plt)
+   *(.got)
+   /* the EFI loader doesn't seem to like a .bss section, so we stick
+      it all into .data: */
+   *(.sbss)
+   *(.scommon)
+   *(.dynbss)
+   *(.bss)
+   *(COMMON)
+  }
+  . = ALIGN(4096);
+  .dynamic  : { *(.dynamic) }
+  . = ALIGN(4096);
+  .rel :
+  {
+    *(.rel.data)
+    *(.rel.data.*)
+    *(.rel.got)
+    *(.rel.stab)
+    *(.data.rel.ro.local)
+    *(.data.rel.local)
+    *(.data.rel.ro)
+    *(.data.rel*)
+  }
+  . = ALIGN(4096);
+  .reloc :		/* This is the PECOFF .reloc section! */
+  {
+    *(.reloc)
+  }
+  . = ALIGN(4096);
+  .dynsym   : { *(.dynsym) }
+  . = ALIGN(4096);
+  .dynstr   : { *(.dynstr) }
+  . = ALIGN(4096);
+  /DISCARD/ :
+  {
+    *(.rel.reloc)
+    *(.eh_frame)
+    *(.note.GNU-stack)
+  }
+  .comment 0 : { *(.comment) }
+}
diff --git a/linux-x86/gnu-efi/lib/libefi.a b/linux-x86/gnu-efi/lib/libefi.a
new file mode 100644
index 0000000000000000000000000000000000000000..7fed675afdf78f94f0c5e797ddb4b32bbd420030
GIT binary patch
literal 89884
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
Wf`Pf4`Uv$$3oTq}VY?vt{r>>LLrW$A

literal 0
HcmV?d00001

diff --git a/linux-x86/gnu-efi/lib/libgnuefi.a b/linux-x86/gnu-efi/lib/libgnuefi.a
new file mode 100644
index 0000000000000000000000000000000000000000..12645990d86d2dfef68424cb0cdc9c5c88505065
GIT binary patch
literal 1884
zcmbVN%}*0S6rZIlETvfsHc^Db5($(<mM$#?4KdV;Xe1<vs4>y9)D^1zfOeZuV}Jyz
zHfs|O9{eke2k~G$G#bF8HYO$>Ja{lhz{CsoR^Qw1z|w?(zI5g{?_=JZoq6xIsaK8%
zC(l?rgxw^$d)(b#cXzj25L~*-JPU%SliH722_Y63Q9{`7I0A7c91F^-LK2F4H!?-S
zvFHRM(G`J^?Cum}7||R>a=9SH_U!d|kn4dNY0Ns;KX{&D7zk7%27>NzgnTj>kFIu-
z8p2Ui9Y>}7wX51-vqNLjIrU0*n3J}oO{utkBKryr779nyOACeCWR<2i+bz><=HtR!
zPCHuwYsW&NF8NhUnPkb0^w#00x%8$ww3t(mzJ}=Yw=y3BH{WGnwxB;P#IC=Q^6BF2
z4~S~d{QUD}DXX@S`B|1rR%(^Zdxm2^Gr!WsxeY0AYz4iPU(6+!b${#6(b0h4e_C)3
z42`x49?>h#v`@rh6JbT@bV=}Yc?IWGT!EWa<b={jhy(WkG50SM<^jhv*jV;4oURvS
zjk<=AWkes(r7Qfr?UBXD+aIzO0V{7?_4C}Ck7rjd)Woc-yv@JHbG{Xx?XMw3Or#>J
zJPxSFOE^hasxqSz@wTkWL>x~fh!~7TB1#lw(U_`;aQ60uDhKZo5zZ+plYu*NIieVc
zIRG?(4L)zBVcQ3&e}lo>4Qv8LJ4{EULJ78K)>yRyVs`9jcM@#Sp9=;O`s>hFr3rO7
zx(qBy328;4i70y!WVo&{bWUKdo9yWM`axE0l6ydb=S3Ob0ooy73xj?GEXh3h8^MJ^
zG_E-&s-D26B|t1)^n?EJ4$;5aUn3}vfs7LMM|p~7IZJ*QsT^^4l_F2SzGP+D6%qA^
z%-eyduTJe*!W$Nt19f<#rp6K^JN-uheFcOo^`V`{vtQro@}APW&O!RlGvh3@?^MBU
zLcz0{`V91t6qgCvZe(P8X4oO+ir=(z%^YgAdTpB3Qk)jDX|laKmt^{ivg2QB%m}+L
zl-CZPv&Xax-yW$62EHSG|1b(oMD5CJXD_?*+(bL9CrUJD5X~9!0t8ba!&k>l*ef>$
n*i;XCO4J|aDVpW~lbcv0lrY!uyN(+IJ@-n<C61K;+gbkt`=S56

literal 0
HcmV?d00001

diff --git a/linux-x86_64/gnu-efi/include/efi/efi.h b/linux-x86_64/gnu-efi/include/efi/efi.h
new file mode 100644
index 0000000..e9de37b
--- /dev/null
+++ b/linux-x86_64/gnu-efi/include/efi/efi.h
@@ -0,0 +1,50 @@
+/*++
+
+Copyright (c) 1998  Intel Corporation
+
+Module Name:
+
+    efi.h
+
+Abstract:
+
+    Public EFI header files
+
+
+
+Revision History
+
+--*/
+
+//
+// Build flags on input
+//  EFI32
+//  EFI_DEBUG               - Enable debugging code
+//  EFI_NT_EMULATOR         - Building for running under NT
+//
+
+
+#ifndef _EFI_INCLUDE_
+#define _EFI_INCLUDE_
+
+#define EFI_FIRMWARE_VENDOR         L"INTEL"
+#define EFI_FIRMWARE_MAJOR_REVISION 12
+#define EFI_FIRMWARE_MINOR_REVISION 33
+#define EFI_FIRMWARE_REVISION ((EFI_FIRMWARE_MAJOR_REVISION <<16) | (EFI_FIRMWARE_MINOR_REVISION))
+
+#include "efibind.h"
+#include "efidef.h"
+#include "efidevp.h"
+#include "efipciio.h"
+#include "efiprot.h"
+#include "eficon.h"
+#include "efiser.h"
+#include "efi_nii.h"
+#include "efipxebc.h"
+#include "efinet.h"
+#include "efiapi.h"
+#include "efifs.h"
+#include "efierr.h"
+#include "efiui.h"
+
+#endif
diff --git a/linux-x86_64/gnu-efi/include/efi/efi_nii.h b/linux-x86_64/gnu-efi/include/efi/efi_nii.h
new file mode 100644
index 0000000..ba7a5b2
--- /dev/null
+++ b/linux-x86_64/gnu-efi/include/efi/efi_nii.h
@@ -0,0 +1,74 @@
+#ifndef _EFI_NII_H
+#define _EFI_NII_H
+
+/*++
+Copyright (c) 2000  Intel Corporation
+
+Module name:
+    efi_nii.h
+
+Abstract:
+
+Revision history:
+    2000-Feb-18 M(f)J   GUID updated.
+                Structure order changed for machine word alignment.
+                Added StringId[4] to structure.
+                
+    2000-Feb-14 M(f)J   Genesis.
+--*/
+
+#define EFI_NETWORK_INTERFACE_IDENTIFIER_PROTOCOL \
+    { 0xE18541CD, 0xF755, 0x4f73, {0x92, 0x8D, 0x64, 0x3C, 0x8A, 0x79, 0xB2, 0x29} }
+
+#define EFI_NETWORK_INTERFACE_IDENTIFIER_INTERFACE_REVISION 0x00010000
+
+typedef enum {
+    EfiNetworkInterfaceUndi = 1
+} EFI_NETWORK_INTERFACE_TYPE;
+
+typedef struct {
+
+    UINT64 Revision;
+    // Revision of the network interface identifier protocol interface.
+
+    UINT64 ID;
+    // Address of the first byte of the identifying structure for this
+    // network interface.  This is set to zero if there is no structure.
+    //
+    // For PXE/UNDI this is the first byte of the !PXE structure.
+
+    UINT64 ImageAddr;
+    // Address of the UNrelocated driver/ROM image.  This is set
+    // to zero if there is no driver/ROM image.
+    //
+    // For 16-bit UNDI, this is the first byte of the option ROM in
+    // upper memory.
+    //
+    // For 32/64-bit S/W UNDI, this is the first byte of the EFI ROM
+    // image.
+    //
+    // For H/W UNDI, this is set to zero.
+
+    UINT32 ImageSize;
+    // Size of the UNrelocated driver/ROM image of this network interface.
+    // This is set to zero if there is no driver/ROM image.
+
+    CHAR8 StringId[4];
+    // 4 char ASCII string to go in class identifier (option 60) in DHCP
+    // and Boot Server discover packets.
+    // For EfiNetworkInterfaceUndi this field is "UNDI".
+    // For EfiNetworkInterfaceSnp this field is "SNPN".
+
+    UINT8 Type;
+    UINT8 MajorVer;
+    UINT8 MinorVer;
+    // Information to be placed into the PXE DHCP and Discover packets.
+    // This is the network interface type and version number that will
+    // be placed into DHCP option 94 (client network interface identifier).
+    BOOLEAN Ipv6Supported;
+	UINT8   IfNum;	// interface number to be used with pxeid structure
+} EFI_NETWORK_INTERFACE_IDENTIFIER_INTERFACE;
+
+extern EFI_GUID NetworkInterfaceIdentifierProtocol;
+
+#endif // _EFI_NII_H
diff --git a/linux-x86_64/gnu-efi/include/efi/efi_pxe.h b/linux-x86_64/gnu-efi/include/efi/efi_pxe.h
new file mode 100644
index 0000000..d24251f
--- /dev/null
+++ b/linux-x86_64/gnu-efi/include/efi/efi_pxe.h
@@ -0,0 +1,1743 @@
+#ifndef _EFI_PXE_H
+#define _EFI_PXE_H
+
+
+/*++
+Copyright (c) Intel  1999
+
+Module name:
+    efi_pxe.h
+
+32/64-bit PXE specification:
+    alpha-4, 99-Dec-17
+
+Abstract:
+    This header file contains all of the PXE type definitions,
+    structure prototypes, global variables and constants that
+    are needed for porting PXE to EFI.
+--*/
+
+#pragma pack(1)
+
+#define PXE_INTEL_ORDER         1   // Intel order
+//#define PXE_NETWORK_ORDER         1   // network order
+
+#define PXE_UINT64_SUPPORT          1   // UINT64 supported
+//#define PXE_NO_UINT64_SUPPORT     1   // UINT64 not supported
+
+#define PXE_BUSTYPE(a,b,c,d)            \
+((((PXE_UINT32)(d) & 0xFF) << 24) | \
+(((PXE_UINT32)(c) & 0xFF) << 16) |  \
+(((PXE_UINT32)(b) & 0xFF) << 8) |       \
+((PXE_UINT32)(a) & 0xFF))
+
+//
+// UNDI ROM ID and devive ID signature
+//
+#define PXE_BUSTYPE_PXE         PXE_BUSTYPE('!', 'P', 'X', 'E')
+
+//
+// BUS ROM ID signatures
+//
+#define PXE_BUSTYPE_PCI         PXE_BUSTYPE('P', 'C', 'I', 'R')
+#define PXE_BUSTYPE_PC_CARD     PXE_BUSTYPE('P', 'C', 'C', 'R')
+#define PXE_BUSTYPE_USB         PXE_BUSTYPE('U', 'S', 'B', 'R')
+#define PXE_BUSTYPE_1394        PXE_BUSTYPE('1', '3', '9', '4')
+
+#define PXE_SWAP_UINT16(n)          \
+((((PXE_UINT16)(n) & 0x00FF) << 8) |    \
+(((PXE_UINT16)(n) & 0xFF00) >> 8))
+
+#define PXE_SWAP_UINT32(n)              \
+((((PXE_UINT32)(n) & 0x000000FF) << 24) |   \
+(((PXE_UINT32)(n) & 0x0000FF00) << 8) |     \
+(((PXE_UINT32)(n) & 0x00FF0000) >> 8) |     \
+(((PXE_UINT32)(n) & 0xFF000000) >> 24))
+
+#if PXE_UINT64_SUPPORT != 0
+#define PXE_SWAP_UINT64(n)                  \
+((((PXE_UINT64)(n) & 0x00000000000000FF) << 56) |   \
+(((PXE_UINT64)(n) & 0x000000000000FF00) << 40) |    \
+(((PXE_UINT64)(n) & 0x0000000000FF0000) << 24) |    \
+(((PXE_UINT64)(n) & 0x00000000FF000000) << 8) | \
+(((PXE_UINT64)(n) & 0x000000FF00000000) >> 8) | \
+(((PXE_UINT64)(n) & 0x0000FF0000000000) >> 24) |    \
+(((PXE_UINT64)(n) & 0x00FF000000000000) >> 40) |    \
+(((PXE_UINT64)(n) & 0xFF00000000000000) >> 56))
+#endif // PXE_UINT64_SUPPORT
+
+#if PXE_NO_UINT64_SUPPORT != 0
+#define PXE_SWAP_UINT64(n)                      \
+{                                       \
+PXE_UINT32 tmp = (PXE_UINT64)(n)[1];                \
+(PXE_UINT64)(n)[1] = PXE_SWAP_UINT32((PXE_UINT64)(n)[0]);   \
+(PXE_UINT64)(n)[0] = tmp;                       \
+}
+#endif // PXE_NO_UINT64_SUPPORT
+
+#define PXE_CPBSIZE_NOT_USED            0   // zero
+#define PXE_DBSIZE_NOT_USED         0   // zero
+#define PXE_CPBADDR_NOT_USED        (PXE_UINT64)0       // zero
+#define PXE_DBADDR_NOT_USED     (PXE_UINT64)0       // zero
+
+#define PXE_CONST const
+
+#define PXE_VOLATILE volatile
+
+typedef void PXE_VOID;
+
+typedef unsigned char PXE_UINT8;
+
+typedef unsigned short PXE_UINT16;
+
+typedef unsigned PXE_UINT32;
+
+#if PXE_UINT64_SUPPORT != 0
+// typedef unsigned long PXE_UINT64;
+typedef UINT64 PXE_UINT64;
+#endif // PXE_UINT64_SUPPORT
+
+#if PXE_NO_UINT64_SUPPORT != 0
+typedef PXE_UINT32 PXE_UINT64[2];
+#endif // PXE_NO_UINT64_SUPPORT
+
+typedef unsigned PXE_UINTN;
+
+typedef PXE_UINT8 PXE_BOOL;
+
+#define PXE_FALSE               0   // zero
+#define PXE_TRUE                    (!PXE_FALSE)
+
+typedef PXE_UINT16 PXE_OPCODE;
+
+//
+// Return UNDI operational state.
+//
+#define PXE_OPCODE_GET_STATE                    0x0000
+
+//
+// Change UNDI operational state from Stopped to Started.
+//
+#define PXE_OPCODE_START                    0x0001
+
+//
+// Change UNDI operational state from Started to Stopped.
+//
+#define PXE_OPCODE_STOP                     0x0002
+
+//
+// Get UNDI initialization information.
+//
+#define PXE_OPCODE_GET_INIT_INFO                0x0003
+
+//
+// Get NIC configuration information.
+//
+#define PXE_OPCODE_GET_CONFIG_INFO              0x0004
+
+//
+// Changed UNDI operational state from Started to Initialized.
+//
+#define PXE_OPCODE_INITIALIZE                   0x0005
+
+//
+// Re-initialize the NIC H/W.
+//
+#define PXE_OPCODE_RESET                    0x0006
+
+//
+// Change the UNDI operational state from Initialized to Started.
+//
+#define PXE_OPCODE_SHUTDOWN                 0x0007
+
+//
+// Read & change state of external interrupt enables.
+//
+#define PXE_OPCODE_INTERRUPT_ENABLES                0x0008
+
+//
+// Read & change state of packet receive filters.
+//
+#define PXE_OPCODE_RECEIVE_FILTERS              0x0009
+
+//
+// Read & change station MAC address.
+//
+#define PXE_OPCODE_STATION_ADDRESS              0x000A
+
+//
+// Read traffic statistics.
+//
+#define PXE_OPCODE_STATISTICS                   0x000B
+
+//
+// Convert multicast IP address to multicast MAC address.
+//
+#define PXE_OPCODE_MCAST_IP_TO_MAC              0x000C
+
+//
+// Read or change non-volatile storage on the NIC.
+//
+#define PXE_OPCODE_NVDATA                   0x000D
+
+//
+// Get & clear interrupt status.
+//
+#define PXE_OPCODE_GET_STATUS                   0x000E
+
+//
+// Fill media header in packet for transmit.
+//
+#define PXE_OPCODE_FILL_HEADER              0x000F
+
+//
+// Transmit packet(s).
+//
+#define PXE_OPCODE_TRANSMIT                 0x0010
+
+//
+// Receive packet.
+//
+#define PXE_OPCODE_RECEIVE                  0x0011
+
+// last valid opcode:
+#define PXE_OPCODE_VALID_MAX                    0x0011
+
+//
+// Last valid PXE UNDI OpCode number.
+//
+#define PXE_OPCODE_LAST_VALID                   0x0011
+
+typedef PXE_UINT16 PXE_OPFLAGS;
+
+#define PXE_OPFLAGS_NOT_USED                    0x0000
+
+////////////////////////////////////////
+// UNDI Get State
+//
+
+// No OpFlags
+
+////////////////////////////////////////
+// UNDI Start
+//
+
+// No OpFlags
+
+////////////////////////////////////////
+// UNDI Stop
+//
+
+// No OpFlags
+
+////////////////////////////////////////
+// UNDI Get Init Info
+//
+
+// No Opflags
+
+////////////////////////////////////////
+// UNDI Get Config Info
+//
+
+// No Opflags
+
+////////////////////////////////////////
+// UNDI Initialize
+//
+
+#define PXE_OPFLAGS_INITIALIZE_CABLE_DETECT_MASK    0x0001
+#define PXE_OPFLAGS_INITIALIZE_DETECT_CABLE         0x0000
+#define PXE_OPFLAGS_INITIALIZE_DO_NOT_DETECT_CABLE  0x0001
+
+////////////////////////////////////////
+// UNDI Reset
+//
+
+#define PXE_OPFLAGS_RESET_DISABLE_INTERRUPTS        0x0001
+#define PXE_OPFLAGS_RESET_DISABLE_FILTERS           0x0002
+
+////////////////////////////////////////
+// UNDI Shutdown
+//
+
+// No OpFlags
+
+////////////////////////////////////////
+// UNDI Interrupt Enables
+//
+
+//
+// Select whether to enable or disable external interrupt signals.
+// Setting both enable and disable will return PXE_STATCODE_INVALID_OPFLAGS.
+//
+#define PXE_OPFLAGS_INTERRUPT_OPMASK                0xC000
+#define PXE_OPFLAGS_INTERRUPT_ENABLE                0x8000
+#define PXE_OPFLAGS_INTERRUPT_DISABLE           0x4000
+#define PXE_OPFLAGS_INTERRUPT_READ              0x0000
+
+//
+// Enable receive interrupts.  An external interrupt will be generated
+// after a complete non-error packet has been received.
+//
+#define PXE_OPFLAGS_INTERRUPT_RECEIVE           0x0001
+
+//
+// Enable transmit interrupts.  An external interrupt will be generated
+// after a complete non-error packet has been transmitted.
+//
+#define PXE_OPFLAGS_INTERRUPT_TRANSMIT          0x0002
+
+//
+// Enable command interrupts.  An external interrupt will be generated
+// when command execution stops.
+//
+#define PXE_OPFLAGS_INTERRUPT_COMMAND           0x0004
+
+//
+// Generate software interrupt.  Setting this bit generates an external
+// interrupt, if it is supported by the hardware.
+//
+#define PXE_OPFLAGS_INTERRUPT_SOFTWARE          0x0008
+
+////////////////////////////////////////
+// UNDI Receive Filters
+//
+
+//
+// Select whether to enable or disable receive filters.
+// Setting both enable and disable will return PXE_STATCODE_INVALID_OPCODE.
+//
+#define PXE_OPFLAGS_RECEIVE_FILTER_OPMASK           0xC000
+#define PXE_OPFLAGS_RECEIVE_FILTER_ENABLE           0x8000
+#define PXE_OPFLAGS_RECEIVE_FILTER_DISABLE          0x4000
+#define PXE_OPFLAGS_RECEIVE_FILTER_READ         0x0000
+
+//
+// To reset the contents of the multicast MAC address filter list,
+// set this OpFlag:
+//
+#define PXE_OPFLAGS_RECEIVE_FILTER_RESET_MCAST_LIST 0x2000
+
+//
+// Enable unicast packet receiving.  Packets sent to the current station
+// MAC address will be received.
+//
+#define PXE_OPFLAGS_RECEIVE_FILTER_UNICAST          0x0001
+
+//
+// Enable broadcast packet receiving.  Packets sent to the broadcast 
+// MAC address will be received.
+//
+#define PXE_OPFLAGS_RECEIVE_FILTER_BROADCAST        0x0002
+
+//
+// Enable filtered multicast packet receiving.  Packets sent to any
+// of the multicast MAC addresses in the multicast MAC address filter
+// list will be received.  If the filter list is empty, no multicast
+//
+#define PXE_OPFLAGS_RECEIVE_FILTER_FILTERED_MULTICAST   0x0004
+
+//
+// Enable promiscuous packet receiving.  All packets will be received.
+//
+#define PXE_OPFLAGS_RECEIVE_FILTER_PROMISCUOUS      0x0008
+
+//
+// Enable promiscuous multicast packet receiving.  All multicast
+// packets will be received.
+//
+#define PXE_OPFLAGS_RECEIVE_FILTER_ALL_MULTICAST        0x0010
+
+////////////////////////////////////////
+// UNDI Station Address
+//
+
+#define PXE_OPFLAGS_STATION_ADDRESS_READ            0x0000
+#define PXE_OPFLAGS_STATION_ADDRESS_RESET           0x0001
+
+////////////////////////////////////////
+// UNDI Statistics
+//
+
+#define PXE_OPFLAGS_STATISTICS_READ             0x0000
+#define PXE_OPFLAGS_STATISTICS_RESET                0x0001
+
+////////////////////////////////////////
+// UNDI MCast IP to MAC
+//
+
+//
+// Identify the type of IP address in the CPB.
+//
+#define PXE_OPFLAGS_MCAST_IP_TO_MAC_OPMASK          0x0003
+#define PXE_OPFLAGS_MCAST_IPV4_TO_MAC           0x0000
+#define PXE_OPFLAGS_MCAST_IPV6_TO_MAC           0x0001
+
+////////////////////////////////////////
+// UNDI NvData
+//
+
+//
+// Select the type of non-volatile data operation.
+//
+#define PXE_OPFLAGS_NVDATA_OPMASK               0x0001
+#define PXE_OPFLAGS_NVDATA_READ             0x0000
+#define PXE_OPFLAGS_NVDATA_WRITE                0x0001
+
+////////////////////////////////////////
+// UNDI Get Status
+//
+
+//
+// Return current interrupt status.  This will also clear any interrupts
+// that are currently set.  This can be used in a polling routine.  The
+// interrupt flags are still set and cleared even when the interrupts
+// are disabled.
+//
+#define PXE_OPFLAGS_GET_INTERRUPT_STATUS            0x0001
+
+//
+// Return list of transmitted buffers for recycling.  Transmit buffers
+// must not be changed or unallocated until they have recycled.  After
+// issuing a transmit command, wait for a transmit complete interrupt.
+// When a transmit complete interrupt is received, read the transmitted
+// buffers.  Do not plan on getting one buffer per interrupt.  Some
+// NICs and UNDIs may transmit multiple buffers per interrupt.
+//
+#define PXE_OPFLAGS_GET_TRANSMITTED_BUFFERS         0x0002
+
+////////////////////////////////////////
+// UNDI Fill Header
+//
+
+#define PXE_OPFLAGS_FILL_HEADER_OPMASK          0x0001
+#define PXE_OPFLAGS_FILL_HEADER_FRAGMENTED          0x0001
+#define PXE_OPFLAGS_FILL_HEADER_WHOLE           0x0000
+
+////////////////////////////////////////
+// UNDI Transmit
+//
+
+//
+// S/W UNDI only.  Return after the packet has been transmitted.  A
+// transmit complete interrupt will still be generated and the transmit
+// buffer will have to be recycled.
+//
+#define PXE_OPFLAGS_SWUNDI_TRANSMIT_OPMASK          0x0001
+#define PXE_OPFLAGS_TRANSMIT_BLOCK              0x0001
+#define PXE_OPFLAGS_TRANSMIT_DONT_BLOCK         0x0000
+
+//
+//
+//
+#define PXE_OPFLAGS_TRANSMIT_OPMASK             0x0002
+#define PXE_OPFLAGS_TRANSMIT_FRAGMENTED         0x0002
+#define PXE_OPFLAGS_TRANSMIT_WHOLE              0x0000
+
+////////////////////////////////////////
+// UNDI Receive
+//
+
+// No OpFlags
+
+typedef PXE_UINT16 PXE_STATFLAGS;
+
+#define PXE_STATFLAGS_INITIALIZE                0x0000
+
+////////////////////////////////////////
+// Common StatFlags that can be returned by all commands.
+//
+
+//
+// The COMMAND_COMPLETE and COMMAND_FAILED status flags must be
+// implemented by all UNDIs.  COMMAND_QUEUED is only needed by UNDIs
+// that support command queuing.
+//
+#define PXE_STATFLAGS_STATUS_MASK               0xC000
+#define PXE_STATFLAGS_COMMAND_COMPLETE          0xC000
+#define PXE_STATFLAGS_COMMAND_FAILED                0x8000
+#define PXE_STATFLAGS_COMMAND_QUEUED                0x4000
+//#define PXE_STATFLAGS_INITIALIZE              0x0000
+
+#define PXE_STATFLAGS_DB_WRITE_TRUNCATED            0x2000
+
+////////////////////////////////////////
+// UNDI Get State
+//
+
+#define PXE_STATFLAGS_GET_STATE_MASK                0x0003
+#define PXE_STATFLAGS_GET_STATE_INITIALIZED         0x0002
+#define PXE_STATFLAGS_GET_STATE_STARTED         0x0001
+#define PXE_STATFLAGS_GET_STATE_STOPPED         0x0000
+
+////////////////////////////////////////
+// UNDI Start
+//
+
+// No additional StatFlags
+
+////////////////////////////////////////
+// UNDI Get Init Info
+//
+
+#define PXE_STATFLAGS_CABLE_DETECT_MASK          0x0001
+#define PXE_STATFLAGS_CABLE_DETECT_NOT_SUPPORTED 0x0000
+#define PXE_STATFLAGS_CABLE_DETECT_SUPPORTED     0x0001
+
+
+////////////////////////////////////////
+// UNDI Initialize
+//
+
+#define PXE_STATFLAGS_INITIALIZED_NO_MEDIA          0x0001
+
+////////////////////////////////////////
+// UNDI Reset
+//
+
+#define PXE_STATFLAGS_RESET_NO_MEDIA                0x0001
+
+////////////////////////////////////////
+// UNDI Shutdown
+//
+
+// No additional StatFlags
+
+////////////////////////////////////////
+// UNDI Interrupt Enables
+//
+
+//
+// If set, receive interrupts are enabled.
+//
+#define PXE_STATFLAGS_INTERRUPT_RECEIVE         0x0001
+
+//
+// If set, transmit interrupts are enabled.
+//
+#define PXE_STATFLAGS_INTERRUPT_TRANSMIT            0x0002
+
+//
+// If set, command interrupts are enabled.
+//
+#define PXE_STATFLAGS_INTERRUPT_COMMAND         0x0004
+
+
+////////////////////////////////////////
+// UNDI Receive Filters
+//
+
+//
+// If set, unicast packets will be received.
+//
+#define PXE_STATFLAGS_RECEIVE_FILTER_UNICAST        0x0001
+
+//
+// If set, broadcast packets will be received.
+//
+#define PXE_STATFLAGS_RECEIVE_FILTER_BROADCAST      0x0002
+
+//
+// If set, multicast packets that match up with the multicast address
+// filter list will be received.
+//
+#define PXE_STATFLAGS_RECEIVE_FILTER_FILTERED_MULTICAST 0x0004
+
+//
+// If set, all packets will be received.
+//
+#define PXE_STATFLAGS_RECEIVE_FILTER_PROMISCUOUS        0x0008
+
+//
+// If set, all multicast packets will be received.
+//
+#define PXE_STATFLAGS_RECEIVE_FILTER_ALL_MULTICAST  0x0010
+
+////////////////////////////////////////
+// UNDI Station Address
+//
+
+// No additional StatFlags
+
+////////////////////////////////////////
+// UNDI Statistics
+//
+
+// No additional StatFlags
+
+////////////////////////////////////////
+// UNDI MCast IP to MAC
+//
+
+// No additional StatFlags
+
+////////////////////////////////////////
+// UNDI NvData
+//
+
+// No additional StatFlags
+
+
+////////////////////////////////////////
+// UNDI Get Status
+//
+
+//
+// Use to determine if an interrupt has occurred.
+//
+#define PXE_STATFLAGS_GET_STATUS_INTERRUPT_MASK     0x000F
+#define PXE_STATFLAGS_GET_STATUS_NO_INTERRUPTS      0x0000
+
+//
+// If set, at least one receive interrupt occurred.
+//
+#define PXE_STATFLAGS_GET_STATUS_RECEIVE            0x0001
+
+//
+// If set, at least one transmit interrupt occurred.
+//
+#define PXE_STATFLAGS_GET_STATUS_TRANSMIT           0x0002
+
+//
+// If set, at least one command interrupt occurred.
+//
+#define PXE_STATFLAGS_GET_STATUS_COMMAND            0x0004
+
+//
+// If set, at least one software interrupt occurred.
+//
+#define PXE_STATFLAGS_GET_STATUS_SOFTWARE           0x0008
+
+//
+// This flag is set if the transmitted buffer queue is empty.  This flag
+// will be set if all transmitted buffer addresses get written into the DB.
+//
+#define PXE_STATFLAGS_GET_STATUS_TXBUF_QUEUE_EMPTY  0x0010
+
+//
+// This flag is set if no transmitted buffer addresses were written
+// into the DB.  (This could be because DBsize was too small.)
+//
+#define PXE_STATFLAGS_GET_STATUS_NO_TXBUFS_WRITTEN  0x0020
+
+////////////////////////////////////////
+// UNDI Fill Header
+//
+
+// No additional StatFlags
+
+////////////////////////////////////////
+// UNDI Transmit
+//
+
+// No additional StatFlags.
+
+////////////////////////////////////////
+// UNDI Receive
+//
+
+// No additional StatFlags.
+
+typedef PXE_UINT16 PXE_STATCODE;
+
+#define PXE_STATCODE_INITIALIZE             0x0000
+
+////////////////////////////////////////
+// Common StatCodes returned by all UNDI commands, UNDI protocol functions
+// and BC protocol functions.
+//
+
+#define PXE_STATCODE_SUCCESS                    0x0000
+
+#define PXE_STATCODE_INVALID_CDB                0x0001
+#define PXE_STATCODE_INVALID_CPB                0x0002
+#define PXE_STATCODE_BUSY                   	0x0003
+#define PXE_STATCODE_QUEUE_FULL             	0x0004
+#define PXE_STATCODE_ALREADY_STARTED            0x0005
+#define PXE_STATCODE_NOT_STARTED                0x0006
+#define PXE_STATCODE_NOT_SHUTDOWN               0x0007
+#define PXE_STATCODE_ALREADY_INITIALIZED        0x0008
+#define PXE_STATCODE_NOT_INITIALIZED            0x0009
+#define PXE_STATCODE_DEVICE_FAILURE             0x000A
+#define PXE_STATCODE_NVDATA_FAILURE             0x000B
+#define PXE_STATCODE_UNSUPPORTED                0x000C
+#define PXE_STATCODE_BUFFER_FULL                0x000D
+#define PXE_STATCODE_INVALID_PARAMETER		0x000E
+#define PXE_STATCODE_INVALID_UNDI		0x000F
+#define PXE_STATCODE_IPV4_NOT_SUPPORTED		0x0010
+#define PXE_STATCODE_IPV6_NOT_SUPPORTED		0x0011
+#define PXE_STATCODE_NOT_ENOUGH_MEMORY		0x0012
+#define PXE_STATCODE_NO_DATA			0x0013
+
+
+typedef PXE_UINT16 PXE_IFNUM;
+
+//
+// This interface number must be passed to the S/W UNDI Start command.
+//
+#define PXE_IFNUM_START                     0x0000
+
+//
+// This interface number is returned by the S/W UNDI Get State and
+// Start commands if information in the CDB, CPB or DB is invalid.
+//
+#define PXE_IFNUM_INVALID                   0x0000
+
+typedef PXE_UINT16 PXE_CONTROL;
+
+//
+// Setting this flag directs the UNDI to queue this command for later
+// execution if the UNDI is busy and it supports command queuing.
+// If queuing is not supported, a PXE_STATCODE_INVALID_CONTROL error
+// is returned.  If the queue is full, a PXE_STATCODE_CDB_QUEUE_FULL 
+// error is returned.
+//
+#define PXE_CONTROL_QUEUE_IF_BUSY               0x0002
+
+//
+// These two bit values are used to determine if there are more UNDI
+// CDB structures following this one.  If the link bit is set, there
+// must be a CDB structure following this one.  Execution will start
+// on the next CDB structure as soon as this one completes successfully.
+// If an error is generated by this command, execution will stop.
+//
+#define PXE_CONTROL_LINK                    0x0001
+#define PXE_CONTROL_LAST_CDB_IN_LIST                0x0000
+
+typedef PXE_UINT8 PXE_FRAME_TYPE;
+
+#define PXE_FRAME_TYPE_NONE                 0x00
+#define PXE_FRAME_TYPE_UNICAST              0x01
+#define PXE_FRAME_TYPE_BROADCAST                0x02
+#define PXE_FRAME_TYPE_MULTICAST            0x03
+#define PXE_FRAME_TYPE_PROMISCUOUS              0x04
+
+typedef PXE_UINT32 PXE_IPV4;
+
+typedef PXE_UINT32 PXE_IPV6[4];
+#define PXE_MAC_LENGTH 32
+
+typedef PXE_UINT8 PXE_MAC_ADDR[PXE_MAC_LENGTH];
+
+typedef PXE_UINT8 PXE_IFTYPE;
+typedef PXE_UINT16 PXE_MEDIA_PROTOCOL;
+
+//
+// This information is from the ARP section of RFC 1700.
+//
+//     1 Ethernet (10Mb)                                    [JBP]
+//     2 Experimental Ethernet (3Mb)                        [JBP]
+//     3 Amateur Radio AX.25                                [PXK]
+//     4 Proteon ProNET Token Ring                          [JBP]
+//     5 Chaos                                              [GXP]
+//     6 IEEE 802 Networks                                  [JBP]
+//     7 ARCNET                                             [JBP]
+//     8 Hyperchannel                                       [JBP]
+//     9 Lanstar                                             [TU]
+//    10 Autonet Short Address                             [MXB1]
+//    11 LocalTalk                                         [JKR1]
+//    12 LocalNet (IBM PCNet or SYTEK LocalNET)             [JXM]
+//    13 Ultra link                                        [RXD2]
+//    14 SMDS                                              [GXC1]
+//    15 Frame Relay                                        [AGM]
+//    16 Asynchronous Transmission Mode (ATM)              [JXB2]
+//    17 HDLC                                               [JBP]
+//    18 Fibre Channel                            [Yakov Rekhter]
+//    19 Asynchronous Transmission Mode (ATM)      [Mark Laubach]
+//    20 Serial Line                                        [JBP]
+//    21 Asynchronous Transmission Mode (ATM)              [MXB1]
+//
+
+#define PXE_IFTYPE_ETHERNET                 0x01
+#define PXE_IFTYPE_TOKENRING                    0x04
+#define PXE_IFTYPE_FIBRE_CHANNEL                0x12
+
+typedef struct s_pxe_hw_undi {
+PXE_UINT32 Signature;       // PXE_ROMID_SIGNATURE
+PXE_UINT8 Len;          // sizeof(PXE_HW_UNDI)
+PXE_UINT8 Fudge;            // makes 8-bit cksum equal zero
+PXE_UINT8 Rev;          // PXE_ROMID_REV
+PXE_UINT8 IFcnt;            // physical connector count
+PXE_UINT8 MajorVer;         // PXE_ROMID_MAJORVER
+PXE_UINT8 MinorVer;         // PXE_ROMID_MINORVER
+PXE_UINT16 reserved;        // zero, not used
+PXE_UINT32 Implementation;      // implementation flags
+// reserved             // vendor use
+// PXE_UINT32 Status;       // status port
+// PXE_UINT32 Command;      // command port
+// PXE_UINT64 CDBaddr;      // CDB address port
+} PXE_HW_UNDI;
+
+//
+// Status port bit definitions
+//
+
+//
+// UNDI operation state
+//
+#define PXE_HWSTAT_STATE_MASK                   0xC0000000
+#define PXE_HWSTAT_BUSY                     0xC0000000
+#define PXE_HWSTAT_INITIALIZED              0x80000000
+#define PXE_HWSTAT_STARTED                  0x40000000
+#define PXE_HWSTAT_STOPPED                  0x00000000
+
+//
+// If set, last command failed
+//
+#define PXE_HWSTAT_COMMAND_FAILED               0x20000000
+
+//
+// If set, identifies enabled receive filters
+//
+#define PXE_HWSTAT_PROMISCUOUS_MULTICAST_RX_ENABLED 0x00001000
+#define PXE_HWSTAT_PROMISCUOUS_RX_ENABLED           0x00000800
+#define PXE_HWSTAT_BROADCAST_RX_ENABLED         0x00000400
+#define PXE_HWSTAT_MULTICAST_RX_ENABLED         0x00000200
+#define PXE_HWSTAT_UNICAST_RX_ENABLED           0x00000100
+
+//
+// If set, identifies enabled external interrupts
+//
+#define PXE_HWSTAT_SOFTWARE_INT_ENABLED         0x00000080
+#define PXE_HWSTAT_TX_COMPLETE_INT_ENABLED          0x00000040
+#define PXE_HWSTAT_PACKET_RX_INT_ENABLED            0x00000020
+#define PXE_HWSTAT_CMD_COMPLETE_INT_ENABLED         0x00000010
+
+//
+// If set, identifies pending interrupts
+//
+#define PXE_HWSTAT_SOFTWARE_INT_PENDING         0x00000008
+#define PXE_HWSTAT_TX_COMPLETE_INT_PENDING          0x00000004
+#define PXE_HWSTAT_PACKET_RX_INT_PENDING            0x00000002
+#define PXE_HWSTAT_CMD_COMPLETE_INT_PENDING         0x00000001
+
+//
+// Command port definitions
+//
+
+//
+// If set, CDB identified in CDBaddr port is given to UNDI.
+// If not set, other bits in this word will be processed.
+//
+#define PXE_HWCMD_ISSUE_COMMAND             0x80000000
+#define PXE_HWCMD_INTS_AND_FILTS                0x00000000
+
+//
+// Use these to enable/disable receive filters.
+//
+#define PXE_HWCMD_PROMISCUOUS_MULTICAST_RX_ENABLE       0x00001000
+#define PXE_HWCMD_PROMISCUOUS_RX_ENABLE         0x00000800
+#define PXE_HWCMD_BROADCAST_RX_ENABLE           0x00000400
+#define PXE_HWCMD_MULTICAST_RX_ENABLE           0x00000200
+#define PXE_HWCMD_UNICAST_RX_ENABLE             0x00000100
+
+//
+// Use these to enable/disable external interrupts
+//
+#define PXE_HWCMD_SOFTWARE_INT_ENABLE           0x00000080
+#define PXE_HWCMD_TX_COMPLETE_INT_ENABLE            0x00000040
+#define PXE_HWCMD_PACKET_RX_INT_ENABLE          0x00000020
+#define PXE_HWCMD_CMD_COMPLETE_INT_ENABLE           0x00000010
+
+//
+// Use these to clear pending external interrupts
+//
+#define PXE_HWCMD_CLEAR_SOFTWARE_INT                0x00000008
+#define PXE_HWCMD_CLEAR_TX_COMPLETE_INT         0x00000004
+#define PXE_HWCMD_CLEAR_PACKET_RX_INT           0x00000002
+#define PXE_HWCMD_CLEAR_CMD_COMPLETE_INT            0x00000001
+
+typedef struct s_pxe_sw_undi {
+PXE_UINT32 Signature;       // PXE_ROMID_SIGNATURE
+PXE_UINT8 Len;          // sizeof(PXE_SW_UNDI)
+PXE_UINT8 Fudge;            // makes 8-bit cksum zero
+PXE_UINT8 Rev;          // PXE_ROMID_REV
+PXE_UINT8 IFcnt;            // physical connector count
+PXE_UINT8 MajorVer;         // PXE_ROMID_MAJORVER
+PXE_UINT8 MinorVer;         // PXE_ROMID_MINORVER
+PXE_UINT16 reserved1;       // zero, not used
+PXE_UINT32 Implementation;      // Implementation flags
+PXE_UINT64 EntryPoint;      // API entry point
+PXE_UINT8 reserved2[3];     // zero, not used
+PXE_UINT8 BusCnt;           // number of bustypes supported
+PXE_UINT32 BusType[1];      // list of supported bustypes
+} PXE_SW_UNDI;
+
+typedef union u_pxe_undi {
+PXE_HW_UNDI hw;
+PXE_SW_UNDI sw;
+} PXE_UNDI;
+
+//
+// Signature of !PXE structure
+//
+#define PXE_ROMID_SIGNATURE     PXE_BUSTYPE('!', 'P', 'X', 'E')
+
+//
+// !PXE structure format revision
+//
+#define PXE_ROMID_REV                       0x02
+
+//
+// UNDI command interface revision.  These are the values that get sent
+// in option 94 (Client Network Interface Identifier) in the DHCP Discover
+// and PXE Boot Server Request packets.
+//
+#define PXE_ROMID_MAJORVER                  0x03
+#define PXE_ROMID_MINORVER                  0x00
+
+//
+// Implementation flags
+//
+#define PXE_ROMID_IMP_HW_UNDI                   0x80000000
+#define PXE_ROMID_IMP_SW_VIRT_ADDR              0x40000000
+#define PXE_ROMID_IMP_64BIT_DEVICE              0x00010000
+#define PXE_ROMID_IMP_FRAG_SUPPORTED                0x00008000
+#define PXE_ROMID_IMP_CMD_LINK_SUPPORTED            0x00004000
+#define PXE_ROMID_IMP_CMD_QUEUE_SUPPORTED           0x00002000
+#define PXE_ROMID_IMP_MULTI_FRAME_SUPPORTED         0x00001000
+#define PXE_ROMID_IMP_NVDATA_SUPPORT_MASK           0x00000C00
+#define PXE_ROMID_IMP_NVDATA_BULK_WRITABLE          0x00000C00
+#define PXE_ROMID_IMP_NVDATA_SPARSE_WRITABLE        0x00000800
+#define PXE_ROMID_IMP_NVDATA_READ_ONLY          0x00000400
+#define PXE_ROMID_IMP_NVDATA_NOT_AVAILABLE          0x00000000
+#define PXE_ROMID_IMP_STATISTICS_SUPPORTED          0x00000200
+#define PXE_ROMID_IMP_STATION_ADDR_SETTABLE         0x00000100
+#define PXE_ROMID_IMP_PROMISCUOUS_MULTICAST_RX_SUPPORTED    0x00000080
+#define PXE_ROMID_IMP_PROMISCUOUS_RX_SUPPORTED      0x00000040
+#define PXE_ROMID_IMP_BROADCAST_RX_SUPPORTED        0x00000020
+#define PXE_ROMID_IMP_FILTERED_MULTICAST_RX_SUPPORTED   0x00000010
+#define PXE_ROMID_IMP_SOFTWARE_INT_SUPPORTED        0x00000008
+#define PXE_ROMID_IMP_TX_COMPLETE_INT_SUPPORTED     0x00000004
+#define PXE_ROMID_IMP_PACKET_RX_INT_SUPPORTED       0x00000002
+#define PXE_ROMID_IMP_CMD_COMPLETE_INT_SUPPORTED        0x00000001
+
+ 
+typedef struct s_pxe_cdb {
+PXE_OPCODE OpCode;
+PXE_OPFLAGS OpFlags;
+PXE_UINT16 CPBsize;
+PXE_UINT16 DBsize;
+UINT64 CPBaddr;
+UINT64 DBaddr;
+PXE_STATCODE StatCode;
+PXE_STATFLAGS StatFlags;
+PXE_UINT16 IFnum;
+PXE_CONTROL Control;
+} PXE_CDB;
+
+
+typedef union u_pxe_ip_addr {
+PXE_IPV6 IPv6;
+PXE_IPV4 IPv4;
+} PXE_IP_ADDR;
+
+typedef union pxe_device {
+//
+// PCI and PC Card NICs are both identified using bus, device
+// and function numbers.  For PC Card, this may require PC
+// Card services to be loaded in the BIOS or preboot
+// environment.
+//
+struct {
+//
+// See S/W UNDI ROMID structure definition for PCI and
+// PCC BusType definitions.
+//
+PXE_UINT32 BusType;
+
+//
+// Bus, device & function numbers that locate this device.
+//
+PXE_UINT16 Bus;
+PXE_UINT8 Device;
+PXE_UINT8 Function;
+} PCI, PCC;
+
+//
+// %%TBD - More information is needed about enumerating
+// USB and 1394 devices.
+//
+struct {
+PXE_UINT32 BusType;
+PXE_UINT32 tdb;
+} USB, _1394;
+} PXE_DEVICE;
+
+// cpb and db definitions
+
+#define MAX_PCI_CONFIG_LEN 64   // # of dwords
+#define MAX_EEPROM_LEN 128       // #of dwords
+#define MAX_XMIT_BUFFERS    32  // recycling Q length for xmit_done
+#define MAX_MCAST_ADDRESS_CNT 8
+
+typedef struct s_pxe_cpb_start {
+    //
+    // PXE_VOID Delay(PXE_UINT64 microseconds);
+    //
+    // UNDI will never request a delay smaller than 10 microseconds
+    // and will always request delays in increments of 10 microseconds.
+    // The Delay() CallBack routine must delay between n and n + 10 
+    // microseconds before returning control to the UNDI.
+    //
+    // This field cannot be set to zero.
+    //
+    PXE_UINT64 Delay;
+
+    //
+    // PXE_VOID Block(PXE_UINT32 enable);
+    //
+    // UNDI may need to block multi-threaded/multi-processor access to
+    // critical code sections when programming or accessing the network
+    // device.  To this end, a blocking service is needed by the UNDI.
+    // When UNDI needs a block, it will call Block() passing a non-zero
+    // value.  When UNDI no longer needs a block, it will call Block()
+    // with a zero value.  When called, if the Block() is already enabled,
+    // do not return control to the UNDI until the previous Block() is
+    // disabled.
+    //
+    // This field cannot be set to zero.
+    //
+    PXE_UINT64 Block;
+
+    //
+    // PXE_VOID Virt2Phys(PXE_UINT64 virtual, PXE_UINT64 physical_ptr);
+    //
+    // UNDI will pass the virtual address of a buffer and the virtual
+    // address of a 64-bit physical buffer.  Convert the virtual address
+    // to a physical address and write the result to the physical address
+    // buffer.  If virtual and physical addresses are the same, just
+    // copy the virtual address to the physical address buffer.
+    //
+    // This field can be set to zero if virtual and physical addresses 
+    // are equal.
+    //
+    PXE_UINT64 Virt2Phys;
+    //
+    // PXE_VOID Mem_IO(PXE_UINT8 read_write, PXE_UINT8 len, PXE_UINT64 port, 
+    //              PXE_UINT64 buf_addr);
+    //
+    // UNDI will read or write the device io space using this call back 
+    // function. It passes the number of bytes as the len parameter and it 
+    // will be either 1,2,4 or 8.
+    //
+    // This field can not be set to zero.
+    //
+    PXE_UINT64 Mem_IO;
+} PXE_CPB_START;
+
+#define PXE_DELAY_MILLISECOND                   1000
+#define PXE_DELAY_SECOND                    1000000
+#define PXE_IO_READ                     0
+#define PXE_IO_WRITE                        1
+#define PXE_MEM_READ                        2
+#define PXE_MEM_WRITE                       4
+
+
+typedef struct s_pxe_db_get_init_info {
+    //
+    // Minimum length of locked memory buffer that must be given to
+    // the Initialize command. Giving UNDI more memory will generally
+    // give better performance.
+    //
+    // If MemoryRequired is zero, the UNDI does not need and will not
+    // use system memory to receive and transmit packets.
+    //
+    PXE_UINT32 MemoryRequired;
+
+    //
+    // Maximum frame data length for Tx/Rx excluding the media header.
+    //
+    PXE_UINT32 FrameDataLen;
+
+    //
+    // Supported link speeds are in units of mega bits.  Common ethernet
+    // values are 10, 100 and 1000.  Unused LinkSpeeds[] entries are zero
+    // filled.
+    //
+    PXE_UINT32 LinkSpeeds[4];
+
+    //
+    // Number of non-volatile storage items.
+    //
+    PXE_UINT32 NvCount;
+
+    //
+    // Width of non-volatile storage item in bytes.  0, 1, 2 or 4
+    //
+    PXE_UINT16 NvWidth;
+
+    //
+    // Media header length.  This is the typical media header length for
+    // this UNDI.  This information is needed when allocating receive
+    // and transmit buffers.
+    //
+    PXE_UINT16 MediaHeaderLen;
+
+    //
+    // Number of bytes in the NIC hardware (MAC) address.
+    //
+    PXE_UINT16 HWaddrLen;
+
+    //
+    // Maximum number of multicast MAC addresses in the multicast
+    // MAC address filter list.
+    //
+    PXE_UINT16 MCastFilterCnt;
+
+    //
+    // Default number and size of transmit and receive buffers that will 
+    // be allocated by the UNDI.  If MemoryRequired is non-zero, this 
+    // allocation will come out of the memory buffer given to the Initialize 
+    // command.  If MemoryRequired is zero, this allocation will come out of 
+    // memory on the NIC.
+    //
+    PXE_UINT16 TxBufCnt;
+    PXE_UINT16 TxBufSize;
+    PXE_UINT16 RxBufCnt;
+    PXE_UINT16 RxBufSize;
+
+    //
+    // Hardware interface types defined in the Assigned Numbers RFC
+    // and used in DHCP and ARP packets.
+    // See the PXE_IFTYPE typedef and PXE_IFTYPE_xxx macros.
+    //
+    PXE_UINT8 IFtype;
+
+    //
+    // Supported duplex.  See PXE_DUPLEX_xxxxx #defines below.
+    //
+    PXE_UINT8 Duplex;
+
+    //
+    // Supported loopback options.  See PXE_LOOPBACK_xxxxx #defines below.
+    //
+    PXE_UINT8 LoopBack;
+} PXE_DB_GET_INIT_INFO;
+
+#define PXE_MAX_TXRX_UNIT_ETHER             1500
+
+#define PXE_HWADDR_LEN_ETHER                    0x0006
+#define PXE_MAC_HEADER_LEN_ETHER                0x000E
+
+#define PXE_DUPLEX_ENABLE_FULL_SUPPORTED            1
+#define PXE_DUPLEX_FORCE_FULL_SUPPORTED         2
+
+#define PXE_LOOPBACK_INTERNAL_SUPPORTED         1
+#define PXE_LOOPBACK_EXTERNAL_SUPPORTED         2
+
+
+typedef struct s_pxe_pci_config_info {
+    //
+    // This is the flag field for the PXE_DB_GET_CONFIG_INFO union.
+    // For PCI bus devices, this field is set to PXE_BUSTYPE_PCI.
+    //
+    PXE_UINT32 BusType;
+
+    //
+    // This identifies the PCI network device that this UNDI interface
+    // is bound to.
+    //
+    PXE_UINT16 Bus;
+    PXE_UINT8 Device;
+    PXE_UINT8 Function;
+
+    //
+    // This is a copy of the PCI configuration space for this 
+    // network device.
+    //
+    union {
+        PXE_UINT8 Byte[256];
+        PXE_UINT16 Word[128];
+        PXE_UINT32 Dword[64];
+    } Config;
+} PXE_PCI_CONFIG_INFO;
+
+
+typedef struct s_pxe_pcc_config_info {
+    //
+    // This is the flag field for the PXE_DB_GET_CONFIG_INFO union.
+    // For PCC bus devices, this field is set to PXE_BUSTYPE_PCC.
+    //
+    PXE_UINT32 BusType;
+    
+    //
+    // This identifies the PCC network device that this UNDI interface
+    // is bound to.
+    //
+    PXE_UINT16 Bus;
+    PXE_UINT8 Device;
+    PXE_UINT8 Function;
+
+    //
+    // This is a copy of the PCC configuration space for this 
+    // network device.
+    //
+    union {
+        PXE_UINT8 Byte[256];
+        PXE_UINT16 Word[128];
+        PXE_UINT32 Dword[64];
+    } Config;
+} PXE_PCC_CONFIG_INFO;
+
+
+typedef struct s_pxe_usb_config_info {
+    PXE_UINT32 BusType;
+    // %%TBD What should we return here...
+} PXE_USB_CONFIG_INFO;
+
+
+typedef struct s_pxe_1394_config_info {
+    PXE_UINT32 BusType;
+    // %%TBD What should we return here...
+} PXE_1394_CONFIG_INFO;
+
+
+typedef union u_pxe_db_get_config_info {
+    PXE_PCI_CONFIG_INFO pci;
+    PXE_PCC_CONFIG_INFO pcc;
+    PXE_USB_CONFIG_INFO usb;
+    PXE_1394_CONFIG_INFO _1394;
+} PXE_DB_GET_CONFIG_INFO;
+
+
+typedef struct s_pxe_cpb_initialize {
+    //
+    // Address of first (lowest) byte of the memory buffer.  This buffer must
+    // be in contiguous physical memory and cannot be swapped out.  The UNDI
+    // will be using this for transmit and receive buffering.
+    //
+    PXE_UINT64 MemoryAddr;
+
+    //
+    // MemoryLength must be greater than or equal to MemoryRequired
+    // returned by the Get Init Info command.
+    //
+    PXE_UINT32 MemoryLength;
+
+    //
+    // Desired link speed in Mbit/sec.  Common ethernet values are 10, 100
+    // and 1000.  Setting a value of zero will auto-detect and/or use the
+    // default link speed (operation depends on UNDI/NIC functionality).
+    //
+    PXE_UINT32 LinkSpeed;
+
+    //
+    // Suggested number and size of receive and transmit buffers to
+    // allocate.  If MemoryAddr and MemoryLength are non-zero, this
+    // allocation comes out of the supplied memory buffer.  If MemoryAddr 
+    // and MemoryLength are zero, this allocation comes out of memory
+    // on the NIC.
+    //
+    // If these fields are set to zero, the UNDI will allocate buffer
+    // counts and sizes as it sees fit.
+    //
+    PXE_UINT16 TxBufCnt;
+    PXE_UINT16 TxBufSize;
+    PXE_UINT16 RxBufCnt;
+    PXE_UINT16 RxBufSize;
+
+    //
+    // The following configuration parameters are optional and must be zero 
+    // to use the default values.
+    //
+    PXE_UINT8 Duplex; 
+
+    PXE_UINT8 LoopBack;
+} PXE_CPB_INITIALIZE;
+
+
+#define PXE_DUPLEX_DEFAULT                  0x00
+#define PXE_FORCE_FULL_DUPLEX                   0x01
+#define PXE_ENABLE_FULL_DUPLEX              0x02
+
+#define LOOPBACK_NORMAL 0
+#define LOOPBACK_INTERNAL 1
+#define LOOPBACK_EXTERNAL 2
+
+
+typedef struct s_pxe_db_initialize {
+    //
+    // Actual amount of memory used from the supplied memory buffer.  This
+    // may be less that the amount of memory suppllied and may be zero if
+    // the UNDI and network device do not use external memory buffers.
+    //
+    // Memory used by the UNDI and network device is allocated from the 
+    // lowest memory buffer address.
+    //
+    PXE_UINT32 MemoryUsed;
+
+    //
+    // Actual number and size of receive and transmit buffers that were
+    // allocated.
+    //
+    PXE_UINT16 TxBufCnt;
+    PXE_UINT16 TxBufSize;
+    PXE_UINT16 RxBufCnt;
+    PXE_UINT16 RxBufSize;
+} PXE_DB_INITIALIZE;
+
+
+typedef struct s_pxe_cpb_receive_filters {
+    //
+    // List of multicast MAC addresses.  This list, if present, will
+    // replace the existing multicast MAC address filter list.
+    //
+    PXE_MAC_ADDR MCastList[MAX_MCAST_ADDRESS_CNT];
+} PXE_CPB_RECEIVE_FILTERS;
+
+
+typedef struct s_pxe_db_receive_filters {
+    //
+    // Filtered multicast MAC address list.
+    //
+    PXE_MAC_ADDR MCastList[MAX_MCAST_ADDRESS_CNT];
+} PXE_DB_RECEIVE_FILTERS;
+
+
+typedef struct s_pxe_cpb_station_address {
+    //
+    // If supplied and supported, the current station MAC address
+    // will be changed.
+    //
+    PXE_MAC_ADDR StationAddr;
+} PXE_CPB_STATION_ADDRESS;
+
+
+typedef struct s_pxe_dpb_station_address {
+    //
+    // Current station MAC address.
+    //
+    PXE_MAC_ADDR StationAddr;
+
+    //
+    // Station broadcast MAC address.
+    //
+    PXE_MAC_ADDR BroadcastAddr;
+
+    //
+    // Permanent station MAC address.
+    //
+    PXE_MAC_ADDR PermanentAddr;
+} PXE_DB_STATION_ADDRESS;
+
+
+typedef struct s_pxe_db_statistics {
+    //
+    // Bit field identifying what statistic data is collected by the 
+    // UNDI/NIC.
+    // If bit 0x00 is set, Data[0x00] is collected.
+    // If bit 0x01 is set, Data[0x01] is collected.
+    // If bit 0x20 is set, Data[0x20] is collected.
+    // If bit 0x21 is set, Data[0x21] is collected.
+    // Etc.
+    //
+    PXE_UINT64 Supported;
+
+    //
+    // Statistic data.
+    //
+    PXE_UINT64 Data[64];
+} PXE_DB_STATISTICS;
+
+//
+// Total number of frames received.  Includes frames with errors and
+// dropped frames.
+//
+#define PXE_STATISTICS_RX_TOTAL_FRAMES          0x00
+
+//
+// Number of valid frames received and copied into receive buffers.
+//
+#define PXE_STATISTICS_RX_GOOD_FRAMES           0x01
+
+//
+// Number of frames below the minimum length for the media.
+// This would be <64 for ethernet.
+//
+#define PXE_STATISTICS_RX_UNDERSIZE_FRAMES          0x02
+
+//
+// Number of frames longer than the maxminum length for the
+// media.  This would be >1500 for ethernet.
+//
+#define PXE_STATISTICS_RX_OVERSIZE_FRAMES           0x03
+
+//
+// Valid frames that were dropped because receive buffers were full.
+//
+#define PXE_STATISTICS_RX_DROPPED_FRAMES            0x04
+
+//
+// Number of valid unicast frames received and not dropped.
+//
+#define PXE_STATISTICS_RX_UNICAST_FRAMES            0x05
+
+//
+// Number of valid broadcast frames received and not dropped.
+//
+#define PXE_STATISTICS_RX_BROADCAST_FRAMES          0x06
+
+//
+// Number of valid mutlicast frames received and not dropped.
+//
+#define PXE_STATISTICS_RX_MULTICAST_FRAMES          0x07
+
+//
+// Number of frames w/ CRC or alignment errors.
+//
+#define PXE_STATISTICS_RX_CRC_ERROR_FRAMES          0x08
+
+//
+// Total number of bytes received.  Includes frames with errors
+// and dropped frames.
+//
+#define PXE_STATISTICS_RX_TOTAL_BYTES           0x09
+
+//
+// Transmit statistics.
+//
+#define PXE_STATISTICS_TX_TOTAL_FRAMES          0x0A
+#define PXE_STATISTICS_TX_GOOD_FRAMES           0x0B
+#define PXE_STATISTICS_TX_UNDERSIZE_FRAMES          0x0C
+#define PXE_STATISTICS_TX_OVERSIZE_FRAMES           0x0D
+#define PXE_STATISTICS_TX_DROPPED_FRAMES            0x0E
+#define PXE_STATISTICS_TX_UNICAST_FRAMES            0x0F
+#define PXE_STATISTICS_TX_BROADCAST_FRAMES          0x10
+#define PXE_STATISTICS_TX_MULTICAST_FRAMES          0x11
+#define PXE_STATISTICS_TX_CRC_ERROR_FRAMES          0x12
+#define PXE_STATISTICS_TX_TOTAL_BYTES           0x13
+
+//
+// Number of collisions detection on this subnet.
+//
+#define PXE_STATISTICS_COLLISIONS               0x14
+
+//
+// Number of frames destined for unsupported protocol.
+//
+#define PXE_STATISTICS_UNSUPPORTED_PROTOCOL         0x15
+
+
+typedef struct s_pxe_cpb_mcast_ip_to_mac {
+    //
+    // Multicast IP address to be converted to multicast MAC address.
+    //
+    PXE_IP_ADDR IP;
+} PXE_CPB_MCAST_IP_TO_MAC;
+
+
+typedef struct s_pxe_db_mcast_ip_to_mac {
+    //
+    // Multicast MAC address.
+    //
+    PXE_MAC_ADDR MAC;
+} PXE_DB_MCAST_IP_TO_MAC;
+
+
+typedef struct s_pxe_cpb_nvdata_sparse {
+    //
+    // NvData item list.  Only items in this list will be updated.
+    //
+    struct {
+        //  Non-volatile storage address to be changed.
+        PXE_UINT32 Addr;
+
+        // Data item to write into above storage address.
+    
+        union {
+            PXE_UINT8 Byte;
+            PXE_UINT16 Word;
+            PXE_UINT32 Dword;
+        } Data;
+    } Item[MAX_EEPROM_LEN];
+} PXE_CPB_NVDATA_SPARSE;
+
+
+//
+// When using bulk update, the size of the CPB structure must be
+// the same size as the non-volatile NIC storage.
+//
+typedef union u_pxe_cpb_nvdata_bulk {
+    //
+    // Array of byte-wide data items.
+    //
+    PXE_UINT8 Byte[MAX_EEPROM_LEN << 2];
+
+    //
+    // Array of word-wide data items.
+    //
+    PXE_UINT16 Word[MAX_EEPROM_LEN << 1];
+
+    //
+    // Array of dword-wide data items.
+    //
+    PXE_UINT32 Dword[MAX_EEPROM_LEN];
+} PXE_CPB_NVDATA_BULK;
+
+typedef struct s_pxe_db_nvdata {
+
+    // Arrays of data items from non-volatile storage.
+
+    union {
+        //
+        // Array of byte-wide data items.
+        //
+        PXE_UINT8 Byte[MAX_EEPROM_LEN << 2];
+
+        //
+        // Array of word-wide data items.
+        //
+        PXE_UINT16 Word[MAX_EEPROM_LEN << 1];
+
+        // Array of dword-wide data items.
+
+        PXE_UINT32 Dword[MAX_EEPROM_LEN];
+    } Data;
+} PXE_DB_NVDATA;
+
+
+typedef struct s_pxe_db_get_status {
+    //
+    // Length of next receive frame (header + data).  If this is zero,
+    // there is no next receive frame available.
+    //
+    PXE_UINT32 RxFrameLen;
+
+    //
+    // Reserved, set to zero.
+    //
+    PXE_UINT32 reserved;
+
+    //
+    //  Addresses of transmitted buffers that need to be recycled.
+    //
+    PXE_UINT64 TxBuffer[MAX_XMIT_BUFFERS];
+} PXE_DB_GET_STATUS;
+
+
+
+typedef struct s_pxe_cpb_fill_header {
+    //
+    // Source and destination MAC addresses.  These will be copied into
+    // the media header without doing byte swapping.
+    //
+    PXE_MAC_ADDR SrcAddr;
+    PXE_MAC_ADDR DestAddr;
+
+    //
+    // Address of first byte of media header.  The first byte of packet data
+    // follows the last byte of the media header.
+    //
+    PXE_UINT64 MediaHeader;
+
+    //
+    // Length of packet data in bytes (not including the media header).
+    //
+    PXE_UINT32 PacketLen;
+
+    //
+    // Protocol type.  This will be copied into the media header without
+    // doing byte swapping.  Protocol type numbers can be obtained from
+    // the Assigned Numbers RFC 1700.
+    //
+    PXE_UINT16 Protocol;
+
+    //
+    // Length of the media header in bytes.
+    //
+    PXE_UINT16 MediaHeaderLen;
+} PXE_CPB_FILL_HEADER;
+
+
+#define PXE_PROTOCOL_ETHERNET_IP                0x0800
+#define PXE_PROTOCOL_ETHERNET_ARP               0x0806
+#define MAX_XMIT_FRAGMENTS 16
+
+typedef struct s_pxe_cpb_fill_header_fragmented {
+    //
+    // Source and destination MAC addresses.  These will be copied into
+    // the media header without doing byte swapping.
+    //
+    PXE_MAC_ADDR SrcAddr;
+    PXE_MAC_ADDR DestAddr;
+
+    //
+    // Length of packet data in bytes (not including the media header).
+    //
+    PXE_UINT32 PacketLen;
+
+    //
+    // Protocol type.  This will be copied into the media header without
+    // doing byte swapping.  Protocol type numbers can be obtained from
+    // the Assigned Numbers RFC 1700.
+    //
+    PXE_MEDIA_PROTOCOL Protocol;
+
+    //
+    // Length of the media header in bytes.
+    //
+    PXE_UINT16 MediaHeaderLen;
+
+    //
+    // Number of packet fragment descriptors.
+    //
+    PXE_UINT16 FragCnt;
+
+    //
+    // Reserved, must be set to zero.
+    //
+    PXE_UINT16 reserved;
+
+    //
+    // Array of packet fragment descriptors.  The first byte of the media
+    // header is the first byte of the first fragment.
+    //
+    struct {
+        //
+        // Address of this packet fragment.
+        //
+        PXE_UINT64 FragAddr;
+
+        //
+        // Length of this packet fragment.
+        //
+        PXE_UINT32 FragLen;
+
+        //
+        // Reserved, must be set to zero.
+        //
+        PXE_UINT32 reserved;
+    } FragDesc[MAX_XMIT_FRAGMENTS];
+} PXE_CPB_FILL_HEADER_FRAGMENTED;
+
+
+
+typedef struct s_pxe_cpb_transmit {
+    //
+    // Address of first byte of frame buffer.  This is also the first byte
+    // of the media header.
+    //
+    PXE_UINT64 FrameAddr;
+
+    //
+    // Length of the data portion of the frame buffer in bytes.  Do not
+    // include the length of the media header.
+    //
+    PXE_UINT32 DataLen;
+
+    //
+    // Length of the media header in bytes.
+    //
+    PXE_UINT16 MediaheaderLen;
+
+    //
+    // Reserved, must be zero.
+    //
+    PXE_UINT16 reserved;
+} PXE_CPB_TRANSMIT;
+
+
+
+typedef struct s_pxe_cpb_transmit_fragments {
+    //
+    // Length of packet data in bytes (not including the media header).
+    //
+    PXE_UINT32 FrameLen;
+
+    //
+    // Length of the media header in bytes.
+    //
+    PXE_UINT16 MediaheaderLen;
+
+    //
+    // Number of packet fragment descriptors.
+    //
+    PXE_UINT16 FragCnt;
+
+    //
+    // Array of frame fragment descriptors.  The first byte of the first
+    // fragment is also the first byte of the media header.
+    //
+    struct {
+        //
+        // Address of this frame fragment.
+        //
+        PXE_UINT64 FragAddr;
+
+        //
+        // Length of this frame fragment.
+        //
+        PXE_UINT32 FragLen;
+
+        //
+        // Reserved, must be set to zero.
+        //
+        PXE_UINT32 reserved;
+    } FragDesc[MAX_XMIT_FRAGMENTS];
+} PXE_CPB_TRANSMIT_FRAGMENTS;
+
+
+typedef struct s_pxe_cpb_receive {
+    //
+    // Address of first byte of receive buffer.  This is also the first byte
+    // of the frame header.
+    //
+    PXE_UINT64 BufferAddr;
+
+    //
+    // Length of receive buffer.  This must be large enough to hold the
+    // received frame (media header + data).  If the length of smaller than
+    // the received frame, data will be lost.
+    //
+    PXE_UINT32 BufferLen;
+
+    //
+    // Reserved, must be set to zero.
+    //
+    PXE_UINT32 reserved;
+} PXE_CPB_RECEIVE;
+
+
+typedef struct s_pxe_db_receive {
+    //
+    // Source and destination MAC addresses from media header.
+    //
+    PXE_MAC_ADDR SrcAddr;
+    PXE_MAC_ADDR DestAddr;
+
+    //
+    // Length of received frame.  May be larger than receive buffer size.
+    // The receive buffer will not be overwritten.  This is how to tell
+    // if data was lost because the receive buffer was too small.
+    //
+    PXE_UINT32 FrameLen;
+
+    //
+    // Protocol type from media header.
+    //
+    PXE_MEDIA_PROTOCOL Protocol;
+
+    //
+    // Length of media header in received frame.
+    //
+    PXE_UINT16 MediaHeaderLen;
+
+    //
+    // Type of receive frame.
+    //
+    PXE_FRAME_TYPE Type;
+
+    //
+    // Reserved, must be zero.
+    //
+    PXE_UINT8 reserved[7];
+
+} PXE_DB_RECEIVE;
+
+#pragma pack()
+
+/* EOF - efi_pxe.h */
+#endif /* _EFI_PXE_H */
+
diff --git a/linux-x86_64/gnu-efi/include/efi/efiapi.h b/linux-x86_64/gnu-efi/include/efi/efiapi.h
new file mode 100644
index 0000000..7f46e0d
--- /dev/null
+++ b/linux-x86_64/gnu-efi/include/efi/efiapi.h
@@ -0,0 +1,1003 @@
+#ifndef _EFI_API_H
+#define _EFI_API_H
+
+/*++
+
+Copyright (c) 1998  Intel Corporation
+
+Module Name:
+
+    efiapi.h
+
+Abstract:
+
+    Global EFI runtime & boot service interfaces
+
+
+
+
+Revision History
+
+--*/
+
+//
+// EFI Specification Revision
+//
+#define EFI_SYSTEM_TABLE_SIGNATURE 0x5453595320494249
+#define EFI_2_31_SYSTEM_TABLE_REVISION ((2<<16) | (31))
+#define EFI_2_30_SYSTEM_TABLE_REVISION ((2<<16) | (30))
+#define EFI_2_20_SYSTEM_TABLE_REVISION ((2<<16) | (20))
+#define EFI_2_10_SYSTEM_TABLE_REVISION ((2<<16) | (10))
+#define EFI_2_00_SYSTEM_TABLE_REVISION ((2<<16) | (00))
+#define EFI_1_10_SYSTEM_TABLE_REVISION ((1<<16) | (10))
+#define EFI_1_02_SYSTEM_TABLE_REVISION ((1<<16) | (02))
+#define EFI_SYSTEM_TABLE_REVISION EFI_2_31_SYSTEM_TABLE_REVISION
+#define EFI_SPECIFICATION_VERSION EFI_SYSTEM_TABLE_REVISION
+
+
+
+//
+// Declare forward referenced data structures
+//
+
+INTERFACE_DECL(_EFI_SYSTEM_TABLE);
+
+//
+// EFI Memory
+//
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_ALLOCATE_PAGES) (
+    IN EFI_ALLOCATE_TYPE            Type,
+    IN EFI_MEMORY_TYPE              MemoryType,
+    IN UINTN                        NoPages,
+    OUT EFI_PHYSICAL_ADDRESS        *Memory
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_FREE_PAGES) (
+    IN EFI_PHYSICAL_ADDRESS         Memory,
+    IN UINTN                        NoPages
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_GET_MEMORY_MAP) (
+    IN OUT UINTN                    *MemoryMapSize,
+    IN OUT EFI_MEMORY_DESCRIPTOR    *MemoryMap,
+    OUT UINTN                       *MapKey,
+    OUT UINTN                       *DescriptorSize,
+    OUT UINT32                      *DescriptorVersion
+    );
+
+#define NextMemoryDescriptor(Ptr,Size)  ((EFI_MEMORY_DESCRIPTOR *) (((UINT8 *) Ptr) + Size))
+
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_ALLOCATE_POOL) (
+    IN EFI_MEMORY_TYPE              PoolType,
+    IN UINTN                        Size,
+    OUT VOID                        **Buffer
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_FREE_POOL) (
+    IN VOID                         *Buffer
+    );
+
+typedef 
+EFI_STATUS
+(EFIAPI *EFI_SET_VIRTUAL_ADDRESS_MAP) (
+    IN UINTN                        MemoryMapSize,
+    IN UINTN                        DescriptorSize,
+    IN UINT32                       DescriptorVersion,
+    IN EFI_MEMORY_DESCRIPTOR        *VirtualMap
+    );
+
+
+#define EFI_OPTIONAL_PTR            0x00000001
+#define EFI_INTERNAL_FNC            0x00000002      // Pointer to internal runtime fnc
+#define EFI_INTERNAL_PTR            0x00000004      // Pointer to internal runtime data
+
+
+typedef 
+EFI_STATUS
+(EFIAPI *EFI_CONVERT_POINTER) (
+    IN UINTN                        DebugDisposition,
+    IN OUT VOID                     **Address
+    );
+
+
+//
+// EFI Events
+//
+
+
+
+#define EVT_TIMER                           0x80000000
+#define EVT_RUNTIME                         0x40000000
+#define EVT_RUNTIME_CONTEXT                 0x20000000
+
+#define EVT_NOTIFY_WAIT                     0x00000100
+#define EVT_NOTIFY_SIGNAL                   0x00000200
+
+#define EVT_SIGNAL_EXIT_BOOT_SERVICES       0x00000201
+#define EVT_SIGNAL_VIRTUAL_ADDRESS_CHANGE   0x60000202
+
+#define EVT_EFI_SIGNAL_MASK                 0x000000FF
+#define EVT_EFI_SIGNAL_MAX                  2
+
+typedef
+VOID
+(EFIAPI *EFI_EVENT_NOTIFY) (
+    IN EFI_EVENT                Event,
+    IN VOID                     *Context
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_CREATE_EVENT) (
+    IN UINT32                       Type,
+    IN EFI_TPL                      NotifyTpl,
+    IN EFI_EVENT_NOTIFY             NotifyFunction,
+    IN VOID                         *NotifyContext,
+    OUT EFI_EVENT                   *Event
+    );
+
+typedef enum {
+    TimerCancel,
+    TimerPeriodic,
+    TimerRelative,
+    TimerTypeMax
+} EFI_TIMER_DELAY;
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_SET_TIMER) (
+    IN EFI_EVENT                Event,
+    IN EFI_TIMER_DELAY          Type,
+    IN UINT64                   TriggerTime
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_SIGNAL_EVENT) (
+    IN EFI_EVENT                Event
+    );
+
+typedef 
+EFI_STATUS
+(EFIAPI *EFI_WAIT_FOR_EVENT) (
+    IN UINTN                    NumberOfEvents,
+    IN EFI_EVENT                *Event,
+    OUT UINTN                   *Index
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_CLOSE_EVENT) (
+    IN EFI_EVENT                Event
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_CHECK_EVENT) (
+    IN EFI_EVENT                Event
+    );
+
+//
+// Task priority level
+//
+
+#define TPL_APPLICATION    4
+#define TPL_CALLBACK       8
+#define TPL_NOTIFY        16 
+#define TPL_HIGH_LEVEL    31 
+
+typedef
+EFI_TPL
+(EFIAPI *EFI_RAISE_TPL) (
+    IN EFI_TPL      NewTpl
+    );
+
+typedef
+VOID
+(EFIAPI *EFI_RESTORE_TPL) (
+    IN EFI_TPL      OldTpl
+    );
+
+
+//
+// EFI platform varibles
+//
+
+#define EFI_GLOBAL_VARIABLE     \
+    { 0x8BE4DF61, 0x93CA, 0x11d2, {0xAA, 0x0D, 0x00, 0xE0, 0x98, 0x03, 0x2B, 0x8C} }
+
+// Variable attributes
+#define EFI_VARIABLE_NON_VOLATILE           0x00000001
+#define EFI_VARIABLE_BOOTSERVICE_ACCESS     0x00000002
+#define EFI_VARIABLE_RUNTIME_ACCESS         0x00000004
+
+// Variable size limitation
+#define EFI_MAXIMUM_VARIABLE_SIZE           1024
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_GET_VARIABLE) (
+    IN CHAR16                       *VariableName,
+    IN EFI_GUID                     *VendorGuid,
+    OUT UINT32                      *Attributes OPTIONAL,
+    IN OUT UINTN                    *DataSize,
+    OUT VOID                        *Data
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_GET_NEXT_VARIABLE_NAME) (
+    IN OUT UINTN                    *VariableNameSize,
+    IN OUT CHAR16                   *VariableName,
+    IN OUT EFI_GUID                 *VendorGuid
+    );
+
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_SET_VARIABLE) (
+    IN CHAR16                       *VariableName,
+    IN EFI_GUID                     *VendorGuid,
+    IN UINT32                       Attributes,
+    IN UINTN                        DataSize,
+    IN VOID                         *Data
+    );
+
+
+//
+// EFI Time
+//
+
+typedef struct {
+        UINT32                      Resolution;     // 1e-6 parts per million
+        UINT32                      Accuracy;       // hertz
+        BOOLEAN                     SetsToZero;     // Set clears sub-second time
+} EFI_TIME_CAPABILITIES;
+
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_GET_TIME) (
+    OUT EFI_TIME                    *Time,
+    OUT EFI_TIME_CAPABILITIES       *Capabilities OPTIONAL
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_SET_TIME) (
+    IN EFI_TIME                     *Time
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_GET_WAKEUP_TIME) (
+    OUT BOOLEAN                     *Enabled,
+    OUT BOOLEAN                     *Pending,
+    OUT EFI_TIME                    *Time
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_SET_WAKEUP_TIME) (
+    IN BOOLEAN                      Enable,
+    IN EFI_TIME                     *Time OPTIONAL
+    );
+
+
+//
+// Image functions
+//
+
+
+// PE32+ Subsystem type for EFI images
+
+#if !defined(IMAGE_SUBSYSTEM_EFI_APPLICATION)
+#define IMAGE_SUBSYSTEM_EFI_APPLICATION             10
+#define IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER     11
+#define IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER          12
+#endif
+
+// PE32+ Machine type for EFI images
+
+#if !defined(EFI_IMAGE_MACHINE_IA32)
+#define EFI_IMAGE_MACHINE_IA32      0x014c
+#endif
+
+#if !defined(EFI_IMAGE_MACHINE_IA64)
+#define EFI_IMAGE_MACHINE_IA64      0x0200
+#endif
+
+// Image Entry prototype
+
+typedef 
+EFI_STATUS
+(EFIAPI *EFI_IMAGE_ENTRY_POINT) (
+    IN EFI_HANDLE                   ImageHandle,
+    IN struct _EFI_SYSTEM_TABLE     *SystemTable
+    );
+
+typedef 
+EFI_STATUS
+(EFIAPI *EFI_IMAGE_LOAD) (
+    IN BOOLEAN                      BootPolicy,
+    IN EFI_HANDLE                   ParentImageHandle,
+    IN EFI_DEVICE_PATH              *FilePath,
+    IN VOID                         *SourceBuffer   OPTIONAL,
+    IN UINTN                        SourceSize,
+    OUT EFI_HANDLE                  *ImageHandle
+    );
+
+typedef 
+EFI_STATUS
+(EFIAPI *EFI_IMAGE_START) (
+    IN EFI_HANDLE                   ImageHandle,
+    OUT UINTN                       *ExitDataSize,
+    OUT CHAR16                      **ExitData  OPTIONAL
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_EXIT) (
+    IN EFI_HANDLE                   ImageHandle,
+    IN EFI_STATUS                   ExitStatus,
+    IN UINTN                        ExitDataSize,
+    IN CHAR16                       *ExitData OPTIONAL
+    );
+
+typedef 
+EFI_STATUS
+(EFIAPI *EFI_IMAGE_UNLOAD) (
+    IN EFI_HANDLE                   ImageHandle
+    );
+
+
+// Image handle
+#define LOADED_IMAGE_PROTOCOL      \
+    { 0x5B1B31A1, 0x9562, 0x11d2, {0x8E, 0x3F, 0x00, 0xA0, 0xC9, 0x69, 0x72, 0x3B} }
+
+#define EFI_IMAGE_INFORMATION_REVISION      0x1000
+typedef struct {
+    UINT32                          Revision;
+    EFI_HANDLE                      ParentHandle;
+    struct _EFI_SYSTEM_TABLE        *SystemTable;
+
+    // Source location of image
+    EFI_HANDLE                      DeviceHandle;
+    EFI_DEVICE_PATH                 *FilePath;
+    VOID                            *Reserved;
+
+    // Images load options
+    UINT32                          LoadOptionsSize;
+    VOID                            *LoadOptions;
+
+    // Location of where image was loaded
+    VOID                            *ImageBase;
+    UINT64                          ImageSize;
+    EFI_MEMORY_TYPE                 ImageCodeType;
+    EFI_MEMORY_TYPE                 ImageDataType;
+
+    // If the driver image supports a dynamic unload request
+    EFI_IMAGE_UNLOAD                Unload;
+
+} EFI_LOADED_IMAGE;
+
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_EXIT_BOOT_SERVICES) (
+    IN EFI_HANDLE                   ImageHandle,
+    IN UINTN                        MapKey
+    );
+
+//
+// Misc
+//
+
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_STALL) (
+    IN UINTN                    Microseconds
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_SET_WATCHDOG_TIMER) (
+    IN UINTN                    Timeout,
+    IN UINT64                   WatchdogCode,
+    IN UINTN                    DataSize,
+    IN CHAR16                   *WatchdogData OPTIONAL
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_CONNECT_CONTROLLER) (
+    IN EFI_HANDLE               ControllerHandle,
+    IN EFI_HANDLE               *DriverImageHandle OPTIONAL,
+    IN EFI_DEVICE_PATH          *RemainingDevicePath OPTIONAL,
+    IN BOOLEAN                  Recursive
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_DISCONNECT_CONTROLLER) (
+    IN EFI_HANDLE               ControllerHandle,
+    IN EFI_HANDLE               DriverImageHandle OPTIONAL,
+    IN EFI_HANDLE               ChildHandle OPTIONAL
+    );
+
+#define EFI_OPEN_PROTOCOL_BY_HANDLE_PROTOCOL  0x00000001
+#define EFI_OPEN_PROTOCOL_GET_PROTOCOL        0x00000002
+#define EFI_OPEN_PROTOCOL_TEST_PROTOCOL       0x00000004
+#define EFI_OPEN_PROTOCOL_BY_CHILD_CONTROLLER 0x00000008
+#define EFI_OPEN_PROTOCOL_BY_DRIVER           0x00000010
+#define EFI_OPEN_PROTOCOL_EXCLUSIVE           0x00000020
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_OPEN_PROTOCOL) (
+    IN EFI_HANDLE               Handle,
+    IN EFI_GUID                 *Protocol,
+    OUT VOID                    **Interface OPTIONAL,
+    IN EFI_HANDLE               AgentHandle,
+    IN EFI_HANDLE               ControllerHandle,
+    IN UINT32                   Attributes
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_CLOSE_PROTOCOL) (
+    IN EFI_HANDLE               Handle,
+    IN EFI_GUID                 *Protocol,
+    IN EFI_HANDLE               AgentHandle,
+    IN EFI_HANDLE               ControllerHandle
+    );
+
+typedef struct {
+    EFI_HANDLE                  AgentHandle;
+    EFI_HANDLE                  ControllerHandle;
+    UINT32                      Attributes;
+    UINT32                      OpenCount;
+} EFI_OPEN_PROTOCOL_INFORMATION_ENTRY;
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_OPEN_PROTOCOL_INFORMATION) (
+    IN EFI_HANDLE               Handle,
+    IN EFI_GUID                 *Protocol,
+    OUT EFI_OPEN_PROTOCOL_INFORMATION_ENTRY **EntryBuffer,
+    OUT UINTN                   *EntryCount
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PROTOCOLS_PER_HANDLE) (
+    IN EFI_HANDLE               Handle,
+    OUT EFI_GUID                ***ProtocolBuffer,
+    OUT UINTN                   *ProtocolBufferCount
+    );
+
+typedef enum {
+    AllHandles,
+    ByRegisterNotify,
+    ByProtocol
+} EFI_LOCATE_SEARCH_TYPE;
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_LOCATE_HANDLE_BUFFER) (
+    IN EFI_LOCATE_SEARCH_TYPE   SearchType,
+    IN EFI_GUID                 *Protocol OPTIONAL,
+    IN VOID                     *SearchKey OPTIONAL,
+    IN OUT UINTN                *NoHandles,
+    OUT EFI_HANDLE              **Buffer
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_LOCATE_PROTOCOL) (
+    IN EFI_GUID                 *Protocol,
+    IN VOID                     *Registration OPTIONAL,
+    OUT VOID                    **Interface
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_INSTALL_MULTIPLE_PROTOCOL_INTERFACES) (
+    IN OUT EFI_HANDLE           *Handle,
+    ...
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_UNINSTALL_MULTIPLE_PROTOCOL_INTERFACES) (
+    IN OUT EFI_HANDLE           Handle,
+    ...
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_CALCULATE_CRC32) (
+    IN VOID                     *Data,
+    IN UINTN                    DataSize,
+    OUT UINT32                  *Crc32
+    );
+
+typedef
+VOID
+(EFIAPI *EFI_COPY_MEM) (
+    IN VOID                     *Destination,
+    IN VOID                     *Source,
+    IN UINTN                    Length
+    );
+
+typedef
+VOID
+(EFIAPI *EFI_SET_MEM) (
+    IN VOID                     *Buffer,
+    IN UINTN                    Size,
+    IN UINT8                    Value
+    );
+
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_CREATE_EVENT_EX) (
+    IN UINT32                   Type,
+    IN EFI_TPL                  NotifyTpl,
+    IN EFI_EVENT_NOTIFY         NotifyFunction OPTIONAL,
+    IN const VOID               *NotifyContext OPTIONAL,
+    IN const EFI_GUID           EventGroup OPTIONAL,
+    OUT EFI_EVENT               *Event
+    );
+
+typedef enum {
+    EfiResetCold,
+    EfiResetWarm,
+    EfiResetShutdown
+} EFI_RESET_TYPE;
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_RESET_SYSTEM) (
+    IN EFI_RESET_TYPE           ResetType,
+    IN EFI_STATUS               ResetStatus,
+    IN UINTN                    DataSize,
+    IN CHAR16                   *ResetData OPTIONAL
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_GET_NEXT_MONOTONIC_COUNT) (
+    OUT UINT64                  *Count
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_GET_NEXT_HIGH_MONO_COUNT) (
+    OUT UINT32                  *HighCount
+    );
+
+typedef struct {
+  UINT64                            Length;
+  union {
+    EFI_PHYSICAL_ADDRESS  DataBlock;
+    EFI_PHYSICAL_ADDRESS  ContinuationPointer;
+  } Union;
+} EFI_CAPSULE_BLOCK_DESCRIPTOR;
+
+typedef struct {
+  EFI_GUID          CapsuleGuid;
+  UINT32            HeaderSize;
+  UINT32            Flags;
+  UINT32            CapsuleImageSize;
+} EFI_CAPSULE_HEADER;
+
+//
+// The EFI System Table entry must point to an array of capsules
+// that contain the same CapsuleGuid value. The array must be
+// prefixed by a UINT32 that represents the size of the array of capsules.
+//
+typedef struct {
+  UINT32   CapsuleArrayNumber;
+  VOID*    CapsulePtr[1];
+} EFI_CAPSULE_TABLE;
+
+#define CAPSULE_FLAGS_PERSIST_ACROSS_RESET          0x00010000
+#define CAPSULE_FLAGS_POPULATE_SYSTEM_TABLE         0x00020000
+#define CAPSULE_FLAGS_INITIATE_RESET                0x00040000
+
+
+/**
+  Passes capsules to the firmware with both virtual and physical mapping. Depending on the intended
+  consumption, the firmware may process the capsule immediately. If the payload should persist
+  across a system reset, the reset value returned from EFI_QueryCapsuleCapabilities must
+  be passed into ResetSystem() and will cause the capsule to be processed by the firmware as
+  part of the reset process.
+
+  @param  CapsuleHeaderArray    Virtual pointer to an array of virtual pointers to the capsules
+                                being passed into update capsule.
+  @param  CapsuleCount          Number of pointers to EFI_CAPSULE_HEADER in
+                                CaspuleHeaderArray.
+  @param  ScatterGatherList     Physical pointer to a set of
+                                EFI_CAPSULE_BLOCK_DESCRIPTOR that describes the
+                                location in physical memory of a set of capsules.
+
+  @retval EFI_SUCCESS           Valid capsule was passed. If
+                                CAPSULE_FLAGS_PERSIT_ACROSS_RESET is not set, the
+                                capsule has been successfully processed by the firmware.
+  @retval EFI_DEVICE_ERROR      The capsule update was started, but failed due to a device error.
+  @retval EFI_INVALID_PARAMETER CapsuleSize is NULL.
+  @retval EFI_UNSUPPORTED       The capsule type is not supported on this platform.
+  @retval EFI_OUT_OF_RESOURCES  There were insufficient resources to process the capsule.
+
+**/
+typedef
+EFI_STATUS
+(EFIAPI *EFI_UPDATE_CAPSULE)(
+  IN EFI_CAPSULE_HEADER     **CapsuleHeaderArray,
+  IN UINTN                  CapsuleCount,
+  IN EFI_PHYSICAL_ADDRESS   ScatterGatherList   OPTIONAL
+  );
+
+/**
+  Returns if the capsule can be supported via UpdateCapsule().
+
+  @param  CapsuleHeaderArray    Virtual pointer to an array of virtual pointers to the capsules
+                                being passed into update capsule.
+  @param  CapsuleCount          Number of pointers to EFI_CAPSULE_HEADER in
+                                CaspuleHeaderArray.
+  @param  MaxiumCapsuleSize     On output the maximum size that UpdateCapsule() can
+                                support as an argument to UpdateCapsule() via
+                                CapsuleHeaderArray and ScatterGatherList.
+  @param  ResetType             Returns the type of reset required for the capsule update.
+
+  @retval EFI_SUCCESS           Valid answer returned.
+  @retval EFI_UNSUPPORTED       The capsule type is not supported on this platform, and
+                                MaximumCapsuleSize and ResetType are undefined.
+  @retval EFI_INVALID_PARAMETER MaximumCapsuleSize is NULL.
+  @retval EFI_OUT_OF_RESOURCES  There were insufficient resources to process the query request.
+
+**/
+typedef
+EFI_STATUS
+(EFIAPI *EFI_QUERY_CAPSULE_CAPABILITIES)(
+  IN  EFI_CAPSULE_HEADER     **CapsuleHeaderArray,
+  IN  UINTN                  CapsuleCount,
+  OUT UINT64                 *MaximumCapsuleSize,
+  OUT EFI_RESET_TYPE         *ResetType
+  );
+
+//
+// Protocol handler functions
+//
+
+typedef enum {
+    EFI_NATIVE_INTERFACE,
+    EFI_PCODE_INTERFACE
+} EFI_INTERFACE_TYPE;
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_INSTALL_PROTOCOL_INTERFACE) (
+    IN OUT EFI_HANDLE           *Handle,
+    IN EFI_GUID                 *Protocol,
+    IN EFI_INTERFACE_TYPE       InterfaceType,
+    IN VOID                     *Interface
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_REINSTALL_PROTOCOL_INTERFACE) (
+    IN EFI_HANDLE               Handle,
+    IN EFI_GUID                 *Protocol,
+    IN VOID                     *OldInterface,
+    IN VOID                     *NewInterface
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_UNINSTALL_PROTOCOL_INTERFACE) (
+    IN EFI_HANDLE               Handle,
+    IN EFI_GUID                 *Protocol,
+    IN VOID                     *Interface
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_HANDLE_PROTOCOL) (
+    IN EFI_HANDLE               Handle,
+    IN EFI_GUID                 *Protocol,
+    OUT VOID                    **Interface
+    );
+
+typedef
+EFI_STATUS 
+(EFIAPI *EFI_REGISTER_PROTOCOL_NOTIFY) (
+    IN EFI_GUID                 *Protocol,
+    IN EFI_EVENT                Event,
+    OUT VOID                    **Registration
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_LOCATE_HANDLE) (
+    IN EFI_LOCATE_SEARCH_TYPE   SearchType,
+    IN EFI_GUID                 *Protocol OPTIONAL,
+    IN VOID                     *SearchKey OPTIONAL,
+    IN OUT UINTN                *BufferSize,
+    OUT EFI_HANDLE              *Buffer
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_LOCATE_DEVICE_PATH) (
+    IN EFI_GUID                 *Protocol,
+    IN OUT EFI_DEVICE_PATH      **DevicePath,
+    OUT EFI_HANDLE              *Device
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_INSTALL_CONFIGURATION_TABLE) (
+    IN EFI_GUID                 *Guid,
+    IN VOID                     *Table
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_RESERVED_SERVICE) (
+    );
+
+//
+// Standard EFI table header
+//
+typedef
+EFI_STATUS
+(EFIAPI *EFI_QUERY_VARIABLE_INFO)(
+  IN  UINT32            Attributes,
+  OUT UINT64            *MaximumVariableStorageSize,
+  OUT UINT64            *RemainingVariableStorageSize,
+  OUT UINT64            *MaximumVariableSize
+  );
+
+typedef struct _EFI_TABLE_HEARDER {
+    UINT64                      Signature;
+    UINT32                      Revision;
+    UINT32                      HeaderSize;
+    UINT32                      CRC32;
+    UINT32                      Reserved;
+} EFI_TABLE_HEADER;
+
+
+//
+// EFI Runtime Serivces Table
+//
+
+#define EFI_RUNTIME_SERVICES_SIGNATURE 0x56524553544e5552
+#define EFI_RUNTIME_SERVICES_REVISION EFI_SPECIFICATION_VERSION
+
+
+typedef struct  {
+    EFI_TABLE_HEADER                Hdr;
+
+    //
+    // Time services
+    //
+
+    EFI_GET_TIME                    GetTime;
+    EFI_SET_TIME                    SetTime;
+    EFI_GET_WAKEUP_TIME             GetWakeupTime;
+    EFI_SET_WAKEUP_TIME             SetWakeupTime;
+
+    //
+    // Virtual memory services
+    //
+
+    EFI_SET_VIRTUAL_ADDRESS_MAP     SetVirtualAddressMap;
+    EFI_CONVERT_POINTER             ConvertPointer;
+
+    //
+    // Variable serviers
+    //
+
+    EFI_GET_VARIABLE                GetVariable;
+    EFI_GET_NEXT_VARIABLE_NAME      GetNextVariableName;
+    EFI_SET_VARIABLE                SetVariable;
+
+    //
+    // Misc
+    //
+
+    EFI_GET_NEXT_HIGH_MONO_COUNT    GetNextHighMonotonicCount;
+    EFI_RESET_SYSTEM                ResetSystem;
+    //
+    // UEFI 2.0 Capsule Services
+    //
+    EFI_UPDATE_CAPSULE              UpdateCapsule;
+    EFI_QUERY_CAPSULE_CAPABILITIES  QueryCapsuleCapabilities;
+
+    //
+    // Miscellaneous UEFI 2.0 Service
+    //
+    EFI_QUERY_VARIABLE_INFO         QueryVariableInfo;
+
+} EFI_RUNTIME_SERVICES;
+
+
+//
+// EFI Boot Services Table
+//
+
+
+#define EFI_BOOT_SERVICES_SIGNATURE 0x56524553544f4f42
+#define EFI_BOOT_SERVICES_REVISION EFI_SPECIFICATION_VERSION
+
+typedef struct _EFI_BOOT_SERVICES {
+
+    EFI_TABLE_HEADER                Hdr;
+
+    //
+    // Task priority functions
+    //
+
+    EFI_RAISE_TPL                   RaiseTPL;
+    EFI_RESTORE_TPL                 RestoreTPL;
+
+    //
+    // Memory functions
+    //
+
+    EFI_ALLOCATE_PAGES              AllocatePages;
+    EFI_FREE_PAGES                  FreePages;
+    EFI_GET_MEMORY_MAP              GetMemoryMap;
+    EFI_ALLOCATE_POOL               AllocatePool;
+    EFI_FREE_POOL                   FreePool;
+
+    //
+    // Event & timer functions
+    //
+
+    EFI_CREATE_EVENT                CreateEvent;
+    EFI_SET_TIMER                   SetTimer;
+    EFI_WAIT_FOR_EVENT              WaitForEvent;
+    EFI_SIGNAL_EVENT                SignalEvent;
+    EFI_CLOSE_EVENT                 CloseEvent;
+    EFI_CHECK_EVENT                 CheckEvent;
+
+    //
+    // Protocol handler functions
+    //
+
+    EFI_INSTALL_PROTOCOL_INTERFACE  InstallProtocolInterface;
+    EFI_REINSTALL_PROTOCOL_INTERFACE ReinstallProtocolInterface;
+    EFI_UNINSTALL_PROTOCOL_INTERFACE UninstallProtocolInterface;
+    EFI_HANDLE_PROTOCOL             HandleProtocol;
+    EFI_HANDLE_PROTOCOL             PCHandleProtocol;
+    EFI_REGISTER_PROTOCOL_NOTIFY    RegisterProtocolNotify;
+    EFI_LOCATE_HANDLE               LocateHandle;
+    EFI_LOCATE_DEVICE_PATH          LocateDevicePath;
+    EFI_INSTALL_CONFIGURATION_TABLE InstallConfigurationTable;
+
+    //
+    // Image functions
+    //
+
+    EFI_IMAGE_LOAD                  LoadImage;
+    EFI_IMAGE_START                 StartImage;
+    EFI_EXIT                        Exit;
+    EFI_IMAGE_UNLOAD                UnloadImage;
+    EFI_EXIT_BOOT_SERVICES          ExitBootServices;
+
+    //
+    // Misc functions
+    //
+
+    EFI_GET_NEXT_MONOTONIC_COUNT    GetNextMonotonicCount;
+    EFI_STALL                       Stall;
+    EFI_SET_WATCHDOG_TIMER          SetWatchdogTimer;
+
+    //
+    // DriverSupport Services
+    //
+
+    EFI_CONNECT_CONTROLLER          ConnectController;
+    EFI_DISCONNECT_CONTROLLER       DisconnectController;
+
+    //
+    // Open and Close Protocol Services
+    //
+    EFI_OPEN_PROTOCOL               OpenProtocol;
+    EFI_CLOSE_PROTOCOL              CloseProtocol;
+    EFI_OPEN_PROTOCOL_INFORMATION   OpenProtocolInformation;
+
+    //
+    // Library Services
+    //
+    EFI_PROTOCOLS_PER_HANDLE        ProtocolsPerHandle;
+    EFI_LOCATE_HANDLE_BUFFER        LocateHandleBuffer;
+    EFI_LOCATE_PROTOCOL             LocateProtocol;
+    EFI_INSTALL_MULTIPLE_PROTOCOL_INTERFACES InstallMultipleProtocolInterfaces;
+    EFI_UNINSTALL_MULTIPLE_PROTOCOL_INTERFACES UninstallMultipleProtocolInterfaces;
+
+    //
+    // 32-bit CRC Services
+    //
+    EFI_CALCULATE_CRC32             CalculateCrc32;
+
+    //
+    // Misc Services
+    //
+    EFI_COPY_MEM                    CopyMem;
+    EFI_SET_MEM                     SetMem;
+    EFI_CREATE_EVENT_EX             CreateEventEx;
+} EFI_BOOT_SERVICES;
+
+
+//
+// EFI Configuration Table and GUID definitions
+//
+
+#define MPS_TABLE_GUID    \
+    { 0xeb9d2d2f, 0x2d88, 0x11d3, {0x9a, 0x16, 0x0, 0x90, 0x27, 0x3f, 0xc1, 0x4d} }
+
+#define ACPI_TABLE_GUID    \
+    { 0xeb9d2d30, 0x2d88, 0x11d3, {0x9a, 0x16, 0x0, 0x90, 0x27, 0x3f, 0xc1, 0x4d} }
+
+#define ACPI_20_TABLE_GUID  \
+    { 0x8868e871, 0xe4f1, 0x11d3, {0xbc, 0x22, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81} }
+
+#define SMBIOS_TABLE_GUID    \
+    { 0xeb9d2d31, 0x2d88, 0x11d3, {0x9a, 0x16, 0x0, 0x90, 0x27, 0x3f, 0xc1, 0x4d} }
+
+#define SAL_SYSTEM_TABLE_GUID    \
+    { 0xeb9d2d32, 0x2d88, 0x11d3, {0x9a, 0x16, 0x0, 0x90, 0x27, 0x3f, 0xc1, 0x4d} }
+
+
+typedef struct _EFI_CONFIGURATION_TABLE {
+    EFI_GUID                VendorGuid;
+    VOID                    *VendorTable;
+} EFI_CONFIGURATION_TABLE;
+
+
+//
+// EFI System Table
+//
+
+typedef struct _EFI_SYSTEM_TABLE {
+    EFI_TABLE_HEADER                Hdr;
+
+    CHAR16                          *FirmwareVendor;
+    UINT32                          FirmwareRevision;
+
+    EFI_HANDLE                      ConsoleInHandle;
+    SIMPLE_INPUT_INTERFACE          *ConIn;
+
+    EFI_HANDLE                      ConsoleOutHandle;
+    SIMPLE_TEXT_OUTPUT_INTERFACE    *ConOut;
+
+    EFI_HANDLE                      StandardErrorHandle;
+    SIMPLE_TEXT_OUTPUT_INTERFACE    *StdErr;
+
+    EFI_RUNTIME_SERVICES            *RuntimeServices;
+    EFI_BOOT_SERVICES               *BootServices;
+
+    UINTN                           NumberOfTableEntries;
+    EFI_CONFIGURATION_TABLE         *ConfigurationTable;
+
+} EFI_SYSTEM_TABLE;
+
+#endif
+
diff --git a/linux-x86_64/gnu-efi/include/efi/eficon.h b/linux-x86_64/gnu-efi/include/efi/eficon.h
new file mode 100644
index 0000000..089db98
--- /dev/null
+++ b/linux-x86_64/gnu-efi/include/efi/eficon.h
@@ -0,0 +1,302 @@
+#ifndef _EFI_CON_H
+#define _EFI_CON_H
+
+/*++
+
+Copyright (c) 1998  Intel Corporation
+
+Module Name:
+
+    eficon.h
+
+Abstract:
+
+    EFI console protocols
+
+
+
+Revision History
+
+--*/
+
+//
+// Text output protocol
+//
+
+#define SIMPLE_TEXT_OUTPUT_PROTOCOL \
+    { 0x387477c2, 0x69c7, 0x11d2, {0x8e, 0x39, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b} }
+
+INTERFACE_DECL(_SIMPLE_TEXT_OUTPUT_INTERFACE);
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_TEXT_RESET) (
+    IN struct _SIMPLE_TEXT_OUTPUT_INTERFACE     *This,
+    IN BOOLEAN                      ExtendedVerification
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_TEXT_OUTPUT_STRING) (
+    IN struct _SIMPLE_TEXT_OUTPUT_INTERFACE     *This,
+    IN CHAR16                       *String
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_TEXT_TEST_STRING) (
+    IN struct _SIMPLE_TEXT_OUTPUT_INTERFACE     *This,
+    IN CHAR16                       *String
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_TEXT_QUERY_MODE) (
+    IN struct _SIMPLE_TEXT_OUTPUT_INTERFACE     *This,
+    IN UINTN                        ModeNumber,
+    OUT UINTN                       *Columns,
+    OUT UINTN                       *Rows
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_TEXT_SET_MODE) (
+    IN struct _SIMPLE_TEXT_OUTPUT_INTERFACE     *This,
+    IN UINTN                        ModeNumber
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_TEXT_SET_ATTRIBUTE) (
+    IN struct _SIMPLE_TEXT_OUTPUT_INTERFACE     *This,
+    IN UINTN                        Attribute
+    );
+
+#define EFI_BLACK   0x00
+#define EFI_BLUE    0x01
+#define EFI_GREEN   0x02
+#define EFI_CYAN            (EFI_BLUE | EFI_GREEN)
+#define EFI_RED     0x04
+#define EFI_MAGENTA         (EFI_BLUE | EFI_RED)
+#define EFI_BROWN           (EFI_GREEN | EFI_RED)
+#define EFI_LIGHTGRAY       (EFI_BLUE | EFI_GREEN | EFI_RED)
+#define EFI_BRIGHT  0x08
+#define EFI_DARKGRAY        (EFI_BRIGHT)
+#define EFI_LIGHTBLUE       (EFI_BLUE | EFI_BRIGHT)
+#define EFI_LIGHTGREEN      (EFI_GREEN | EFI_BRIGHT)
+#define EFI_LIGHTCYAN       (EFI_CYAN | EFI_BRIGHT)
+#define EFI_LIGHTRED        (EFI_RED | EFI_BRIGHT)
+#define EFI_LIGHTMAGENTA    (EFI_MAGENTA | EFI_BRIGHT)
+#define EFI_YELLOW          (EFI_BROWN | EFI_BRIGHT)
+#define EFI_WHITE           (EFI_BLUE | EFI_GREEN | EFI_RED | EFI_BRIGHT)
+
+#define EFI_TEXT_ATTR(f,b)  ((f) | ((b) << 4))
+
+#define EFI_BACKGROUND_BLACK        0x00
+#define EFI_BACKGROUND_BLUE         0x10
+#define EFI_BACKGROUND_GREEN        0x20
+#define EFI_BACKGROUND_CYAN         (EFI_BACKGROUND_BLUE | EFI_BACKGROUND_GREEN)
+#define EFI_BACKGROUND_RED          0x40
+#define EFI_BACKGROUND_MAGENTA      (EFI_BACKGROUND_BLUE | EFI_BACKGROUND_RED)
+#define EFI_BACKGROUND_BROWN        (EFI_BACKGROUND_GREEN | EFI_BACKGROUND_RED)
+#define EFI_BACKGROUND_LIGHTGRAY    (EFI_BACKGROUND_BLUE | EFI_BACKGROUND_GREEN | EFI_BACKGROUND_RED)
+
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_TEXT_CLEAR_SCREEN) (
+    IN struct _SIMPLE_TEXT_OUTPUT_INTERFACE     *This
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_TEXT_SET_CURSOR_POSITION) (
+    IN struct _SIMPLE_TEXT_OUTPUT_INTERFACE     *This,
+    IN UINTN                        Column,
+    IN UINTN                        Row
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_TEXT_ENABLE_CURSOR) (
+    IN struct _SIMPLE_TEXT_OUTPUT_INTERFACE     *This,
+    IN BOOLEAN                      Enable
+    );
+
+typedef struct {
+    INT32                           MaxMode;
+    // current settings
+    INT32                           Mode;
+    INT32                           Attribute;
+    INT32                           CursorColumn;
+    INT32                           CursorRow;
+    BOOLEAN                         CursorVisible;
+} SIMPLE_TEXT_OUTPUT_MODE;
+
+typedef struct _SIMPLE_TEXT_OUTPUT_INTERFACE {
+    EFI_TEXT_RESET                  Reset;
+
+    EFI_TEXT_OUTPUT_STRING          OutputString;
+    EFI_TEXT_TEST_STRING            TestString;
+
+    EFI_TEXT_QUERY_MODE             QueryMode;
+    EFI_TEXT_SET_MODE               SetMode;
+    EFI_TEXT_SET_ATTRIBUTE          SetAttribute;
+
+    EFI_TEXT_CLEAR_SCREEN           ClearScreen;
+    EFI_TEXT_SET_CURSOR_POSITION    SetCursorPosition;
+    EFI_TEXT_ENABLE_CURSOR          EnableCursor;
+
+    // Current mode
+    SIMPLE_TEXT_OUTPUT_MODE         *Mode;
+} SIMPLE_TEXT_OUTPUT_INTERFACE;
+
+//
+// Define's for required EFI Unicode Box Draw character
+//
+
+#define BOXDRAW_HORIZONTAL                  0x2500
+#define BOXDRAW_VERTICAL                    0x2502
+#define BOXDRAW_DOWN_RIGHT                  0x250c
+#define BOXDRAW_DOWN_LEFT                   0x2510
+#define BOXDRAW_UP_RIGHT                    0x2514
+#define BOXDRAW_UP_LEFT                     0x2518
+#define BOXDRAW_VERTICAL_RIGHT              0x251c
+#define BOXDRAW_VERTICAL_LEFT               0x2524
+#define BOXDRAW_DOWN_HORIZONTAL             0x252c
+#define BOXDRAW_UP_HORIZONTAL               0x2534
+#define BOXDRAW_VERTICAL_HORIZONTAL         0x253c
+
+#define BOXDRAW_DOUBLE_HORIZONTAL           0x2550
+#define BOXDRAW_DOUBLE_VERTICAL             0x2551
+#define BOXDRAW_DOWN_RIGHT_DOUBLE           0x2552
+#define BOXDRAW_DOWN_DOUBLE_RIGHT           0x2553
+#define BOXDRAW_DOUBLE_DOWN_RIGHT           0x2554
+
+#define BOXDRAW_DOWN_LEFT_DOUBLE            0x2555
+#define BOXDRAW_DOWN_DOUBLE_LEFT            0x2556
+#define BOXDRAW_DOUBLE_DOWN_LEFT            0x2557
+
+#define BOXDRAW_UP_RIGHT_DOUBLE             0x2558
+#define BOXDRAW_UP_DOUBLE_RIGHT             0x2559
+#define BOXDRAW_DOUBLE_UP_RIGHT             0x255a
+
+#define BOXDRAW_UP_LEFT_DOUBLE              0x255b
+#define BOXDRAW_UP_DOUBLE_LEFT              0x255c
+#define BOXDRAW_DOUBLE_UP_LEFT              0x255d
+
+#define BOXDRAW_VERTICAL_RIGHT_DOUBLE       0x255e
+#define BOXDRAW_VERTICAL_DOUBLE_RIGHT       0x255f
+#define BOXDRAW_DOUBLE_VERTICAL_RIGHT       0x2560
+
+#define BOXDRAW_VERTICAL_LEFT_DOUBLE        0x2561
+#define BOXDRAW_VERTICAL_DOUBLE_LEFT        0x2562
+#define BOXDRAW_DOUBLE_VERTICAL_LEFT        0x2563
+
+#define BOXDRAW_DOWN_HORIZONTAL_DOUBLE      0x2564
+#define BOXDRAW_DOWN_DOUBLE_HORIZONTAL      0x2565
+#define BOXDRAW_DOUBLE_DOWN_HORIZONTAL      0x2566
+
+#define BOXDRAW_UP_HORIZONTAL_DOUBLE        0x2567
+#define BOXDRAW_UP_DOUBLE_HORIZONTAL        0x2568
+#define BOXDRAW_DOUBLE_UP_HORIZONTAL        0x2569
+
+#define BOXDRAW_VERTICAL_HORIZONTAL_DOUBLE  0x256a
+#define BOXDRAW_VERTICAL_DOUBLE_HORIZONTAL  0x256b
+#define BOXDRAW_DOUBLE_VERTICAL_HORIZONTAL  0x256c
+
+//
+// EFI Required Block Elements Code Chart
+//
+
+#define BLOCKELEMENT_FULL_BLOCK             0x2588
+#define BLOCKELEMENT_LIGHT_SHADE            0x2591
+//
+// EFI Required Geometric Shapes Code Chart
+//
+
+#define GEOMETRICSHAPE_UP_TRIANGLE           0x25b2
+#define GEOMETRICSHAPE_RIGHT_TRIANGLE        0x25ba
+#define GEOMETRICSHAPE_DOWN_TRIANGLE         0x25bc
+#define GEOMETRICSHAPE_LEFT_TRIANGLE         0x25c4
+
+//
+// EFI Required Arrow shapes
+//
+
+#define ARROW_UP                            0x2191
+#define ARROW_DOWN                          0x2193
+
+//
+// Text input protocol
+//
+
+#define SIMPLE_TEXT_INPUT_PROTOCOL  \
+    { 0x387477c1, 0x69c7, 0x11d2, {0x8e, 0x39, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b} }
+
+INTERFACE_DECL(_SIMPLE_INPUT_INTERFACE);
+
+typedef struct {
+    UINT16                              ScanCode;
+    CHAR16                              UnicodeChar;
+} EFI_INPUT_KEY;
+
+//
+// Baseline unicode control chars
+//
+
+#define CHAR_NULL                       0x0000
+#define CHAR_BACKSPACE                  0x0008
+#define CHAR_TAB                        0x0009
+#define CHAR_LINEFEED                   0x000A
+#define CHAR_CARRIAGE_RETURN            0x000D
+
+//
+// Scan codes for base line keys
+//
+
+#define SCAN_NULL                       0x0000
+#define SCAN_UP                         0x0001
+#define SCAN_DOWN                       0x0002
+#define SCAN_RIGHT                      0x0003
+#define SCAN_LEFT                       0x0004
+#define SCAN_HOME                       0x0005
+#define SCAN_END                        0x0006
+#define SCAN_INSERT                     0x0007
+#define SCAN_DELETE                     0x0008
+#define SCAN_PAGE_UP                    0x0009
+#define SCAN_PAGE_DOWN                  0x000A
+#define SCAN_F1                         0x000B
+#define SCAN_F2                         0x000C
+#define SCAN_F3                         0x000D
+#define SCAN_F4                         0x000E
+#define SCAN_F5                         0x000F
+#define SCAN_F6                         0x0010
+#define SCAN_F7                         0x0011
+#define SCAN_F8                         0x0012
+#define SCAN_F9                         0x0013
+#define SCAN_F10                        0x0014
+#define SCAN_ESC                        0x0017
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_INPUT_RESET) (
+    IN struct _SIMPLE_INPUT_INTERFACE   *This,
+    IN BOOLEAN                          ExtendedVerification
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_INPUT_READ_KEY) (
+    IN struct _SIMPLE_INPUT_INTERFACE   *This,
+    OUT EFI_INPUT_KEY                   *Key
+    );
+
+typedef struct _SIMPLE_INPUT_INTERFACE {
+    EFI_INPUT_RESET                     Reset;
+    EFI_INPUT_READ_KEY                  ReadKeyStroke;
+    EFI_EVENT                           WaitForKey;
+} SIMPLE_INPUT_INTERFACE;
+
+#endif
+
diff --git a/linux-x86_64/gnu-efi/include/efi/efidebug.h b/linux-x86_64/gnu-efi/include/efi/efidebug.h
new file mode 100644
index 0000000..f95d492
--- /dev/null
+++ b/linux-x86_64/gnu-efi/include/efi/efidebug.h
@@ -0,0 +1,110 @@
+#ifndef _EFI_DEBUG_H
+#define _EFI_DEBUG_H
+
+/*++
+
+Copyright (c) 1998  Intel Corporation
+
+Module Name:
+
+    efidebug.h
+
+Abstract:
+
+    EFI library debug functions
+
+
+
+Revision History
+
+--*/
+
+extern UINTN     EFIDebug;
+
+#if EFI_DEBUG
+
+    #define DBGASSERT(a)        DbgAssert(__FILE__, __LINE__, #a)
+    #define DEBUG(a)            DbgPrint a
+    
+#else
+
+    #define DBGASSERT(a)
+    #define DEBUG(a)
+    
+#endif
+
+#if EFI_DEBUG_CLEAR_MEMORY
+
+    #define DBGSETMEM(a,l)      SetMem(a,l,(CHAR8)BAD_POINTER)
+
+#else
+
+    #define DBGSETMEM(a,l)
+
+#endif
+
+#define D_INIT        0x00000001          // Initialization style messages
+#define D_WARN        0x00000002          // Warnings
+#define D_LOAD        0x00000004          // Load events
+#define D_FS          0x00000008          // EFI File system
+#define D_POOL        0x00000010          // Alloc & Free's
+#define D_PAGE        0x00000020          // Alloc & Free's
+#define D_INFO        0x00000040          // Verbose
+#define D_VAR         0x00000100          // Variable
+#define D_PARSE       0x00000200          // Command parsing
+#define D_BM          0x00000400          // Boot manager
+#define D_BLKIO       0x00001000          // BlkIo Driver
+#define D_BLKIO_ULTRA 0x00002000          // BlkIo Driver
+#define D_NET         0x00004000          // SNI Driver
+#define D_NET_ULTRA   0x00008000          // SNI Driver
+#define D_TXTIN       0x00010000          // Simple Input Driver
+#define D_TXTOUT      0x00020000          // Simple Text Output Driver
+#define D_ERROR_ATA	  0x00040000		  		// ATA error messages 
+#define D_ERROR       0x80000000          // Error
+
+#define D_RESERVED    0x7fffC880          // Bits not reserved above
+
+//
+// Current Debug level of the system, value of EFIDebug
+//
+//#define EFI_DBUG_MASK   (D_ERROR | D_WARN | D_LOAD | D_BLKIO | D_INIT)
+#define EFI_DBUG_MASK   (D_ERROR)
+
+//
+//
+//
+
+#if EFI_DEBUG
+
+    #define ASSERT(a)               if(!(a))       DBGASSERT(a)
+    #define ASSERT_LOCKED(l)        if(!(l)->Lock) DBGASSERT(l not locked)
+    #define ASSERT_STRUCT(p,t)      DBGASSERT(t not structure), p
+
+#else
+
+    #define ASSERT(a)               
+    #define ASSERT_LOCKED(l)        
+    #define ASSERT_STRUCT(p,t)      
+
+#endif
+
+//
+// Prototypes
+//
+
+INTN
+DbgAssert (
+    CHAR8   *file,
+    INTN    lineno,
+    CHAR8   *string
+    );
+
+INTN
+DbgPrint (
+    INTN    mask,
+    CHAR8   *format,
+    ...
+    );
+
+#endif
+
diff --git a/linux-x86_64/gnu-efi/include/efi/efidef.h b/linux-x86_64/gnu-efi/include/efi/efidef.h
new file mode 100644
index 0000000..07fdf0d
--- /dev/null
+++ b/linux-x86_64/gnu-efi/include/efi/efidef.h
@@ -0,0 +1,196 @@
+#ifndef _EFI_DEF_H
+#define _EFI_DEF_H
+
+/*++
+
+Copyright (c) 1998  Intel Corporation
+
+Module Name:
+
+    efidef.h
+
+Abstract:
+
+    EFI definitions
+
+
+
+
+Revision History
+
+--*/
+
+typedef UINT16          CHAR16;
+typedef UINT8           CHAR8;
+typedef UINT8           BOOLEAN;
+
+#ifndef TRUE
+    #define TRUE    ((BOOLEAN) 1)
+    #define FALSE   ((BOOLEAN) 0)
+#endif
+
+#ifndef NULL
+    #define NULL    ((VOID *) 0)
+#endif
+
+typedef UINTN           EFI_STATUS;
+typedef UINT64          EFI_LBA;
+typedef UINTN           EFI_TPL;
+typedef VOID            *EFI_HANDLE;
+typedef VOID            *EFI_EVENT;
+
+
+//
+// Prototype argument decoration for EFI parameters to indicate
+// their direction
+//
+// IN - argument is passed into the function
+// OUT - argument (pointer) is returned from the function
+// OPTIONAL - argument is optional
+//
+
+#ifndef IN
+    #define IN
+    #define OUT
+    #define OPTIONAL
+#endif
+
+
+//
+// A GUID
+//
+
+typedef struct {          
+    UINT32  Data1;
+    UINT16  Data2;
+    UINT16  Data3;
+    UINT8   Data4[8]; 
+} EFI_GUID;
+
+
+//
+// Time
+//
+
+typedef struct {          
+    UINT16      Year;       // 1998 - 20XX
+    UINT8       Month;      // 1 - 12
+    UINT8       Day;        // 1 - 31
+    UINT8       Hour;       // 0 - 23
+    UINT8       Minute;     // 0 - 59
+    UINT8       Second;     // 0 - 59
+    UINT8       Pad1;
+    UINT32      Nanosecond; // 0 - 999,999,999
+    INT16       TimeZone;   // -1440 to 1440 or 2047
+    UINT8       Daylight;
+    UINT8       Pad2;
+} EFI_TIME;
+
+// Bit definitions for EFI_TIME.Daylight
+#define EFI_TIME_ADJUST_DAYLIGHT    0x01
+#define EFI_TIME_IN_DAYLIGHT        0x02
+
+// Value definition for EFI_TIME.TimeZone
+#define EFI_UNSPECIFIED_TIMEZONE    0x07FF
+
+
+
+//
+// Networking
+//
+
+typedef struct {
+    UINT8                   Addr[4];
+} EFI_IPv4_ADDRESS;
+
+typedef struct {
+    UINT8                   Addr[16];
+} EFI_IPv6_ADDRESS;
+
+typedef struct {
+    UINT8                   Addr[32];
+} EFI_MAC_ADDRESS;
+
+//
+// Memory
+//
+
+typedef UINT64          EFI_PHYSICAL_ADDRESS;
+typedef UINT64          EFI_VIRTUAL_ADDRESS;
+
+typedef enum {
+    AllocateAnyPages,
+    AllocateMaxAddress,
+    AllocateAddress,
+    MaxAllocateType
+} EFI_ALLOCATE_TYPE;
+
+//Preseve the attr on any range supplied.
+//ConventialMemory must have WB,SR,SW when supplied.
+//When allocating from ConventialMemory always make it WB,SR,SW
+//When returning to ConventialMemory always make it WB,SR,SW
+//When getting the memory map, or on RT for runtime types
+
+
+typedef enum {
+    EfiReservedMemoryType,
+    EfiLoaderCode,
+    EfiLoaderData,
+    EfiBootServicesCode,
+    EfiBootServicesData,
+    EfiRuntimeServicesCode,
+    EfiRuntimeServicesData,
+    EfiConventionalMemory,
+    EfiUnusableMemory,
+    EfiACPIReclaimMemory,
+    EfiACPIMemoryNVS,
+    EfiMemoryMappedIO,
+    EfiMemoryMappedIOPortSpace,
+    EfiPalCode,
+    EfiMaxMemoryType
+} EFI_MEMORY_TYPE;
+
+// possible caching types for the memory range
+#define EFI_MEMORY_UC           0x0000000000000001
+#define EFI_MEMORY_WC           0x0000000000000002
+#define EFI_MEMORY_WT           0x0000000000000004
+#define EFI_MEMORY_WB           0x0000000000000008
+#define EFI_MEMORY_UCE          0x0000000000000010  
+
+// physical memory protection on range 
+#define EFI_MEMORY_WP           0x0000000000001000
+#define EFI_MEMORY_RP           0x0000000000002000
+#define EFI_MEMORY_XP           0x0000000000004000
+
+// range requires a runtime mapping
+#define EFI_MEMORY_RUNTIME      0x8000000000000000
+
+#define EFI_MEMORY_DESCRIPTOR_VERSION  1
+typedef struct {
+    UINT32                          Type;           // Field size is 32 bits followed by 32 bit pad
+    UINT32                          Pad;
+    EFI_PHYSICAL_ADDRESS            PhysicalStart;  // Field size is 64 bits
+    EFI_VIRTUAL_ADDRESS             VirtualStart;   // Field size is 64 bits
+    UINT64                          NumberOfPages;  // Field size is 64 bits
+    UINT64                          Attribute;      // Field size is 64 bits
+} EFI_MEMORY_DESCRIPTOR;
+
+//
+// International Language
+//
+
+typedef UINT8   ISO_639_2;
+#define ISO_639_2_ENTRY_SIZE    3
+
+//
+//
+//
+
+#define EFI_PAGE_SIZE   4096
+#define EFI_PAGE_MASK   0xFFF
+#define EFI_PAGE_SHIFT  12
+
+#define EFI_SIZE_TO_PAGES(a)  \
+    ( ((a) >> EFI_PAGE_SHIFT) + ((a) & EFI_PAGE_MASK ? 1 : 0) )
+
+#endif
diff --git a/linux-x86_64/gnu-efi/include/efi/efidevp.h b/linux-x86_64/gnu-efi/include/efi/efidevp.h
new file mode 100644
index 0000000..beb5785
--- /dev/null
+++ b/linux-x86_64/gnu-efi/include/efi/efidevp.h
@@ -0,0 +1,402 @@
+#ifndef _DEVPATH_H
+#define _DEVPATH_H
+
+/*++
+
+Copyright (c) 1998  Intel Corporation
+
+Module Name:
+
+    devpath.h
+
+Abstract:
+
+    Defines for parsing the EFI Device Path structures
+
+
+
+Revision History
+
+--*/
+
+//
+// Device Path structures - Section C
+//
+
+typedef struct _EFI_DEVICE_PATH {
+        UINT8                           Type;
+        UINT8                           SubType;
+        UINT8                           Length[2];
+} EFI_DEVICE_PATH;
+
+#define EFI_DP_TYPE_MASK                    0x7F
+#define EFI_DP_TYPE_UNPACKED                0x80
+
+//#define END_DEVICE_PATH_TYPE                0xff
+#define END_DEVICE_PATH_TYPE                0x7f
+//#define END_DEVICE_PATH_TYPE_UNPACKED       0x7f
+
+#define END_ENTIRE_DEVICE_PATH_SUBTYPE      0xff
+#define END_INSTANCE_DEVICE_PATH_SUBTYPE    0x01
+#define END_DEVICE_PATH_LENGTH              (sizeof(EFI_DEVICE_PATH))
+
+
+#define DP_IS_END_TYPE(a)
+#define DP_IS_END_SUBTYPE(a)        ( ((a)->SubType == END_ENTIRE_DEVICE_PATH_SUBTYPE )
+
+#define DevicePathType(a)           ( ((a)->Type) & EFI_DP_TYPE_MASK )
+#define DevicePathSubType(a)        ( (a)->SubType )
+#define DevicePathNodeLength(a)     ( ((a)->Length[0]) | ((a)->Length[1] << 8) )
+#define NextDevicePathNode(a)       ( (EFI_DEVICE_PATH *) ( ((UINT8 *) (a)) + DevicePathNodeLength(a)))
+//#define IsDevicePathEndType(a)      ( DevicePathType(a) == END_DEVICE_PATH_TYPE_UNPACKED )
+#define IsDevicePathEndType(a)      ( DevicePathType(a) == END_DEVICE_PATH_TYPE )
+#define IsDevicePathEndSubType(a)   ( (a)->SubType == END_ENTIRE_DEVICE_PATH_SUBTYPE )
+#define IsDevicePathEnd(a)          ( IsDevicePathEndType(a) && IsDevicePathEndSubType(a) )
+#define IsDevicePathUnpacked(a)     ( (a)->Type & EFI_DP_TYPE_UNPACKED )
+
+
+#define SetDevicePathNodeLength(a,l) {                  \
+            (a)->Length[0] = (UINT8) (l);               \
+            (a)->Length[1] = (UINT8) ((l) >> 8);        \
+            }
+
+#define SetDevicePathEndNode(a)  {                      \
+            (a)->Type = END_DEVICE_PATH_TYPE;           \
+            (a)->SubType = END_ENTIRE_DEVICE_PATH_SUBTYPE;     \
+            (a)->Length[0] = sizeof(EFI_DEVICE_PATH);   \
+            (a)->Length[1] = 0;                         \
+            }
+
+
+
+/*
+ *
+ */
+#define HARDWARE_DEVICE_PATH            0x01
+
+#define HW_PCI_DP                       0x01
+typedef struct _PCI_DEVICE_PATH {
+        EFI_DEVICE_PATH                 Header;
+        UINT8                           Function;
+        UINT8                           Device;
+} PCI_DEVICE_PATH;
+
+#define HW_PCCARD_DP                    0x02
+typedef struct _PCCARD_DEVICE_PATH {
+        EFI_DEVICE_PATH                 Header;
+        UINT8                           SocketNumber;
+} PCCARD_DEVICE_PATH;
+
+#define HW_MEMMAP_DP                    0x03
+typedef struct _MEMMAP_DEVICE_PATH {
+        EFI_DEVICE_PATH                 Header;
+        UINT32                          MemoryType;
+        EFI_PHYSICAL_ADDRESS            StartingAddress;
+        EFI_PHYSICAL_ADDRESS            EndingAddress;
+} MEMMAP_DEVICE_PATH;
+
+#define HW_VENDOR_DP                    0x04
+typedef struct _VENDOR_DEVICE_PATH {
+        EFI_DEVICE_PATH                 Header;
+        EFI_GUID                        Guid;
+} VENDOR_DEVICE_PATH;
+
+#define UNKNOWN_DEVICE_GUID \
+    { 0xcf31fac5, 0xc24e, 0x11d2,  {0x85, 0xf3, 0x0, 0xa0, 0xc9, 0x3e, 0xc9, 0x3b}  }
+
+typedef struct _UKNOWN_DEVICE_VENDOR_DP {
+    VENDOR_DEVICE_PATH      DevicePath;
+    UINT8                   LegacyDriveLetter;
+} UNKNOWN_DEVICE_VENDOR_DEVICE_PATH;
+
+#define HW_CONTROLLER_DP            0x05
+typedef struct _CONTROLLER_DEVICE_PATH {
+        EFI_DEVICE_PATH     Header;
+        UINT32              Controller;
+} CONTROLLER_DEVICE_PATH;
+
+/*
+ *
+ */
+#define ACPI_DEVICE_PATH                 0x02
+
+#define ACPI_DP                         0x01
+typedef struct _ACPI_HID_DEVICE_PATH {
+        EFI_DEVICE_PATH                 Header;
+        UINT32                          HID;
+        UINT32                          UID;
+} ACPI_HID_DEVICE_PATH;
+
+#define EXPANDED_ACPI_DP		0x02
+typedef struct _EXPANDED_ACPI_HID_DEVICE_PATH {
+	EFI_DEVICE_PATH			Header;
+	UINT32				HID;
+	UINT32				UID;
+	UINT32				CID;
+	UINT8				HidStr[1];
+} EXPANDED_ACPI_HID_DEVICE_PATH;
+
+//
+// EISA ID Macro
+// EISA ID Definition 32-bits
+//  bits[15:0] - three character compressed ASCII EISA ID.
+//  bits[31:16] - binary number
+//   Compressed ASCII is 5 bits per character 0b00001 = 'A' 0b11010 = 'Z'
+//
+#define PNP_EISA_ID_CONST       0x41d0    
+#define EISA_ID(_Name, _Num)    ((UINT32) ((_Name) | (_Num) << 16))   
+#define EISA_PNP_ID(_PNPId)     (EISA_ID(PNP_EISA_ID_CONST, (_PNPId)))
+
+#define PNP_EISA_ID_MASK        0xffff
+#define EISA_ID_TO_NUM(_Id)     ((_Id) >> 16)
+/*
+ *
+ */
+#define MESSAGING_DEVICE_PATH           0x03 
+
+#define MSG_ATAPI_DP                    0x01
+typedef struct _ATAPI_DEVICE_PATH {
+        EFI_DEVICE_PATH                 Header;
+        UINT8                           PrimarySecondary;
+        UINT8                           SlaveMaster;
+        UINT16                          Lun;
+} ATAPI_DEVICE_PATH;
+
+#define MSG_SCSI_DP                     0x02
+typedef struct _SCSI_DEVICE_PATH {
+        EFI_DEVICE_PATH                 Header;
+        UINT16                          Pun;
+        UINT16                          Lun; 
+} SCSI_DEVICE_PATH;
+
+#define MSG_FIBRECHANNEL_DP             0x03
+typedef struct _FIBRECHANNEL_DEVICE_PATH {
+        EFI_DEVICE_PATH                 Header;
+        UINT32                          Reserved;
+        UINT64                          WWN;
+        UINT64                          Lun;
+} FIBRECHANNEL_DEVICE_PATH;
+
+#define MSG_1394_DP                     0x04
+typedef struct _F1394_DEVICE_PATH {
+        EFI_DEVICE_PATH                 Header;
+        UINT32                          Reserved;
+        UINT64                          Guid;
+} F1394_DEVICE_PATH;
+
+#define MSG_USB_DP                      0x05
+typedef struct _USB_DEVICE_PATH {
+        EFI_DEVICE_PATH                 Header;
+        UINT8                           Port;
+        UINT8                           Endpoint;
+} USB_DEVICE_PATH;
+
+#define MSG_USB_CLASS_DP                0x0F
+typedef struct _USB_CLASS_DEVICE_PATH {
+        EFI_DEVICE_PATH                 Header;
+        UINT16                          VendorId;
+        UINT16                          ProductId;
+        UINT8                           DeviceClass;
+        UINT8                           DeviceSubclass;
+        UINT8                           DeviceProtocol;
+} USB_CLASS_DEVICE_PATH;
+
+#define MSG_I2O_DP                      0x06
+typedef struct _I2O_DEVICE_PATH {
+        EFI_DEVICE_PATH                 Header;
+        UINT32                          Tid;
+} I2O_DEVICE_PATH;
+
+#define MSG_MAC_ADDR_DP                 0x0b
+typedef struct _MAC_ADDR_DEVICE_PATH {
+        EFI_DEVICE_PATH                 Header;
+        EFI_MAC_ADDRESS                 MacAddress;
+        UINT8                           IfType;
+} MAC_ADDR_DEVICE_PATH;
+
+#define MSG_IPv4_DP                     0x0c
+typedef struct _IPv4_DEVICE_PATH {
+        EFI_DEVICE_PATH                 Header;
+        EFI_IPv4_ADDRESS                LocalIpAddress;
+        EFI_IPv4_ADDRESS                RemoteIpAddress;
+        UINT16                          LocalPort;
+        UINT16                          RemotePort;
+        UINT16                          Protocol;
+        BOOLEAN                         StaticIpAddress;
+} IPv4_DEVICE_PATH;
+
+#define MSG_IPv6_DP                     0x0d
+typedef struct _IPv6_DEVICE_PATH {
+        EFI_DEVICE_PATH                 Header;
+        EFI_IPv6_ADDRESS                LocalIpAddress;
+        EFI_IPv6_ADDRESS                RemoteIpAddress;
+        UINT16                          LocalPort;
+        UINT16                          RemotePort;
+        UINT16                          Protocol;
+        BOOLEAN                         StaticIpAddress;
+} IPv6_DEVICE_PATH;
+
+#define MSG_INFINIBAND_DP               0x09
+typedef struct _INFINIBAND_DEVICE_PATH {
+        EFI_DEVICE_PATH                 Header;
+        UINT32                          Reserved;
+        UINT64                          NodeGuid;
+        UINT64                          IocGuid;
+        UINT64                          DeviceId;
+} INFINIBAND_DEVICE_PATH;
+
+#define MSG_UART_DP                     0x0e
+typedef struct _UART_DEVICE_PATH {
+        EFI_DEVICE_PATH                 Header;
+        UINT32                          Reserved;
+        UINT64                          BaudRate;
+        UINT8                           DataBits;
+        UINT8                           Parity;
+        UINT8                           StopBits;
+} UART_DEVICE_PATH;
+
+#define MSG_VENDOR_DP                   0x0A
+/* Use VENDOR_DEVICE_PATH struct */
+
+#define DEVICE_PATH_MESSAGING_PC_ANSI \
+    { 0xe0c14753, 0xf9be, 0x11d2,  {0x9a, 0x0c, 0x00, 0x90, 0x27, 0x3f, 0xc1, 0x4d}  }
+
+#define DEVICE_PATH_MESSAGING_VT_100 \
+    { 0xdfa66065, 0xb419, 0x11d3,  {0x9a, 0x2d, 0x00, 0x90, 0x27, 0x3f, 0xc1, 0x4d}  }
+
+
+
+#define MEDIA_DEVICE_PATH               0x04
+
+#define MEDIA_HARDDRIVE_DP              0x01
+typedef struct _HARDDRIVE_DEVICE_PATH {
+        EFI_DEVICE_PATH                 Header;
+        UINT32                          PartitionNumber;
+        UINT64                          PartitionStart;
+        UINT64                          PartitionSize;
+        UINT8                           Signature[16];
+        UINT8                           MBRType;
+        UINT8                           SignatureType;
+} HARDDRIVE_DEVICE_PATH;
+
+#define MBR_TYPE_PCAT                       0x01
+#define MBR_TYPE_EFI_PARTITION_TABLE_HEADER 0x02
+
+#define SIGNATURE_TYPE_MBR                  0x01
+#define SIGNATURE_TYPE_GUID                 0x02
+
+#define MEDIA_CDROM_DP                  0x02
+typedef struct _CDROM_DEVICE_PATH {
+        EFI_DEVICE_PATH                 Header;
+        UINT32                          BootEntry;
+        UINT64                          PartitionStart;
+        UINT64                          PartitionSize;
+} CDROM_DEVICE_PATH;
+
+#define MEDIA_VENDOR_DP                 0x03
+/* Use VENDOR_DEVICE_PATH struct */
+
+#define MEDIA_FILEPATH_DP               0x04
+typedef struct _FILEPATH_DEVICE_PATH {
+        EFI_DEVICE_PATH                 Header;
+        CHAR16                          PathName[1];
+} FILEPATH_DEVICE_PATH;
+
+#define SIZE_OF_FILEPATH_DEVICE_PATH EFI_FIELD_OFFSET(FILEPATH_DEVICE_PATH,PathName)
+
+#define MEDIA_PROTOCOL_DP               0x05
+typedef struct _MEDIA_PROTOCOL_DEVICE_PATH {
+        EFI_DEVICE_PATH                 Header;
+        EFI_GUID                        Protocol;
+} MEDIA_PROTOCOL_DEVICE_PATH;
+
+
+#define BBS_DEVICE_PATH                 0x05
+#define BBS_BBS_DP                      0x01
+typedef struct _BBS_BBS_DEVICE_PATH {
+        EFI_DEVICE_PATH                 Header;
+        UINT16                          DeviceType;
+        UINT16                          StatusFlag;
+        CHAR8                           String[1];
+} BBS_BBS_DEVICE_PATH;
+
+/* DeviceType definitions - from BBS specification */
+#define BBS_TYPE_FLOPPY                 0x01
+#define BBS_TYPE_HARDDRIVE              0x02
+#define BBS_TYPE_CDROM                  0x03
+#define BBS_TYPE_PCMCIA                 0x04
+#define BBS_TYPE_USB                    0x05
+#define BBS_TYPE_EMBEDDED_NETWORK       0x06
+#define BBS_TYPE_DEV                    0x80
+#define BBS_TYPE_UNKNOWN                0xFF
+
+typedef union {
+    EFI_DEVICE_PATH                      DevPath;
+    PCI_DEVICE_PATH                      Pci;
+    PCCARD_DEVICE_PATH                   PcCard;
+    MEMMAP_DEVICE_PATH                   MemMap;
+    VENDOR_DEVICE_PATH                   Vendor;
+    UNKNOWN_DEVICE_VENDOR_DEVICE_PATH    UnknownVendor;   
+    CONTROLLER_DEVICE_PATH               Controller;
+    ACPI_HID_DEVICE_PATH                 Acpi;
+
+    ATAPI_DEVICE_PATH                    Atapi;
+    SCSI_DEVICE_PATH                     Scsi;
+    FIBRECHANNEL_DEVICE_PATH             FibreChannel;
+
+    F1394_DEVICE_PATH                    F1394;
+    USB_DEVICE_PATH                      Usb;
+    USB_CLASS_DEVICE_PATH                UsbClass;
+    I2O_DEVICE_PATH                      I2O;
+    MAC_ADDR_DEVICE_PATH                 MacAddr;
+    IPv4_DEVICE_PATH                     Ipv4;
+    IPv6_DEVICE_PATH                     Ipv6;
+    INFINIBAND_DEVICE_PATH               InfiniBand;
+    UART_DEVICE_PATH                     Uart;
+
+    HARDDRIVE_DEVICE_PATH                HardDrive;
+    CDROM_DEVICE_PATH                    CD;
+
+    FILEPATH_DEVICE_PATH                 FilePath;
+    MEDIA_PROTOCOL_DEVICE_PATH           MediaProtocol;
+
+    BBS_BBS_DEVICE_PATH                  Bbs;
+
+} EFI_DEV_PATH;
+
+typedef union {
+    EFI_DEVICE_PATH                      *DevPath;
+    PCI_DEVICE_PATH                      *Pci;
+    PCCARD_DEVICE_PATH                   *PcCard;
+    MEMMAP_DEVICE_PATH                   *MemMap;
+    VENDOR_DEVICE_PATH                   *Vendor;
+    UNKNOWN_DEVICE_VENDOR_DEVICE_PATH    *UnknownVendor;   
+    CONTROLLER_DEVICE_PATH               *Controller;
+    ACPI_HID_DEVICE_PATH                 *Acpi;
+
+    ATAPI_DEVICE_PATH                    *Atapi;
+    SCSI_DEVICE_PATH                     *Scsi;
+    FIBRECHANNEL_DEVICE_PATH             *FibreChannel;
+
+    F1394_DEVICE_PATH                    *F1394;
+    USB_DEVICE_PATH                      *Usb;
+    USB_CLASS_DEVICE_PATH                *UsbClass;
+    I2O_DEVICE_PATH                      *I2O;
+    MAC_ADDR_DEVICE_PATH                 *MacAddr;
+    IPv4_DEVICE_PATH                     *Ipv4;
+    IPv6_DEVICE_PATH                     *Ipv6;
+    INFINIBAND_DEVICE_PATH               *InfiniBand;
+    UART_DEVICE_PATH                     *Uart;
+
+    HARDDRIVE_DEVICE_PATH                *HardDrive;
+
+    FILEPATH_DEVICE_PATH                 *FilePath;
+    MEDIA_PROTOCOL_DEVICE_PATH           *MediaProtocol;
+
+    CDROM_DEVICE_PATH                    *CD;
+    BBS_BBS_DEVICE_PATH                  *Bbs;
+
+} EFI_DEV_PATH_PTR;
+
+
+#endif
diff --git a/linux-x86_64/gnu-efi/include/efi/efierr.h b/linux-x86_64/gnu-efi/include/efi/efierr.h
new file mode 100644
index 0000000..669d7ba
--- /dev/null
+++ b/linux-x86_64/gnu-efi/include/efi/efierr.h
@@ -0,0 +1,60 @@
+#ifndef _EFI_ERR_H
+#define _EFI_ERR_H
+
+/*++
+
+Copyright (c) 1998  Intel Corporation
+
+Module Name:
+
+    efierr.h
+
+Abstract:
+
+    EFI error codes
+
+
+
+
+Revision History
+
+--*/
+
+
+#define EFIWARN(a)                            (a)
+#define EFI_ERROR(a)              (((INTN) a) < 0)
+
+
+#define EFI_SUCCESS                             0
+#define EFI_LOAD_ERROR                  EFIERR(1)
+#define EFI_INVALID_PARAMETER           EFIERR(2)
+#define EFI_UNSUPPORTED                 EFIERR(3)
+#define EFI_BAD_BUFFER_SIZE             EFIERR(4)
+#define EFI_BUFFER_TOO_SMALL            EFIERR(5)
+#define EFI_NOT_READY                   EFIERR(6)
+#define EFI_DEVICE_ERROR                EFIERR(7)
+#define EFI_WRITE_PROTECTED             EFIERR(8)
+#define EFI_OUT_OF_RESOURCES            EFIERR(9)
+#define EFI_VOLUME_CORRUPTED            EFIERR(10)
+#define EFI_VOLUME_FULL                 EFIERR(11)
+#define EFI_NO_MEDIA                    EFIERR(12)
+#define EFI_MEDIA_CHANGED               EFIERR(13)
+#define EFI_NOT_FOUND                   EFIERR(14)
+#define EFI_ACCESS_DENIED               EFIERR(15)
+#define EFI_NO_RESPONSE                 EFIERR(16)
+#define EFI_NO_MAPPING                  EFIERR(17)
+#define EFI_TIMEOUT                     EFIERR(18)
+#define EFI_NOT_STARTED                 EFIERR(19)
+#define EFI_ALREADY_STARTED             EFIERR(20)
+#define EFI_ABORTED                     EFIERR(21)
+#define EFI_ICMP_ERROR                  EFIERR(22)
+#define EFI_TFTP_ERROR                  EFIERR(23)
+#define EFI_PROTOCOL_ERROR              EFIERR(24)
+
+#define EFI_WARN_UNKOWN_GLYPH           EFIWARN(1)
+#define EFI_WARN_DELETE_FAILURE         EFIWARN(2)
+#define EFI_WARN_WRITE_FAILURE          EFIWARN(3)
+#define EFI_WARN_BUFFER_TOO_SMALL       EFIWARN(4)
+
+#endif
+
diff --git a/linux-x86_64/gnu-efi/include/efi/efifs.h b/linux-x86_64/gnu-efi/include/efi/efifs.h
new file mode 100644
index 0000000..fc595d1
--- /dev/null
+++ b/linux-x86_64/gnu-efi/include/efi/efifs.h
@@ -0,0 +1,116 @@
+#ifndef _EFI_FS_H
+#define _EFI_FS_H
+
+/*++
+
+Copyright (c) 1998  Intel Corporation
+
+Module Name:
+
+    efifs.h
+
+Abstract:
+
+    EFI File System structures
+
+
+
+Revision History
+
+--*/
+
+
+//
+// EFI Partition header (normaly starts in LBA 1)
+//
+
+#define EFI_PARTITION_SIGNATURE         0x5053595320494249
+#define EFI_PARTITION_REVISION          0x00010001
+#define MIN_EFI_PARTITION_BLOCK_SIZE    512
+#define EFI_PARTITION_LBA               1
+
+typedef struct _EFI_PARTITION_HEADER {
+    EFI_TABLE_HEADER    Hdr;
+    UINT32              DirectoryAllocationNumber;
+    UINT32              BlockSize;
+    EFI_LBA             FirstUsableLba;
+    EFI_LBA             LastUsableLba;
+    EFI_LBA             UnusableSpace;
+    EFI_LBA             FreeSpace;
+    EFI_LBA             RootFile;
+    EFI_LBA             SecutiryFile;
+} EFI_PARTITION_HEADER;
+
+
+//
+// File header
+//
+
+#define EFI_FILE_HEADER_SIGNATURE   0x454c494620494249
+#define EFI_FILE_HEADER_REVISION    0x00010000
+#define EFI_FILE_STRING_SIZE        260
+
+typedef struct _EFI_FILE_HEADER {
+    EFI_TABLE_HEADER    Hdr;
+    UINT32              Class;
+    UINT32              LBALOffset;
+    EFI_LBA             Parent;
+    UINT64              FileSize;
+    UINT64              FileAttributes;
+    EFI_TIME            FileCreateTime;
+    EFI_TIME            FileModificationTime;
+    EFI_GUID            VendorGuid;
+    CHAR16              FileString[EFI_FILE_STRING_SIZE];
+} EFI_FILE_HEADER;
+
+
+//
+// Return the file's first LBAL which is in the same
+// logical block as the file header
+//
+
+#define EFI_FILE_LBAL(a)    ((EFI_LBAL *) (((CHAR8 *) (a)) + (a)->LBALOffset))
+
+#define EFI_FILE_CLASS_FREE_SPACE   1
+#define EFI_FILE_CLASS_EMPTY        2
+#define EFI_FILE_CLASS_NORMAL       3
+
+
+//
+// Logical Block Address List - the fundemental block
+// description structure
+//
+
+#define EFI_LBAL_SIGNATURE      0x4c41424c20494249
+#define EFI_LBAL_REVISION       0x00010000
+
+typedef struct _EFI_LBAL {
+    EFI_TABLE_HEADER    Hdr;
+    UINT32              Class;
+    EFI_LBA             Parent;
+    EFI_LBA             Next;
+    UINT32              ArraySize;
+    UINT32              ArrayCount;
+} EFI_LBAL;
+
+// Array size 
+#define EFI_LBAL_ARRAY_SIZE(lbal,offs,blks)  \
+        (((blks) - (offs) - (lbal)->Hdr.HeaderSize) / sizeof(EFI_RL))
+
+//
+// Logical Block run-length
+//
+
+typedef struct {
+    EFI_LBA     Start;
+    UINT64      Length;
+} EFI_RL;
+
+//
+// Return the run-length structure from an LBAL header
+//
+
+#define EFI_LBAL_RL(a)      ((EFI_RL*) (((CHAR8 *) (a)) + (a)->Hdr.HeaderSize))
+
+#endif
+
diff --git a/linux-x86_64/gnu-efi/include/efi/efigpt.h b/linux-x86_64/gnu-efi/include/efi/efigpt.h
new file mode 100644
index 0000000..d1694ae
--- /dev/null
+++ b/linux-x86_64/gnu-efi/include/efi/efigpt.h
@@ -0,0 +1,68 @@
+#ifndef _EFI_GPT_H
+#define _EFI_GPT_H
+/*++
+
+Copyright (c) 1998  Intel Corporation
+
+Module Name:
+
+    EfiGpt.h
+    
+Abstract:
+    Include file for EFI partitioning scheme
+
+
+
+Revision History
+
+--*/
+
+#define PRIMARY_PART_HEADER_LBA         1
+
+typedef struct {
+    EFI_TABLE_HEADER    Header;
+    EFI_LBA             MyLBA;
+    EFI_LBA             AlternateLBA;
+    EFI_LBA             FirstUsableLBA;
+    EFI_LBA             LastUsableLBA;
+    EFI_GUID            DiskGUID;
+    EFI_LBA             PartitionEntryLBA;
+    UINT32              NumberOfPartitionEntries;
+    UINT32              SizeOfPartitionEntry;
+    UINT32              PartitionEntryArrayCRC32;
+} EFI_PARTITION_TABLE_HEADER;
+
+#define EFI_PTAB_HEADER_ID  "EFI PART"
+
+typedef struct {
+    EFI_GUID    PartitionTypeGUID;
+    EFI_GUID    UniquePartitionGUID;
+    EFI_LBA     StartingLBA;
+    EFI_LBA     EndingLBA;
+    UINT64      Attributes;
+    CHAR16      PartitionName[36];
+} EFI_PARTITION_ENTRY;
+
+//
+// EFI Partition Attributes
+//
+#define EFI_PART_USED_BY_EFI            0x0000000000000001
+#define EFI_PART_REQUIRED_TO_FUNCTION   0x0000000000000002
+#define EFI_PART_USED_BY_OS             0x0000000000000004
+#define EFI_PART_REQUIRED_BY_OS         0x0000000000000008
+#define EFI_PART_BACKUP_REQUIRED        0x0000000000000010
+#define EFI_PART_USER_DATA              0x0000000000000020
+#define EFI_PART_CRITICAL_USER_DATA     0x0000000000000040
+#define EFI_PART_REDUNDANT_PARTITION    0x0000000000000080
+
+#define EFI_PART_TYPE_UNUSED_GUID   \
+    { 0x00000000, 0x0000, 0x0000, {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00} }
+    
+#define EFI_PART_TYPE_EFI_SYSTEM_PART_GUID  \
+    { 0xc12a7328, 0xf81f, 0x11d2, {0xba, 0x4b, 0x00, 0xa0, 0xc9, 0x3e, 0xc9, 0x3b} }
+
+#define EFI_PART_TYPE_LEGACY_MBR_GUID   \
+    { 0x024dee41, 0x33e7, 0x11d3, {0x9d, 0x69, 0x00, 0x08, 0xc7, 0x81, 0xf3, 0x9f} }
+
+#endif
+
diff --git a/linux-x86_64/gnu-efi/include/efi/efilib.h b/linux-x86_64/gnu-efi/include/efi/efilib.h
new file mode 100644
index 0000000..740c2ff
--- /dev/null
+++ b/linux-x86_64/gnu-efi/include/efi/efilib.h
@@ -0,0 +1,880 @@
+#ifndef _EFILIB_INCLUDE_
+#define _EFILIB_INCLUDE_
+
+/*++
+
+Copyright (c) 2000  Intel Corporation
+
+Module Name:
+
+    efilib.h
+
+Abstract:
+
+    EFI library functions
+
+
+
+Revision History
+
+--*/
+
+#include "efidebug.h"
+#include "efipart.h"
+#include "efilibplat.h"
+#include "efilink.h"
+#include "efirtlib.h"
+#include "pci22.h"
+#include "libsmbios.h"
+
+//
+// Public read-only data in the EFI library
+//
+
+extern EFI_SYSTEM_TABLE         *ST;
+extern EFI_BOOT_SERVICES        *BS;
+extern EFI_RUNTIME_SERVICES     *RT;
+
+extern EFI_GUID DevicePathProtocol;
+extern EFI_GUID LoadedImageProtocol;
+extern EFI_GUID TextInProtocol;
+extern EFI_GUID TextOutProtocol;
+extern EFI_GUID BlockIoProtocol;
+extern EFI_GUID DiskIoProtocol;
+extern EFI_GUID FileSystemProtocol;
+extern EFI_GUID LoadFileProtocol;
+extern EFI_GUID DeviceIoProtocol;
+extern EFI_GUID VariableStoreProtocol;
+extern EFI_GUID LegacyBootProtocol;
+extern EFI_GUID UnicodeCollationProtocol;
+extern EFI_GUID SerialIoProtocol;
+extern EFI_GUID VgaClassProtocol;
+extern EFI_GUID TextOutSpliterProtocol;
+extern EFI_GUID ErrorOutSpliterProtocol;
+extern EFI_GUID TextInSpliterProtocol;
+extern EFI_GUID SimpleNetworkProtocol;
+extern EFI_GUID PxeBaseCodeProtocol;
+extern EFI_GUID PxeCallbackProtocol;
+extern EFI_GUID NetworkInterfaceIdentifierProtocol;
+extern EFI_GUID UiProtocol;
+extern EFI_GUID InternalShellProtocol;
+extern EFI_GUID PciIoProtocol;
+
+extern EFI_GUID EfiGlobalVariable;
+extern EFI_GUID GenericFileInfo;
+extern EFI_GUID FileSystemInfo;
+extern EFI_GUID FileSystemVolumeLabelInfo;
+extern EFI_GUID PcAnsiProtocol;
+extern EFI_GUID Vt100Protocol;
+extern EFI_GUID NullGuid;
+extern EFI_GUID UnknownDevice;
+
+extern EFI_GUID EfiPartTypeSystemPartitionGuid;
+extern EFI_GUID EfiPartTypeLegacyMbrGuid;
+
+extern EFI_GUID MpsTableGuid;
+extern EFI_GUID AcpiTableGuid;
+extern EFI_GUID SMBIOSTableGuid;
+extern EFI_GUID SalSystemTableGuid;
+
+//
+// EFI Variable strings
+//
+#define LOAD_OPTION_ACTIVE      0x00000001
+
+#define VarLanguageCodes       L"LangCodes"
+#define VarLanguage            L"Lang"
+#define VarTimeout             L"Timeout"
+#define VarConsoleInp          L"ConIn"
+#define VarConsoleOut          L"ConOut"
+#define VarErrorOut            L"ErrOut"
+#define VarBootOption          L"Boot%04x"
+#define VarBootOrder           L"BootOrder"
+#define VarBootNext            L"BootNext"
+#define VarBootCurrent         L"BootCurrent"
+#define VarDriverOption        L"Driver%04x"
+#define VarDriverOrder         L"DriverOrder"
+#define VarConsoleInpDev       L"ConInDev"
+#define VarConsoleOutDev       L"ConOutDev"
+#define VarErrorOutDev         L"ErrOutDev"
+
+#define LanguageCodeEnglish    "eng"
+
+extern EFI_DEVICE_PATH RootDevicePath[];
+extern EFI_DEVICE_PATH EndDevicePath[];
+extern EFI_DEVICE_PATH EndInstanceDevicePath[];
+
+//
+// Other public data in the EFI library
+//
+
+extern EFI_MEMORY_TYPE PoolAllocationType;
+
+//
+// STATIC - Name is internal to the module
+// INTERNAL - Name is internal to the component (i.e., directory)
+// BOOTSERVCE - Name of a boot service function
+//
+
+#define STATIC
+#define INTERNAL
+#define BOOTSERVICE
+
+//
+// Prototypes
+//
+
+VOID
+InitializeLib (
+    IN EFI_HANDLE           ImageHandle,
+    IN EFI_SYSTEM_TABLE     *SystemTable
+    );
+
+VOID
+InitializeUnicodeSupport (
+    CHAR8 *LangCode
+    );
+
+VOID
+EFIDebugVariable (
+    VOID
+    );
+
+VOID
+SetCrc (
+    IN OUT EFI_TABLE_HEADER *Hdr
+    );
+
+VOID
+SetCrcAltSize (
+    IN UINTN                 Size,
+    IN OUT EFI_TABLE_HEADER *Hdr
+    );
+
+BOOLEAN
+CheckCrc (
+    IN UINTN                 MaxSize,
+    IN OUT EFI_TABLE_HEADER *Hdr
+    );
+
+BOOLEAN
+CheckCrcAltSize (
+    IN UINTN                 MaxSize,
+    IN UINTN                 Size,
+    IN OUT EFI_TABLE_HEADER *Hdr
+    );
+
+UINT32
+CalculateCrc (
+    UINT8 *pt,
+    UINTN Size
+    );
+
+VOID
+ZeroMem (
+    IN VOID     *Buffer,
+    IN UINTN     Size
+    );
+
+VOID
+SetMem (
+    IN VOID     *Buffer,
+    IN UINTN    Size,
+    IN UINT8    Value    
+    );
+
+VOID
+CopyMem (
+    IN VOID     *Dest,
+    IN VOID     *Src,
+    IN UINTN    len
+    );
+
+INTN
+CompareMem (
+    IN VOID     *Dest,
+    IN VOID     *Src,
+    IN UINTN    len
+    );
+
+INTN
+StrCmp (
+    IN CHAR16   *s1,
+    IN CHAR16   *s2
+    );
+
+INTN
+StrnCmp (
+    IN CHAR16   *s1,
+    IN CHAR16   *s2,
+    IN UINTN    len
+    );
+
+INTN
+StriCmp (
+    IN CHAR16   *s1,
+    IN CHAR16   *s2
+    );
+
+VOID
+StrLwr (
+    IN CHAR16   *Str
+    );
+
+VOID
+StrUpr (
+    IN CHAR16   *Str
+    );
+
+VOID
+StrCpy (
+    IN CHAR16   *Dest,
+    IN CHAR16    *Src
+    );
+
+VOID
+StrCat (
+    IN CHAR16   *Dest,
+    IN CHAR16   *Src
+    );
+
+UINTN
+StrLen (
+    IN CHAR16   *s1
+    );
+
+UINTN
+StrSize (
+    IN CHAR16   *s1
+    );
+
+CHAR16 *
+StrDuplicate (
+    IN CHAR16   *Src
+    );
+
+UINTN
+strlena (
+    IN CHAR8    *s1
+    );
+    
+UINTN
+strcmpa (
+    IN CHAR8    *s1,
+    IN CHAR8    *s2
+    );
+
+UINTN
+strncmpa (
+    IN CHAR8    *s1,
+    IN CHAR8    *s2,
+    IN UINTN    len
+    );
+
+UINTN
+xtoi (
+    CHAR16      *str
+    );
+
+UINTN
+Atoi (
+    CHAR16  *str
+    );
+
+BOOLEAN 
+MetaMatch (
+    IN CHAR16   *String,
+    IN CHAR16   *Pattern
+    );
+
+BOOLEAN 
+MetaiMatch (
+    IN CHAR16   *String,
+    IN CHAR16   *Pattern
+    );
+
+UINT64
+LShiftU64 (
+    IN UINT64   Operand,
+    IN UINTN    Count
+    );
+
+UINT64
+RShiftU64 (
+    IN UINT64   Operand,
+    IN UINTN    Count
+    );
+
+UINT64
+MultU64x32 (
+    IN UINT64   Multiplicand,
+    IN UINTN    Multiplier
+    );
+
+UINT64
+DivU64x32 (
+    IN UINT64   Dividend,
+    IN UINTN    Divisor,
+    OUT UINTN   *Remainder OPTIONAL
+    );
+
+VOID
+InitializeLock (
+    IN OUT FLOCK    *Lock,
+    IN EFI_TPL  Priority
+    );
+
+VOID
+AcquireLock (
+    IN FLOCK    *Lock
+    );
+
+VOID
+ReleaseLock (
+    IN FLOCK    *Lock
+    );
+
+
+INTN
+CompareGuid(
+    IN EFI_GUID     *Guid1,
+    IN EFI_GUID     *Guid2
+    );
+
+VOID *
+AllocatePool (
+    IN UINTN     Size
+    );
+
+VOID *
+AllocateZeroPool (
+    IN UINTN     Size
+    );
+
+VOID *
+ReallocatePool (
+    IN VOID                 *OldPool,
+    IN UINTN                OldSize,
+    IN UINTN                NewSize
+    );
+
+VOID
+FreePool (
+    IN VOID     *p
+    );
+
+
+VOID
+Output (
+    IN CHAR16   *Str
+    );
+
+VOID
+Input (
+    IN CHAR16   *Prompt OPTIONAL,
+    OUT CHAR16  *InStr,
+    IN UINTN    StrLen
+    );
+
+VOID
+IInput (
+    IN SIMPLE_TEXT_OUTPUT_INTERFACE     *ConOut,
+    IN SIMPLE_INPUT_INTERFACE           *ConIn,
+    IN CHAR16                           *Prompt OPTIONAL,
+    OUT CHAR16                          *InStr,
+    IN UINTN                            StrLen
+    );
+
+UINTN
+Print (
+    IN CHAR16   *fmt,
+    ...
+    );
+
+UINTN
+SPrint (
+    OUT CHAR16  *Str,
+    IN UINTN    StrSize,
+    IN CHAR16   *fmt,
+    ...
+    );
+
+CHAR16 *
+PoolPrint (
+    IN CHAR16           *fmt,
+    ...
+    );
+
+typedef struct {
+    CHAR16      *str;
+    UINTN       len;
+    UINTN       maxlen;
+} POOL_PRINT;
+
+CHAR16 *
+CatPrint (
+    IN OUT POOL_PRINT   *Str,
+    IN CHAR16           *fmt,
+    ...
+    );
+
+UINTN
+PrintAt (
+    IN UINTN    Column,
+    IN UINTN    Row,
+    IN CHAR16   *fmt,
+    ...
+    );
+
+UINTN
+IPrint (
+    IN SIMPLE_TEXT_OUTPUT_INTERFACE    *Out,
+    IN CHAR16                          *fmt,
+    ...
+    );
+
+UINTN
+IPrintAt (
+    IN SIMPLE_TEXT_OUTPUT_INTERFACE     *Out,
+    IN UINTN                            Column,
+    IN UINTN                            Row,
+    IN CHAR16                           *fmt,
+    ...
+    );
+
+UINTN
+APrint (
+    IN CHAR8    *fmt,
+    ...
+    );
+
+VOID
+ValueToHex (
+    IN CHAR16   *Buffer,
+    IN UINT64   v
+    );
+
+VOID
+ValueToString (
+    IN CHAR16   *Buffer,
+    IN BOOLEAN  Comma,
+    IN INT64    v
+    );
+
+VOID
+TimeToString (
+    OUT CHAR16      *Buffer,
+    IN EFI_TIME     *Time
+    );
+
+VOID
+GuidToString (
+    OUT CHAR16      *Buffer,
+    IN EFI_GUID     *Guid
+    );
+
+VOID
+StatusToString (
+    OUT CHAR16      *Buffer,
+    EFI_STATUS      Status
+    );
+
+VOID
+DumpHex (
+    IN UINTN        Indent,
+    IN UINTN        Offset,
+    IN UINTN        DataSize,
+    IN VOID         *UserData
+    );
+
+BOOLEAN
+GrowBuffer(
+    IN OUT EFI_STATUS   *Status,
+    IN OUT VOID         **Buffer,
+    IN UINTN            BufferSize
+    );
+
+EFI_MEMORY_DESCRIPTOR *
+LibMemoryMap (
+    OUT UINTN               *NoEntries,
+    OUT UINTN               *MapKey,
+    OUT UINTN               *DescriptorSize,
+    OUT UINT32              *DescriptorVersion
+    );
+
+VOID *
+LibGetVariable (
+    IN CHAR16               *Name,
+    IN EFI_GUID             *VendorGuid
+    );
+
+VOID *
+LibGetVariableAndSize (
+    IN CHAR16               *Name,
+    IN EFI_GUID             *VendorGuid,
+    OUT UINTN               *VarSize
+    );
+
+EFI_STATUS
+LibDeleteVariable (
+    IN CHAR16   *VarName,
+    IN EFI_GUID *VarGuid
+    );
+
+EFI_STATUS
+LibInsertToTailOfBootOrder (
+    IN  UINT16  BootOption,
+    IN  BOOLEAN OnlyInsertIfEmpty
+    );
+
+EFI_STATUS
+LibLocateProtocol (
+    IN  EFI_GUID    *ProtocolGuid,
+    OUT VOID        **Interface
+    );
+
+EFI_STATUS
+LibLocateHandle (
+    IN EFI_LOCATE_SEARCH_TYPE   SearchType,
+    IN EFI_GUID                 *Protocol OPTIONAL,
+    IN VOID                     *SearchKey OPTIONAL,
+    IN OUT UINTN                *NoHandles,
+    OUT EFI_HANDLE              **Buffer
+    );
+
+EFI_STATUS
+LibLocateHandleByDiskSignature (
+    IN UINT8                        MBRType,
+    IN UINT8                        SignatureType,
+    IN VOID                         *Signature,
+    IN OUT UINTN                    *NoHandles,
+    OUT EFI_HANDLE                  **Buffer
+    );
+
+EFI_STATUS
+LibInstallProtocolInterfaces (
+    IN OUT EFI_HANDLE       *Handle,
+    ...
+    );
+
+VOID
+LibUninstallProtocolInterfaces (
+    IN EFI_HANDLE           Handle,
+    ...
+    );
+
+EFI_STATUS
+LibReinstallProtocolInterfaces (
+    IN OUT EFI_HANDLE           *Handle,
+    ...
+    );
+
+EFI_EVENT
+LibCreateProtocolNotifyEvent (
+    IN EFI_GUID             *ProtocolGuid,
+    IN EFI_TPL              NotifyTpl,
+    IN EFI_EVENT_NOTIFY     NotifyFunction,
+    IN VOID                 *NotifyContext,
+    OUT VOID                *Registration
+    );
+
+EFI_STATUS
+WaitForSingleEvent (
+    IN EFI_EVENT        Event,
+    IN UINT64           Timeout OPTIONAL
+    );
+
+VOID
+WaitForEventWithTimeout (
+    IN  EFI_EVENT       Event,
+    IN  UINTN           Timeout,
+    IN  UINTN           Row,
+    IN  UINTN           Column,
+    IN  CHAR16          *String,
+    IN  EFI_INPUT_KEY   TimeoutKey,
+    OUT EFI_INPUT_KEY   *Key
+    );
+
+EFI_FILE_HANDLE
+LibOpenRoot (
+    IN EFI_HANDLE           DeviceHandle
+    );
+
+EFI_FILE_INFO *
+LibFileInfo (
+    IN EFI_FILE_HANDLE      FHand
+    );
+
+EFI_FILE_SYSTEM_INFO *
+LibFileSystemInfo (
+    IN EFI_FILE_HANDLE      FHand
+    );
+
+EFI_FILE_SYSTEM_VOLUME_LABEL_INFO *
+LibFileSystemVolumeLabelInfo (
+    IN EFI_FILE_HANDLE      FHand
+    );
+
+BOOLEAN
+ValidMBR(
+    IN  MASTER_BOOT_RECORD  *Mbr,
+    IN  EFI_BLOCK_IO        *BlkIo
+    );
+
+BOOLEAN
+LibMatchDevicePaths (
+    IN  EFI_DEVICE_PATH *Multi,
+    IN  EFI_DEVICE_PATH *Single
+    );
+
+EFI_DEVICE_PATH *
+LibDuplicateDevicePathInstance (
+    IN EFI_DEVICE_PATH  *DevPath
+    );
+
+EFI_DEVICE_PATH *
+DevicePathFromHandle (
+    IN EFI_HANDLE           Handle
+    );
+
+EFI_DEVICE_PATH *
+DevicePathInstance (
+    IN OUT EFI_DEVICE_PATH  **DevicePath,
+    OUT UINTN               *Size
+    );
+
+UINTN
+DevicePathInstanceCount (
+    IN EFI_DEVICE_PATH      *DevicePath
+    );
+
+EFI_DEVICE_PATH *
+AppendDevicePath (
+    IN EFI_DEVICE_PATH      *Src1,
+    IN EFI_DEVICE_PATH      *Src2
+    );
+
+EFI_DEVICE_PATH *
+AppendDevicePathNode (
+    IN EFI_DEVICE_PATH      *Src1,
+    IN EFI_DEVICE_PATH      *Src2
+    );
+
+EFI_DEVICE_PATH*
+AppendDevicePathInstance (
+    IN EFI_DEVICE_PATH  *Src,
+    IN EFI_DEVICE_PATH  *Instance
+    );
+
+EFI_DEVICE_PATH *
+FileDevicePath (
+    IN EFI_HANDLE           Device  OPTIONAL,
+    IN CHAR16               *FileName
+    );
+
+UINTN
+DevicePathSize (
+    IN EFI_DEVICE_PATH      *DevPath
+    );
+
+EFI_DEVICE_PATH *
+DuplicateDevicePath (
+    IN EFI_DEVICE_PATH      *DevPath
+    );
+
+EFI_DEVICE_PATH *
+UnpackDevicePath (
+    IN EFI_DEVICE_PATH      *DevPath
+    );
+
+EFI_STATUS
+LibDevicePathToInterface (
+    IN EFI_GUID             *Protocol,
+    IN EFI_DEVICE_PATH      *FilePath,
+    OUT VOID                **Interface
+    );
+
+CHAR16 *
+DevicePathToStr (
+    EFI_DEVICE_PATH         *DevPath
+    );
+
+//
+// BugBug: I need my own include files
+//
+typedef struct {
+    UINT8   Register;
+    UINT8   Function;
+    UINT8   Device;
+    UINT8   Bus;
+    UINT32  Reserved;
+} EFI_ADDRESS;
+
+typedef union {
+    UINT64          Address;
+    EFI_ADDRESS     EfiAddress;
+} EFI_PCI_ADDRESS_UNION;
+
+
+EFI_STATUS
+PciFindDeviceClass (
+    IN  OUT EFI_PCI_ADDRESS_UNION   *Address,
+    IN      UINT8                   BaseClass,
+    IN      UINT8                   SubClass
+    );
+
+EFI_STATUS
+PciFindDevice (
+    IN  OUT EFI_PCI_ADDRESS_UNION   *DeviceAddress,
+    IN      UINT16                  VendorId,
+    IN      UINT16                  DeviceId,
+    IN OUT  PCI_TYPE00              *Pci
+    );
+
+//
+// SIMPLE_READ_FILE object used to access files
+//
+
+typedef VOID        *SIMPLE_READ_FILE;
+
+EFI_STATUS
+OpenSimpleReadFile (
+    IN BOOLEAN                  BootPolicy,
+    IN VOID                     *SourceBuffer   OPTIONAL,
+    IN UINTN                    SourceSize,
+    IN OUT EFI_DEVICE_PATH      **FilePath,
+    OUT EFI_HANDLE              *DeviceHandle,    
+    OUT SIMPLE_READ_FILE        *SimpleReadHandle
+    );
+
+EFI_STATUS
+ReadSimpleReadFile (
+    IN SIMPLE_READ_FILE     SimpleReadHandle,
+    IN UINTN                Offset,
+    IN OUT UINTN            *ReadSize,
+    OUT VOID                *Buffer
+    );
+
+
+VOID
+CloseSimpleReadFile (
+    IN SIMPLE_READ_FILE     SimpleReadHandle
+    );
+
+VOID
+InitializeGuid (
+    VOID
+    );
+
+UINT8
+DecimaltoBCD(
+    IN  UINT8 DecValue
+    );
+
+UINT8
+BCDtoDecimal(
+    IN  UINT8 BcdValue
+    );
+
+EFI_STATUS
+LibGetSystemConfigurationTable(
+    IN EFI_GUID *TableGuid,
+    IN OUT VOID **Table
+    );
+
+BOOLEAN
+LibIsValidTextGraphics (
+    IN  CHAR16  Graphic,   
+    OUT CHAR8   *PcAnsi,    OPTIONAL
+    OUT CHAR8   *Ascii      OPTIONAL
+    );
+
+BOOLEAN
+IsValidAscii (
+    IN  CHAR16  Ascii
+    );
+
+BOOLEAN
+IsValidEfiCntlChar (
+    IN  CHAR16  c
+    );
+
+CHAR16 *
+LibGetUiString (
+    IN  EFI_HANDLE      Handle,
+    IN  UI_STRING_TYPE  StringType,
+    IN  ISO_639_2       *LangCode,
+    IN  BOOLEAN         ReturnDevicePathStrOnMismatch
+    );
+
+CHAR8*
+LibGetSmbiosString (
+    IN  SMBIOS_STRUCTURE_POINTER    *Smbios,
+    IN  UINT16                      StringNumber
+    );
+
+EFI_STATUS
+LibGetSmbiosSystemGuidAndSerialNumber (
+    IN  EFI_GUID    *SystemGuid,
+    OUT CHAR8       **SystemSerialNumber
+    );
+
+
+EFI_STATUS
+InitializeGlobalIoDevice (
+        IN  EFI_DEVICE_PATH             *DevicePath,
+        IN  EFI_GUID                    *Protocol,
+        IN  CHAR8                       *ErrorStr,
+        OUT EFI_DEVICE_IO_INTERFACE     **GlobalIoFncs 
+        );
+
+UINT32 
+ReadPort (
+        IN  EFI_DEVICE_IO_INTERFACE     *GlobalIoFncs, 
+        IN  EFI_IO_WIDTH                Width,
+        IN  UINTN                       Port
+        );
+
+UINT32 
+WritePort (
+        IN  EFI_DEVICE_IO_INTERFACE     *GlobalIoFncs, 
+        IN  EFI_IO_WIDTH                Width,
+        IN  UINTN                       Port,
+        IN  UINTN                       Data
+        );
+
+UINT32 
+ReadPciConfig (
+        IN  EFI_DEVICE_IO_INTERFACE     *GlobalIoFncs, 
+        IN  EFI_IO_WIDTH                Width,
+        IN  UINTN                       Port
+        );
+
+UINT32 
+WritePciConfig (
+        IN  EFI_DEVICE_IO_INTERFACE     *GlobalIoFncs, 
+        IN  EFI_IO_WIDTH                Width,
+        IN  UINTN                       Port,
+        IN  UINTN                       Data
+        );
+
+extern EFI_DEVICE_IO_INTERFACE  *GlobalIoFncs;
+
+#define outp(_Port, _DataByte)  (UINT8)WritePort(GlobalIoFncs,  IO_UINT8,  (UINTN)_Port, (UINTN)_DataByte)
+#define inp(_Port)              (UINT8)ReadPort(GlobalIoFncs,   IO_UINT8,  (UINTN)_Port)
+#define outpw(_Port, _DataByte) (UINT16)WritePort(GlobalIoFncs, IO_UINT16, (UINTN)_Port, (UINTN)_DataByte)
+#define inpw(_Port)             (UINT16)ReadPort(GlobalIoFncs,  IO_UINT16, (UINTN)_Port)
+#define outpd(_Port, _DataByte) (UINT32)WritePort(GlobalIoFncs, IO_UINT32, (UINTN)_Port, (UINTN)_DataByte)
+#define inpd(_Port)             (UINT32)ReadPort(GlobalIoFncs,  IO_UINT32, (UINTN)_Port)
+
+#define writepci8(_Addr, _DataByte)  (UINT8)WritePciConfig(GlobalIoFncs,  IO_UINT8,  (UINTN)_Addr, (UINTN)_DataByte)
+#define readpci8(_Addr)              (UINT8)ReadPciConfig(GlobalIoFncs,   IO_UINT8,  (UINTN)_Addr)
+#define writepci16(_Addr, _DataByte) (UINT16)WritePciConfig(GlobalIoFncs, IO_UINT16, (UINTN)_Addr, (UINTN)_DataByte)
+#define readpci16(_Addr)             (UINT16)ReadPciConfig(GlobalIoFncs,  IO_UINT16, (UINTN)_Addr)
+#define writepci32(_Addr, _DataByte) (UINT32)WritePciConfig(GlobalIoFncs, IO_UINT32, (UINTN)_Addr, (UINTN)_DataByte)
+#define readpci32(_Addr)             (UINT32)ReadPciConfig(GlobalIoFncs,  IO_UINT32, (UINTN)_Addr)
+
+#define Pause()             WaitForSingleEvent (ST->ConIn->WaitForKey, 0)
+#define Port80(_PostCode)   GlobalIoFncs->Io.Write (GlobalIoFncs, IO_UINT16, (UINT64)0x80, 1, &(_PostCode))
+
+#endif
diff --git a/linux-x86_64/gnu-efi/include/efi/efilink.h b/linux-x86_64/gnu-efi/include/efi/efilink.h
new file mode 100644
index 0000000..b2ff4fa
--- /dev/null
+++ b/linux-x86_64/gnu-efi/include/efi/efilink.h
@@ -0,0 +1,177 @@
+#ifndef _EFI_LINK_H
+#define _EFI_LINK_H
+
+/*++
+
+Copyright (c) 1998  Intel Corporation
+
+Module Name:
+
+    link.h (renamed efilink.h to avoid conflicts)
+
+Abstract:
+
+    EFI link list macro's
+
+
+
+Revision History
+
+--*/
+
+#ifndef EFI_NT_EMUL
+
+//
+// List entry - doubly linked list
+//
+
+typedef struct _LIST_ENTRY {
+    struct _LIST_ENTRY  *Flink;
+    struct _LIST_ENTRY  *Blink;
+} LIST_ENTRY;
+
+#endif 
+
+
+//
+//  VOID
+//  InitializeListHead(
+//      LIST_ENTRY *ListHead
+//      );
+//
+
+#define InitializeListHead(ListHead) \
+    (ListHead)->Flink = ListHead;    \
+    (ListHead)->Blink = ListHead;
+
+//
+//  BOOLEAN
+//  IsListEmpty(
+//      PLIST_ENTRY ListHead
+//      );
+//
+
+#define IsListEmpty(ListHead) \
+    ((ListHead)->Flink == (ListHead))
+
+//
+//  VOID
+//  RemoveEntryList(
+//      PLIST_ENTRY Entry
+//      );
+//
+
+#define _RemoveEntryList(Entry) {       \
+        LIST_ENTRY *_Blink, *_Flink;    \
+        _Flink = (Entry)->Flink;        \
+        _Blink = (Entry)->Blink;        \
+        _Blink->Flink = _Flink;         \
+        _Flink->Blink = _Blink;         \
+        }
+
+#if EFI_DEBUG
+    #define RemoveEntryList(Entry)                      \
+        _RemoveEntryList(Entry);                        \
+        (Entry)->Flink = (LIST_ENTRY *) BAD_POINTER;    \
+        (Entry)->Blink = (LIST_ENTRY *) BAD_POINTER; 
+#else
+    #define RemoveEntryList(Entry)      \
+        _RemoveEntryList(Entry);
+#endif
+
+//
+//  VOID
+//  InsertTailList(
+//      PLIST_ENTRY ListHead,
+//      PLIST_ENTRY Entry
+//      );
+//
+
+#define InsertTailList(ListHead,Entry) {\
+    LIST_ENTRY *_ListHead, *_Blink;     \
+    _ListHead = (ListHead);             \
+    _Blink = _ListHead->Blink;          \
+    (Entry)->Flink = _ListHead;         \
+    (Entry)->Blink = _Blink;            \
+    _Blink->Flink = (Entry);            \
+    _ListHead->Blink = (Entry);         \
+    }
+
+//
+//  VOID
+//  InsertHeadList(
+//      PLIST_ENTRY ListHead,
+//      PLIST_ENTRY Entry
+//      );
+//
+
+#define InsertHeadList(ListHead,Entry) {\
+    LIST_ENTRY *_ListHead, *_Flink;     \
+    _ListHead = (ListHead);             \
+    _Flink = _ListHead->Flink;          \
+    (Entry)->Flink = _Flink;            \
+    (Entry)->Blink = _ListHead;         \
+    _Flink->Blink = (Entry);            \
+    _ListHead->Flink = (Entry);         \
+    }
+
+//  VOID
+//  SwapListEntries(
+//      PLIST_ENTRY Entry1,
+//      PLIST_ENTRY Entry2
+//      );
+//
+// Put Entry2 before Entry1
+//
+#define SwapListEntries(Entry1,Entry2) {\
+    LIST_ENTRY *Entry1Flink, *Entry1Blink;     \
+    LIST_ENTRY *Entry2Flink, *Entry2Blink;     \
+    Entry2Flink = (Entry2)->Flink;             \
+    Entry2Blink = (Entry2)->Blink;             \
+    Entry1Flink = (Entry1)->Flink;             \
+    Entry1Blink = (Entry1)->Blink;             \
+    Entry2Blink->Flink = Entry2Flink;       \
+    Entry2Flink->Blink = Entry2Blink;        \
+    (Entry2)->Flink = Entry1;               \
+    (Entry2)->Blink = Entry1Blink;          \
+    Entry1Blink->Flink = (Entry2);            \
+    (Entry1)->Blink = (Entry2);             \
+    }
+
+//
+//  EFI_FIELD_OFFSET - returns the byte offset to a field within a structure
+//
+
+#define EFI_FIELD_OFFSET(TYPE,Field) ((UINTN)(&(((TYPE *) 0)->Field)))
+
+//
+//  CONTAINING_RECORD - returns a pointer to the structure
+//      from one of it's elements.
+//
+
+#define _CR(Record, TYPE, Field)  \
+    ((TYPE *) ( (CHAR8 *)(Record) - (CHAR8 *) &(((TYPE *) 0)->Field)))
+
+#if EFI_DEBUG
+    #define CR(Record, TYPE, Field, Sig)     \
+        _CR(Record, TYPE, Field)->Signature != Sig ?        \
+            (TYPE *) ASSERT_STRUCT(_CR(Record, TYPE, Field), Record) : \
+            _CR(Record, TYPE, Field)
+#else
+    #define CR(Record, TYPE, Field, Signature)   \
+        _CR(Record, TYPE, Field)                           
+#endif
+
+
+//
+// A lock structure
+//
+
+typedef struct _FLOCK {
+    EFI_TPL     Tpl;
+    EFI_TPL     OwnerTpl;
+    UINTN       Lock;
+} FLOCK;
+
+#endif
+
diff --git a/linux-x86_64/gnu-efi/include/efi/efinet.h b/linux-x86_64/gnu-efi/include/efi/efinet.h
new file mode 100644
index 0000000..b2e5aa8
--- /dev/null
+++ b/linux-x86_64/gnu-efi/include/efi/efinet.h
@@ -0,0 +1,340 @@
+#ifndef _EFINET_H
+#define _EFINET_H
+
+
+/*++
+Copyright (c) 1999  Intel Corporation
+
+Module Name:
+    efinet.h
+
+Abstract:
+    EFI Simple Network protocol
+
+Revision History
+--*/
+
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//      Simple Network Protocol
+//
+
+#define EFI_SIMPLE_NETWORK_PROTOCOL \
+    { 0xA19832B9, 0xAC25, 0x11D3, {0x9A, 0x2D, 0x00, 0x90, 0x27, 0x3F, 0xC1, 0x4D} }
+
+
+INTERFACE_DECL(_EFI_SIMPLE_NETWORK);
+
+///////////////////////////////////////////////////////////////////////////////
+//
+
+typedef struct {
+    //
+    // Total number of frames received.  Includes frames with errors and
+    // dropped frames.
+    //
+    UINT64  RxTotalFrames;
+
+    //
+    // Number of valid frames received and copied into receive buffers.
+    //
+    UINT64  RxGoodFrames;
+
+    //
+    // Number of frames below the minimum length for the media.
+    // This would be <64 for ethernet.
+    //
+    UINT64  RxUndersizeFrames;
+
+    //
+    // Number of frames longer than the maxminum length for the
+    // media.  This would be >1500 for ethernet.
+    //
+    UINT64  RxOversizeFrames;
+
+    //
+    // Valid frames that were dropped because receive buffers were full.
+    //
+    UINT64  RxDroppedFrames;
+
+    //
+    // Number of valid unicast frames received and not dropped.
+    //
+    UINT64  RxUnicastFrames;
+
+    //
+    // Number of valid broadcast frames received and not dropped.
+    //
+    UINT64  RxBroadcastFrames;
+
+    //
+    // Number of valid mutlicast frames received and not dropped.
+    //
+    UINT64  RxMulticastFrames;
+
+    //
+    // Number of frames w/ CRC or alignment errors.
+    //
+    UINT64  RxCrcErrorFrames;
+
+    //
+    // Total number of bytes received.  Includes frames with errors
+    // and dropped frames.
+    //
+    UINT64  RxTotalBytes;
+
+    //
+    // Transmit statistics.
+    //
+    UINT64  TxTotalFrames;
+    UINT64  TxGoodFrames;
+    UINT64  TxUndersizeFrames;
+    UINT64  TxOversizeFrames;
+    UINT64  TxDroppedFrames;
+    UINT64  TxUnicastFrames;
+    UINT64  TxBroadcastFrames;
+    UINT64  TxMulticastFrames;
+    UINT64  TxCrcErrorFrames;
+    UINT64  TxTotalBytes;
+
+    //
+    // Number of collisions detection on this subnet.
+    //
+    UINT64  Collisions;
+
+    //
+    // Number of frames destined for unsupported protocol.
+    //
+    UINT64  UnsupportedProtocol;
+
+} EFI_NETWORK_STATISTICS;
+
+///////////////////////////////////////////////////////////////////////////////
+//
+
+typedef enum {
+    EfiSimpleNetworkStopped,
+    EfiSimpleNetworkStarted,
+    EfiSimpleNetworkInitialized,
+    EfiSimpleNetworkMaxState
+} EFI_SIMPLE_NETWORK_STATE;
+
+///////////////////////////////////////////////////////////////////////////////
+//
+
+#define EFI_SIMPLE_NETWORK_RECEIVE_UNICAST               0x01
+#define EFI_SIMPLE_NETWORK_RECEIVE_MULTICAST             0x02
+#define EFI_SIMPLE_NETWORK_RECEIVE_BROADCAST             0x04
+#define EFI_SIMPLE_NETWORK_RECEIVE_PROMISCUOUS           0x08
+#define EFI_SIMPLE_NETWORK_RECEIVE_PROMISCUOUS_MULTICAST 0x10
+
+///////////////////////////////////////////////////////////////////////////////
+//
+
+#define EFI_SIMPLE_NETWORK_RECEIVE_INTERRUPT        0x01
+#define EFI_SIMPLE_NETWORK_TRANSMIT_INTERRUPT       0x02
+#define EFI_SIMPLE_NETWORK_COMMAND_INTERRUPT        0x04
+#define EFI_SIMPLE_NETWORK_SOFTWARE_INTERRUPT       0x08
+
+///////////////////////////////////////////////////////////////////////////////
+//
+#define MAX_MCAST_FILTER_CNT    16
+typedef struct {
+    UINT32                      State;
+    UINT32                      HwAddressSize;
+    UINT32                      MediaHeaderSize;
+    UINT32                      MaxPacketSize;
+    UINT32                      NvRamSize;
+    UINT32                      NvRamAccessSize;
+    UINT32                      ReceiveFilterMask;
+    UINT32                      ReceiveFilterSetting;
+    UINT32                      MaxMCastFilterCount;
+    UINT32                      MCastFilterCount;
+    EFI_MAC_ADDRESS             MCastFilter[MAX_MCAST_FILTER_CNT];
+    EFI_MAC_ADDRESS             CurrentAddress;
+    EFI_MAC_ADDRESS             BroadcastAddress;
+    EFI_MAC_ADDRESS             PermanentAddress;
+    UINT8                       IfType;
+    BOOLEAN                     MacAddressChangeable;
+    BOOLEAN                     MultipleTxSupported;
+    BOOLEAN                     MediaPresentSupported;
+    BOOLEAN                     MediaPresent;
+} EFI_SIMPLE_NETWORK_MODE;
+
+///////////////////////////////////////////////////////////////////////////////
+//
+
+typedef 
+EFI_STATUS 
+(EFIAPI *EFI_SIMPLE_NETWORK_START) (
+    IN struct _EFI_SIMPLE_NETWORK  *This
+);
+
+///////////////////////////////////////////////////////////////////////////////
+//
+
+typedef 
+EFI_STATUS 
+(EFIAPI *EFI_SIMPLE_NETWORK_STOP) (
+    IN struct _EFI_SIMPLE_NETWORK  *This
+);
+
+///////////////////////////////////////////////////////////////////////////////
+//
+
+typedef 
+EFI_STATUS 
+(EFIAPI *EFI_SIMPLE_NETWORK_INITIALIZE) (
+    IN struct _EFI_SIMPLE_NETWORK  *This,
+    IN UINTN                       ExtraRxBufferSize  OPTIONAL,
+    IN UINTN                       ExtraTxBufferSize  OPTIONAL
+);
+
+///////////////////////////////////////////////////////////////////////////////
+//
+
+typedef 
+EFI_STATUS 
+(EFIAPI *EFI_SIMPLE_NETWORK_RESET) (
+    IN struct _EFI_SIMPLE_NETWORK   *This,
+    IN BOOLEAN                      ExtendedVerification
+);
+
+///////////////////////////////////////////////////////////////////////////////
+//
+
+typedef 
+EFI_STATUS 
+(EFIAPI *EFI_SIMPLE_NETWORK_SHUTDOWN) (
+    IN struct _EFI_SIMPLE_NETWORK  *This
+);
+
+///////////////////////////////////////////////////////////////////////////////
+//
+
+typedef 
+EFI_STATUS 
+(EFIAPI *EFI_SIMPLE_NETWORK_RECEIVE_FILTERS) (
+    IN struct _EFI_SIMPLE_NETWORK   *This,
+    IN UINT32                       Enable,
+    IN UINT32                       Disable,
+    IN BOOLEAN                      ResetMCastFilter,
+    IN UINTN                        MCastFilterCnt     OPTIONAL,
+    IN EFI_MAC_ADDRESS              *MCastFilter       OPTIONAL
+);
+
+///////////////////////////////////////////////////////////////////////////////
+//
+
+typedef 
+EFI_STATUS 
+(EFIAPI *EFI_SIMPLE_NETWORK_STATION_ADDRESS) (
+    IN struct _EFI_SIMPLE_NETWORK   *This,
+    IN BOOLEAN                      Reset,
+    IN EFI_MAC_ADDRESS              *New      OPTIONAL
+);
+
+///////////////////////////////////////////////////////////////////////////////
+//
+
+typedef 
+EFI_STATUS 
+(EFIAPI *EFI_SIMPLE_NETWORK_STATISTICS) (
+    IN struct _EFI_SIMPLE_NETWORK   *This,
+    IN BOOLEAN                      Reset,
+    IN OUT UINTN                    *StatisticsSize   OPTIONAL,
+    OUT EFI_NETWORK_STATISTICS      *StatisticsTable  OPTIONAL
+);
+
+///////////////////////////////////////////////////////////////////////////////
+//
+
+typedef 
+EFI_STATUS 
+(EFIAPI *EFI_SIMPLE_NETWORK_MCAST_IP_TO_MAC) (
+    IN struct _EFI_SIMPLE_NETWORK   *This,
+    IN BOOLEAN                      IPv6,
+    IN EFI_IP_ADDRESS               *IP,
+    OUT EFI_MAC_ADDRESS             *MAC
+);
+
+///////////////////////////////////////////////////////////////////////////////
+//
+
+typedef 
+EFI_STATUS 
+(EFIAPI *EFI_SIMPLE_NETWORK_NVDATA) (
+    IN struct _EFI_SIMPLE_NETWORK  *This,
+    IN BOOLEAN                     ReadWrite,
+    IN UINTN                       Offset,
+    IN UINTN                       BufferSize,
+    IN OUT VOID                    *Buffer
+);
+
+///////////////////////////////////////////////////////////////////////////////
+//
+
+typedef 
+EFI_STATUS 
+(EFIAPI *EFI_SIMPLE_NETWORK_GET_STATUS) (
+    IN struct _EFI_SIMPLE_NETWORK  *This,
+    OUT UINT32                     *InterruptStatus  OPTIONAL,
+    OUT VOID                       **TxBuf           OPTIONAL
+);
+
+///////////////////////////////////////////////////////////////////////////////
+//
+
+typedef 
+EFI_STATUS 
+(EFIAPI *EFI_SIMPLE_NETWORK_TRANSMIT) (
+    IN struct _EFI_SIMPLE_NETWORK   *This,
+    IN UINTN                        HeaderSize,
+    IN UINTN                        BufferSize,
+    IN VOID                         *Buffer,
+    IN EFI_MAC_ADDRESS              *SrcAddr     OPTIONAL,
+    IN EFI_MAC_ADDRESS              *DestAddr    OPTIONAL,
+    IN UINT16                       *Protocol    OPTIONAL
+);
+
+///////////////////////////////////////////////////////////////////////////////
+//
+
+typedef 
+EFI_STATUS 
+(EFIAPI *EFI_SIMPLE_NETWORK_RECEIVE) (
+    IN struct _EFI_SIMPLE_NETWORK   *This,
+    OUT UINTN                       *HeaderSize  OPTIONAL,
+    IN OUT UINTN                    *BufferSize,
+    OUT VOID                        *Buffer,
+    OUT EFI_MAC_ADDRESS             *SrcAddr     OPTIONAL,
+    OUT EFI_MAC_ADDRESS             *DestAddr    OPTIONAL,
+    OUT UINT16                      *Protocol    OPTIONAL
+);
+
+///////////////////////////////////////////////////////////////////////////////
+//
+
+#define EFI_SIMPLE_NETWORK_INTERFACE_REVISION   0x00010000
+
+typedef struct _EFI_SIMPLE_NETWORK {
+    UINT64                              Revision;
+    EFI_SIMPLE_NETWORK_START            Start;
+    EFI_SIMPLE_NETWORK_STOP             Stop;
+    EFI_SIMPLE_NETWORK_INITIALIZE       Initialize;
+    EFI_SIMPLE_NETWORK_RESET            Reset;
+    EFI_SIMPLE_NETWORK_SHUTDOWN         Shutdown;
+    EFI_SIMPLE_NETWORK_RECEIVE_FILTERS  ReceiveFilters;
+    EFI_SIMPLE_NETWORK_STATION_ADDRESS  StationAddress;
+    EFI_SIMPLE_NETWORK_STATISTICS       Statistics;
+    EFI_SIMPLE_NETWORK_MCAST_IP_TO_MAC  MCastIpToMac;
+    EFI_SIMPLE_NETWORK_NVDATA           NvData;
+    EFI_SIMPLE_NETWORK_GET_STATUS       GetStatus;
+    EFI_SIMPLE_NETWORK_TRANSMIT         Transmit;
+    EFI_SIMPLE_NETWORK_RECEIVE          Receive;
+    EFI_EVENT                           WaitForPacket;
+    EFI_SIMPLE_NETWORK_MODE             *Mode;
+} EFI_SIMPLE_NETWORK;
+
+#endif /* _EFINET_H */
diff --git a/linux-x86_64/gnu-efi/include/efi/efipart.h b/linux-x86_64/gnu-efi/include/efi/efipart.h
new file mode 100644
index 0000000..d4c5573
--- /dev/null
+++ b/linux-x86_64/gnu-efi/include/efi/efipart.h
@@ -0,0 +1,61 @@
+#ifndef _EFI_PART_H
+#define _EFI_PART_H
+
+/*++
+
+Copyright (c) 1998  Intel Corporation
+
+Module Name:
+
+    efipart.h
+    
+Abstract:   
+    Info about disk partitions and Master Boot Records
+
+
+
+
+Revision History
+
+--*/
+
+//
+//
+//
+
+#define EFI_PARTITION   0xef
+#define MBR_SIZE        512
+
+#pragma pack(1)
+
+typedef struct {
+    UINT8       BootIndicator;
+    UINT8       StartHead;
+    UINT8       StartSector;
+    UINT8       StartTrack;
+    UINT8       OSIndicator;
+    UINT8       EndHead;
+    UINT8       EndSector;
+    UINT8       EndTrack;
+    UINT8       StartingLBA[4];
+    UINT8       SizeInLBA[4];
+} MBR_PARTITION_RECORD;
+
+#define EXTRACT_UINT32(D) (UINT32)(D[0] | (D[1] << 8) | (D[2] << 16) | (D[3] << 24))
+
+#define MBR_SIGNATURE           0xaa55
+#define MIN_MBR_DEVICE_SIZE     0x80000
+#define MBR_ERRATA_PAD          0x40000 // 128 MB
+
+#define MAX_MBR_PARTITIONS  4   
+typedef struct {
+    UINT8                   BootStrapCode[440];
+    UINT8                   UniqueMbrSignature[4];
+    UINT8                   Unknown[2];
+    MBR_PARTITION_RECORD    Partition[MAX_MBR_PARTITIONS];
+    UINT16                  Signature;
+} MASTER_BOOT_RECORD;
+#pragma pack()
+
+
+#endif
diff --git a/linux-x86_64/gnu-efi/include/efi/efipciio.h b/linux-x86_64/gnu-efi/include/efi/efipciio.h
new file mode 100644
index 0000000..0724f95
--- /dev/null
+++ b/linux-x86_64/gnu-efi/include/efi/efipciio.h
@@ -0,0 +1,219 @@
+#ifndef _EFI_PCI_IO_H
+#define _EFI_PCI_IO_H
+
+#define EFI_PCI_IO_PROTOCOL \
+    { 0x4cf5b200, 0x68b8, 0x4ca5, {0x9e, 0xec, 0xb2, 0x3e, 0x3f, 0x50, 0x02, 0x9a} }
+
+INTERFACE_DECL(_EFI_PCI_IO);
+
+typedef enum {
+    EfiPciIoWidthUint8,
+    EfiPciIoWidthUint16,
+    EfiPciIoWidthUint32,
+    EfiPciIoWidthUint64,
+    EfiPciIoWidthFifoUint8,
+    EfiPciIoWidthFifoUint16,
+    EfiPciIoWidthFifoUint32,
+    EfiPciIoWidthFifoUint64,
+    EfiPciIoWidthFillUint8,
+    EfiPciIoWidthFillUint16,
+    EfiPciIoWidthFillUint32,
+    EfiPciIoWidthFillUint64,
+    EfiPciIoWidthMaximum
+} EFI_PCI_IO_PROTOCOL_WIDTH;
+
+#define EFI_PCI_IO_PASS_THROUGH_BAR 0xff
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PCI_IO_PROTOCOL_POLL_IO_MEM) (
+  IN struct _EFI_PCI_IO *This,
+  IN EFI_PCI_IO_PROTOCOL_WIDTH  Width,
+  IN UINT8                      BarIndex,
+  IN UINT64                     Offset,
+  IN UINT64                     Mask,
+  IN UINT64                     Value,
+  IN UINT64                     Delay,
+  OUT UINT64                    *Result
+  );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PCI_IO_PROTOCOL_IO_MEM) (
+  IN struct _EFI_PCI_IO *This,
+  IN EFI_PCI_IO_PROTOCOL_WIDTH  Width,
+  IN UINT8                      BarIndex,
+  IN UINT64                     Offset,
+  IN UINTN                      Count,
+  IN OUT VOID                   *Buffer
+);
+
+typedef struct {
+  EFI_PCI_IO_PROTOCOL_IO_MEM    Read;
+  EFI_PCI_IO_PROTOCOL_IO_MEM    Write;
+} EFI_PCI_IO_PROTOCOL_ACCESS;
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PCI_IO_PROTOCOL_CONFIG) (
+  IN struct _EFI_PCI_IO *This,
+  IN EFI_PCI_IO_PROTOCOL_WIDTH  Width,
+  IN UINT32                     Offset,
+  IN UINTN                      Count,
+  IN OUT VOID                   *Buffer
+);
+
+typedef struct {
+  EFI_PCI_IO_PROTOCOL_CONFIG Read;
+  EFI_PCI_IO_PROTOCOL_CONFIG Write;
+} EFI_PCI_IO_PROTOCOL_CONFIG_ACCESS;
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PCI_IO_PROTOCOL_COPY_MEM) (
+  IN struct _EFI_PCI_IO *This,
+  IN EFI_PCI_IO_PROTOCOL_WIDTH  Width,
+  IN UINT8                      DestBarIndex,
+  IN UINT64                     DestOffset,
+  IN UINT8                      SrcBarIndex,
+  IN UINT64                     SrcOffset,
+  IN UINTN                      Count
+  );
+
+typedef enum {
+    EfiPciIoOperationBusMasterRead,
+    EfiPciIoOperationBusMasterWrite,
+    EfiPciIoOperationBusMasterCommonBuffer,
+    EfiPciIoOperationMaximum
+} EFI_PCI_IO_PROTOCOL_OPERATION;
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PCI_IO_PROTOCOL_MAP) (
+  IN struct _EFI_PCI_IO    *This,
+  IN EFI_PCI_IO_PROTOCOL_OPERATION Operation,
+  IN VOID                          *HostAddress,
+  IN OUT UINTN                     *NumberOfBytes,
+  OUT EFI_PHYSICAL_ADDRESS         *DeviceAddress,
+  OUT VOID                         **Mapping
+  );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PCI_IO_PROTOCOL_UNMAP) (
+  IN struct _EFI_PCI_IO *This,
+  IN VOID                       *Mapping
+);
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PCI_IO_PROTOCOL_ALLOCATE_BUFFER) (
+  IN struct _EFI_PCI_IO *This,
+  IN EFI_ALLOCATE_TYPE          Type,
+  IN EFI_MEMORY_TYPE            MemoryType,
+  IN UINTN                      Pages,
+  OUT VOID                      **HostAddress,
+  IN UINT64                     Attributes
+  );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PCI_IO_PROTOCOL_FREE_BUFFER) (
+  IN struct _EFI_PCI_IO *This,
+  IN UINTN                      Pages,
+  IN VOID                       *HostAddress
+  );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PCI_IO_PROTOCOL_FLUSH) (
+  IN struct _EFI_PCI_IO *This
+  );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PCI_IO_PROTOCOL_GET_LOCATION) (
+  IN struct _EFI_PCI_IO *This,
+  OUT UINTN                     *SegmentNumber,
+  OUT UINTN                     *BusNumber,
+  OUT UINTN                     *DeviceNumber,
+  OUT UINTN                     *FunctionNumber
+  );
+
+#define EFI_PCI_IO_ATTRIBUTE_ISA_IO               0x0002
+#define EFI_PCI_IO_ATTRIBUTE_VGA_PALETTE_IO       0x0004
+#define EFI_PCI_IO_ATTRIBUTE_VGA_MEMORY           0x0008
+#define EFI_PCI_IO_ATTRIBUTE_VGA_IO               0x0010
+#define EFI_PCI_IO_ATTRIBUTE_IDE_PRIMARY_IO       0x0020
+#define EFI_PCI_IO_ATTRIBUTE_IDE_SECONDARY_IO     0x0040
+#define EFI_PCI_IO_ATTRIBUTE_MEMORY_WRITE_COMBINE 0x0080
+#define EFI_PCI_IO_ATTRIBUTE_IO                   0x0100
+#define EFI_PCI_IO_ATTRIBUTE_MEMORY               0x0200
+#define EFI_PCI_IO_ATTRIBUTE_BUS_MASTER           0x0400
+#define EFI_PCI_IO_ATTRIBUTE_MEMORY_CACHED        0x0800
+#define EFI_PCI_IO_ATTRIBUTE_MEMORY_DISABLE       0x1000
+#define EFI_PCI_IO_ATTRIBUTE_EMBEDDED_DEVICE      0x2000
+#define EFI_PCI_IO_ATTRIBUTE_EMBEDDED_ROM         0x4000
+#define EFI_PCI_IO_ATTRIBUTE_DUAL_ADDRESS_CYCLE   0x8000
+#define EFI_PCI_IO_ATTRIBUTE_ISA_IO_16            0x10000
+#define EFI_PCI_IO_ATTRIBUTE_VGA_PALETTE_IO_16    0x20000
+#define EFI_PCI_IO_ATTRIBUTE_VGA_IO_16            0x40000
+
+typedef enum {
+    EfiPciIoAttributeOperationGet,
+    EfiPciIoAttributeOperationSet,
+    EfiPciIoAttributeOperationEnable,
+    EfiPciIoAttributeOperationDisable,
+    EfiPciIoAttributeOperationSupported,
+    EfiPciIoAttributeOperationMaximum
+} EFI_PCI_IO_PROTOCOL_ATTRIBUTE_OPERATION;
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PCI_IO_PROTOCOL_ATTRIBUTES) (
+  IN struct _EFI_PCI_IO             *This,
+  IN EFI_PCI_IO_PROTOCOL_ATTRIBUTE_OPERATION Operation,
+  IN UINT64                                  Attributes,
+  OUT UINT64                                 *Result OPTIONAL
+  );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PCI_IO_PROTOCOL_GET_BAR_ATTRIBUTES) (
+  IN struct _EFI_PCI_IO *This,
+  IN UINT8                      BarIndex,
+  OUT UINT64                    *Supports OPTIONAL,
+  OUT VOID                      **Resources OPTIONAL
+  );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PCI_IO_PROTOCOL_SET_BAR_ATTRIBUTES) (
+  IN struct _EFI_PCI_IO *This,
+  IN UINT64                     Attributes,
+  IN UINT8                      BarIndex,
+  IN OUT UINT64                 *Offset,
+  IN OUT UINT64                 *Length
+  );
+
+typedef struct _EFI_PCI_IO {
+  EFI_PCI_IO_PROTOCOL_POLL_IO_MEM        PollMem;
+  EFI_PCI_IO_PROTOCOL_POLL_IO_MEM        PollIo;
+  EFI_PCI_IO_PROTOCOL_ACCESS             Mem;
+  EFI_PCI_IO_PROTOCOL_ACCESS             Io;
+  EFI_PCI_IO_PROTOCOL_CONFIG_ACCESS      Pci;
+  EFI_PCI_IO_PROTOCOL_COPY_MEM           CopyMem;
+  EFI_PCI_IO_PROTOCOL_MAP                Map;
+  EFI_PCI_IO_PROTOCOL_UNMAP              Unmap;
+  EFI_PCI_IO_PROTOCOL_ALLOCATE_BUFFER    AllocateBuffer;
+  EFI_PCI_IO_PROTOCOL_FREE_BUFFER        FreeBuffer;
+  EFI_PCI_IO_PROTOCOL_FLUSH              Flush;
+  EFI_PCI_IO_PROTOCOL_GET_LOCATION       GetLocation;
+  EFI_PCI_IO_PROTOCOL_ATTRIBUTES         Attributes;
+  EFI_PCI_IO_PROTOCOL_GET_BAR_ATTRIBUTES GetBarAttributes;
+  EFI_PCI_IO_PROTOCOL_SET_BAR_ATTRIBUTES SetBarAttributes;
+  UINT64                                 RomSize;
+  VOID                                   *RomImage;
+} EFI_PCI_IO;
+
+#endif /* _EFI_PCI_IO_H */
diff --git a/linux-x86_64/gnu-efi/include/efi/efiprot.h b/linux-x86_64/gnu-efi/include/efi/efiprot.h
new file mode 100644
index 0000000..a6df337
--- /dev/null
+++ b/linux-x86_64/gnu-efi/include/efi/efiprot.h
@@ -0,0 +1,736 @@
+#ifndef _EFI_PROT_H
+#define _EFI_PROT_H
+
+/*++
+
+Copyright (c) 1998  Intel Corporation
+
+Module Name:
+
+    efiprot.h
+
+Abstract:
+
+    EFI Protocols
+
+
+
+Revision History
+
+--*/
+
+//
+//  FPSWA library protocol
+//
+#define FPSWA_PROTOCOL          \
+    { 0xc41b6531, 0x97b9, 0x11d3, {0x9a, 0x29, 0x0, 0x90, 0x27, 0x3f, 0xc1, 0x4d} }
+
+//
+// Device Path protocol
+//
+
+#define DEVICE_PATH_PROTOCOL    \
+    { 0x9576e91, 0x6d3f, 0x11d2, {0x8e, 0x39, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b} }
+
+
+//
+// Block IO protocol
+//
+
+#define BLOCK_IO_PROTOCOL \
+    { 0x964e5b21, 0x6459, 0x11d2, {0x8e, 0x39, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b} }
+#define EFI_BLOCK_IO_INTERFACE_REVISION   0x00010000
+#define EFI_BLOCK_IO_INTERFACE_REVISION2  0x00020001
+#define EFI_BLOCK_IO_INTERFACE_REVISION3  ((2<<16) | 31)
+
+INTERFACE_DECL(_EFI_BLOCK_IO);
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_BLOCK_RESET) (
+    IN struct _EFI_BLOCK_IO     *This,
+    IN BOOLEAN                  ExtendedVerification
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_BLOCK_READ) (
+    IN struct _EFI_BLOCK_IO     *This,
+    IN UINT32                   MediaId,
+    IN EFI_LBA                  LBA,
+    IN UINTN                    BufferSize,
+    OUT VOID                    *Buffer
+    );
+
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_BLOCK_WRITE) (
+    IN struct _EFI_BLOCK_IO     *This,
+    IN UINT32                   MediaId,
+    IN EFI_LBA                  LBA,
+    IN UINTN                    BufferSize,
+    IN VOID                     *Buffer
+    );
+
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_BLOCK_FLUSH) (
+    IN struct _EFI_BLOCK_IO     *This
+    );
+
+
+
+typedef struct {
+    UINT32              MediaId;
+    BOOLEAN             RemovableMedia;
+    BOOLEAN             MediaPresent;
+
+    BOOLEAN             LogicalPartition;
+    BOOLEAN             ReadOnly;
+    BOOLEAN             WriteCaching;
+
+    UINT32              BlockSize;
+    UINT32              IoAlign;
+
+    EFI_LBA             LastBlock;
+
+    /* revision 2 */
+    EFI_LBA             LowestAlignedLba;
+    UINT32              LogicalBlocksPerPhysicalBlock;
+    /* revision 3 */
+    UINT32              OptimalTransferLengthGranularity;
+} EFI_BLOCK_IO_MEDIA;
+
+typedef struct _EFI_BLOCK_IO {
+    UINT64                  Revision;
+
+    EFI_BLOCK_IO_MEDIA      *Media;
+
+    EFI_BLOCK_RESET         Reset;
+    EFI_BLOCK_READ          ReadBlocks;
+    EFI_BLOCK_WRITE         WriteBlocks;
+    EFI_BLOCK_FLUSH         FlushBlocks;
+
+} EFI_BLOCK_IO;
+
+
+
+//
+// Disk Block IO protocol
+//
+
+#define DISK_IO_PROTOCOL \
+    { 0xce345171, 0xba0b, 0x11d2,  {0x8e, 0x4f, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b} }
+#define EFI_DISK_IO_INTERFACE_REVISION   0x00010000
+
+INTERFACE_DECL(_EFI_DISK_IO);
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_DISK_READ) (
+    IN struct _EFI_DISK_IO      *This,
+    IN UINT32                   MediaId,
+    IN UINT64                   Offset,
+    IN UINTN                    BufferSize,
+    OUT VOID                    *Buffer
+    );
+
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_DISK_WRITE) (
+    IN struct _EFI_DISK_IO      *This,
+    IN UINT32                   MediaId,
+    IN UINT64                   Offset,
+    IN UINTN                    BufferSize,
+    IN VOID                     *Buffer
+    );
+
+
+typedef struct _EFI_DISK_IO {
+    UINT64              Revision;
+    EFI_DISK_READ       ReadDisk;
+    EFI_DISK_WRITE      WriteDisk;
+} EFI_DISK_IO;
+
+
+//
+// Simple file system protocol
+//
+
+#define SIMPLE_FILE_SYSTEM_PROTOCOL \
+    { 0x964e5b22, 0x6459, 0x11d2, {0x8e, 0x39, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b} }
+
+INTERFACE_DECL(_EFI_FILE_IO_INTERFACE);
+INTERFACE_DECL(_EFI_FILE_HANDLE);
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_VOLUME_OPEN) (
+    IN struct _EFI_FILE_IO_INTERFACE    *This,
+    OUT struct _EFI_FILE_HANDLE         **Root
+    );
+
+#define EFI_FILE_IO_INTERFACE_REVISION   0x00010000
+
+typedef struct _EFI_FILE_IO_INTERFACE {
+    UINT64                  Revision;
+    EFI_VOLUME_OPEN         OpenVolume;
+} EFI_FILE_IO_INTERFACE;
+
+//
+//
+//
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_FILE_OPEN) (
+    IN struct _EFI_FILE_HANDLE  *File,
+    OUT struct _EFI_FILE_HANDLE **NewHandle,
+    IN CHAR16                   *FileName,
+    IN UINT64                   OpenMode,
+    IN UINT64                   Attributes
+    );
+
+// Open modes
+#define EFI_FILE_MODE_READ      0x0000000000000001
+#define EFI_FILE_MODE_WRITE     0x0000000000000002
+#define EFI_FILE_MODE_CREATE    0x8000000000000000
+
+// File attributes
+#define EFI_FILE_READ_ONLY      0x0000000000000001
+#define EFI_FILE_HIDDEN         0x0000000000000002
+#define EFI_FILE_SYSTEM         0x0000000000000004
+#define EFI_FILE_RESERVIED      0x0000000000000008
+#define EFI_FILE_DIRECTORY      0x0000000000000010
+#define EFI_FILE_ARCHIVE        0x0000000000000020
+#define EFI_FILE_VALID_ATTR     0x0000000000000037
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_FILE_CLOSE) (
+    IN struct _EFI_FILE_HANDLE  *File
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_FILE_DELETE) (
+    IN struct _EFI_FILE_HANDLE  *File
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_FILE_READ) (
+    IN struct _EFI_FILE_HANDLE  *File,
+    IN OUT UINTN                *BufferSize,
+    OUT VOID                    *Buffer
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_FILE_WRITE) (
+    IN struct _EFI_FILE_HANDLE  *File,
+    IN OUT UINTN                *BufferSize,
+    IN VOID                     *Buffer
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_FILE_SET_POSITION) (
+    IN struct _EFI_FILE_HANDLE  *File,
+    IN UINT64                   Position
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_FILE_GET_POSITION) (
+    IN struct _EFI_FILE_HANDLE  *File,
+    OUT UINT64                  *Position
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_FILE_GET_INFO) (
+    IN struct _EFI_FILE_HANDLE  *File,
+    IN EFI_GUID                 *InformationType,
+    IN OUT UINTN                *BufferSize,
+    OUT VOID                    *Buffer
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_FILE_SET_INFO) (
+    IN struct _EFI_FILE_HANDLE  *File,
+    IN EFI_GUID                 *InformationType,
+    IN UINTN                    BufferSize,
+    IN VOID                     *Buffer
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_FILE_FLUSH) (
+    IN struct _EFI_FILE_HANDLE  *File
+    );
+
+
+
+#define EFI_FILE_HANDLE_REVISION         0x00010000
+typedef struct _EFI_FILE_HANDLE {
+    UINT64                  Revision;
+    EFI_FILE_OPEN           Open;
+    EFI_FILE_CLOSE          Close;
+    EFI_FILE_DELETE         Delete;
+    EFI_FILE_READ           Read;
+    EFI_FILE_WRITE          Write;
+    EFI_FILE_GET_POSITION   GetPosition;
+    EFI_FILE_SET_POSITION   SetPosition;
+    EFI_FILE_GET_INFO       GetInfo;
+    EFI_FILE_SET_INFO       SetInfo;
+    EFI_FILE_FLUSH          Flush;
+} EFI_FILE, *EFI_FILE_HANDLE;
+
+
+//
+// File information types
+//
+
+#define EFI_FILE_INFO_ID   \
+    { 0x9576e92, 0x6d3f, 0x11d2, {0x8e, 0x39, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b} }
+
+typedef struct {
+    UINT64                  Size;
+    UINT64                  FileSize;
+    UINT64                  PhysicalSize;
+    EFI_TIME                CreateTime;
+    EFI_TIME                LastAccessTime;
+    EFI_TIME                ModificationTime;
+    UINT64                  Attribute;
+    CHAR16                  FileName[1];
+} EFI_FILE_INFO;
+
+//
+// The FileName field of the EFI_FILE_INFO data structure is variable length.
+// Whenever code needs to know the size of the EFI_FILE_INFO data structure, it needs to
+// be the size of the data structure without the FileName field.  The following macro 
+// computes this size correctly no matter how big the FileName array is declared.
+// This is required to make the EFI_FILE_INFO data structure ANSI compilant. 
+//
+
+#define SIZE_OF_EFI_FILE_INFO EFI_FIELD_OFFSET(EFI_FILE_INFO,FileName)
+
+#define EFI_FILE_SYSTEM_INFO_ID    \
+    { 0x9576e93, 0x6d3f, 0x11d2, {0x8e, 0x39, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b} }
+
+typedef struct {
+    UINT64                  Size;
+    BOOLEAN                 ReadOnly;
+    UINT64                  VolumeSize;
+    UINT64                  FreeSpace;
+    UINT32                  BlockSize;
+    CHAR16                  VolumeLabel[1];
+} EFI_FILE_SYSTEM_INFO;
+
+//
+// The VolumeLabel field of the EFI_FILE_SYSTEM_INFO data structure is variable length.
+// Whenever code needs to know the size of the EFI_FILE_SYSTEM_INFO data structure, it needs
+// to be the size of the data structure without the VolumeLable field.  The following macro 
+// computes this size correctly no matter how big the VolumeLable array is declared.
+// This is required to make the EFI_FILE_SYSTEM_INFO data structure ANSI compilant. 
+//
+
+#define SIZE_OF_EFI_FILE_SYSTEM_INFO EFI_FIELD_OFFSET(EFI_FILE_SYSTEM_INFO,VolumeLabel)
+
+#define EFI_FILE_SYSTEM_VOLUME_LABEL_INFO_ID    \
+    { 0xDB47D7D3,0xFE81, 0x11d3, {0x9A, 0x35, 0x00, 0x90, 0x27, 0x3F, 0xC1, 0x4D} }
+
+typedef struct {
+    CHAR16                  VolumeLabel[1];
+} EFI_FILE_SYSTEM_VOLUME_LABEL_INFO;
+
+#define SIZE_OF_EFI_FILE_SYSTEM_VOLUME_LABEL_INFO EFI_FIELD_OFFSET(EFI_FILE_SYSTEM_VOLUME_LABEL_INFO,VolumeLabel)
+
+//
+// Load file protocol
+//
+
+
+#define LOAD_FILE_PROTOCOL \
+    { 0x56EC3091, 0x954C, 0x11d2, {0x8E, 0x3F, 0x00, 0xA0, 0xC9, 0x69, 0x72, 0x3B} }
+
+INTERFACE_DECL(_EFI_LOAD_FILE_INTERFACE);
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_LOAD_FILE) (
+    IN struct _EFI_LOAD_FILE_INTERFACE  *This,
+    IN EFI_DEVICE_PATH                  *FilePath,
+    IN BOOLEAN                          BootPolicy,
+    IN OUT UINTN                        *BufferSize,
+    IN VOID                             *Buffer OPTIONAL
+    );
+
+typedef struct _EFI_LOAD_FILE_INTERFACE {
+    EFI_LOAD_FILE                       LoadFile;
+} EFI_LOAD_FILE_INTERFACE;
+
+
+//
+// Device IO protocol
+//
+
+#define DEVICE_IO_PROTOCOL \
+    { 0xaf6ac311, 0x84c3, 0x11d2, {0x8e, 0x3c, 0x00, 0xa0, 0xc9, 0x69, 0x72, 0x3b} }
+
+INTERFACE_DECL(_EFI_DEVICE_IO_INTERFACE);
+
+typedef enum {
+    IO_UINT8,
+    IO_UINT16,
+    IO_UINT32,
+    IO_UINT64,
+//
+// Specification Change: Copy from MMIO to MMIO vs. MMIO to buffer, buffer to MMIO
+//
+    MMIO_COPY_UINT8,
+    MMIO_COPY_UINT16,
+    MMIO_COPY_UINT32,
+    MMIO_COPY_UINT64
+} EFI_IO_WIDTH;
+
+#define EFI_PCI_ADDRESS(_bus,_dev,_func) \
+    ( (UINT64) ( (((UINTN)_bus) << 24) + (((UINTN)_dev) << 16) + (((UINTN)_func) << 8) ) )
+
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_DEVICE_IO) (
+    IN struct _EFI_DEVICE_IO_INTERFACE *This,
+    IN EFI_IO_WIDTH                 Width,
+    IN UINT64                       Address,
+    IN UINTN                        Count,
+    IN OUT VOID                     *Buffer
+    );
+
+typedef struct {
+    EFI_DEVICE_IO                   Read;
+    EFI_DEVICE_IO                   Write;
+} EFI_IO_ACCESS;
+
+typedef 
+EFI_STATUS
+(EFIAPI *EFI_PCI_DEVICE_PATH) (
+    IN struct _EFI_DEVICE_IO_INTERFACE  *This,
+    IN UINT64                           Address,
+    IN OUT EFI_DEVICE_PATH              **PciDevicePath
+    );
+
+typedef enum {
+    EfiBusMasterRead,
+    EfiBusMasterWrite,
+    EfiBusMasterCommonBuffer
+} EFI_IO_OPERATION_TYPE;
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_IO_MAP) (
+    IN struct _EFI_DEVICE_IO_INTERFACE  *This,
+    IN EFI_IO_OPERATION_TYPE            Operation,
+    IN EFI_PHYSICAL_ADDRESS             *HostAddress,
+    IN OUT UINTN                        *NumberOfBytes,
+    OUT EFI_PHYSICAL_ADDRESS            *DeviceAddress,
+    OUT VOID                            **Mapping
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_IO_UNMAP) (
+    IN struct _EFI_DEVICE_IO_INTERFACE  *This,
+    IN VOID                             *Mapping
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_IO_ALLOCATE_BUFFER) (
+    IN struct _EFI_DEVICE_IO_INTERFACE  *This,
+    IN EFI_ALLOCATE_TYPE                Type,
+    IN EFI_MEMORY_TYPE                  MemoryType,
+    IN UINTN                            Pages,
+    IN OUT EFI_PHYSICAL_ADDRESS         *HostAddress
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_IO_FLUSH) (
+    IN struct _EFI_DEVICE_IO_INTERFACE  *This
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_IO_FREE_BUFFER) (
+    IN struct _EFI_DEVICE_IO_INTERFACE  *This,
+    IN UINTN                            Pages,
+    IN EFI_PHYSICAL_ADDRESS             HostAddress
+    );
+
+typedef struct _EFI_DEVICE_IO_INTERFACE {
+    EFI_IO_ACCESS                       Mem;
+    EFI_IO_ACCESS                       Io;
+    EFI_IO_ACCESS                       Pci;
+    EFI_IO_MAP                          Map;
+    EFI_PCI_DEVICE_PATH                 PciDevicePath;
+    EFI_IO_UNMAP                        Unmap;
+    EFI_IO_ALLOCATE_BUFFER              AllocateBuffer;
+    EFI_IO_FLUSH                        Flush;
+    EFI_IO_FREE_BUFFER                  FreeBuffer;
+} EFI_DEVICE_IO_INTERFACE;
+
+
+//
+// Unicode Collation protocol
+//
+
+#define UNICODE_COLLATION_PROTOCOL \
+    { 0x1d85cd7f, 0xf43d, 0x11d2, {0x9a, 0xc,  0x0, 0x90, 0x27, 0x3f, 0xc1, 0x4d} }
+
+#define UNICODE_BYTE_ORDER_MARK       (CHAR16)(0xfeff)
+
+INTERFACE_DECL(_EFI_UNICODE_COLLATION_INTERFACE);
+
+typedef
+INTN
+(EFIAPI *EFI_UNICODE_STRICOLL) (
+    IN struct _EFI_UNICODE_COLLATION_INTERFACE  *This,
+    IN CHAR16                         *s1,
+    IN CHAR16                         *s2
+    );
+
+typedef
+BOOLEAN
+(EFIAPI *EFI_UNICODE_METAIMATCH) (
+    IN struct _EFI_UNICODE_COLLATION_INTERFACE  *This,
+    IN CHAR16                         *String,
+    IN CHAR16                         *Pattern
+    );
+
+typedef
+VOID
+(EFIAPI *EFI_UNICODE_STRLWR) (
+    IN struct _EFI_UNICODE_COLLATION_INTERFACE  *This,
+    IN OUT CHAR16                       *Str
+    );
+
+typedef
+VOID
+(EFIAPI *EFI_UNICODE_STRUPR) (
+    IN struct _EFI_UNICODE_COLLATION_INTERFACE  *This,
+    IN OUT CHAR16                       *Str
+    );
+
+typedef
+VOID
+(EFIAPI *EFI_UNICODE_FATTOSTR) (
+    IN struct _EFI_UNICODE_COLLATION_INTERFACE  *This,
+    IN UINTN                            FatSize,
+    IN CHAR8                            *Fat,
+    OUT CHAR16                          *String
+    );
+
+typedef
+BOOLEAN
+(EFIAPI *EFI_UNICODE_STRTOFAT) (
+    IN struct _EFI_UNICODE_COLLATION_INTERFACE  *This,
+    IN CHAR16                           *String,
+    IN UINTN                            FatSize,
+    OUT CHAR8                           *Fat
+    );
+
+
+typedef struct _EFI_UNICODE_COLLATION_INTERFACE {
+
+    // general
+    EFI_UNICODE_STRICOLL                StriColl;
+    EFI_UNICODE_METAIMATCH              MetaiMatch;
+    EFI_UNICODE_STRLWR                  StrLwr;
+    EFI_UNICODE_STRUPR                  StrUpr;
+
+    // for supporting fat volumes
+    EFI_UNICODE_FATTOSTR                FatToStr;
+    EFI_UNICODE_STRTOFAT                StrToFat;
+
+    CHAR8                               *SupportedLanguages;
+} EFI_UNICODE_COLLATION_INTERFACE;
+
+/* Graphics output protocol */
+#define EFI_GRAPHICS_OUTPUT_PROTOCOL_GUID \
+  { \
+    0x9042a9de, 0x23dc, 0x4a38, {0x96, 0xfb, 0x7a, 0xde, 0xd0, 0x80, 0x51, 0x6a } \
+  }
+
+typedef struct _EFI_GRAPHICS_OUTPUT_PROTOCOL EFI_GRAPHICS_OUTPUT_PROTOCOL;
+
+typedef struct {
+  UINT32            RedMask;
+  UINT32            GreenMask;
+  UINT32            BlueMask;
+  UINT32            ReservedMask;
+} EFI_PIXEL_BITMASK;
+
+typedef enum {
+  PixelRedGreenBlueReserved8BitPerColor,
+  PixelBlueGreenRedReserved8BitPerColor,
+  PixelBitMask,
+  PixelBltOnly,
+  PixelFormatMax
+} EFI_GRAPHICS_PIXEL_FORMAT;
+
+typedef struct {
+  UINT32                     Version;
+  UINT32                     HorizontalResolution;
+  UINT32                     VerticalResolution;
+  EFI_GRAPHICS_PIXEL_FORMAT  PixelFormat;
+  EFI_PIXEL_BITMASK          PixelInformation;
+  UINT32                     PixelsPerScanLine;
+} EFI_GRAPHICS_OUTPUT_MODE_INFORMATION;
+
+/**
+  Return the current video mode information.
+
+  @param  This       Protocol instance pointer.
+  @param  ModeNumber The mode number to return information on.
+  @param  SizeOfInfo A pointer to the size, in bytes, of the Info buffer.
+  @param  Info       A pointer to callee allocated buffer that returns information about ModeNumber.
+
+  @retval EFI_SUCCESS           Mode information returned.
+  @retval EFI_BUFFER_TOO_SMALL  The Info buffer was too small.
+  @retval EFI_DEVICE_ERROR      A hardware error occurred trying to retrieve the video mode.
+  @retval EFI_NOT_STARTED       Video display is not initialized. Call SetMode ()
+  @retval EFI_INVALID_PARAMETER One of the input args was NULL.
+
+**/
+typedef
+EFI_STATUS
+(EFIAPI *EFI_GRAPHICS_OUTPUT_PROTOCOL_QUERY_MODE) (
+  IN  EFI_GRAPHICS_OUTPUT_PROTOCOL          *This,
+  IN  UINT32                                ModeNumber,
+  OUT UINTN                                 *SizeOfInfo,
+  OUT EFI_GRAPHICS_OUTPUT_MODE_INFORMATION  **Info
+  )
+;
+
+/**
+  Return the current video mode information.
+
+  @param  This              Protocol instance pointer.
+  @param  ModeNumber        The mode number to be set.
+
+  @retval EFI_SUCCESS       Graphics mode was changed.
+  @retval EFI_DEVICE_ERROR  The device had an error and could not complete the request.
+  @retval EFI_UNSUPPORTED   ModeNumber is not supported by this device.
+
+**/
+typedef
+EFI_STATUS
+(EFIAPI *EFI_GRAPHICS_OUTPUT_PROTOCOL_SET_MODE) (
+  IN  EFI_GRAPHICS_OUTPUT_PROTOCOL *This,
+  IN  UINT32                       ModeNumber
+  )
+;
+
+typedef struct {
+  UINT8 Blue;
+  UINT8 Green;
+  UINT8 Red;
+  UINT8 Reserved;
+} EFI_GRAPHICS_OUTPUT_BLT_PIXEL;
+
+typedef union {
+  EFI_GRAPHICS_OUTPUT_BLT_PIXEL Pixel;
+  UINT32                        Raw;
+} EFI_GRAPHICS_OUTPUT_BLT_PIXEL_UNION;
+
+typedef enum {
+  EfiBltVideoFill,
+  EfiBltVideoToBltBuffer,
+  EfiBltBufferToVideo, 
+  EfiBltVideoToVideo,
+  EfiGraphicsOutputBltOperationMax
+} EFI_GRAPHICS_OUTPUT_BLT_OPERATION;
+
+/**
+  The following table defines actions for BltOperations:
+
+  <B>EfiBltVideoFill</B> - Write data from the  BltBuffer pixel (SourceX, SourceY) 
+  directly to every pixel of the video display rectangle 
+  (DestinationX, DestinationY) (DestinationX + Width, DestinationY + Height). 
+  Only one pixel will be used from the BltBuffer. Delta is NOT used.
+
+  <B>EfiBltVideoToBltBuffer</B> - Read data from the video display rectangle 
+  (SourceX, SourceY) (SourceX + Width, SourceY + Height) and place it in 
+  the BltBuffer rectangle (DestinationX, DestinationY ) 
+  (DestinationX + Width, DestinationY + Height). If DestinationX or 
+  DestinationY is not zero then Delta must be set to the length in bytes 
+  of a row in the BltBuffer.
+
+  <B>EfiBltBufferToVideo</B> - Write data from the  BltBuffer rectangle 
+  (SourceX, SourceY) (SourceX + Width, SourceY + Height) directly to the 
+  video display rectangle (DestinationX, DestinationY) 
+  (DestinationX + Width, DestinationY + Height). If SourceX or SourceY is 
+  not zero then Delta must be set to the length in bytes of a row in the 
+  BltBuffer.
+
+  <B>EfiBltVideoToVideo</B> - Copy from the video display rectangle (SourceX, SourceY)
+  (SourceX + Width, SourceY + Height) .to the video display rectangle 
+  (DestinationX, DestinationY) (DestinationX + Width, DestinationY + Height). 
+  The BltBuffer and Delta  are not used in this mode.
+
+  @param  This         Protocol instance pointer.
+  @param  BltBuffer    Buffer containing data to blit into video buffer. This
+                       buffer has a size of Width*Height*sizeof(EFI_GRAPHICS_OUTPUT_BLT_PIXEL)
+  @param  BltOperation Operation to perform on BlitBuffer and video memory
+  @param  SourceX      X coordinate of source for the BltBuffer.
+  @param  SourceY      Y coordinate of source for the BltBuffer.
+  @param  DestinationX X coordinate of destination for the BltBuffer.
+  @param  DestinationY Y coordinate of destination for the BltBuffer.
+  @param  Width        Width of rectangle in BltBuffer in pixels.
+  @param  Height       Hight of rectangle in BltBuffer in pixels.
+  @param  Delta        OPTIONAL
+
+  @retval EFI_SUCCESS           The Blt operation completed.
+  @retval EFI_INVALID_PARAMETER BltOperation is not valid.
+  @retval EFI_DEVICE_ERROR      A hardware error occured writting to the video buffer.
+
+**/
+typedef
+EFI_STATUS
+(EFIAPI *EFI_GRAPHICS_OUTPUT_PROTOCOL_BLT) (
+  IN  EFI_GRAPHICS_OUTPUT_PROTOCOL            *This,
+  IN  EFI_GRAPHICS_OUTPUT_BLT_PIXEL           *BltBuffer,   OPTIONAL
+  IN  EFI_GRAPHICS_OUTPUT_BLT_OPERATION       BltOperation,
+  IN  UINTN                                   SourceX,
+  IN  UINTN                                   SourceY,
+  IN  UINTN                                   DestinationX,
+  IN  UINTN                                   DestinationY,
+  IN  UINTN                                   Width,
+  IN  UINTN                                   Height,
+  IN  UINTN                                   Delta         OPTIONAL
+  );
+
+typedef struct {
+  UINT32                                 MaxMode;
+  UINT32                                 Mode;
+  EFI_GRAPHICS_OUTPUT_MODE_INFORMATION   *Info;
+  UINTN                                  SizeOfInfo;
+  EFI_PHYSICAL_ADDRESS                   FrameBufferBase;
+  UINTN                                  FrameBufferSize;
+} EFI_GRAPHICS_OUTPUT_PROTOCOL_MODE;
+
+struct _EFI_GRAPHICS_OUTPUT_PROTOCOL {
+  EFI_GRAPHICS_OUTPUT_PROTOCOL_QUERY_MODE  QueryMode;
+  EFI_GRAPHICS_OUTPUT_PROTOCOL_SET_MODE    SetMode;
+  EFI_GRAPHICS_OUTPUT_PROTOCOL_BLT         Blt;
+  EFI_GRAPHICS_OUTPUT_PROTOCOL_MODE        *Mode;
+};
+#endif
+
diff --git a/linux-x86_64/gnu-efi/include/efi/efipxebc.h b/linux-x86_64/gnu-efi/include/efi/efipxebc.h
new file mode 100644
index 0000000..792d323
--- /dev/null
+++ b/linux-x86_64/gnu-efi/include/efi/efipxebc.h
@@ -0,0 +1,463 @@
+#ifndef _EFIPXEBC_H
+#define _EFIPXEBC_H
+
+/*++
+
+Copyright (c) 1998  Intel Corporation
+
+Module Name:
+
+    efipxebc.h
+
+Abstract:
+
+    EFI PXE Base Code Protocol
+
+
+
+Revision History
+
+--*/
+
+//
+// PXE Base Code protocol
+//
+
+#define EFI_PXE_BASE_CODE_PROTOCOL \
+    { 0x03c4e603, 0xac28, 0x11d3, {0x9a, 0x2d, 0x00, 0x90, 0x27, 0x3f, 0xc1, 0x4d} }
+
+INTERFACE_DECL(_EFI_PXE_BASE_CODE);
+
+#define DEFAULT_TTL 4
+#define DEFAULT_ToS 0
+//
+// Address definitions
+//
+
+typedef union {
+    UINT32      Addr[4];
+    EFI_IPv4_ADDRESS    v4;
+    EFI_IPv6_ADDRESS    v6;
+} EFI_IP_ADDRESS;
+
+typedef UINT16 EFI_PXE_BASE_CODE_UDP_PORT;
+
+//
+// Packet definitions
+//
+
+typedef struct {
+    UINT8                           BootpOpcode;
+    UINT8                           BootpHwType;
+    UINT8                           BootpHwAddrLen;
+    UINT8                           BootpGateHops;
+    UINT32                          BootpIdent;
+    UINT16                          BootpSeconds;
+    UINT16                          BootpFlags;
+    UINT8                           BootpCiAddr[4];
+    UINT8                           BootpYiAddr[4];
+    UINT8                           BootpSiAddr[4];
+    UINT8                           BootpGiAddr[4];
+    UINT8                           BootpHwAddr[16];
+    UINT8                           BootpSrvName[64];
+    UINT8                           BootpBootFile[128];
+    UINT32                          DhcpMagik;
+    UINT8                           DhcpOptions[56];
+} EFI_PXE_BASE_CODE_DHCPV4_PACKET;
+
+// TBD in EFI v1.1
+//typedef struct {
+//    UINT8                           reserved;
+//} EFI_PXE_BASE_CODE_DHCPV6_PACKET;
+
+typedef union {
+    UINT8                               Raw[1472];
+    EFI_PXE_BASE_CODE_DHCPV4_PACKET     Dhcpv4;
+//    EFI_PXE_BASE_CODE_DHCPV6_PACKET     Dhcpv6;
+} EFI_PXE_BASE_CODE_PACKET;
+
+typedef struct {
+    UINT8                   Type;
+    UINT8                   Code;
+    UINT16                  Checksum;
+    union {
+        UINT32              reserved;
+        UINT32              Mtu;
+        UINT32              Pointer;
+        struct {
+            UINT16          Identifier;
+            UINT16          Sequence;
+        } Echo;
+    } u;
+    UINT8                   Data[494];
+} EFI_PXE_BASE_CODE_ICMP_ERROR;
+
+typedef struct {
+    UINT8                   ErrorCode;
+    CHAR8                   ErrorString[127];
+} EFI_PXE_BASE_CODE_TFTP_ERROR;
+
+//
+// IP Receive Filter definitions
+//
+#define EFI_PXE_BASE_CODE_MAX_IPCNT             8
+typedef struct {
+    UINT8                       Filters;
+    UINT8                       IpCnt;
+    UINT16                      reserved;
+    EFI_IP_ADDRESS              IpList[EFI_PXE_BASE_CODE_MAX_IPCNT];
+} EFI_PXE_BASE_CODE_IP_FILTER;
+
+#define EFI_PXE_BASE_CODE_IP_FILTER_STATION_IP             0x0001
+#define EFI_PXE_BASE_CODE_IP_FILTER_BROADCAST              0x0002
+#define EFI_PXE_BASE_CODE_IP_FILTER_PROMISCUOUS            0x0004
+#define EFI_PXE_BASE_CODE_IP_FILTER_PROMISCUOUS_MULTICAST  0x0008
+
+//
+// ARP Cache definitions
+//
+
+typedef struct {
+    EFI_IP_ADDRESS       IpAddr;
+    EFI_MAC_ADDRESS      MacAddr;
+} EFI_PXE_BASE_CODE_ARP_ENTRY;
+
+typedef struct {
+    EFI_IP_ADDRESS       IpAddr;
+    EFI_IP_ADDRESS       SubnetMask;
+    EFI_IP_ADDRESS       GwAddr;
+} EFI_PXE_BASE_CODE_ROUTE_ENTRY;
+
+//
+// UDP definitions
+//
+
+#define EFI_PXE_BASE_CODE_UDP_OPFLAGS_ANY_SRC_IP    0x0001
+#define EFI_PXE_BASE_CODE_UDP_OPFLAGS_ANY_SRC_PORT  0x0002
+#define EFI_PXE_BASE_CODE_UDP_OPFLAGS_ANY_DEST_IP   0x0004
+#define EFI_PXE_BASE_CODE_UDP_OPFLAGS_ANY_DEST_PORT 0x0008
+#define EFI_PXE_BASE_CODE_UDP_OPFLAGS_USE_FILTER    0x0010
+#define EFI_PXE_BASE_CODE_UDP_OPFLAGS_MAY_FRAGMENT  0x0020
+
+//
+// Discover() definitions
+//
+
+#define EFI_PXE_BASE_CODE_BOOT_TYPE_BOOTSTRAP           0   
+#define EFI_PXE_BASE_CODE_BOOT_TYPE_MS_WINNT_RIS        1
+#define EFI_PXE_BASE_CODE_BOOT_TYPE_INTEL_LCM           2
+#define EFI_PXE_BASE_CODE_BOOT_TYPE_DOSUNDI             3
+#define EFI_PXE_BASE_CODE_BOOT_TYPE_NEC_ESMPRO          4
+#define EFI_PXE_BASE_CODE_BOOT_TYPE_IBM_WSoD            5
+#define EFI_PXE_BASE_CODE_BOOT_TYPE_IBM_LCCM            6
+#define EFI_PXE_BASE_CODE_BOOT_TYPE_CA_UNICENTER_TNG    7
+#define EFI_PXE_BASE_CODE_BOOT_TYPE_HP_OPENVIEW         8
+#define EFI_PXE_BASE_CODE_BOOT_TYPE_ALTIRIS_9           9
+#define EFI_PXE_BASE_CODE_BOOT_TYPE_ALTIRIS_10          10
+#define EFI_PXE_BASE_CODE_BOOT_TYPE_ALTIRIS_11          11
+#define EFI_PXE_BASE_CODE_BOOT_TYPE_NOT_USED_12         12
+#define EFI_PXE_BASE_CODE_BOOT_TYPE_REDHAT_INSTALL      13
+#define EFI_PXE_BASE_CODE_BOOT_TYPE_REDHAT_BOOT         14
+#define EFI_PXE_BASE_CODE_BOOT_TYPE_REMBO               15
+#define EFI_PXE_BASE_CODE_BOOT_TYPE_BEOBOOT             16
+//
+// 17 through 32767 are reserved
+// 32768 through 65279 are for vendor use
+// 65280 through 65534 are reserved
+//
+#define EFI_PXE_BASE_CODE_BOOT_TYPE_PXETEST             65535
+
+#define EFI_PXE_BASE_CODE_BOOT_LAYER_MASK               0x7FFF
+#define EFI_PXE_BASE_CODE_BOOT_LAYER_INITIAL            0x0000
+
+
+typedef struct {
+    UINT16                      Type;
+    BOOLEAN                     AcceptAnyResponse;
+    UINT8                       Reserved;
+    EFI_IP_ADDRESS              IpAddr;
+} EFI_PXE_BASE_CODE_SRVLIST;
+
+typedef struct {
+    BOOLEAN                     UseMCast;
+    BOOLEAN                     UseBCast;
+    BOOLEAN                     UseUCast;
+    BOOLEAN                     MustUseList;
+    EFI_IP_ADDRESS              ServerMCastIp;
+    UINT16                      IpCnt;
+    EFI_PXE_BASE_CODE_SRVLIST   SrvList[1];
+} EFI_PXE_BASE_CODE_DISCOVER_INFO;
+
+//
+// Mtftp() definitions
+//
+
+typedef enum {
+    EFI_PXE_BASE_CODE_TFTP_FIRST,
+    EFI_PXE_BASE_CODE_TFTP_GET_FILE_SIZE,
+    EFI_PXE_BASE_CODE_TFTP_READ_FILE,
+    EFI_PXE_BASE_CODE_TFTP_WRITE_FILE,
+    EFI_PXE_BASE_CODE_TFTP_READ_DIRECTORY,
+    EFI_PXE_BASE_CODE_MTFTP_GET_FILE_SIZE,
+    EFI_PXE_BASE_CODE_MTFTP_READ_FILE,
+    EFI_PXE_BASE_CODE_MTFTP_READ_DIRECTORY,
+    EFI_PXE_BASE_CODE_MTFTP_LAST
+} EFI_PXE_BASE_CODE_TFTP_OPCODE;
+
+typedef struct {
+    EFI_IP_ADDRESS   MCastIp;
+    EFI_PXE_BASE_CODE_UDP_PORT  CPort;
+    EFI_PXE_BASE_CODE_UDP_PORT  SPort;
+    UINT16                      ListenTimeout;
+    UINT16                      TransmitTimeout;
+} EFI_PXE_BASE_CODE_MTFTP_INFO;
+
+//
+// PXE Base Code Mode structure
+//
+
+#define EFI_PXE_BASE_CODE_MAX_ARP_ENTRIES       8
+#define EFI_PXE_BASE_CODE_MAX_ROUTE_ENTRIES     8
+
+typedef struct {
+    BOOLEAN                         Started;
+    BOOLEAN                         Ipv6Available;
+    BOOLEAN                         Ipv6Supported;
+    BOOLEAN                         UsingIpv6;
+    BOOLEAN                         BisSupported;
+    BOOLEAN                         BisDetected;
+    BOOLEAN                         AutoArp;
+    BOOLEAN                         SendGUID;
+    BOOLEAN                         DhcpDiscoverValid;
+    BOOLEAN                         DhcpAckReceived;
+    BOOLEAN                         ProxyOfferReceived;
+    BOOLEAN                         PxeDiscoverValid;
+    BOOLEAN                         PxeReplyReceived;
+    BOOLEAN                         PxeBisReplyReceived;
+    BOOLEAN                         IcmpErrorReceived;
+    BOOLEAN                         TftpErrorReceived;
+    BOOLEAN                         MakeCallbacks;
+    UINT8                           TTL;
+    UINT8                           ToS;
+    EFI_IP_ADDRESS                  StationIp;
+    EFI_IP_ADDRESS                  SubnetMask;
+    EFI_PXE_BASE_CODE_PACKET        DhcpDiscover;
+    EFI_PXE_BASE_CODE_PACKET        DhcpAck;
+    EFI_PXE_BASE_CODE_PACKET        ProxyOffer;
+    EFI_PXE_BASE_CODE_PACKET        PxeDiscover;
+    EFI_PXE_BASE_CODE_PACKET        PxeReply;
+    EFI_PXE_BASE_CODE_PACKET        PxeBisReply;
+    EFI_PXE_BASE_CODE_IP_FILTER     IpFilter;
+    UINT32                          ArpCacheEntries;
+    EFI_PXE_BASE_CODE_ARP_ENTRY     ArpCache[EFI_PXE_BASE_CODE_MAX_ARP_ENTRIES];
+    UINT32                          RouteTableEntries;
+    EFI_PXE_BASE_CODE_ROUTE_ENTRY   RouteTable[EFI_PXE_BASE_CODE_MAX_ROUTE_ENTRIES];
+    EFI_PXE_BASE_CODE_ICMP_ERROR    IcmpError;
+    EFI_PXE_BASE_CODE_TFTP_ERROR    TftpError;
+} EFI_PXE_BASE_CODE_MODE;
+
+//
+// PXE Base Code Interface Function definitions
+//
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PXE_BASE_CODE_START) (
+    IN struct _EFI_PXE_BASE_CODE    *This,
+    IN BOOLEAN                      UseIpv6
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PXE_BASE_CODE_STOP) (
+    IN struct _EFI_PXE_BASE_CODE    *This
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PXE_BASE_CODE_DHCP) (
+    IN struct _EFI_PXE_BASE_CODE    *This,
+    IN BOOLEAN                      SortOffers
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PXE_BASE_CODE_DISCOVER) (
+    IN struct _EFI_PXE_BASE_CODE            *This,
+    IN UINT16                               Type,
+    IN UINT16                               *Layer,
+    IN BOOLEAN                              UseBis,
+    IN OUT EFI_PXE_BASE_CODE_DISCOVER_INFO  *Info   OPTIONAL
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PXE_BASE_CODE_MTFTP) (
+    IN struct _EFI_PXE_BASE_CODE        *This,
+    IN EFI_PXE_BASE_CODE_TFTP_OPCODE    Operation,
+    IN OUT VOID                         *BufferPtr  OPTIONAL,
+    IN BOOLEAN                          Overwrite,
+    IN OUT UINTN                        *BufferSize,
+    IN UINTN                            *BlockSize  OPTIONAL,
+    IN EFI_IP_ADDRESS                   *ServerIp,
+    IN UINT8                            *Filename,
+    IN EFI_PXE_BASE_CODE_MTFTP_INFO     *Info       OPTIONAL,
+    IN BOOLEAN                          DontUseBuffer
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PXE_BASE_CODE_UDP_WRITE) (
+    IN struct _EFI_PXE_BASE_CODE        *This,
+    IN UINT16                           OpFlags,
+    IN EFI_IP_ADDRESS                   *DestIp,
+    IN EFI_PXE_BASE_CODE_UDP_PORT       *DestPort,
+    IN EFI_IP_ADDRESS                   *GatewayIp,  OPTIONAL
+    IN EFI_IP_ADDRESS                   *SrcIp,      OPTIONAL
+    IN OUT EFI_PXE_BASE_CODE_UDP_PORT   *SrcPort,    OPTIONAL
+    IN UINTN                            *HeaderSize, OPTIONAL
+    IN VOID                             *HeaderPtr,  OPTIONAL
+    IN UINTN                            *BufferSize,
+    IN VOID                             *BufferPtr
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PXE_BASE_CODE_UDP_READ) (
+    IN struct _EFI_PXE_BASE_CODE        *This,
+    IN UINT16                           OpFlags,
+    IN OUT EFI_IP_ADDRESS               *DestIp,      OPTIONAL
+    IN OUT EFI_PXE_BASE_CODE_UDP_PORT   *DestPort,    OPTIONAL
+    IN OUT EFI_IP_ADDRESS               *SrcIp,       OPTIONAL
+    IN OUT EFI_PXE_BASE_CODE_UDP_PORT   *SrcPort,     OPTIONAL
+    IN UINTN                            *HeaderSize,  OPTIONAL
+    IN VOID                             *HeaderPtr,   OPTIONAL
+    IN OUT UINTN                        *BufferSize,
+    IN VOID                             *BufferPtr
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PXE_BASE_CODE_SET_IP_FILTER) (
+    IN struct _EFI_PXE_BASE_CODE    *This,
+    IN EFI_PXE_BASE_CODE_IP_FILTER  *NewFilter
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PXE_BASE_CODE_ARP) (
+    IN struct _EFI_PXE_BASE_CODE    *This,
+    IN EFI_IP_ADDRESS               *IpAddr,      
+    IN EFI_MAC_ADDRESS              *MacAddr      OPTIONAL
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PXE_BASE_CODE_SET_PARAMETERS) (
+    IN struct _EFI_PXE_BASE_CODE    *This,
+    IN BOOLEAN                      *NewAutoArp,    OPTIONAL
+    IN BOOLEAN                      *NewSendGUID,   OPTIONAL
+    IN UINT8                        *NewTTL,        OPTIONAL
+    IN UINT8                        *NewToS,        OPTIONAL
+    IN BOOLEAN                      *NewMakeCallback    OPTIONAL
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PXE_BASE_CODE_SET_STATION_IP) (
+    IN struct _EFI_PXE_BASE_CODE    *This,
+    IN EFI_IP_ADDRESS               *NewStationIp,  OPTIONAL
+    IN EFI_IP_ADDRESS               *NewSubnetMask  OPTIONAL
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PXE_BASE_CODE_SET_PACKETS) (
+    IN struct _EFI_PXE_BASE_CODE    *This,
+    BOOLEAN                         *NewDhcpDiscoverValid,  OPTIONAL
+    BOOLEAN                         *NewDhcpAckReceived,    OPTIONAL
+    BOOLEAN                         *NewProxyOfferReceived, OPTIONAL
+    BOOLEAN                         *NewPxeDiscoverValid,   OPTIONAL
+    BOOLEAN                         *NewPxeReplyReceived,   OPTIONAL
+    BOOLEAN                         *NewPxeBisReplyReceived,OPTIONAL
+    IN EFI_PXE_BASE_CODE_PACKET     *NewDhcpDiscover, OPTIONAL
+    IN EFI_PXE_BASE_CODE_PACKET     *NewDhcpAck,      OPTIONAL
+    IN EFI_PXE_BASE_CODE_PACKET     *NewProxyOffer,   OPTIONAL
+    IN EFI_PXE_BASE_CODE_PACKET     *NewPxeDiscover,  OPTIONAL
+    IN EFI_PXE_BASE_CODE_PACKET     *NewPxeReply,     OPTIONAL
+    IN EFI_PXE_BASE_CODE_PACKET     *NewPxeBisReply   OPTIONAL
+    );
+
+//
+// PXE Base Code Protocol structure
+//
+
+#define EFI_PXE_BASE_CODE_INTERFACE_REVISION    0x00010000
+
+typedef struct _EFI_PXE_BASE_CODE {
+    UINT64                              Revision;
+    EFI_PXE_BASE_CODE_START             Start;
+    EFI_PXE_BASE_CODE_STOP              Stop;
+    EFI_PXE_BASE_CODE_DHCP              Dhcp;
+    EFI_PXE_BASE_CODE_DISCOVER          Discover;
+    EFI_PXE_BASE_CODE_MTFTP             Mtftp;
+    EFI_PXE_BASE_CODE_UDP_WRITE         UdpWrite;
+    EFI_PXE_BASE_CODE_UDP_READ          UdpRead;
+    EFI_PXE_BASE_CODE_SET_IP_FILTER     SetIpFilter;
+    EFI_PXE_BASE_CODE_ARP               Arp;
+    EFI_PXE_BASE_CODE_SET_PARAMETERS    SetParameters;
+    EFI_PXE_BASE_CODE_SET_STATION_IP    SetStationIp;
+    EFI_PXE_BASE_CODE_SET_PACKETS       SetPackets;
+    EFI_PXE_BASE_CODE_MODE              *Mode;
+} EFI_PXE_BASE_CODE;
+
+//
+// Call Back Definitions
+//
+
+#define EFI_PXE_BASE_CODE_CALLBACK_PROTOCOL \
+    { 0x245dca21, 0xfb7b, 0x11d3, {0x8f, 0x01, 0x00, 0xa0, 0xc9, 0x69, 0x72, 0x3b} }
+
+//
+// Revision Number
+//
+
+#define EFI_PXE_BASE_CODE_CALLBACK_INTERFACE_REVISION   0x00010000
+
+INTERFACE_DECL(_EFI_PXE_BASE_CODE_CALLBACK);
+
+typedef enum {
+    EFI_PXE_BASE_CODE_FUNCTION_FIRST,
+    EFI_PXE_BASE_CODE_FUNCTION_DHCP,
+    EFI_PXE_BASE_CODE_FUNCTION_DISCOVER,
+    EFI_PXE_BASE_CODE_FUNCTION_MTFTP,
+    EFI_PXE_BASE_CODE_FUNCTION_UDP_WRITE,
+    EFI_PXE_BASE_CODE_FUNCTION_UDP_READ,
+    EFI_PXE_BASE_CODE_FUNCTION_ARP,
+    EFI_PXE_BASE_CODE_FUNCTION_IGMP,
+    EFI_PXE_BASE_CODE_PXE_FUNCTION_LAST
+} EFI_PXE_BASE_CODE_FUNCTION;
+
+typedef enum {
+    EFI_PXE_BASE_CODE_CALLBACK_STATUS_FIRST,
+    EFI_PXE_BASE_CODE_CALLBACK_STATUS_CONTINUE,
+    EFI_PXE_BASE_CODE_CALLBACK_STATUS_ABORT,
+    EFI_PXE_BASE_CODE_CALLBACK_STATUS_LAST
+} EFI_PXE_BASE_CODE_CALLBACK_STATUS;
+
+typedef
+EFI_PXE_BASE_CODE_CALLBACK_STATUS 
+(EFIAPI *EFI_PXE_CALLBACK) (
+    IN struct _EFI_PXE_BASE_CODE_CALLBACK   *This,
+    IN EFI_PXE_BASE_CODE_FUNCTION           Function,
+    IN BOOLEAN                              Received,
+    IN UINT32                               PacketLen,
+    IN EFI_PXE_BASE_CODE_PACKET             *Packet     OPTIONAL
+    );
+
+typedef struct _EFI_PXE_BASE_CODE_CALLBACK {
+    UINT64                      Revision;
+    EFI_PXE_CALLBACK            Callback;
+} EFI_PXE_BASE_CODE_CALLBACK;
+
+#endif /* _EFIPXEBC_H */
diff --git a/linux-x86_64/gnu-efi/include/efi/efirtlib.h b/linux-x86_64/gnu-efi/include/efi/efirtlib.h
new file mode 100644
index 0000000..0100180
--- /dev/null
+++ b/linux-x86_64/gnu-efi/include/efi/efirtlib.h
@@ -0,0 +1,141 @@
+#ifndef _EFI_RT_LIB_INCLUDE_
+#define _EFI_RT_LIB_INCLUDE_
+/*++
+
+Copyright (c) 1998  Intel Corporation
+
+Module Name:
+
+    efilib.h
+
+Abstract:
+
+    EFI Runtime library functions
+
+
+
+Revision History
+
+--*/
+
+#include "efidebug.h"
+#include "efipart.h"
+#include "efilibplat.h"
+
+
+VOID
+RUNTIMEFUNCTION
+RtZeroMem (
+    IN VOID     *Buffer,
+    IN UINTN     Size
+    );
+
+VOID
+RUNTIMEFUNCTION
+RtSetMem (
+    IN VOID     *Buffer,
+    IN UINTN    Size,
+    IN UINT8    Value    
+    );
+
+VOID
+RUNTIMEFUNCTION
+RtCopyMem (
+    IN VOID     *Dest,
+    IN VOID     *Src,
+    IN UINTN    len
+    );
+
+INTN
+RUNTIMEFUNCTION
+RtCompareMem (
+    IN VOID     *Dest,
+    IN VOID     *Src,
+    IN UINTN    len
+    );
+
+INTN
+RUNTIMEFUNCTION
+RtStrCmp (
+    IN CHAR16   *s1,
+    IN CHAR16   *s2
+    );
+
+
+VOID
+RUNTIMEFUNCTION
+RtStrCpy (
+    IN CHAR16   *Dest,
+    IN CHAR16    *Src
+    );
+
+VOID
+RUNTIMEFUNCTION
+RtStrCat (
+    IN CHAR16   *Dest,
+    IN CHAR16   *Src
+    );
+
+UINTN
+RUNTIMEFUNCTION
+RtStrLen (
+    IN CHAR16   *s1
+    );
+
+UINTN
+RUNTIMEFUNCTION
+RtStrSize (
+    IN CHAR16   *s1
+    );
+
+INTN
+RUNTIMEFUNCTION
+RtCompareGuid (
+    IN EFI_GUID     *Guid1,
+    IN EFI_GUID     *Guid2
+    );
+
+UINT8
+RUNTIMEFUNCTION
+RtDecimaltoBCD(
+    IN  UINT8 BcdValue
+    );
+
+UINT8
+RUNTIMEFUNCTION
+RtBCDtoDecimal(
+    IN  UINT8 BcdValue
+    );
+
+//
+// Virtual mapping transition support.  (Only used during
+// the virtual address change transisition)
+//
+
+VOID
+RUNTIMEFUNCTION
+RtLibEnableVirtualMappings (
+    VOID
+    );
+
+VOID
+RUNTIMEFUNCTION
+RtConvertList (
+    IN UINTN            DebugDisposition,
+    IN OUT LIST_ENTRY   *ListHead
+    );
+
+VOID
+RUNTIMEFUNCTION
+RtAcquireLock (
+    IN FLOCK    *Lock
+    );
+
+VOID
+RUNTIMEFUNCTION
+RtReleaseLock (
+    IN FLOCK    *Lock
+    );
+
+
+#endif
diff --git a/linux-x86_64/gnu-efi/include/efi/efiser.h b/linux-x86_64/gnu-efi/include/efi/efiser.h
new file mode 100644
index 0000000..fcc97a1
--- /dev/null
+++ b/linux-x86_64/gnu-efi/include/efi/efiser.h
@@ -0,0 +1,132 @@
+#ifndef _EFI_SER_H
+#define _EFI_SER_H
+
+/*++
+
+Copyright (c) 1998  Intel Corporation
+
+Module Name:
+
+    efiser.h
+
+Abstract:
+
+    EFI serial protocol
+
+Revision History
+
+--*/
+
+//
+// Serial protocol
+//
+
+#define SERIAL_IO_PROTOCOL \
+    { 0xBB25CF6F, 0xF1D4, 0x11D2, {0x9A, 0x0C, 0x00, 0x90, 0x27, 0x3F, 0xC1, 0xFD} }
+
+INTERFACE_DECL(_SERIAL_IO_INTERFACE);
+
+typedef enum {
+    DefaultParity,      
+    NoParity,           
+    EvenParity,
+    OddParity,
+    MarkParity,
+    SpaceParity
+} EFI_PARITY_TYPE;
+
+typedef enum {
+    DefaultStopBits,        
+    OneStopBit,         // 1 stop bit
+    OneFiveStopBits,    // 1.5 stop bits
+    TwoStopBits         // 2 stop bits
+} EFI_STOP_BITS_TYPE;
+
+#define EFI_SERIAL_CLEAR_TO_SEND                   0x0010  // RO
+#define EFI_SERIAL_DATA_SET_READY                  0x0020  // RO
+#define EFI_SERIAL_RING_INDICATE                   0x0040  // RO
+#define EFI_SERIAL_CARRIER_DETECT                  0x0080  // RO
+#define EFI_SERIAL_REQUEST_TO_SEND                 0x0002  // WO
+#define EFI_SERIAL_DATA_TERMINAL_READY             0x0001  // WO
+#define EFI_SERIAL_INPUT_BUFFER_EMPTY              0x0100  // RO
+#define EFI_SERIAL_OUTPUT_BUFFER_EMPTY             0x0200  // RO
+#define EFI_SERIAL_HARDWARE_LOOPBACK_ENABLE        0x1000  // RW
+#define EFI_SERIAL_SOFTWARE_LOOPBACK_ENABLE        0x2000  // RW
+#define EFI_SERIAL_HARDWARE_FLOW_CONTROL_ENABLE    0x4000  // RW
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_SERIAL_RESET) (
+    IN struct _SERIAL_IO_INTERFACE  *This
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_SERIAL_SET_ATTRIBUTES) (
+    IN struct _SERIAL_IO_INTERFACE  *This,
+    IN UINT64                       BaudRate,
+    IN UINT32                       ReceiveFifoDepth,
+    IN UINT32                       Timeout,
+    IN EFI_PARITY_TYPE              Parity,
+    IN UINT8                        DataBits,
+    IN EFI_STOP_BITS_TYPE           StopBits
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_SERIAL_SET_CONTROL_BITS) (
+    IN struct _SERIAL_IO_INTERFACE  *This,
+    IN UINT32                       Control
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_SERIAL_GET_CONTROL_BITS) (
+    IN struct _SERIAL_IO_INTERFACE  *This,
+    OUT UINT32                      *Control
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_SERIAL_WRITE) (
+    IN struct _SERIAL_IO_INTERFACE  *This,
+    IN OUT UINTN                    *BufferSize,
+    IN VOID                         *Buffer
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_SERIAL_READ) (
+    IN struct _SERIAL_IO_INTERFACE  *This,
+    IN OUT UINTN                    *BufferSize,
+    OUT VOID                        *Buffer
+    );
+
+typedef struct {
+    UINT32                  ControlMask;
+
+    // current Attributes
+    UINT32                  Timeout;
+    UINT64                  BaudRate;
+    UINT32                  ReceiveFifoDepth;
+    UINT32                  DataBits;
+    UINT32                  Parity;
+    UINT32                  StopBits;
+} SERIAL_IO_MODE;
+
+#define SERIAL_IO_INTERFACE_REVISION    0x00010000
+
+typedef struct _SERIAL_IO_INTERFACE {
+    UINT32                       Revision;
+    EFI_SERIAL_RESET             Reset;
+    EFI_SERIAL_SET_ATTRIBUTES    SetAttributes;
+    EFI_SERIAL_SET_CONTROL_BITS  SetControl;
+    EFI_SERIAL_GET_CONTROL_BITS  GetControl;
+    EFI_SERIAL_WRITE             Write;
+    EFI_SERIAL_READ              Read;
+
+    SERIAL_IO_MODE               *Mode;
+} SERIAL_IO_INTERFACE;
+
+#endif
+
diff --git a/linux-x86_64/gnu-efi/include/efi/efistdarg.h b/linux-x86_64/gnu-efi/include/efi/efistdarg.h
new file mode 100644
index 0000000..8a96b94
--- /dev/null
+++ b/linux-x86_64/gnu-efi/include/efi/efistdarg.h
@@ -0,0 +1,33 @@
+#ifndef _EFISTDARG_H_
+#define _EFISTDARG_H_
+
+/*++
+
+Copyright (c) 1998  Intel Corporation
+
+Module Name:
+
+    devpath.h
+
+Abstract:
+
+    Defines for parsing the EFI Device Path structures
+
+
+
+Revision History
+
+--*/
+#ifdef __GNUC__
+#include "stdarg.h"
+#else
+#define _INTSIZEOF(n)   ( (sizeof(n) + sizeof(UINTN) - 1) & ~(sizeof(UINTN) - 1) )
+
+typedef CHAR8 * va_list;
+
+#define va_start(ap,v)  ( ap = (va_list)&v + _INTSIZEOF(v) )
+#define va_arg(ap,t)    ( *(t *)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)) )
+#define va_end(ap)  ( ap = (va_list)0 )
+#endif
+
+#endif  /* _INC_STDARG */
diff --git a/linux-x86_64/gnu-efi/include/efi/efiui.h b/linux-x86_64/gnu-efi/include/efi/efiui.h
new file mode 100644
index 0000000..7341943
--- /dev/null
+++ b/linux-x86_64/gnu-efi/include/efi/efiui.h
@@ -0,0 +1,54 @@
+#ifndef _EFI_UI_H
+#define _EFI_UI_H
+
+/*++
+
+Copyright (c) 200  Intel Corporation
+
+Module Name:
+
+    EfiUi.h
+    
+Abstract:   
+    Protocol used to build User Interface (UI) stuff.
+
+    This protocol is just data. It is a multi dimentional array.
+    For each string there is an array of UI_STRING_ENTRY. Each string
+    is for a different language translation of the same string. The list 
+    is terminated by a NULL UiString. There can be any number of 
+    UI_STRING_ENTRY arrays. A NULL array terminates the list. A NULL array
+    entry contains all zeros.  
+
+    Thus the shortest possible EFI_UI_PROTOCOL has three UI_STRING_ENTRY.
+    The String, it's NULL terminator, and the NULL terminator for the entire 
+    thing.
+
+
+Revision History
+
+--*/
+
+#define EFI_UI_PROTOCOL \
+    { 0x32dd7981, 0x2d27, 0x11d4, {0xbc, 0x8b, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81} }
+
+
+typedef enum {
+    UiDeviceString,
+    UiVendorString,
+    UiMaxString
+} UI_STRING_TYPE;
+
+typedef struct {
+    ISO_639_2   *LangCode;
+    CHAR16      *UiString;
+} UI_STRING_ENTRY;
+
+#define EFI_UI_VERSION      0x00010000
+
+typedef struct _UI_INTERFACE {
+    UINT32          Version;
+    UI_STRING_ENTRY *Entry;
+} UI_INTERFACE;
+
+
+#endif
diff --git a/linux-x86_64/gnu-efi/include/efi/libsmbios.h b/linux-x86_64/gnu-efi/include/efi/libsmbios.h
new file mode 100644
index 0000000..8f1a28e
--- /dev/null
+++ b/linux-x86_64/gnu-efi/include/efi/libsmbios.h
@@ -0,0 +1,132 @@
+#ifndef _LIB_SMBIOS_H
+#define _LIB_SMBIOS_H
+/*++
+
+Copyright (c) 2000  Intel Corporation
+
+Module Name:
+
+    LibSmbios.h
+    
+Abstract:
+
+    Lib include  for SMBIOS services. Used to get system serial number and GUID
+
+Revision History
+
+--*/
+
+//
+// Define SMBIOS tables.
+//
+#pragma pack(1)
+typedef struct {
+    UINT8   AnchorString[4];
+    UINT8   EntryPointStructureChecksum;
+    UINT8   EntryPointLength;
+    UINT8   MajorVersion;
+    UINT8   MinorVersion;
+    UINT16  MaxStructureSize;
+    UINT8   EntryPointRevision;
+    UINT8   FormattedArea[5];
+    UINT8   IntermediateAnchorString[5];
+    UINT8   IntermediateChecksum;
+    UINT16  TableLength;
+    UINT32  TableAddress;
+    UINT16  NumberOfSmbiosStructures;
+    UINT8   SmbiosBcdRevision;
+} SMBIOS_STRUCTURE_TABLE;
+
+//
+// Please note that SMBIOS structures can be odd byte aligned since the
+//  unformated section of each record is a set of arbitrary size strings.
+//
+
+typedef struct {
+    UINT8   Type;
+    UINT8   Length;
+    UINT8   Handle[2];
+} SMBIOS_HEADER;
+
+typedef UINT8   SMBIOS_STRING;
+
+typedef struct {
+    SMBIOS_HEADER   Hdr;
+    SMBIOS_STRING   Vendor;
+    SMBIOS_STRING   BiosVersion;
+    UINT8           BiosSegment[2];
+    SMBIOS_STRING   BiosReleaseDate;
+    UINT8           BiosSize;
+    UINT8           BiosCharacteristics[8];
+} SMBIOS_TYPE0;
+
+typedef struct {
+    SMBIOS_HEADER   Hdr;
+    SMBIOS_STRING   Manufacturer;
+    SMBIOS_STRING   ProductName;
+    SMBIOS_STRING   Version;
+    SMBIOS_STRING   SerialNumber;
+
+    //
+    // always byte copy this data to prevent alignment faults!
+    //
+    EFI_GUID        Uuid;
+    
+    UINT8           WakeUpType;
+} SMBIOS_TYPE1;
+
+typedef struct {
+    SMBIOS_HEADER   Hdr;
+    SMBIOS_STRING   Manufacturer;
+    SMBIOS_STRING   ProductName;
+    SMBIOS_STRING   Version;
+    SMBIOS_STRING   SerialNumber;
+} SMBIOS_TYPE2;
+
+typedef struct {
+    SMBIOS_HEADER   Hdr;
+    SMBIOS_STRING   Manufacturer;
+    UINT8           Type;
+    SMBIOS_STRING   Version;
+    SMBIOS_STRING   SerialNumber;
+    SMBIOS_STRING   AssetTag;
+    UINT8           BootupState;
+    UINT8           PowerSupplyState;
+    UINT8           ThermalState;
+    UINT8           SecurityStatus;
+    UINT8           OemDefined[4];
+} SMBIOS_TYPE3;
+
+typedef struct {
+    SMBIOS_HEADER   Hdr;
+    UINT8           Socket;
+    UINT8           ProcessorType;
+    UINT8           ProcessorFamily;
+    SMBIOS_STRING   ProcessorManufacture;
+    UINT8           ProcessorId[8];
+    SMBIOS_STRING   ProcessorVersion;
+    UINT8           Voltage;
+    UINT8           ExternalClock[2];
+    UINT8           MaxSpeed[2];
+    UINT8           CurrentSpeed[2];
+    UINT8           Status;
+    UINT8           ProcessorUpgrade;
+    UINT8           L1CacheHandle[2];
+    UINT8           L2CacheHandle[2];
+    UINT8           L3CacheHandle[2];
+} SMBIOS_TYPE4;
+
+typedef union {
+    SMBIOS_HEADER   *Hdr;
+    SMBIOS_TYPE0    *Type0;
+    SMBIOS_TYPE1    *Type1;
+    SMBIOS_TYPE2    *Type2;
+    SMBIOS_TYPE3    *Type3;
+    SMBIOS_TYPE4    *Type4;
+    UINT8           *Raw;
+} SMBIOS_STRUCTURE_POINTER;
+#pragma pack()
+
+
+#endif
+
diff --git a/linux-x86_64/gnu-efi/include/efi/pci22.h b/linux-x86_64/gnu-efi/include/efi/pci22.h
new file mode 100644
index 0000000..b94f519
--- /dev/null
+++ b/linux-x86_64/gnu-efi/include/efi/pci22.h
@@ -0,0 +1,193 @@
+#ifndef _PCI22_H
+#define _PCI22_H
+
+/*++
+
+Copyright (c) 1999  Intel Corporation
+
+Module Name:
+
+    pci22.h
+    
+Abstract:      
+    Support for PCI 2.2 standard.
+
+
+
+
+Revision History
+
+--*/
+
+#ifdef SOFT_SDV
+#define PCI_MAX_BUS     1
+#else
+#define PCI_MAX_BUS     255
+#endif
+
+#define PCI_MAX_DEVICE  31
+#define PCI_MAX_FUNC    7
+
+//
+// Command
+//
+#define PCI_VGA_PALETTE_SNOOP_DISABLED   0x20
+
+#pragma pack(1)
+typedef struct {
+    UINT16      VendorId;
+    UINT16      DeviceId;
+    UINT16      Command;
+    UINT16      Status;
+    UINT8       RevisionID;
+    UINT8       ClassCode[3];
+    UINT8       CacheLineSize;
+    UINT8       LaytencyTimer;
+    UINT8       HeaderType;
+    UINT8       BIST;
+} PCI_DEVICE_INDEPENDENT_REGION;
+
+typedef struct {
+    UINT32      Bar[6];
+    UINT32      CISPtr;
+    UINT16      SubsystemVendorID;
+    UINT16      SubsystemID;
+    UINT32      ExpansionRomBar;
+    UINT32      Reserved[2];
+    UINT8       InterruptLine;
+    UINT8       InterruptPin;
+    UINT8       MinGnt;
+    UINT8       MaxLat;     
+} PCI_DEVICE_HEADER_TYPE_REGION;
+
+typedef struct {
+    PCI_DEVICE_INDEPENDENT_REGION   Hdr;
+    PCI_DEVICE_HEADER_TYPE_REGION   Device;
+} PCI_TYPE00;
+
+typedef struct {              
+    UINT32      Bar[2];
+    UINT8       PrimaryBus;
+    UINT8       SecondaryBus;
+    UINT8       SubordinateBus;
+    UINT8       SecondaryLatencyTimer;
+    UINT8       IoBase;
+    UINT8       IoLimit;
+    UINT16      SecondaryStatus;
+    UINT16      MemoryBase;
+    UINT16      MemoryLimit;
+    UINT16      PrefetchableMemoryBase;
+    UINT16      PrefetchableMemoryLimit;
+    UINT32      PrefetchableBaseUpper32;
+    UINT32      PrefetchableLimitUpper32;
+    UINT16      IoBaseUpper16;
+    UINT16      IoLimitUpper16;
+    UINT32      Reserved;
+    UINT32      ExpansionRomBAR;
+    UINT8       InterruptLine;
+    UINT8       InterruptPin;
+    UINT16      BridgeControl;
+} PCI_BRIDGE_CONTROL_REGISTER;
+
+#define PCI_CLASS_DISPLAY_CTRL          0x03
+#define PCI_CLASS_VGA                   0x00
+
+#define PCI_CLASS_BRIDGE                0x06
+#define PCI_CLASS_ISA                   0x01
+#define PCI_CLASS_ISA_POSITIVE_DECODE   0x80
+
+#define PCI_CLASS_NETWORK               0x02 
+#define PCI_CLASS_ETHERNET              0x00
+        
+#define HEADER_TYPE_DEVICE              0x00
+#define HEADER_TYPE_PCI_TO_PCI_BRIDGE   0x01
+#define HEADER_TYPE_MULTI_FUNCTION      0x80
+#define HEADER_LAYOUT_CODE              0x7f
+
+#define IS_PCI_BRIDGE(_p) ((((_p)->Hdr.HeaderType) & HEADER_LAYOUT_CODE) == HEADER_TYPE_PCI_TO_PCI_BRIDGE)        
+#define IS_PCI_MULTI_FUNC(_p)   (((_p)->Hdr.HeaderType) & HEADER_TYPE_MULTI_FUNCTION)         
+
+typedef struct {
+    PCI_DEVICE_INDEPENDENT_REGION   Hdr;
+    PCI_BRIDGE_CONTROL_REGISTER     Bridge;
+} PCI_TYPE01;
+
+typedef struct {
+    UINT8   Register;
+    UINT8   Function;
+    UINT8   Device;
+    UINT8   Bus;
+    UINT8   Reserved[4];
+} DEFIO_PCI_ADDR;
+
+typedef struct {
+    UINT32  Reg     : 8;
+    UINT32  Func    : 3;
+    UINT32  Dev     : 5;
+    UINT32  Bus     : 8;
+    UINT32  Reserved: 7;
+    UINT32  Enable  : 1;
+} PCI_CONFIG_ACCESS_CF8;
+
+#pragma pack()
+
+#define EFI_ROOT_BRIDGE_LIST    'eprb'
+typedef struct {
+    UINTN           Signature;
+
+    UINT16          BridgeNumber;
+    UINT16          PrimaryBus;
+    UINT16          SubordinateBus;
+
+    EFI_DEVICE_PATH *DevicePath;
+
+    LIST_ENTRY      Link;
+} PCI_ROOT_BRIDGE_ENTRY;
+
+
+#define PCI_EXPANSION_ROM_HEADER_SIGNATURE        0xaa55
+#define EFI_PCI_EXPANSION_ROM_HEADER_EFISIGNATURE 0x0EF1
+#define PCI_DATA_STRUCTURE_SIGNATURE              EFI_SIGNATURE_32('P','C','I','R')
+
+#pragma pack(1)
+typedef struct {
+    UINT16          Signature;              // 0xaa55
+    UINT8           Reserved[0x16];
+    UINT16          PcirOffset;
+} PCI_EXPANSION_ROM_HEADER;
+
+
+typedef struct {
+    UINT16          Signature;              // 0xaa55
+    UINT16          InitializationSize;
+    UINT16          EfiSignature;           // 0x0EF1
+    UINT16          EfiSubsystem;
+    UINT16          EfiMachineType;
+    UINT8           Reserved[0x0A];
+    UINT16          EfiImageHeaderOffset;
+    UINT16          PcirOffset;
+} EFI_PCI_EXPANSION_ROM_HEADER;
+
+typedef struct {
+    UINT32          Signature;              // "PCIR" 
+    UINT16          VendorId;
+    UINT16          DeviceId;
+    UINT16          Reserved0;
+    UINT16          Length;
+    UINT8           Revision;
+    UINT8           ClassCode[3];
+    UINT16          ImageLength;
+    UINT16          CodeRevision;
+    UINT8           CodeType;
+    UINT8           Indicator;
+    UINT16          Reserved1;
+} PCI_DATA_STRUCTURE;
+#pragma pack()
+
+#endif
+    
+
+
+
+
+    
diff --git a/linux-x86_64/gnu-efi/include/efi/protocol/adapterdebug.h b/linux-x86_64/gnu-efi/include/efi/protocol/adapterdebug.h
new file mode 100644
index 0000000..d70af5d
--- /dev/null
+++ b/linux-x86_64/gnu-efi/include/efi/protocol/adapterdebug.h
@@ -0,0 +1,32 @@
+#ifndef _ADAPTER_DEBUG_H
+#define _ADAPTER_DEBUG_H
+
+/*++
+
+Copyright (c) 1999  Intel Corporation
+
+Module Name:
+
+    AdapterDebug.h
+    
+Abstract:
+
+    Protocol to debug the EDD 3.0 enablement of BIOS option ROMs
+
+
+
+Revision History
+
+--*/
+
+// {82F86881-282B-11d4-BC7D-0080C73C8881}
+#define ADAPTER_DEBUG_PROTOCOL \
+{ 0x82f86881, 0x282b, 0x11d4, {0xbc, 0x7d, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81} }
+
+//
+// This protocol points to the BIOS_LEGACY_DRIVE data structure
+//  see edd.h for more details
+//
+
+#endif
+
diff --git a/linux-x86_64/gnu-efi/include/efi/protocol/eficonsplit.h b/linux-x86_64/gnu-efi/include/efi/protocol/eficonsplit.h
new file mode 100644
index 0000000..15adb92
--- /dev/null
+++ b/linux-x86_64/gnu-efi/include/efi/protocol/eficonsplit.h
@@ -0,0 +1,32 @@
+#ifndef _EFI_CONFORK_H
+#define _EFI_CONFORK_H
+/*++
+
+Copyright (c) 1999  Intel Corporation
+
+Module Name:
+
+Abstract:
+
+
+
+Revision History
+
+--*/
+
+
+
+//
+// ConOut Forker Protocol
+//
+
+#define TEXT_OUT_SPLITER_PROTOCOL    \
+    { 0x56d830a0, 0x7e7a, 0x11d3, {0xbb, 0xa0, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b} }
+
+#define ERROR_OUT_SPLITER_PROTOCOL    \
+    { 0xf0ba9039, 0x68f1, 0x425e, {0xaa, 0x7f, 0xd9, 0xaa, 0xf9, 0x1b, 0x82, 0xa1}}
+
+#define TEXT_IN_SPLITER_PROTOCOL    \
+    { 0xf9a3c550, 0x7fb5, 0x11d3, {0xbb, 0xa0, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b} }
+
+#endif
diff --git a/linux-x86_64/gnu-efi/include/efi/protocol/efidbg.h b/linux-x86_64/gnu-efi/include/efi/protocol/efidbg.h
new file mode 100644
index 0000000..1f95a70
--- /dev/null
+++ b/linux-x86_64/gnu-efi/include/efi/protocol/efidbg.h
@@ -0,0 +1,210 @@
+/*
+ * Copyright (c) 1999, 2000
+ * Intel Corporation.
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ * 
+ *    This product includes software developed by Intel Corporation and
+ *    its contributors.
+ * 
+ * 4. Neither the name of Intel Corporation or its contributors may be
+ *    used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY INTEL CORPORATION AND CONTRIBUTORS ``AS IS''
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL INTEL CORPORATION OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * 
+ */
+
+
+#ifndef _EFIDBG_H_
+#define _EFIDBG_H_
+
+#include "eficontext.h"
+#include "efiser.h"
+
+typedef struct _DEBUGPORT_16550_CONFIG_DATA {
+        UINT32							PortAddress;
+        UINT64                          BaudRate;
+    	UINT32               			ReceiveFifoDepth;
+    	UINT32               			Timeout;
+        UINT8                           Parity;
+        UINT8                           DataBits;
+        UINT8                           StopBits;
+	    UINT32                       	ControlMask;
+        BOOLEAN							RtsCtsEnable;		// RTS, CTS control
+} DEBUGPORT_16550_CONFIG_DATA;
+
+typedef struct _DEBUGPORT_16550_DEVICE_PATH {
+        EFI_DEVICE_PATH                 Header;
+        DEBUGPORT_16550_CONFIG_DATA		ConfigData;
+} DEBUGPORT_16550_DEVICE_PATH;
+
+typedef union {
+    EFI_DEVICE_PATH                     DevPath;
+    DEBUGPORT_16550_DEVICE_PATH         Uart;
+    // add new types of debugport device paths to this union...
+} DEBUGPORT_DEV_PATH;
+
+
+//
+// Debug Support protocol {2755590C-6F3C-42FA-9EA4-A3BA543CDA25}
+//
+
+#define DEBUG_SUPPORT_PROTOCOL \
+{ 0x2755590C, 0x6F3C, 0x42fa, 0x9E, 0xA4, 0xA3, 0xBA, 0x54, 0x3C, 0xDA, 0x25 }
+
+
+typedef UINTN EXCEPTION_TYPE;
+
+typedef
+VOID
+(*EXCEPTION_HANDLER) (
+	IN EXCEPTION_TYPE ExceptionType,
+    IN SYSTEM_CONTEXT *SystemContext
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_REGISTER_TIMER_TICK_CALLBACK) (
+    IN struct _EFI_DEBUG_SUPPORT_INTERFACE  *This,
+    IN EXCEPTION_HANDLER	                TimerTickCallback
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_REGISTER_EXCEPTION_HANDLER) (
+    IN     struct _EFI_DEBUG_SUPPORT_INTERFACE  *This,
+    IN     EXCEPTION_HANDLER                    ExceptionHandler,
+    IN     EXCEPTION_TYPE                       ExceptionType
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_IP_CALL_TRACE) (
+    IN     struct _EFI_DEBUG_SUPPORT_INTERFACE  *This
+    );
+
+
+#define EFI_DEBUG_SUPPORT_INTERFACE_REVISION     0x00010000
+
+typedef struct _EFI_DEBUG_SUPPORT_INTERFACE {
+    UINT32                          	Revision;
+    EFI_REGISTER_TIMER_TICK_CALLBACK	RegisterTimerTickCallback;
+    EFI_REGISTER_EXCEPTION_HANDLER  	RegisterExceptionHandler;
+    EFI_IP_CALL_TRACE               	IpCallTrace;
+} EFI_DEBUG_SUPPORT_INTERFACE;
+
+
+//
+// Debugport io protocol {EBA4E8D2-3858-41EC-A281-2647BA9660D0}
+//
+
+#define DEBUGPORT_IO_PROTOCOL \
+{ 0XEBA4E8D2, 0X3858, 0X41EC, 0XA2, 0X81, 0X26, 0X47, 0XBA, 0X96, 0X60, 0XD0 }
+ 
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_DEBUGPORT_IO_RESET) (
+    IN struct _EFI_DEBUGPORT_IO_INTERFACE  	*This
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_DEBUGPORT_IO_READ) (
+    IN     struct _EFI_DEBUGPORT_IO_INTERFACE	*This,
+    IN OUT UINTN                    		*BufferSize,
+    OUT VOID                         		*Buffer
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_DEBUGPORT_IO_WRITE) (
+    IN     struct _EFI_DEBUGPORT_IO_INTERFACE *This,
+    IN OUT UINTN                    		*BufferSize,
+    IN VOID                         		*Buffer
+    );
+
+#define EFI_DEBUGPORT_IO_INTERFACE_REVISION   0x00010000
+
+typedef struct _EFI_DEBUGPORT_IO_INTERFACE {
+    UINT32                          		Revision;
+    EFI_DEBUGPORT_IO_READ					Read;
+    EFI_DEBUGPORT_IO_WRITE					Write;
+    EFI_DEBUGPORT_IO_RESET					Reset;
+} EFI_DEBUGPORT_IO_INTERFACE;
+
+
+//
+// Debugport UART16550 control protocol {628EA978-4C26-4605-BC02-A42A496917DD}
+//
+
+#define DEBUGPORT_UART16550_CONTROL_PROTOCOL \
+{ 0X628EA978, 0X4C26, 0X4605, 0XBC, 0X2, 0XA4, 0X2A, 0X49, 0X69, 0X17, 0XDD }
+ 
+// Note: The definitions for EFI_PARITY_TYPE, EFI_STOP_BITS_TYPE, and 
+// SERIAL_IO_MODE are included from efiser.h
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_UART16550_SET_ATTRIBUTES) (
+    IN struct _EFI_DEBUGPORT_UART16550_CONTROL_INTERFACE  	*This,
+    IN UINT64                       	BaudRate,
+    IN UINT32                       	ReceiveFifoDepth,
+    IN UINT32                       	Timeout,
+    IN EFI_PARITY_TYPE       			Parity,
+    IN UINT8                        	DataBits,
+    IN EFI_STOP_BITS_TYPE    			StopBits
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_UART16550_SET_CONTROL_BITS) (
+    IN struct _EFI_DEBUGPORT_UART16550_CONTROL_INTERFACE  	*This,
+    IN UINT32                       	Control
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_UART16550_GET_CONTROL_BITS) (
+    IN struct _EFI_DEBUGPORT_UART16550_CONTROL_INTERFACE	*This,
+    OUT UINT32                      	*Control
+    );
+
+#define EFI_DEBUGPORT_UART16550_CONTROL_INTERFACE_REVISION   0x00010000
+
+typedef struct _EFI_DEBUGPORT_UART16550_CONTROL_INTERFACE {
+    UINT32                          	Revision;
+	EFI_UART16550_SET_ATTRIBUTES		SetAttributes;
+	EFI_UART16550_SET_CONTROL_BITS		SetControl;
+	EFI_UART16550_GET_CONTROL_BITS 		GetControl;
+	DEBUGPORT_16550_CONFIG_DATA			*Mode;
+} EFI_DEBUGPORT_UART16550_CONTROL_INTERFACE;
+        
+
+#define DEVICE_PATH_DEBUGPORT DEBUGPORT_IO_PROTOCOL
+        
+#endif /* _EFIDBG_H_ */
diff --git a/linux-x86_64/gnu-efi/include/efi/protocol/efivar.h b/linux-x86_64/gnu-efi/include/efi/protocol/efivar.h
new file mode 100644
index 0000000..92dc506
--- /dev/null
+++ b/linux-x86_64/gnu-efi/include/efi/protocol/efivar.h
@@ -0,0 +1,133 @@
+/*++
+
+Copyright (c) 1998  Intel Corporation
+
+Module Name:
+
+Abstract:
+
+
+
+Revision History
+
+--*/
+
+
+
+//
+// The variable store protocol interface is specific to the reference
+// implementation.  The initialization code adds variable store devices
+// to the system, and the FW connects to the devices to provide the
+// variable store interfaces through these devices.
+//
+
+//
+// Variable Store Device protocol
+//
+
+#define VARIABLE_STORE_PROTOCOL    \
+    { 0xf088cd91, 0xa046, 0x11d2, {0x8e, 0x42, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b} }
+
+INTERFACE_DECL(_EFI_VARIABLE_STORE);
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_STORE_CLEAR) (
+    IN struct _EFI_VARIABLE_STORE   *This,
+    IN UINTN                        BankNo,
+    IN OUT VOID                     *Scratch
+    );
+
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_STORE_READ) (
+    IN struct _EFI_VARIABLE_STORE   *This,
+    IN UINTN                        BankNo,
+    IN UINTN                        Offset,
+    IN UINTN                        BufferSize,
+    OUT VOID                        *Buffer
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_STORE_UPDATE) (
+    IN struct _EFI_VARIABLE_STORE   *This,
+    IN UINTN                        BankNo,
+    IN UINTN                        Offset,
+    IN UINTN                        BufferSize,
+    IN VOID                         *Buffer
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_STORE_SIZE) (
+    IN struct _EFI_VARIABLE_STORE   *This,
+    IN UINTN                        NoBanks
+    );
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_TRANSACTION_UPDATE) (
+    IN struct _EFI_VARIABLE_STORE   *This,
+    IN UINTN                        BankNo,
+    IN VOID                         *NewContents
+    );
+
+typedef struct _EFI_VARIABLE_STORE {
+
+    //
+    // Number of banks and bank size
+    //
+
+    UINT32                      Attributes;
+    UINT32                      BankSize;
+    UINT32                      NoBanks;
+
+    //
+    // Functions to access the storage banks
+    //
+
+    EFI_STORE_CLEAR             ClearStore;
+    EFI_STORE_READ              ReadStore;
+    EFI_STORE_UPDATE            UpdateStore;
+    EFI_STORE_SIZE              SizeStore OPTIONAL;
+    EFI_TRANSACTION_UPDATE      TransactionUpdate OPTIONAL;
+
+} EFI_VARIABLE_STORE;
+
+
+//
+//
+// ClearStore()     - A function to clear the requested storage bank.  A cleared
+//      bank contains all "on" bits.
+//
+// ReadStore()      - Read data from the requested store.
+//
+// UpdateStore()    - Updates data on the requested store. The FW will only
+//      ever issue updates to clear bits in the store. Updates must be
+//      performed in LSb to MSb order of the update buffer.
+//
+// SizeStore()      - An optional function for non-runtime stores that can be
+//      dynamically sized.  The FW will only ever increase or decrease the store
+//      by 1 banksize at a time, and it is always adding or removing a bank from 
+//      the end of the store.
+//
+// By default the FW will update variables and storage banks in an
+// "atomic" manner by keeping 1 old copy of the data during an update,
+// and recovering appropiately if the power is lost during the middle
+// of an operation.  To do this the FW needs to have multiple banks
+// of storage dedicated to its use. If that's not possible, the driver 
+// can implement an atomic bank update function and the FW will allow 
+// 1 bank in this case.  (It will allow any number of banks,
+// but it won't require an "extra" bank to provide its bank transaction 
+// function).
+//
+// TransactionUpdate()  - An optional function that can clear & update an 
+//      entire bank in an "atomic" fashion.  If the operation fails in the 
+//      middle the driver is responsible for having either the previous copy 
+//      of the bank's data or the new copy.  A copy that's partially written
+//      is not valid as internal data settings may get lost.  Supply this
+//      function only when needed.
+//
+
diff --git a/linux-x86_64/gnu-efi/include/efi/protocol/intload.h b/linux-x86_64/gnu-efi/include/efi/protocol/intload.h
new file mode 100644
index 0000000..fb24e3f
--- /dev/null
+++ b/linux-x86_64/gnu-efi/include/efi/protocol/intload.h
@@ -0,0 +1,27 @@
+/*++
+
+Copyright (c) 1999 Intel Corporation
+
+Module Name:
+
+    intload
+
+Abstract:
+
+    EFI support for loading internally linked in apps
+
+
+
+Revision History
+
+--*/
+
+#ifndef _INTERNAL_LOAD_INCLUDE_
+#define _INTERNAL_LOAD_INCLUDE_
+
+// {D65A6B8C-71E5-4df0-A909-F0D2992B5AA9}
+#define INTERNAL_SHELL_GUID \
+    { 0xd65a6b8c, 0x71e5, 0x4df0, {0xa9, 0x09, 0xf0, 0xd2, 0x99, 0x2b, 0x5a, 0xa9} }
+
+
+#endif
diff --git a/linux-x86_64/gnu-efi/include/efi/protocol/legacyboot.h b/linux-x86_64/gnu-efi/include/efi/protocol/legacyboot.h
new file mode 100644
index 0000000..16e94e7
--- /dev/null
+++ b/linux-x86_64/gnu-efi/include/efi/protocol/legacyboot.h
@@ -0,0 +1,119 @@
+/*++
+
+Copyright (c) 1999 Intel Corporation
+
+Module Name:
+
+    legacyboot
+
+Abstract:
+
+    EFI support for legacy boot
+
+
+
+Revision History
+
+--*/
+
+#ifndef _LEGACY_BOOT_INCLUDE_
+#define _LEGACY_BOOT_INCLUDE_
+
+#define LEGACY_BOOT_PROTOCOL \
+    { 0x376e5eb2, 0x30e4, 0x11d3, { 0xba, 0xe5, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81 } }
+
+#pragma pack(1)
+
+//
+// BBS 1.01 (See Appendix A) IPL and BCV Table Entry Data structure.
+//  Seg:Off pointers have been converted to EFI pointers in this data structure
+//  This is the structure that also maps to the EFI device path for the boot selection
+//
+typedef struct {
+    UINT16  DeviceType;
+    UINT16  StatusFlag;
+    UINT32  Reserved;
+    VOID    *BootHandler;   // Not an EFI entry point
+    CHAR8   *DescString;
+} BBS_TABLE_ENTRY;
+#pragma pack()
+
+typedef
+EFI_STATUS
+(EFIAPI *LEGACY_BOOT_CALL) (
+    IN EFI_DEVICE_PATH      *DevicePath
+    );
+
+
+//
+// BBS support functions
+//  PnP Call numbers and BiosSelector hidden in implementation
+//
+
+typedef enum {
+    IplRelative,
+    BcvRelative
+} BBS_TYPE;
+
+INTERFACE_DECL(_LEGACY_BOOT_INTERFACE);
+
+//
+// == PnP Function 0x60 then BbsVersion == 0x0101 if this call fails then BbsVersion == 0x0000
+//
+
+//
+// == PnP Function 0x61
+//
+typedef
+EFI_STATUS
+(EFIAPI *GET_DEVICE_COUNT) (
+    IN  struct _LEGACY_BOOT_INTERFACE   *This,
+    IN  BBS_TYPE        *TableType,
+    OUT UINTN           *DeviceCount,
+    OUT UINTN           *MaxCount
+    );
+
+//
+// == PnP Function 0x62
+//
+typedef
+EFI_STATUS
+(EFIAPI *GET_PRIORITY_AND_TABLE) (
+    IN  struct _LEGACY_BOOT_INTERFACE   *This,
+    IN  BBS_TYPE        *TableType,
+    IN OUT  UINTN       *PrioritySize, // MaxCount * sizeof(UINT8)
+    OUT     UINTN       *Priority,
+    IN OUT  UINTN       *TableSize,    // MaxCount * sizeof(BBS_TABLE_ENTRY)
+    OUT BBS_TABLE_ENTRY *TableEntrySize
+    );
+
+//
+// == PnP Function 0x63
+//
+typedef
+EFI_STATUS
+(EFIAPI *SET_PRIORITY) (
+    IN  struct _LEGACY_BOOT_INTERFACE   *This,
+    IN  BBS_TYPE        *TableType,
+    IN OUT  UINTN       *PrioritySize,
+    OUT     UINTN       *Priority
+    );
+
+typedef struct _LEGACY_BOOT_INTERFACE {
+    LEGACY_BOOT_CALL    BootIt;
+
+    //
+    // New functions to allow BBS booting to be configured from EFI
+    //
+    UINTN                   BbsVersion;     // Currently 0x0101
+    GET_DEVICE_COUNT        GetDeviceCount;
+    GET_PRIORITY_AND_TABLE  GetPriorityAndTable;
+    SET_PRIORITY            SetPriority;   
+} LEGACY_BOOT_INTERFACE;
+
+EFI_STATUS
+PlInitializeLegacyBoot (
+    VOID
+    );
+
+#endif
diff --git a/linux-x86_64/gnu-efi/include/efi/protocol/piflash64.h b/linux-x86_64/gnu-efi/include/efi/protocol/piflash64.h
new file mode 100644
index 0000000..d521dfc
--- /dev/null
+++ b/linux-x86_64/gnu-efi/include/efi/protocol/piflash64.h
@@ -0,0 +1,121 @@
+#ifndef _PIFLASH64_H
+#define _PIFLASH64_H
+
+/*++
+
+Copyright (c) 1999  Intel Corporation
+
+Module Name:
+
+    PIflash64.h
+    
+Abstract:
+
+    Iflash64.efi protocol to abstract iflash from
+    the system.
+
+Revision History
+
+--*/
+
+//
+// Guid that identifies the IFLASH protocol
+//
+#define IFLASH64_PROTOCOL_PROTOCOL \
+    { 0x65cba110, 0x74ab, 0x11d3, 0xbb, 0x89, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81 };
+
+//
+// Unlock FLASH from StartAddress to EndAddress and return a LockKey
+//
+typedef
+EFI_STATUS
+(EFIAPI *UNLOCK_FLASH_API)(
+    IN struct _IFLASH64_PROTOCOL_INTERFACE  *This
+    );
+
+//
+// Lock the flash represented by the LockKey
+//
+typedef
+EFI_STATUS
+(EFIAPI *LOCK_FLASH_API)(
+    IN struct _IFLASH64_PROTOCOL_INTERFACE  *This
+    );
+
+//
+// Status callback for a utility like IFLASH64
+//
+//  Token would map to a list like Ted proposed. The utility has no idea what 
+//      happens on the other side.
+//  ErrorStatus - Level of Error or success. Independent of Token. If you 
+//      don't know the token you will at least know pass or fail.
+//  String - Optional extra information about the error. Could be used for 
+//      debug or future expansion
+//
+//  Attributes - Options screen attributes for String. Could allow the string to be different colors.
+//
+typedef
+EFI_STATUS
+(EFIAPI *UTILITY_PROGRESS_API)(
+    IN struct _IFLASH64_PROTOCOL_INTERFACE  *This,
+    IN  UINTN                               Token,
+    IN  EFI_STATUS                          ErrorStatus, 
+    IN  CHAR16                              *String,    OPTIONAL
+    IN  UINTN                               *Attributes OPTIONAL
+    );
+
+//
+// Token Values
+//
+// IFlash64 Token Codes
+#define IFLASH_TOKEN_IFLASHSTART    0xB0                // IFlash64 has started
+#define IFLASH_TOKEN_READINGFILE    0xB1                // Reading File
+#define IFLASH_TOKEN_INITVPP        0xB2                // Initializing Vpp
+#define IFLASH_TOKEN_DISABLEVPP     0x10                // Disable Vpp
+#define IFLASH_TOKEN_FLASHUNLOCK    0xB3                // Unlocking FLASH Devices
+#define IFLASH_TOKEN_FLASHERASE     0xB4                // Erasing FLASH Devices
+#define IFLASH_TOKEN_FLASHPROGRAM   0xB5                // Programming FLASH
+#define IFLASH_TOKEN_FLASHVERIFY    0xB6                // Verifying FLASH
+#define IFLASH_TOKEN_UPDATESUCCES   0xB7                // FLASH Updage Success!
+
+#define IFLASH_TOKEN_PROGRESS_READINGFILE   0x11        // % Reading File
+#define IFLASH_TOKEN_PROGRESS_FLASHUNLOCK   0x13        // % Unlocking FLASH Devices
+#define IFLASH_TOKEN_PROGRESS_FLASHERASE    0x14        // % Erasing FLASH Devices
+#define IFLASH_TOKEN_PROGRESS_FLASHPROGRAM  0x15        // % Programming FLASH
+#define IFLASH_TOKEN_PROGRESS_FLASHVERIFY   0x16        // % Verifying FLASH
+
+#define IFLASH_TOKEN_READINGFILE_ER 0xB8                // File Read Error
+#define IFLASH_TOKEN_INITVPP_ER     0xB9                // Initialization of IFB Error
+#define IFLASH_TOKEN_FLASHUNLOCK_ER 0xBA                // FLASH Unlock Error
+#define IFLASH_TOKEN_FLASHERASE_ER  0xBB                // FLASH Erase Error
+#define IFLASH_TOKEN_FLASHVERIFY_ER 0xBC                // FLASH Verify Error
+#define IFLASH_TOKEN_FLASHPROG_ER   0xBD                // FLASH Program Error
+
+#define IFLASH_TABLE_END            0x00
+
+//
+// If this number changes one of the existing API's has changes
+//
+#define IFLASH_PI_MAJOR_VERSION 0x01
+
+//
+// This number changes when new APIs or data variables get added to the end
+//  of the data structure
+//
+#define IFLASH_PI_MINOR_VERSION 0x01
+
+typedef struct _IFLASH64_PROTOCOL_INTERFACE {
+    UINT32                  MajorVersion;       
+    UINT32                  MinorVersion;   
+    UNLOCK_FLASH_API        UnlockFlash;
+    LOCK_FLASH_API          LockFlash;
+    UTILITY_PROGRESS_API    Progress;
+    
+    //
+    // Future expansion goes here
+    //
+
+} IFLASH64_PROTOCOL_INTERFACE;
+
+
+#endif
diff --git a/linux-x86_64/gnu-efi/include/efi/protocol/vgaclass.h b/linux-x86_64/gnu-efi/include/efi/protocol/vgaclass.h
new file mode 100644
index 0000000..d0deb5c
--- /dev/null
+++ b/linux-x86_64/gnu-efi/include/efi/protocol/vgaclass.h
@@ -0,0 +1,95 @@
+#ifndef _VGA_CLASS_H
+#define _VGA_CLASS_H
+
+/*++
+
+Copyright (c) 1999  Intel Corporation
+
+Module Name:
+
+    VgaClass.h
+    
+Abstract:
+
+    Vga Mini port binding to Vga Class protocol
+
+
+
+Revision History
+
+--*/
+
+//
+// VGA Device Structure
+//
+
+// {0E3D6310-6FE4-11d3-BB81-0080C73C8881}
+#define VGA_CLASS_DRIVER_PROTOCOL \
+    { 0xe3d6310, 0x6fe4, 0x11d3, {0xbb, 0x81, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81} }
+
+typedef 
+EFI_STATUS 
+(* INIT_VGA_CARD) (
+    IN  UINTN   VgaMode,
+    IN  VOID    *Context
+    );
+
+typedef struct {
+    UINTN   MaxColumns;
+    UINTN   MaxRows;
+} MAX_CONSOLE_GEOMETRY;
+
+#define VGA_CON_OUT_DEV_SIGNATURE   EFI_SIGNATURE_32('c','v','g','a')
+typedef struct {
+    UINTN                           Signature;
+
+    EFI_HANDLE                      Handle;
+    SIMPLE_TEXT_OUTPUT_INTERFACE    ConOut;
+    SIMPLE_TEXT_OUTPUT_MODE         ConOutMode;
+    EFI_DEVICE_PATH                 *DevicePath;
+
+    UINT8                           *Buffer;
+    EFI_DEVICE_IO_INTERFACE         *DeviceIo;
+
+    //
+    // Video Card Context
+    //
+    INIT_VGA_CARD                   InitVgaCard;
+    VOID                            *VgaCardContext;
+    MAX_CONSOLE_GEOMETRY            *Geometry;
+    //
+    // Video buffer normally 0xb8000
+    //
+    UINT64                          VideoBuffer;
+
+    //
+    // Clear Screen & Default Attribute
+    //
+    UINT32                          Attribute;
+
+    //
+    // -1 means search for active VGA device
+    //
+    EFI_PCI_ADDRESS_UNION           Pci;
+} VGA_CON_OUT_DEV;
+
+#define VGA_CON_OUT_DEV_FROM_THIS(a) CR(a, VGA_CON_OUT_DEV, ConOut, VGA_CON_OUT_DEV_SIGNATURE)
+
+//
+// Vga Class Driver Protocol. 
+// GUID defined in EFI Lib
+//
+
+typedef 
+EFI_STATUS
+(EFIAPI *INSTALL_VGA_DRIVER) (
+    IN  VGA_CON_OUT_DEV    *ConOutDev 
+    );
+
+typedef struct {
+    UINT32               Version;
+    INSTALL_VGA_DRIVER   InstallGenericVgaDriver;
+} INSTALL_VGA_DRIVER_INTERFACE;
+
+#endif
+
diff --git a/linux-x86_64/gnu-efi/include/efi/romload.h b/linux-x86_64/gnu-efi/include/efi/romload.h
new file mode 100644
index 0000000..0506011
--- /dev/null
+++ b/linux-x86_64/gnu-efi/include/efi/romload.h
@@ -0,0 +1,41 @@
+#ifndef _EFI_ROMLOAD_H
+#define _EFI_ROMLOAD_H
+
+#define ROM_SIGNATURE 0xaa55
+#define PCIDS_SIGNATURE "PCIR"
+#pragma pack(push)
+#pragma pack(1)
+typedef struct 
+{
+    UINT8    Pcids_Sig[4];
+    UINT16  VendId;
+    UINT16  DevId;
+    UINT16  Vpd_Off;
+    UINT16  Size;
+    UINT8 Rev;
+    UINT8 Class_Code[3];
+    UINT16  Image_Len;
+    UINT16  Rev_Lvl;
+    UINT8 Code_Type;
+    UINT8 Indi;
+    UINT16  Rsvd;
+}PciDataStructure;
+typedef struct
+{
+    UINT16 Size;
+    UINT32 Header_Sig;
+    UINT16 SubSystem;
+    UINT16 MachineType;
+    UINT8  Resvd[10];
+    UINT16 EfiOffset;
+}ArchData;
+typedef struct 
+{
+    UINT16 Rom_Sig;
+    ArchData Arch_Data;
+    UINT16 Pcids_Off;
+    UINT8 resvd[38];
+}RomHeader;
+#pragma pack(pop)
+
+#endif
diff --git a/linux-x86_64/gnu-efi/include/efi/x86_64/efibind.h b/linux-x86_64/gnu-efi/include/efi/x86_64/efibind.h
new file mode 100644
index 0000000..b940943
--- /dev/null
+++ b/linux-x86_64/gnu-efi/include/efi/x86_64/efibind.h
@@ -0,0 +1,285 @@
+/*++
+
+Copyright (c) 1998  Intel Corporation
+
+Module Name:
+
+    efefind.h
+
+Abstract:
+
+    EFI to compile bindings
+
+
+
+
+Revision History
+
+--*/
+#ifndef X86_64_EFI_BIND
+#define X86_64_EFI_BIND
+#ifndef __GNUC__
+#pragma pack()
+#endif
+
+//
+// Basic int types of various widths
+//
+
+#if !defined(__STDC_VERSION__) || (__STDC_VERSION__ < 199901L )
+
+    // No ANSI C 1999/2000 stdint.h integer width declarations 
+
+    #if defined(_MSC_EXTENSIONS)
+
+        // Use Microsoft C compiler integer width declarations 
+
+        typedef unsigned __int64    uint64_t;
+        typedef __int64             int64_t;
+        typedef unsigned __int32    uint32_t;
+        typedef __int32             int32_t;
+        typedef unsigned short      uint16_t;
+        typedef short               int16_t;
+        typedef unsigned char       uint8_t;
+        typedef char                int8_t;
+    #elif defined(__GNUC__)
+        typedef unsigned long long  uint64_t __attribute__((aligned (8)));
+        typedef long long           int64_t __attribute__((aligned (8)));
+        typedef unsigned int        uint32_t;
+        typedef int                 int32_t;
+        typedef unsigned short      uint16_t;
+        typedef short               int16_t;
+        typedef unsigned char       uint8_t;
+        typedef char                int8_t;
+    #elif defined(UNIX_LP64)
+
+        /*  Use LP64 programming model from C_FLAGS for integer width declarations */
+
+       typedef unsigned long       uint64_t;
+       typedef long                int64_t;
+       typedef unsigned int        uint32_t;
+       typedef int                 int32_t;
+       typedef unsigned short      uint16_t;
+       typedef short               int16_t;
+       typedef unsigned char       uint8_t;
+       typedef char                int8_t;
+    #else
+
+       /*  Assume P64 programming model from C_FLAGS for integer width declarations */
+
+       typedef unsigned long long  uint64_t __attribute__((aligned (8)));
+       typedef long long           int64_t __attribute__((aligned (8)));
+       typedef unsigned int        uint32_t;
+       typedef int                 int32_t;
+       typedef unsigned short      uint16_t;
+       typedef short               int16_t;
+       typedef unsigned char       uint8_t;
+       typedef char                int8_t;
+    #endif
+#endif
+
+//
+// Basic EFI types of various widths
+//
+
+#ifndef __WCHAR_TYPE__
+# define __WCHAR_TYPE__ short
+#endif
+
+typedef uint64_t   UINT64;
+typedef int64_t    INT64;
+
+#ifndef _BASETSD_H_
+    typedef uint32_t   UINT32;
+    typedef int32_t    INT32;
+#endif
+
+typedef uint16_t   UINT16;
+typedef int16_t    INT16;
+typedef uint8_t    UINT8;
+typedef int8_t     INT8;
+typedef __WCHAR_TYPE__ WCHAR;
+
+#undef VOID
+#define VOID    void
+
+
+typedef int64_t    INTN;
+typedef uint64_t   UINTN;
+
+#ifdef EFI_NT_EMULATOR
+    #define POST_CODE(_Data)
+#else    
+    #ifdef EFI_DEBUG
+#define POST_CODE(_Data)    __asm mov eax,(_Data) __asm out 0x80,al
+    #else
+        #define POST_CODE(_Data)
+    #endif  
+#endif
+
+#define EFIERR(a)           (0x8000000000000000 | a)
+#define EFI_ERROR_MASK      0x8000000000000000
+#define EFIERR_OEM(a)       (0xc000000000000000 | a)      
+
+
+#define BAD_POINTER         0xFBFBFBFBFBFBFBFB
+#define MAX_ADDRESS         0xFFFFFFFFFFFFFFFF
+
+#ifdef EFI_NT_EMULATOR
+    #define BREAKPOINT()        __asm { int 3 }
+#else
+    #define BREAKPOINT()        while (TRUE);    // Make it hang on Bios[Dbg]32
+#endif
+
+//
+// Pointers must be aligned to these address to function
+//
+
+#define MIN_ALIGNMENT_SIZE  4
+
+#define ALIGN_VARIABLE(Value ,Adjustment) \
+            (UINTN)Adjustment = 0; \
+            if((UINTN)Value % MIN_ALIGNMENT_SIZE) \
+                (UINTN)Adjustment = MIN_ALIGNMENT_SIZE - ((UINTN)Value % MIN_ALIGNMENT_SIZE); \
+            Value = (UINTN)Value + (UINTN)Adjustment
+
+
+//
+// Define macros to build data structure signatures from characters.
+//
+
+#define EFI_SIGNATURE_16(A,B)             ((A) | (B<<8))
+#define EFI_SIGNATURE_32(A,B,C,D)         (EFI_SIGNATURE_16(A,B)     | (EFI_SIGNATURE_16(C,D)     << 16))
+#define EFI_SIGNATURE_64(A,B,C,D,E,F,G,H) (EFI_SIGNATURE_32(A,B,C,D) | ((UINT64)(EFI_SIGNATURE_32(E,F,G,H)) << 32))
+//
+// To export & import functions in the EFI emulator environment
+//
+
+#ifdef EFI_NT_EMULATOR
+    #define EXPORTAPI           __declspec( dllexport )
+#else
+    #define EXPORTAPI
+#endif
+
+
+//
+// EFIAPI - prototype calling convention for EFI function pointers
+// BOOTSERVICE - prototype for implementation of a boot service interface
+// RUNTIMESERVICE - prototype for implementation of a runtime service interface
+// RUNTIMEFUNCTION - prototype for implementation of a runtime function that is not a service
+// RUNTIME_CODE - pragma macro for declaring runtime code    
+//
+
+#ifndef EFIAPI                  // Forces EFI calling conventions reguardless of compiler options 
+    #ifdef _MSC_EXTENSIONS
+        #define EFIAPI __cdecl  // Force C calling convention for Microsoft C compiler 
+    #else
+        #define EFIAPI          // Substitute expresion to force C calling convention 
+    #endif
+#endif
+
+#define BOOTSERVICE
+//#define RUNTIMESERVICE(proto,a)    alloc_text("rtcode",a); proto a
+//#define RUNTIMEFUNCTION(proto,a)   alloc_text("rtcode",a); proto a
+#define RUNTIMESERVICE
+#define RUNTIMEFUNCTION
+
+
+#define RUNTIME_CODE(a)         alloc_text("rtcode", a)
+#define BEGIN_RUNTIME_DATA()    data_seg("rtdata")
+#define END_RUNTIME_DATA()      data_seg("")
+
+#define VOLATILE    volatile
+
+#define MEMORY_FENCE()    
+
+#ifdef EFI_NT_EMULATOR
+
+//
+// To help ensure proper coding of integrated drivers, they are
+// compiled as DLLs.  In NT they require a dll init entry pointer.
+// The macro puts a stub entry point into the DLL so it will load.
+//
+
+#define EFI_DRIVER_ENTRY_POINT(InitFunction)    \
+    UINTN                                       \
+    __stdcall                                   \
+    _DllMainCRTStartup (                        \
+        UINTN    Inst,                          \
+        UINTN    reason_for_call,               \
+        VOID    *rserved                        \
+        )                                       \
+    {                                           \
+        return 1;                               \
+    }                                           \
+                                                \
+    int                                         \
+    EXPORTAPI                                   \
+    __cdecl                                     \
+    InitializeDriver (                          \
+        void *ImageHandle,                      \
+        void *SystemTable                       \
+        )                                       \
+    {                                           \
+        return InitFunction(ImageHandle, SystemTable);       \
+    }
+
+
+    #define LOAD_INTERNAL_DRIVER(_if, type, name, entry)      \
+        (_if)->LoadInternal(type, name, NULL)             
+
+#else // EFI_NT_EMULATOR 
+
+//
+// When build similiar to FW, then link everything together as
+// one big module.
+//
+
+    #define EFI_DRIVER_ENTRY_POINT(InitFunction)    \
+        UINTN                                       \
+        InitializeDriver (                          \
+            VOID    *ImageHandle,                   \
+            VOID    *SystemTable                    \
+            )                                       \
+        {                                           \
+            return InitFunction(ImageHandle,        \
+                    SystemTable);                   \
+        }                                           \
+                                                    \
+        EFI_STATUS efi_main(                        \
+            EFI_HANDLE image,                       \
+            EFI_SYSTEM_TABLE *systab                \
+            ) __attribute__((weak,                  \
+                    alias ("InitializeDriver")));
+
+    #define LOAD_INTERNAL_DRIVER(_if, type, name, entry)    \
+            (_if)->LoadInternal(type, name, entry)
+
+#endif // EFI_FW_NT 
+
+//
+// Some compilers don't support the forward reference construct:
+//  typedef struct XXXXX
+//
+// The following macro provide a workaround for such cases.
+//
+#ifdef NO_INTERFACE_DECL
+#define INTERFACE_DECL(x)
+#else
+#ifdef __GNUC__
+#define INTERFACE_DECL(x) struct x
+#else
+#define INTERFACE_DECL(x) typedef struct x
+#endif
+#endif
+
+/* for x86_64, EFI_FUNCTION_WRAPPER must be defined */
+UINTN uefi_call_wrapper(void *func, unsigned long va_num, ...);
+#define EFI_FUNCTION __attribute__((ms_abi))
+
+#ifdef _MSC_EXTENSIONS
+#pragma warning ( disable : 4731 )  // Suppress warnings about modification of EBP
+#endif
+
+#endif
+
diff --git a/linux-x86_64/gnu-efi/include/efi/x86_64/efilibplat.h b/linux-x86_64/gnu-efi/include/efi/x86_64/efilibplat.h
new file mode 100644
index 0000000..3844578
--- /dev/null
+++ b/linux-x86_64/gnu-efi/include/efi/x86_64/efilibplat.h
@@ -0,0 +1,26 @@
+/*++
+
+Copyright (c) 1998  Intel Corporation
+
+Module Name:
+
+    efilibplat.h
+
+Abstract:
+
+    EFI to compile bindings
+
+
+
+
+Revision History
+
+--*/
+
+VOID
+InitializeLibPlatform (
+    IN EFI_HANDLE           ImageHandle,
+    IN EFI_SYSTEM_TABLE     *SystemTable
+    );
+
+   
diff --git a/linux-x86_64/gnu-efi/include/efi/x86_64/pe.h b/linux-x86_64/gnu-efi/include/efi/x86_64/pe.h
new file mode 100644
index 0000000..16e40ef
--- /dev/null
+++ b/linux-x86_64/gnu-efi/include/efi/x86_64/pe.h
@@ -0,0 +1,591 @@
+/* 
+    PE32+ header file
+ */
+#ifndef _PE_H
+#define _PE_H
+
+#define IMAGE_DOS_SIGNATURE                 0x5A4D      // MZ
+#define IMAGE_OS2_SIGNATURE                 0x454E      // NE
+#define IMAGE_OS2_SIGNATURE_LE              0x454C      // LE
+#define IMAGE_NT_SIGNATURE                  0x00004550  // PE00  
+#define IMAGE_EDOS_SIGNATURE                0x44454550  // PEED
+
+
+typedef struct _IMAGE_DOS_HEADER {      // DOS .EXE header
+    UINT16   e_magic;                     // Magic number
+    UINT16   e_cblp;                      // Bytes on last page of file
+    UINT16   e_cp;                        // Pages in file
+    UINT16   e_crlc;                      // Relocations
+    UINT16   e_cparhdr;                   // Size of header in paragraphs
+    UINT16   e_minalloc;                  // Minimum extra paragraphs needed
+    UINT16   e_maxalloc;                  // Maximum extra paragraphs needed
+    UINT16   e_ss;                        // Initial (relative) SS value
+    UINT16   e_sp;                        // Initial SP value
+    UINT16   e_csum;                      // Checksum
+    UINT16   e_ip;                        // Initial IP value
+    UINT16   e_cs;                        // Initial (relative) CS value
+    UINT16   e_lfarlc;                    // File address of relocation table
+    UINT16   e_ovno;                      // Overlay number
+    UINT16   e_res[4];                    // Reserved words
+    UINT16   e_oemid;                     // OEM identifier (for e_oeminfo)
+    UINT16   e_oeminfo;                   // OEM information; e_oemid specific
+    UINT16   e_res2[10];                  // Reserved words
+    UINT32   e_lfanew;                    // File address of new exe header
+  } IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;
+
+typedef struct _IMAGE_OS2_HEADER {      // OS/2 .EXE header
+    UINT16   ne_magic;                    // Magic number
+    UINT8    ne_ver;                      // Version number
+    UINT8    ne_rev;                      // Revision number
+    UINT16   ne_enttab;                   // Offset of Entry Table
+    UINT16   ne_cbenttab;                 // Number of bytes in Entry Table
+    UINT32   ne_crc;                      // Checksum of whole file
+    UINT16   ne_flags;                    // Flag UINT16
+    UINT16   ne_autodata;                 // Automatic data segment number
+    UINT16   ne_heap;                     // Initial heap allocation
+    UINT16   ne_stack;                    // Initial stack allocation
+    UINT32   ne_csip;                     // Initial CS:IP setting
+    UINT32   ne_sssp;                     // Initial SS:SP setting
+    UINT16   ne_cseg;                     // Count of file segments
+    UINT16   ne_cmod;                     // Entries in Module Reference Table
+    UINT16   ne_cbnrestab;                // Size of non-resident name table
+    UINT16   ne_segtab;                   // Offset of Segment Table
+    UINT16   ne_rsrctab;                  // Offset of Resource Table
+    UINT16   ne_restab;                   // Offset of resident name table
+    UINT16   ne_modtab;                   // Offset of Module Reference Table
+    UINT16   ne_imptab;                   // Offset of Imported Names Table
+    UINT32   ne_nrestab;                  // Offset of Non-resident Names Table
+    UINT16   ne_cmovent;                  // Count of movable entries
+    UINT16   ne_align;                    // Segment alignment shift count
+    UINT16   ne_cres;                     // Count of resource segments
+    UINT8    ne_exetyp;                   // Target Operating system
+    UINT8    ne_flagsothers;              // Other .EXE flags
+    UINT16   ne_pretthunks;               // offset to return thunks
+    UINT16   ne_psegrefbytes;             // offset to segment ref. bytes
+    UINT16   ne_swaparea;                 // Minimum code swap area size
+    UINT16   ne_expver;                   // Expected Windows version number
+  } IMAGE_OS2_HEADER, *PIMAGE_OS2_HEADER;
+
+//
+// File header format.
+//
+
+typedef struct _IMAGE_FILE_HEADER {
+    UINT16   Machine;
+    UINT16   NumberOfSections;
+    UINT32   TimeDateStamp;
+    UINT32   PointerToSymbolTable;
+    UINT32   NumberOfSymbols;
+    UINT16   SizeOfOptionalHeader;
+    UINT16   Characteristics;
+} IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;
+
+#define IMAGE_SIZEOF_FILE_HEADER             20
+
+#define IMAGE_FILE_RELOCS_STRIPPED           0x0001  // Relocation info stripped from file.
+#define IMAGE_FILE_EXECUTABLE_IMAGE          0x0002  // File is executable  (i.e. no unresolved externel references).
+#define IMAGE_FILE_LINE_NUMS_STRIPPED        0x0004  // Line nunbers stripped from file.
+#define IMAGE_FILE_LOCAL_SYMS_STRIPPED       0x0008  // Local symbols stripped from file.
+#define IMAGE_FILE_BYTES_REVERSED_LO         0x0080  // Bytes of machine word are reversed.
+#define IMAGE_FILE_32BIT_MACHINE             0x0100  // 32 bit word machine.
+#define IMAGE_FILE_DEBUG_STRIPPED            0x0200  // Debugging info stripped from file in .DBG file
+#define IMAGE_FILE_SYSTEM                    0x1000  // System File.
+#define IMAGE_FILE_DLL                       0x2000  // File is a DLL.
+#define IMAGE_FILE_BYTES_REVERSED_HI         0x8000  // Bytes of machine word are reversed.
+
+#define IMAGE_FILE_MACHINE_UNKNOWN           0
+#define IMAGE_FILE_MACHINE_I386              0x14c   // Intel 386.
+#define IMAGE_FILE_MACHINE_R3000             0x162   // MIPS little-endian, 0540 big-endian
+#define IMAGE_FILE_MACHINE_R4000             0x166   // MIPS little-endian
+#define IMAGE_FILE_MACHINE_ALPHA             0x184   // Alpha_AXP
+#define IMAGE_FILE_MACHINE_POWERPC           0x1F0   // IBM PowerPC Little-Endian
+#define IMAGE_FILE_MACHINE_TAHOE             0x7cc   // Intel EM machine
+//
+// Directory format.
+//
+
+typedef struct _IMAGE_DATA_DIRECTORY {
+    UINT32   VirtualAddress;
+    UINT32   Size;
+} IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;
+
+#define IMAGE_NUMBEROF_DIRECTORY_ENTRIES    16
+
+//
+// Optional header format.
+//
+
+typedef struct _IMAGE_OPTIONAL_HEADER {
+    //
+    // Standard fields.
+    //
+
+    UINT16    Magic;
+    UINT8     MajorLinkerVersion;
+    UINT8     MinorLinkerVersion;
+    UINT32    SizeOfCode;
+    UINT32    SizeOfInitializedData;
+    UINT32    SizeOfUninitializedData;
+    UINT32    AddressOfEntryPoint;
+    UINT32    BaseOfCode;
+    UINT32    BaseOfData;
+                
+    //
+    // NT additional fields.
+    //
+
+    UINT32   ImageBase;
+    UINT32   SectionAlignment;
+    UINT32   FileAlignment;
+    UINT16   MajorOperatingSystemVersion;
+    UINT16   MinorOperatingSystemVersion;
+    UINT16   MajorImageVersion;
+    UINT16   MinorImageVersion;
+    UINT16   MajorSubsystemVersion;
+    UINT16   MinorSubsystemVersion;
+    UINT32   Reserved1;
+    UINT32   SizeOfImage;
+    UINT32   SizeOfHeaders;
+    UINT32   CheckSum;
+    UINT16   Subsystem;
+    UINT16   DllCharacteristics;
+    UINT32   SizeOfStackReserve;
+    UINT32   SizeOfStackCommit;
+    UINT32   SizeOfHeapReserve;
+    UINT32   SizeOfHeapCommit;
+    UINT32   LoaderFlags;
+    UINT32   NumberOfRvaAndSizes;
+    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
+} IMAGE_OPTIONAL_HEADER, *PIMAGE_OPTIONAL_HEADER;
+
+typedef struct _IMAGE_ROM_OPTIONAL_HEADER {
+    UINT16  Magic;
+    UINT8   MajorLinkerVersion;
+    UINT8   MinorLinkerVersion;
+    UINT32  SizeOfCode;
+    UINT32  SizeOfInitializedData;
+    UINT32  SizeOfUninitializedData;
+    UINT32  AddressOfEntryPoint;
+    UINT32  BaseOfCode;
+    UINT32  BaseOfData;
+    UINT32  BaseOfBss;
+    UINT32  GprMask;
+    UINT32  CprMask[4];
+    UINT32  GpValue;
+} IMAGE_ROM_OPTIONAL_HEADER, *PIMAGE_ROM_OPTIONAL_HEADER;
+
+#define IMAGE_SIZEOF_ROM_OPTIONAL_HEADER      56
+#define IMAGE_SIZEOF_STD_OPTIONAL_HEADER      28
+#define IMAGE_SIZEOF_NT_OPTIONAL_HEADER      224
+
+#define IMAGE_NT_OPTIONAL_HDR_MAGIC        0x10b
+#define IMAGE_ROM_OPTIONAL_HDR_MAGIC       0x107
+
+typedef struct _IMAGE_NT_HEADERS {
+    UINT32 Signature;
+    IMAGE_FILE_HEADER FileHeader;
+    IMAGE_OPTIONAL_HEADER OptionalHeader;
+} IMAGE_NT_HEADERS, *PIMAGE_NT_HEADERS;
+
+typedef struct _IMAGE_ROM_HEADERS {
+    IMAGE_FILE_HEADER FileHeader;
+    IMAGE_ROM_OPTIONAL_HEADER OptionalHeader;
+} IMAGE_ROM_HEADERS, *PIMAGE_ROM_HEADERS;
+
+#define IMAGE_FIRST_SECTION( ntheader ) ((PIMAGE_SECTION_HEADER)        \
+    ((UINT32)ntheader +                                                  \
+     FIELD_OFFSET( IMAGE_NT_HEADERS, OptionalHeader ) +                 \
+     ((PIMAGE_NT_HEADERS)(ntheader))->FileHeader.SizeOfOptionalHeader   \
+    ))
+
+
+// Subsystem Values
+
+#define IMAGE_SUBSYSTEM_UNKNOWN              0   // Unknown subsystem.
+#define IMAGE_SUBSYSTEM_NATIVE               1   // Image doesn't require a subsystem.
+#define IMAGE_SUBSYSTEM_WINDOWS_GUI          2   // Image runs in the Windows GUI subsystem.
+#define IMAGE_SUBSYSTEM_WINDOWS_CUI          3   // Image runs in the Windows character subsystem.
+#define IMAGE_SUBSYSTEM_OS2_CUI              5   // image runs in the OS/2 character subsystem.
+#define IMAGE_SUBSYSTEM_POSIX_CUI            7   // image run  in the Posix character subsystem.
+
+
+// Directory Entries
+
+#define IMAGE_DIRECTORY_ENTRY_EXPORT         0   // Export Directory
+#define IMAGE_DIRECTORY_ENTRY_IMPORT         1   // Import Directory
+#define IMAGE_DIRECTORY_ENTRY_RESOURCE       2   // Resource Directory
+#define IMAGE_DIRECTORY_ENTRY_EXCEPTION      3   // Exception Directory
+#define IMAGE_DIRECTORY_ENTRY_SECURITY       4   // Security Directory
+#define IMAGE_DIRECTORY_ENTRY_BASERELOC      5   // Base Relocation Table
+#define IMAGE_DIRECTORY_ENTRY_DEBUG          6   // Debug Directory
+#define IMAGE_DIRECTORY_ENTRY_COPYRIGHT      7   // Description String
+#define IMAGE_DIRECTORY_ENTRY_GLOBALPTR      8   // Machine Value (MIPS GP)
+#define IMAGE_DIRECTORY_ENTRY_TLS            9   // TLS Directory
+#define IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG   10   // Load Configuration Directory
+
+//
+// Section header format.
+//
+
+#define IMAGE_SIZEOF_SHORT_NAME              8
+
+typedef struct _IMAGE_SECTION_HEADER {
+    UINT8   Name[IMAGE_SIZEOF_SHORT_NAME];
+    union {
+            UINT32   PhysicalAddress;
+            UINT32   VirtualSize;
+    } Misc;
+    UINT32   VirtualAddress;
+    UINT32   SizeOfRawData;
+    UINT32   PointerToRawData;
+    UINT32   PointerToRelocations;
+    UINT32   PointerToLinenumbers;
+    UINT16   NumberOfRelocations;
+    UINT16   NumberOfLinenumbers;
+    UINT32   Characteristics;
+} IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;
+
+#define IMAGE_SIZEOF_SECTION_HEADER          40
+
+#define IMAGE_SCN_TYPE_NO_PAD                0x00000008  // Reserved.
+
+#define IMAGE_SCN_CNT_CODE                   0x00000020  // Section contains code.
+#define IMAGE_SCN_CNT_INITIALIZED_DATA       0x00000040  // Section contains initialized data.
+#define IMAGE_SCN_CNT_UNINITIALIZED_DATA     0x00000080  // Section contains uninitialized data.
+
+#define IMAGE_SCN_LNK_OTHER                  0x00000100  // Reserved.
+#define IMAGE_SCN_LNK_INFO                   0x00000200  // Section contains comments or some other type of information.
+#define IMAGE_SCN_LNK_REMOVE                 0x00000800  // Section contents will not become part of image.
+#define IMAGE_SCN_LNK_COMDAT                 0x00001000  // Section contents comdat.
+
+#define IMAGE_SCN_ALIGN_1BYTES               0x00100000  //
+#define IMAGE_SCN_ALIGN_2BYTES               0x00200000  //
+#define IMAGE_SCN_ALIGN_4BYTES               0x00300000  //
+#define IMAGE_SCN_ALIGN_8BYTES               0x00400000  //
+#define IMAGE_SCN_ALIGN_16BYTES              0x00500000  // Default alignment if no others are specified.
+#define IMAGE_SCN_ALIGN_32BYTES              0x00600000  //
+#define IMAGE_SCN_ALIGN_64BYTES              0x00700000  //
+
+#define IMAGE_SCN_MEM_DISCARDABLE            0x02000000  // Section can be discarded.
+#define IMAGE_SCN_MEM_NOT_CACHED             0x04000000  // Section is not cachable.
+#define IMAGE_SCN_MEM_NOT_PAGED              0x08000000  // Section is not pageable.
+#define IMAGE_SCN_MEM_SHARED                 0x10000000  // Section is shareable.
+#define IMAGE_SCN_MEM_EXECUTE                0x20000000  // Section is executable.
+#define IMAGE_SCN_MEM_READ                   0x40000000  // Section is readable.
+#define IMAGE_SCN_MEM_WRITE                  0x80000000  // Section is writeable.
+
+//
+// Symbol format.
+//
+
+
+#define IMAGE_SIZEOF_SYMBOL                  18
+
+//
+// Section values.
+//
+// Symbols have a section number of the section in which they are
+// defined. Otherwise, section numbers have the following meanings:
+//
+
+#define IMAGE_SYM_UNDEFINED           (UINT16)0           // Symbol is undefined or is common.
+#define IMAGE_SYM_ABSOLUTE            (UINT16)-1          // Symbol is an absolute value.
+#define IMAGE_SYM_DEBUG               (UINT16)-2          // Symbol is a special debug item.
+
+//
+// Type (fundamental) values.
+//
+
+#define IMAGE_SYM_TYPE_NULL                  0           // no type.
+#define IMAGE_SYM_TYPE_VOID                  1           //
+#define IMAGE_SYM_TYPE_CHAR                  2           // type character.
+#define IMAGE_SYM_TYPE_SHORT                 3           // type short integer.
+#define IMAGE_SYM_TYPE_INT                   4           //
+#define IMAGE_SYM_TYPE_LONG                  5           //
+#define IMAGE_SYM_TYPE_FLOAT                 6           //
+#define IMAGE_SYM_TYPE_DOUBLE                7           //
+#define IMAGE_SYM_TYPE_STRUCT                8           //
+#define IMAGE_SYM_TYPE_UNION                 9           //
+#define IMAGE_SYM_TYPE_ENUM                  10          // enumeration.
+#define IMAGE_SYM_TYPE_MOE                   11          // member of enumeration.
+#define IMAGE_SYM_TYPE_BYTE                  12          //
+#define IMAGE_SYM_TYPE_WORD                  13          //
+#define IMAGE_SYM_TYPE_UINT                  14          //
+#define IMAGE_SYM_TYPE_DWORD                 15          //
+
+//
+// Type (derived) values.
+//
+
+#define IMAGE_SYM_DTYPE_NULL                 0           // no derived type.
+#define IMAGE_SYM_DTYPE_POINTER              1           // pointer.
+#define IMAGE_SYM_DTYPE_FUNCTION             2           // function.
+#define IMAGE_SYM_DTYPE_ARRAY                3           // array.
+
+//
+// Storage classes.
+//
+
+#define IMAGE_SYM_CLASS_END_OF_FUNCTION      (BYTE )-1
+#define IMAGE_SYM_CLASS_NULL                 0
+#define IMAGE_SYM_CLASS_AUTOMATIC            1
+#define IMAGE_SYM_CLASS_EXTERNAL             2
+#define IMAGE_SYM_CLASS_STATIC               3
+#define IMAGE_SYM_CLASS_REGISTER             4
+#define IMAGE_SYM_CLASS_EXTERNAL_DEF         5
+#define IMAGE_SYM_CLASS_LABEL                6
+#define IMAGE_SYM_CLASS_UNDEFINED_LABEL      7
+#define IMAGE_SYM_CLASS_MEMBER_OF_STRUCT     8
+#define IMAGE_SYM_CLASS_ARGUMENT             9
+#define IMAGE_SYM_CLASS_STRUCT_TAG           10
+#define IMAGE_SYM_CLASS_MEMBER_OF_UNION      11
+#define IMAGE_SYM_CLASS_UNION_TAG            12
+#define IMAGE_SYM_CLASS_TYPE_DEFINITION      13
+#define IMAGE_SYM_CLASS_UNDEFINED_STATIC     14
+#define IMAGE_SYM_CLASS_ENUM_TAG             15
+#define IMAGE_SYM_CLASS_MEMBER_OF_ENUM       16
+#define IMAGE_SYM_CLASS_REGISTER_PARAM       17
+#define IMAGE_SYM_CLASS_BIT_FIELD            18
+#define IMAGE_SYM_CLASS_BLOCK                100
+#define IMAGE_SYM_CLASS_FUNCTION             101
+#define IMAGE_SYM_CLASS_END_OF_STRUCT        102
+#define IMAGE_SYM_CLASS_FILE                 103
+// new
+#define IMAGE_SYM_CLASS_SECTION              104
+#define IMAGE_SYM_CLASS_WEAK_EXTERNAL        105
+
+// type packing constants
+
+#define N_BTMASK                            017
+#define N_TMASK                             060
+#define N_TMASK1                            0300
+#define N_TMASK2                            0360
+#define N_BTSHFT                            4
+#define N_TSHIFT                            2
+
+// MACROS
+
+//
+// Communal selection types.
+//
+
+#define IMAGE_COMDAT_SELECT_NODUPLICATES   1
+#define IMAGE_COMDAT_SELECT_ANY            2
+#define IMAGE_COMDAT_SELECT_SAME_SIZE      3
+#define IMAGE_COMDAT_SELECT_EXACT_MATCH    4
+#define IMAGE_COMDAT_SELECT_ASSOCIATIVE    5
+
+#define IMAGE_WEAK_EXTERN_SEARCH_NOLIBRARY 1
+#define IMAGE_WEAK_EXTERN_SEARCH_LIBRARY   2
+#define IMAGE_WEAK_EXTERN_SEARCH_ALIAS     3
+
+
+//
+// Relocation format.
+//
+
+typedef struct _IMAGE_RELOCATION {
+    UINT32   VirtualAddress;
+    UINT32   SymbolTableIndex;
+    UINT16    Type;
+} IMAGE_RELOCATION;
+
+#define IMAGE_SIZEOF_RELOCATION              10
+
+//
+// I386 relocation types.
+//
+
+#define IMAGE_REL_I386_ABSOLUTE              0           // Reference is absolute, no relocation is necessary
+#define IMAGE_REL_I386_DIR16                 01          // Direct 16-bit reference to the symbols virtual address
+#define IMAGE_REL_I386_REL16                 02          // PC-relative 16-bit reference to the symbols virtual address
+#define IMAGE_REL_I386_DIR32                 06          // Direct 32-bit reference to the symbols virtual address
+#define IMAGE_REL_I386_DIR32NB               07          // Direct 32-bit reference to the symbols virtual address, base not included
+#define IMAGE_REL_I386_SEG12                 011         // Direct 16-bit reference to the segment-selector bits of a 32-bit virtual address
+#define IMAGE_REL_I386_SECTION               012
+#define IMAGE_REL_I386_SECREL                013
+#define IMAGE_REL_I386_REL32                 024         // PC-relative 32-bit reference to the symbols virtual address
+
+//
+// MIPS relocation types.
+//
+
+#define IMAGE_REL_MIPS_ABSOLUTE              0           // Reference is absolute, no relocation is necessary
+#define IMAGE_REL_MIPS_REFHALF               01
+#define IMAGE_REL_MIPS_REFWORD               02
+#define IMAGE_REL_MIPS_JMPADDR               03
+#define IMAGE_REL_MIPS_REFHI                 04
+#define IMAGE_REL_MIPS_REFLO                 05
+#define IMAGE_REL_MIPS_GPREL                 06
+#define IMAGE_REL_MIPS_LITERAL               07
+#define IMAGE_REL_MIPS_SECTION               012
+#define IMAGE_REL_MIPS_SECREL                013
+#define IMAGE_REL_MIPS_REFWORDNB             042
+#define IMAGE_REL_MIPS_PAIR                  045
+
+//
+// Alpha Relocation types.
+//
+
+#define IMAGE_REL_ALPHA_ABSOLUTE             0x0
+#define IMAGE_REL_ALPHA_REFLONG              0x1
+#define IMAGE_REL_ALPHA_REFQUAD              0x2
+#define IMAGE_REL_ALPHA_GPREL32              0x3
+#define IMAGE_REL_ALPHA_LITERAL              0x4
+#define IMAGE_REL_ALPHA_LITUSE               0x5
+#define IMAGE_REL_ALPHA_GPDISP               0x6
+#define IMAGE_REL_ALPHA_BRADDR               0x7
+#define IMAGE_REL_ALPHA_HINT                 0x8
+#define IMAGE_REL_ALPHA_INLINE_REFLONG       0x9
+#define IMAGE_REL_ALPHA_REFHI                0xA
+#define IMAGE_REL_ALPHA_REFLO                0xB
+#define IMAGE_REL_ALPHA_PAIR                 0xC
+#define IMAGE_REL_ALPHA_MATCH                0xD
+#define IMAGE_REL_ALPHA_SECTION              0xE
+#define IMAGE_REL_ALPHA_SECREL               0xF
+#define IMAGE_REL_ALPHA_REFLONGNB            0x10
+
+//
+// IBM PowerPC relocation types.
+//
+
+#define IMAGE_REL_PPC_ABSOLUTE 0x0000  // NOP
+#define IMAGE_REL_PPC_ADDR64   0x0001  // 64-bit address
+#define IMAGE_REL_PPC_ADDR32   0x0002  // 32-bit address
+#define IMAGE_REL_PPC_ADDR24   0x0003  // 26-bit address, shifted left 2 (branch absolute)
+#define IMAGE_REL_PPC_ADDR16   0x0004  // 16-bit address
+#define IMAGE_REL_PPC_ADDR14   0x0005  // 16-bit address, shifted left 2 (load doubleword)
+#define IMAGE_REL_PPC_REL24    0x0006  // 26-bit PC-relative offset, shifted left 2 (branch relative)
+#define IMAGE_REL_PPC_REL14    0x0007  // 16-bit PC-relative offset, shifted left 2 (br cond relative)
+#define IMAGE_REL_PPC_TOCREL16 0x0008  // 16-bit offset from TOC base
+#define IMAGE_REL_PPC_TOCREL14 0x0009  // 16-bit offset from TOC base, shifted left 2 (load doubleword)
+
+#define IMAGE_REL_PPC_ADDR32NB 0x000A  // 32-bit addr w/o image base
+#define IMAGE_REL_PPC_SECREL   0x000B  // va of containing section (as in an image sectionhdr)
+#define IMAGE_REL_PPC_SECTION  0x000C  // sectionheader number
+#define IMAGE_REL_PPC_IFGLUE   0x000D  // substitute TOC restore instruction iff symbol is glue code
+#define IMAGE_REL_PPC_IMGLUE   0x000E  // symbol is glue code; virtual address is TOC restore instruction
+
+#define IMAGE_REL_PPC_TYPEMASK 0x00FF  // mask to isolate above values in IMAGE_RELOCATION.Type
+
+// Flag bits in IMAGE_RELOCATION.TYPE
+
+#define IMAGE_REL_PPC_NEG      0x0100  // subtract reloc value rather than adding it
+#define IMAGE_REL_PPC_BRTAKEN  0x0200  // fix branch prediction bit to predict branch taken
+#define IMAGE_REL_PPC_BRNTAKEN 0x0400  // fix branch prediction bit to predict branch not taken
+#define IMAGE_REL_PPC_TOCDEFN  0x0800  // toc slot defined in file (or, data in toc)
+
+//
+// Based relocation format.
+//
+
+typedef struct _IMAGE_BASE_RELOCATION {
+    UINT32   VirtualAddress;
+    UINT32   SizeOfBlock;
+//  UINT16    TypeOffset[1];
+} IMAGE_BASE_RELOCATION, *PIMAGE_BASE_RELOCATION;
+
+#define IMAGE_SIZEOF_BASE_RELOCATION         8
+
+//
+// Based relocation types.
+//
+
+#define IMAGE_REL_BASED_ABSOLUTE              0
+#define IMAGE_REL_BASED_HIGH                  1
+#define IMAGE_REL_BASED_LOW                   2
+#define IMAGE_REL_BASED_HIGHLOW               3
+#define IMAGE_REL_BASED_HIGHADJ               4
+#define IMAGE_REL_BASED_MIPS_JMPADDR          5
+#define IMAGE_REL_BASED_IA64_IMM64            9
+#define IMAGE_REL_BASED_DIR64                 10
+
+//
+// Line number format.
+//
+
+typedef struct _IMAGE_LINENUMBER {
+    union {
+        UINT32   SymbolTableIndex;               // Symbol table index of function name if Linenumber is 0.
+        UINT32   VirtualAddress;                 // Virtual address of line number.
+    } Type;
+    UINT16    Linenumber;                         // Line number.
+} IMAGE_LINENUMBER;
+
+#define IMAGE_SIZEOF_LINENUMBER              6
+
+//
+// Archive format.
+//
+
+#define IMAGE_ARCHIVE_START_SIZE             8
+#define IMAGE_ARCHIVE_START                  "!<arch>\n"
+#define IMAGE_ARCHIVE_END                    "`\n"
+#define IMAGE_ARCHIVE_PAD                    "\n"
+#define IMAGE_ARCHIVE_LINKER_MEMBER          "/               "
+#define IMAGE_ARCHIVE_LONGNAMES_MEMBER       "//              "
+
+typedef struct _IMAGE_ARCHIVE_MEMBER_HEADER {
+    UINT8     Name[16];                          // File member name - `/' terminated.
+    UINT8     Date[12];                          // File member date - decimal.
+    UINT8     UserID[6];                         // File member user id - decimal.
+    UINT8     GroupID[6];                        // File member group id - decimal.
+    UINT8     Mode[8];                           // File member mode - octal.
+    UINT8     Size[10];                          // File member size - decimal.
+    UINT8     EndHeader[2];                      // String to end header.
+} IMAGE_ARCHIVE_MEMBER_HEADER, *PIMAGE_ARCHIVE_MEMBER_HEADER;
+
+#define IMAGE_SIZEOF_ARCHIVE_MEMBER_HDR      60
+
+//
+// DLL support.
+//
+
+//
+// Export Format
+//
+
+typedef struct _IMAGE_EXPORT_DIRECTORY {
+    UINT32   Characteristics;
+    UINT32   TimeDateStamp;
+    UINT16   MajorVersion;
+    UINT16   MinorVersion;
+    UINT32   Name;
+    UINT32   Base;
+    UINT32   NumberOfFunctions;
+    UINT32   NumberOfNames;
+    UINT32   *AddressOfFunctions;
+    UINT32   *AddressOfNames;
+    UINT32   *AddressOfNameOrdinals;
+} IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;
+
+//
+// Import Format
+//
+
+typedef struct _IMAGE_IMPORT_BY_NAME {
+    UINT16    Hint;
+    UINT8     Name[1];
+} IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;
+
+typedef struct _IMAGE_THUNK_DATA {
+    union {
+        UINT32 Function;
+        UINT32 Ordinal;
+        PIMAGE_IMPORT_BY_NAME AddressOfData;
+    } u1;
+} IMAGE_THUNK_DATA, *PIMAGE_THUNK_DATA;
+
+#define IMAGE_ORDINAL_FLAG 0x80000000
+#define IMAGE_SNAP_BY_ORDINAL(Ordinal) ((Ordinal & IMAGE_ORDINAL_FLAG) != 0)
+#define IMAGE_ORDINAL(Ordinal) (Ordinal & 0xffff)
+
+typedef struct _IMAGE_IMPORT_DESCRIPTOR {
+    UINT32   Characteristics;
+    UINT32   TimeDateStamp;
+    UINT32   ForwarderChain;
+    UINT32   Name;
+    PIMAGE_THUNK_DATA FirstThunk;
+} IMAGE_IMPORT_DESCRIPTOR, *PIMAGE_IMPORT_DESCRIPTOR;
+
+#endif
diff --git a/linux-x86_64/gnu-efi/lib/crt0-efi-x86_64.o b/linux-x86_64/gnu-efi/lib/crt0-efi-x86_64.o
new file mode 100644
index 0000000000000000000000000000000000000000..9a10d08d64e94ab109743407b7d0f74070909c96
GIT binary patch
literal 1328
zcmbW0Jxc>Y5QZmyB}Rn^7K%+8ML`ZyC~1_$FCwUrbg}T<=&6C6hTIB?jfHjoPkQ|^
z7XAc5=iS>i$Cxy}us1W$?#%4o?Y$hG9#5oF<dmX48b*#14Tdh2j9;QGrK$4znW@$)
z{avt1e;cNLQLTNz@h^?3yuN4N5L;zq>qWg#s|I<I?!@-qd7Yr8JRNj3c{fTc@)}V@
zo}v7BympoTZ}XgrbIynoB^z%FJ|*H+jwQpAfrVEHSQ#GZ0}Cz3hSu4FPukd-mUU!p
z8E^4A)Rg&cS4dcyzr*wBKOxq+eEW@lXR$V^0td1t=9j1ARqmYFBal4*A~U&nWIp4;
zGWRKV%~SRtwRbEm+M-39Fv|?RWq<Hd{oD3XWu8w;_D{}9f6}~JNzrdqNASOIGVYh6
z4N)d-;&FBC%TMGi82>L{VxAkZPu%NVBHy`dW4Jel7sqh&f^JjO%~KfmsHGY~t3ZCF
zRY%iFsP2M&6$RuU*3ZjlCkN!4zg_8og4?Das^){+556CS`wRc;JC@r!IPS3HE9^ty
Ub37c+vk!sK^Kcvt0>^Or0b`S2*Z=?k

literal 0
HcmV?d00001

diff --git a/linux-x86_64/gnu-efi/lib/elf_x86_64_efi.lds b/linux-x86_64/gnu-efi/lib/elf_x86_64_efi.lds
new file mode 100644
index 0000000..32cf687
--- /dev/null
+++ b/linux-x86_64/gnu-efi/lib/elf_x86_64_efi.lds
@@ -0,0 +1,63 @@
+/* Same as elf_x86_64_fbsd_efi.lds, except for OUTPUT_FORMAT below - KEEP IN SYNC */
+OUTPUT_FORMAT("elf64-x86-64", "elf64-x86-64", "elf64-x86-64")
+OUTPUT_ARCH(i386:x86-64)
+ENTRY(_start)
+SECTIONS
+{
+  . = 0;
+  ImageBase = .;
+  .hash : { *(.hash) }	/* this MUST come first! */
+  . = ALIGN(4096);
+  .eh_frame : 
+  { 
+    *(.eh_frame)
+  }
+  . = ALIGN(4096);
+  .text :
+  {
+   *(.text)
+  }
+  . = ALIGN(4096);
+  .reloc :
+  {
+   *(.reloc)
+  }
+  . = ALIGN(4096);
+  .data :
+  {
+   *(.rodata*)
+   *(.got.plt)
+   *(.got)
+   *(.data*)
+   *(.sdata)
+   /* the EFI loader doesn't seem to like a .bss section, so we stick
+      it all into .data: */
+   *(.sbss)
+   *(.scommon)
+   *(.dynbss)
+   *(.bss)
+   *(COMMON)
+   *(.rel.local)
+  }
+  . = ALIGN(4096);
+  .dynamic  : { *(.dynamic) }
+  . = ALIGN(4096);
+  .rela :
+  {
+    *(.rela.data*)
+    *(.rela.got)
+    *(.rela.stab)
+  }
+  . = ALIGN(4096);
+  .dynsym   : { *(.dynsym) }
+  . = ALIGN(4096);
+  .dynstr   : { *(.dynstr) }
+  . = ALIGN(4096);
+  .ignored.reloc :
+  {
+    *(.rela.reloc)
+    *(.eh_frame)
+    *(.note.GNU-stack)
+  }
+  .comment 0 : { *(.comment) }
+}
diff --git a/linux-x86_64/gnu-efi/lib/libefi.a b/linux-x86_64/gnu-efi/lib/libefi.a
new file mode 100644
index 0000000000000000000000000000000000000000..f4eb88e394b55944e5a8ae2ddce40a7f3a5ea96c
GIT binary patch
literal 114950
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

literal 0
HcmV?d00001

diff --git a/linux-x86_64/gnu-efi/lib/libgnuefi.a b/linux-x86_64/gnu-efi/lib/libgnuefi.a
new file mode 100644
index 0000000000000000000000000000000000000000..8764d531e7e54777bdacef77b00f886f56a5fea2
GIT binary patch
literal 2480
zcmcIm-Afcv6u;A&juyB@glXXT5Gm!jqwBgz$bzZ27)AObdPv7@Tq)O)-4WLwQqYBl
zA@HF;qL+I1aZw2DDS9dT1BCF!@S%?vJ7?xzy?a?PjSf5a%=z8lx#!$F_Z+t6hLuZC
z_0@G~<zjRtyLu8`Jw1k|#eyku)U<df=a1JBLL%_Y5K`TX&sff$cG8w>lf3Od&CZf(
zXC{N11QTP0WMV84*PRYcjAF!M5MqB!#N%MaJ7Gi_uUi~22Tv&q1PVnVedNI6C?O>Q
zOa*X?oFOWq{zaoii=W(S`f4z0Y!2YBw0*6<c_m=c<=?gLBN%JuYN+>%Mn+WXy{F5i
zDD_8o(6JFF)w$26KPb)2ZPDUp{p<DN;-)*gg2XkJ#M15tU*Ggc)a|!MX}DN=@y+x;
z&>vsxn{N`byr8Ocwbc7bBMMcLx0H{jvI(TcEu#d^#3;dv?<QAwHz3WS{{CLAb!g;%
zn-<p-dZ9hzIGJf%>x>!jizT$y*_;ihY+HG|E!Y;h5GtZPzeAKlRB1X}qpm`Fh+k%N
z>r4kq&o5+MYl7%`Hy7$D{^r^Rm*`I{*CP5vK2P+tlg-*QfXz6rtwUbzdDlumBRb?@
z>GssvWX{Uk;_4@UZvsy|)oN*l6tm0r09aJwwSbNOcvVHILa>5VN!V4eRd`P7e;s@=
zR16+bc>E3#gm<16*WCgpQoA@o1S@cFGwhVaOEP~sFWjpr17OH!g7bybA*&%&q!u)O
zBks@fbAZWbhb~hr{yj7Vk++4moIBE&SW;h@FSa9$Eyu^aD#d@u@^57RT*>h{E^Fjf
zk?(slj&@}KE0)hjD((dNl`=$}C0V`<;BqyDgh+)ih4pY=$Y;M^%9?VT9CYt+EiF_*
z#^U*hz5Sq>AJxl~o!vnvKTa=SW3f@Cg7*}ufxSJZ(8|4L>Sfdi)N`VymuWCPM>D<o
zR?}OIQExuE;q6ernfe)(`oQpk;RC}5hQAow%Or8VWAwTp{67vy^)Re4QRI4Sfl0h?
z@-2BOItlNx|6x7sZ~YIeVeXGTP87L@&=&6y=N1_Fh5>l1@y4sn<~`)F8rIl>Tw;8#
j<oFzyHS+#v4P#FdYmdjr^F;g#2e=N4OTR1sgR1)jxXk!5

literal 0
HcmV?d00001

-- 
1.7.4.1

